ARCHITECTURE "Maxwell"

   PROCESSOR_ID Maxwell;
    ISSUE_SLOTS 2;
   WORD_SIZE 64;
   BRANCH_DELAY 0;
   ELF_ID 190;
   ELF_ABI 0x33;
   ELF_ABI_VERSION 7;


   ELF_VERSION 101;

   RELOCATORS
  { "R_CUDA_NONE", 0, False, False, 0,0, { { 0, 0} } }
  { "R_CUDA_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_G32", "R_CUDA_G32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_G64", "R_CUDA_G64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS32_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_TEX_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_SAMP_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 20, 12} } }
  { "R_CUDA_SURF_HW_DESC", 4, 0, 32 }
  { "R_CUDA_SURF_HW_SW_DESC", 5, 0, 32 }
  { "R_CUDA_ABS32_LO_26", 0x00000000ffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_HI_26", 0xffffffff00000000, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS24_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 24} } }
  { "R_CUDA_ABS24_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS16_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 16} } }
  { "R_CUDA_ABS16_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 16} } }
  { "R_CUDA_TEX_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 32, 8} } }
  { "R_CUDA_SAMP_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 40, 5} } }
  { "R_CUDA_SURF_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 26, 6} } }
  { "R_CUDA_TEX_BINDLESSOFF13_32", 0xffffffffffffffff, False, False, 0,2, { { 32, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_47", 0xffffffffffffffff, False, False, 0,2, { { 47, 13} } }
  { "R_CUDA_CONST_FIELD19_28", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 28, 18},
  { 26, 1} } }
  { "R_CUDA_CONST_FIELD19_23", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 23, 19} } }
  { "R_CUDA_TEX_SLOT9_49", 0xffffffffffffffff, False, False, 0,0, { { 49, 9} } }
  { "R_CUDA_6_31", 0xffffffffffffffff, False, False, 0,0, { { 31, 6} } }
  { "R_CUDA_2_47", 0xffffffffffffffff, False, False, 0,0, { { 47, 2} } }
  { "R_CUDA_TEX_BINDLESSOFF13_41", 0xffffffffffffffff, False, False, 0,2, { { 41, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_45", 0xffffffffffffffff, False, False, 0,2, { { 45, 13} } }
  { "R_CUDA_FUNC_DESC32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC_32", "R_CUDA_FUNC_DESC_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_FUNC_DESC_64", "R_CUDA_FUNC_DESC_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_CONST_FIELD21_26", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 26, 21} } }
  { "R_CUDA_QUERY_DESC21_37", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 37, 21} } }
  { "R_CUDA_CONST_FIELD19_26", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 26, 19} } }
  { "R_CUDA_CONST_FIELD21_23", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 23, 21} } }
  { "R_CUDA_PCREL_IMM24_26", 0xffffffffffffffff, True, False, 0,0, { { 26, 24} } }
  { "R_CUDA_PCREL_IMM24_23", 0xffffffffffffffff, True, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS24_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 24} } }
  { "R_CUDA_ABS16_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 16} } }
  { "R_CUDA_FUNC_DESC32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_CONST_FIELD19_20", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 20, 19} } }
  { "R_CUDA_BINDLESSOFF13_36", 0xffffffffffffffff, False, False, 0,2, { { 36, 13} } }
  { "R_CUDA_SURF_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_INSTRUCTION64", 17, 0, 64 }
  { "R_CUDA_CONST_FIELD21_20", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 20, 21} } }
  { "R_CUDA_ABS32_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS32_LO_32", 0x00000000ffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS32_HI_32", 0xffffffff00000000, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS47_34", 0xffffffffffffffff, False, False, 0,2, { { 34, 47} } }
  { "R_CUDA_ABS16_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 16} } }
  { "R_CUDA_ABS24_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 24} } }
  { "R_CUDA_FUNC_DESC32_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_32", 0x00000000ffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_32", 0xffffffff00000000, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_CONST_FIELD19_40", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 40, 19} } }
  { "R_CUDA_BINDLESSOFF14_40", 0xffffffffffffffff, False, False, 0,2, { { 40, 14} } }
  { "R_CUDA_CONST_FIELD21_38", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 38, 21} } }
  { "R_CUDA_INSTRUCTION128", 17, 0, 128 }
  { "R_CUDA_YIELD_OPCODE9_0", 18, 0, 9 }
  { "R_CUDA_YIELD_CLEAR_PRED4_87", 19, 87, 4 }
  { "R_CUDA_32_LO", 0x00000000ffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_32_HI", 0xffffffff00000000, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_UNUSED_CLEAR32", "R_CUDA_UNUSED_CLEAR32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_UNUSED_CLEAR64", "R_CUDA_UNUSED_CLEAR64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS24_40", 0xffffffffffffffff, False, False, 0,0, { { 40, 24} } }
      ;


   OPTIONS NOCHECK_OPCLASS_AMBIGUITY,
                           CASE_INSENSITIVE_SYNTAX,
                           VLIW_BRACE_NOTATION;
   RELATIVE_ADDRESS_BASE CURRENT_INSTRUCTION + 8;

   EMPTY_INSTRUCTION = "NOP;";

   CONDITION TYPES
      ILLEGAL_INSTR_ENCODING_ERROR : ERROR
      OOR_REG_ERROR : ERROR
      MISALIGNED_REG_ERROR : ERROR
      INVALID_CONST_ADDR_ERROR : ERROR
      MISALIGNED_ADDR_ERROR : ERROR
      UNPREDICTABLE_BEHAVIOR_ERROR : ERROR
      PC_MISALIGNED_ERROR : ERROR

      ILLEGAL_INSTR_ENCODING_WARNING : WARNING
      OOR_REG_WARNING : WARNING
      MISALIGNED_REG_WARNING : WARNING
      INVALID_CONST_ADDR_WARNING : WARNING
      MISALIGNED_ADDR_WARNING : WARNING
      UNPREDICTABLE_BEHAVIOR_WARNING : WARNING

      ILLEGAL_INSTR_ENCODING_INFO : INFO
      OOR_REG_INFO : INFO
      MISALIGNED_REG_INFO : INFO
      INVALID_CONST_ADDR_INFO : INFO
      MISALIGNED_ADDR_INFO : INFO
      UNPREDICTABLE_BEHAVIOR_INFO : INFO

      ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR : ERROR
      INVALID_CONST_ADDR_SASS_ONLY_ERROR : ERROR

PARAMETERS
    MAX_REG_COUNT = 255
    SHADER_TYPE = 0
    MAX_CONST_BANK = 17

CONSTANTS
    ITYPE_OTHER = 0
    ITYPE_ABC_REG = 1
    ITYPE_ABC_BCST = 2
    ITYPE_ABC_CCST = 3
    ITYPE_ABC_B20I = 4

    BRT_CALL = 1
    BRT_RETURN = 2
    BRT_BRANCH = 3
    BRT_BRANCHOUT = 4

    VQ_ADU = 0
    VQ_FMA64 = 1
    VQ_SHM = 2
    VQ_TEX = 3
    VQ_XU = 4
    VQ_GENERICS = 5
    VQ_REDIRECTABLE = 6
    VQ_UNORDERED = 7
    VQ_IPA_PASS = 8
    VQ_IPA_MUL = 9
    VQ_IPA_SC = 10
    VQ_REDIRECTABLE_FP16 = 11

    MEMORY_LOAD = 1
    MEMORY_STORE = 2

    ST_UNKNOWN = 0
    ST_PS = 1
    ST_TI = 2
    ST_TS = 3
    ST_GS = 4
    ST_CS = 5
    ST_VSA = 6
    ST_VSB = 7

    ISHADER_VS = 0
    ISHADER_GS = 1
    ISHADER_TI = 2
    ISHADER_TS = 3
    ISHADER_CS = 4
    ISHADER_PS = 5
    ISHADER_ALL = 0x3f

    IERROR_ILLEGAL_INSTR_DECODING = 0
    IERROR_MISALIGNED_REG = 1
    IERROR_ILLEGAL_SPH_INSTR_COMBINATION = 2
    IERROR_ILLEGAL_INSTR_PARAM = 3
    IERROR_ILLEGAL_INSTR_PARAM2 = 4
    IERROR_INVALID_CONST_ADDR = 5
    IERROR_OOR_REG = 6
    IERROR_OOR_ADDR = 7
    IERROR_MISALIGNED_ADDR = 8
    IERROR_INVALID_ADDR_SPACE = 9
    IERROR_GEOMETRY_SM_ERROR = 10
    IERROR_PC_WRAP = 11
    IERROR_PC_OVERFLOW = 12
    IERROR_PC_MISALIGNED = 13
    IERROR_API_STACK_ERROR = 14
    IERROR_PHYSICAL_ATTR_MISMATCH_ERROR = 15
    IERROR_ILLEGAL_INSTR_LSU = 16
    IERROR_PHYSICAL_STACK_OVERFLOW = 17

    IOPERAND_MAP_NON_EXISTENT_OPERAND = 30

    IOPERAND_TYPE_INTEGER = 0
    IOPERAND_TYPE_SIGNED_INTEGER = 1
    IOPERAND_TYPE_UNSIGNED_INTEGER = 2
    IOPERAND_TYPE_FLOAT = 3
    IOPERAND_TYPE_DOUBLE = 4
    IOPERAND_TYPE_GENERIC_ADDRESS = 5
    IOPERAND_TYPE_SHARED_ADDRESS = 6
    IOPERAND_TYPE_LOCAL_ADDRESS = 7
    IOPERAND_TYPE_TRAM_ADDRESS = 8
    IOPERAND_TYPE_LOGICAL_ATTR_ADDRESS = 9
    IOPERAND_TYPE_PHYSICAL_ATTR_ADDRESS = 10
    IOPERAND_TYPE_GENERIC = 11
    IOPERAND_TYPE_NON_EXISTENT_OPERAND = 12
    IOPERAND_TYPE_CONSTANT_ADDRESS = 13
    IOPERAND_TYPE_VILD_INDEX = 14
    IOPERAND_TYPE_VOTE_INDEX = 15
    IOPERAND_TYPE_STP_INDEX = 16
    IOPERAND_TYPE_PIXLD_INDEX = 17
    IOPERAND_TYPE_PATCH_OFFSET_ADDRESS = 18
    IOPERAND_TYPE_RAW_ISBE_ACCESS = 19
    IOPERAND_TYPE_GLOBAL_ADDRESS = 20
    IOPERAND_TYPE_TEX = 21
    IOPERAND_TYPE_GS_STATE = 22
    IOPERAND_TYPE_SURFACE_COORDINATES = 23
    IOPERAND_TYPE_FP16SIMD = 24

    INST_TYPE_MATH = 0
    INST_TYPE_COUPLED_MATH = 0
    INST_TYPE_MIO_RD_SCBD = 1
    INST_TYPE_DECOUPLED_RD_SCBD = 1
    INST_TYPE_MIO_RD_WR_SCBD = 2
    INST_TYPE_DECOUPLED_RD_WR_SCBD = 2
    INST_TYPE_COUPLED_EMULATABLE = 3
    INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD = 4







REGISTERS



    UnaryInv noINV, INV;
    UnaryNeg noNEG, NEG;
    UnaryAbs noABS, ABS;

    SIDL_NAMES
        NO_CUSTOM_NAME,
        VOTE_VTG,
 TEXS16,
 TLDS16,
 TLD4S16,
  HFMA2_REG,
  HFMA2_IMM,
  HFMA2_BCST,
  HSET2_REG,
  HSET2_IMM,
  HSET2_BCST,
  HADD2_BCST,
  HADD2_IMM,
  HADD2_REG,
  HMUL2_REG,
  HMUL2_IMM,
  HMUL2_BCST,
  HFMA2_REG,
  HFMA2_IMM,
  HFMA2_BCST,
  HSET2_REG,
  HSET2_IMM,
  HSET2_BCST,
  HADD2_BCST,
  HADD2_IMM,
  HADD2_REG,
  HMUL2_REG,
  HMUL2_IMM,
  HMUL2_BCST,
    IDP_REG,
    IDP_BCST,
  ATOM,
  ATOM_CAS,
  ATOMS,
  ATOMS_CAS,
  FADD_Rb,
  FADD_Imm,
  FADD_c,
  FCHK_Rb,
  FCHK_Imm,
  FCHK_C,
  FFMA_Rb_Rc,
  FFMA_Imm_Rc,
  FFMA_Rb_Imm,
  FFMA_c_Rc,
  FFMA_Rb_c,
  FMNMX_Rb,
  FMNMX_Imm,
  FMNMX_C,
  FMUL_Rb,
  FMUL_Imm,
  FMUL_c,
  FSEL_Rb,
  FSEL_Imm,
  FSEL_C,
  FSETP_Rb,
  FSETP_Imm,
  FSETP_C,
  FSET_Rb,
  FSET_Imm,
  FSET_C,
  MUFU_Rb,
  MUFU_Imm,
  MUFU_c,
  DADD_Rc,
  DADD_Imm,
  DADD_C,
  DFMA_Rb_Rc,
  DFMA_Imm_Rc,
  DFMA_C_Rc,
  DFMA_Rb_Imm,
  DFMA_Rb_C,
  DMUL_Rb,
  DMUL_Imm,
  DMUL_C,
  DSETP_Rc,
  DSETP_Imm,
  DSETP_C,
  BMOV_clear_Rd,
  BMOV_clear_Bd,
  BMOV_pquad_R,
  BMOV_pquad_I,
  BMOV_pquad_C,
  BMOV_pquad_B,
  BMOV_dst64_I,
  BMOV_dst64_R,
  BMOV_dst64_C,
  CALL_ABS_C,
  CALL_ABS_I,
  CALL_ABS_R,
  CALL_REL_I,
  CALL_REL_R,
  JMP_I,
  JMP_C,
  NANOSLEEP_R,
  NANOSLEEP_I,
  NANOSLEEP_C,
  NANOTRAP_R,
  NANOTRAP_I,
  NANOTRAP_C,
  RPCMOV_dstPc,
  RPCMOV_dstPc_imm,
  RPCMOV_dstPc_const,
  RPCMOV_srcPc,
  RPCMOV_dstPc64_I,
  RPCMOV_dstPc64_C,
  WARPSYNC_Rb,
  WARPSYNC_Imm,
  WARPSYNC_C,
  HADD2_Rb,
  HADD2_Imm,
  HADD2_c,
  HFMA2_Rb_Rc,
  HFMA2_Imm_Rc,
  HFMA2_c_Rc,
  HFMA2_Rb_c,
  HFMA2_Rb_Imm,
  HMMA_Rb_Rc,
  HMUL2_Rb,
  HMUL2_Imm,
  HMUL2_c,
  HSET2_Rb,
  HSET2_Imm,
  HSET2_c,
  HSETP2_Rb,
  HSETP2_Imm,
  HSETP2_c,
  BMSK_Rb,
  BMSK_Imm,
  BMSK_C,
  BREV_Rb,
  BREV_Imm,
  BREV_C,
  FLO_Rb,
  FLO_Imm,
  FLO_C,
  IABS_Rb,
  IABS_Imm,
  IABS_C,
  IADD3_Rb,
  IADD3_C,
  IADD3_Imm,
  IDP_Rb,
  IDP_C,
  IMAD_Rb_Rc,
  IMAD_Imm_Rc,
  IMAD_C_Rc,
  IMAD_Rb_Imm,
  IMAD_Rb_C,
  IMAD_WIDE_Rb_Rc,
  IMAD_WIDE_Imm_Rc,
  IMAD_WIDE_C_Rc,
  IMAD_WIDE_Rb_C,
  ISETP_Rb,
  ISETP_Imm,
  ISETP_C,
  LEA_Rb_Rc,
  LEA_C_Rc,
  LEA_Imm_Rc,
  LEA_Rb_Imm,
  LOP3_Rb,
  LOP3_Imm,
  LOP3_C,
  MOV_Rb,
  MOV_Imm,
  MOV_c,
  P2R_Rb,
  P2R_Imm,
  P2R_C,
  PLOP3_0,
  PLOP3_1_R,
  PLOP3_1_C,
  PLOP3_2_R,
  PLOP3_2_C,
  PLOP3_3_R,
  PLOP3_3_C,
  POPC_Rb,
  POPC_Imm,
  POPC_C,
  PRMT_Rb_Rc,
  PRMT_Imm_Rc,
  PRMT_C_Rc,
  PRMT_Rb_Imm,
  PRMT_Rb_C,
  R2P_Rb,
  R2P_Imm,
  R2P_C,
  SEL_Rb,
  SEL_Imm,
  SEL_C,
  SGXT_Rb,
  SGXT_Imm,
  SGXT_C,
  SHF_Rb_Rc,
  SHF_Imm_Rc,
  SHF_Rb_Imm,
  SHF_C_Rc,
  SHF_Rb_C,
  VABSDIFF_Rb_Rc,
  VABSDIFF_Imm_Rc,
  VABSDIFF_C_Rc,
  VABSDIFF_Rb_Imm,
  VABSDIFF_Rb_C,
  VABSDIFF4_Rb_Rc,
  VABSDIFF4_Imm_Rc,
  VABSDIFF4_C_Rc,
  VABSDIFF4_Rb_Imm,
  VABSDIFF4_Rb_C,
  F2F_R,
  F2F_C,
  F2F_Imm,
  F2F64_R,
  F2F64_C,
  F2F64_Imm,
  F2I_R,
  F2I_C,
  F2I_I,
  F2I64_R,
  F2I64_C,
  F2I64_I,
  FRND_R,
  FRND_C,
  FRND_I,
  FRND64_R,
  FRND64_C,
  FRND64_I,
  I2F_R,
  I2F_C,
  I2F_I,
  I2F64_R,
  I2F64_C,
  I2F64_I,
  IPA_Rb,
  IPA_Imm,
  IPA_c,
  OUT_R,
  OUT_I,
  ATOMG,
  ATOMG_CAS,
  CCTLT_Rb,
  CCTLT_C,
  SHFL_Rb_Rc,
  SHFL_Imm_Rc,
  SHFL_Rb_Imm,
  SHFL_Imm_Imm,
  BAR_R,
  BAR_R_Imm,
  BAR_Imm_R,
  BAR_Imm_Imm,
  SUATOM_I,
  SUATOM_TID,
  SUATOM_R,
  SUATOM_I_CAS,
  SUATOM_TID_CAS,
  SUATOM_R_CAS,
  SULD_D_I,
  SULD_D_TID,
  SULD_D_R,
  SULD_P_I,
  SULD_P_TID,
  SULD_P_R,
  SURED_I,
  SURED_TID,
  SURED_R,
  SUST_D_I,
  SUST_D_TID,
  SUST_D_R,
  SUST_P_I,
  SUST_P_TID,
  SUST_P_R,
  TEX,
  TEX_B_noConst,
  TEX_B,
  TLD,
  TLD_B_noConst,
  TLD_B,
  TLD4,
  TLD4_B_noConst,
  TLD4_B,
  TMML,
  TMML_B_noConst,
  TMML_B,
  TXD,
  TXD_B_noConst,
  TXD_B,
  TXQ,
  TXQ_B_noConst,
  TXQ_B,
    BMOV_Rd_Rpc,
    BMOV_Rpc_Rb,
    BMOV_Rpc_Imm,
    BMOV_Rd_CBU,
    BMOV_CBU_Rb,
    BMOV_CBU_Ba,
    BMOV_CBU_Imm,
    JMP_CONST,
 DUMMY ;





    NonZeroRegister R0(0..9), R(0..254)=(0..254);





    NonZeroRegisterFAU = NonZeroRegister;





    ZeroRegister RZ=255;

    RegisterFAU = NonZeroRegisterFAU + ZeroRegister;
    Register = NonZeroRegister + ZeroRegister;



    REUSE reuse=1, noreuse=0;
    GRF = Register;
    USCHED_INFO



            YIELD_SB *= 0,

            W1G = 1,
            W2G = 2,
            W3G = 3,
            W4G = 4,
            W5G = 5,
            W6G = 6,
            W7G = 7,
            W8G = 8,
            W9G = 9,
            W10G = 10,
            W11G = 11,
            W12G = 12,
            W13G = 13,
            W14G = 14,
            W15G = 15,
            W1 = 17,
            W2 = 18,
            W3 = 19,
            W4 = 20,
            W5 = 21,
            W6 = 22,
            W7 = 23,
            W8 = 24,
            W9 = 25,
            W10 = 26,
            W11 = 27,
            OFF_DECK_DRAIN = 0,
            DRAIN = 0,
            WAIT1_GROUP = 1,
            WAIT2_GROUP = 2,
            WAIT3_GROUP = 3,
            WAIT4_GROUP = 4,
            WAIT5_GROUP = 5,
            WAIT6_GROUP = 6,
            WAIT7_GROUP = 7,
            WAIT8_GROUP = 8,
            WAIT9_GROUP = 9,
            WAIT10_GROUP = 10,
            WAIT11_GROUP = 11,
            WAIT12_GROUP = 12,
            WAIT13_GROUP = 13,
            WAIT14_GROUP = 14,
            WAIT15_GROUP = 15,
            WAIT1_BOOST = 17,
            WAIT2_BOOST = 18,
            WAIT3_BOOST = 19,
            WAIT4_BOOST = 20,
            WAIT5_BOOST = 21,
            WAIT6_BOOST = 22,
            WAIT7_BOOST = 23,
            WAIT8_BOOST = 24,
            WAIT9_BOOST = 25,
            WAIT10_BOOST = 26,
            WAIT11_BOOST = 27,
            PIXBAR = 28,
            YLD = 29,
            YLD6 = 29,
            YIELD = 29,
            YIELD6 = 29,
            OFF_DECK_YIELD = 29,
            YLD8 = 30,
            YIELD8 = 30,
            W1B = 17,
            W2B = 18,
            W3B = 19,
            W4B = 20,
            W5B = 21,
            W6B = 22,
            W7B = 23,
            W8B = 24,
            W9B = 25,
            W10B = 26,
            W11B = 27,
            OFF_DECK_YIELD_SB_ALL = 0,
            WAIT1_END_GROUP = 1,
            WAIT2_END_GROUP = 2,
            WAIT3_END_GROUP = 3,
            WAIT4_END_GROUP = 4,
            WAIT5_END_GROUP = 5,
            WAIT6_END_GROUP = 6,
            WAIT7_END_GROUP = 7,
            WAIT8_END_GROUP = 8,
            WAIT9_END_GROUP = 9,
            WAIT10_END_GROUP = 10,
            WAIT11_END_GROUP = 11,
            WAIT12_END_GROUP = 12,
            WAIT13_END_GROUP = 13,
            WAIT14_END_GROUP = 14,
            WAIT15_END_GROUP = 15,
            floxy2 = 16,
            trans1 = 17,
            trans2 = 18,
            trans3 = 19,
            trans4 = 20,
            trans5 = 21,
            trans6 = 22,
            trans7 = 23,
            trans8 = 24,
            trans9 = 25,
            trans10 = 26,
            trans11 = 27,
            OFF_DECK_PIXBAR = 28,
            OFF_DECK_YIELD6 = 29,
            OFF_DECK_YIELD8 = 30,
            OFF_DECK = 31;

    Scoreboard SB(0..5);

    REQ req*;
    RD rd*;
    WR wr*;



    Predicate P(0..7), PT=7;

    SpecialRegister SR(0..255)=(0..255),

                      SR_LANEID = 0,
                      SR_CLOCK,
                      SR_VIRTCFG,
                      SR_VIRTID,
                      SR_PM(0..7),

                      SR_ORDERING_TICKET=15,
                      SR_PRIM_TYPE,
                      SR_INVOCATION_ID,
                      SR_Y_DIRECTION,
                      SR_THREAD_KILL,
                      SM_SHADER_TYPE,
                      SR_DIRECTCBEWRITEADDRESSLOW=21,
                      SR_DIRECTCBEWRITEADDRESSHIGH=22,
                      SR_DIRECTCBEWRITEENABLED=23,
                      SR_MACHINE_ID_(0..3)=(24..27),
                      SR_AFFINITY,
                      SR_INVOCATION_INFO,
                      SR_WSCALEFACTOR_XY,
                      SR_WSCALEFACTOR_Z,
                      SR_TID=32, "SR_TID.X", "SR_TID.Y", "SR_TID.Z",
                      SR_CTAPARAM, SR_CTA_PARAM=36,
                      "SR_CTAID.X", "SR_CTAID.Y", "SR_CTAID.Z",
                      SR_NTID,
                      SR_CirQueueIncrMinusOne, SR_NLATC,

                      SR_SWINLO=48, SR_SWINSZ,
                      SR_SMEMSZ, SR_SMEMBANKS,
                      SR_LWINLO, SR_LWINSZ,
                      SR_LMEMLOSZ, SR_LMEMHIOFF,
                      SR_EQMASK, SR_LTMASK, SR_LEMASK, SR_GTMASK, SR_GEMASK,
                      SR_REGALLOC, SR_CTXADDR,

                      SR_GLOBALERRORSTATUS=64,

                      SR_WARPERRORSTATUS=66, SR_WARPERRORSTATUSCLEAR,

                      SR_PM_HI(0..7)=(72..79),
                      SR_CLOCKLO=80, SR_CLOCKHI,
                      SR_GLOBALTIMERLO, SR_GLOBALTIMERHI,

                      SR_HWTASKID=96, SR_CIRCULARQUEUEENTRYINDEX,
                      SR_CIRCULARQUEUEENTRYADDRESSLOW,
                      SR_CIRCULARQUEUEENTRYADDRESSHIGH;







    Round1 RN, RM, RP, RZ;
    F2FRound1 PASS=1, PASS, PASS, RN, RM, RP, RZ, PASS=0, ROUND=4, FLOOR, CEIL, TRUNC;
    F2FRound2 PASS, ROUND=0, FLOOR, CEIL, TRUNC, RN=0, RM, RP, RZ;
    Round3 ROUND, FLOOR, CEIL, TRUNC;
    VOP MRG_16H, MRG_16L, MRG_8B0, MRG_8B2, ACC, MIN, MAX, PASS;
    IPAOp PASS, MUL, CONSTANT, SC;
    IDXOnly IDX;

    VRed2 SIMD_MRG, ACC, INVALIDRED2, INVALIDRED3;
    AtomOp INVALIDATOMOP(0..15), ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR,EXCH,SAFEADD=10;
    AtomsOp INVALIDATOMSOP(0..15), ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR,EXCH;
    AtomsSz "32"=0, U32=0, S32=1, "64"=2, U64=2, S64=3;
    AtomsSPIN noSPIN=0, SPIN=1;
    RedOp INVALIDREDOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR;

    VMadScale PASS,SHR_7,SHR_15,INVALIDVMADSCALE3;
    INC NOINC,INC;
    IPAOpN MUL, SC;
    Bop AND, OR, XOR, INVALIDBOP03,INVALIDBOP13=3,INVALIDBOP3=3;
    LOP AND, OR, XOR, PASS_B;
    POP F, T, Z, NZ;
    PopcFmt "32", "16_V2", "8_V4", "INVALIDPOPCFMT3";
    Red POPC,AND,OR,INVALIDBARMODE3;

    CC CC=1;
    optCC noCC, CC;
    CCPR PR=0, CC=1;

    Float INVALIDFPDEST0, INVALIDFPSRC0=0, F16, F32, F64;
    FloatNo64 INVALIDFPDEST0, INVALIDFPSRC0=0, F16, F32;
    Float16 F16=1;
    Float32 INVALIDFPDEST0, INVALIDFPSRC0=0, F32=2;
    Float64 F64=3;
    F32 F32;
    F2Ffmts1 "INVALIDFPDEST0.INVALIDFPSRC0"=0, "F32.F32"=10;
    F2Ffmts1_16 "F16.F16"=5;
    F2Ffmts1_64 "F64.F64"=15;
    F2Ffmts2 "F16.INVALIDFPSRC0"=1, "F32.INVALIDFPSRC0"=2, "F64.INVALIDFPSRC0"=3,
                      "INVALIDFPDEST0.F32"=8, "F16.F32"=9;
    F2Ffmts2_64_32 "F64.F32"=11;
    F2Ffmts2_16 "INVALIDFPDEST0.F16"=4, "F32.F16"=6;
    F2Ffmts2_64_16 "F64.F16"=7;
    F2Ffmts2_64 "INVALIDFPDEST0.F64"=12, "F16.F64"=13, "F32.F64"=14;

    Integer8 U8 = 0, S8 = 1;
    Invalid8 INVALID0 = 0, INVALID1 = 1;
    Integer16 U16 = 2, S16 = 3;
    Invalid16 INVALID2 = 2, INVALID3 = 3;
    Integer32 U32 = 4, S32 = 5;
    Invalid32 INVALID4 = 4, INVALID5 = 5;
    Integer64 U64 = 6, S64 = 7;
    Invalid64 INVALID6 = 6, INVALID7 = 7;
    Integer128 U128= 8, S128= 9;


    UInteger8 U8 = 0;
    UInteger16 U16 = 2;
    UInteger32 U32 = 4;
    UInteger64 U64 = 6;
    UInteger128 U128= 8;

    SInteger8 S8 = 1;
    SInteger16 S16 = 3;
    SInteger32 S32 = 5;
    SInteger64 S64 = 7;
    SInteger128 S128= 9;

    U8 U8 = 0;
    U16 U16 = 2;
    S16 S16 = 3;
    U32 U32 = 4, INVALIDASEL7=6, INVALIDBSEL7=6, INVALIDSEL7=6;
    IntegerSPA U32, S32, U24, S24, U16H0, S16H0, U16H1, S16H1;
    IntegerSPB U16H0, S16H0, U24, S24;
    IntegerSPC U32, S32, U24, S24, U16H0, S16H0;
    IMADSP_SD SD=3;
    VInteger32 U32 = 4, S32 = 5, INVALIDASEL7=7, INVALIDASEL6=6,
                      INVALIDBSEL7=7, INVALIDBSEL6=6, INVALIDSEL7=7, INVALIDSEL6=6;

    Integer = Integer8 + Integer16 + Integer32 + Integer64;
    UInteger_old = U8 + U16 + U32;
    LInteger = Integer8 + Integer16 + Integer32 + Integer64 + Integer128;
    Integer1632 = Integer16 + Integer32;
    IntegerNo8 = Invalid8 + Integer16 + Integer32 + Integer64;
    IntegerInv8No64 = Invalid8 + Integer16 + Integer32;
    IntegerNo16 = Integer8 + Integer32 + Integer64;
    IntegerNo64 = Integer8 + Integer16 + Integer32;
    IntegerNo16Inv64 = Integer8 + Integer32 + Invalid64;
    IntegerNo16No64 = Integer8 + Integer32;


    UInteger = UInteger8 + UInteger16 + UInteger32 + UInteger64;
    ULInteger = UInteger8 + UInteger16 + UInteger32 + UInteger64 + UInteger128;
    UInteger1632 = UInteger16 + UInteger32;
    UIntegerNo8 = Invalid8 + UInteger16 + UInteger32 + UInteger64;
    UIntegerInv8No64 = Invalid8 + UInteger16 + UInteger32;
    UIntegerNo16 = UInteger8 + UInteger32 + UInteger64;
    UIntegerNo64 = UInteger8 + UInteger16 + UInteger32;
    UIntegerNo16Inv64 = UInteger8 + UInteger32 + Invalid64;
    UIntegerNo16No64 = UInteger8 + UInteger32;

    SInteger = SInteger8 + SInteger16 + SInteger32 + SInteger64;
    SLInteger = SInteger8 + SInteger16 + SInteger32 + SInteger64 + SInteger128;
    SInteger1632 = SInteger16 + SInteger32;
    SIntegerNo8 = Invalid8 + SInteger16 + SInteger32 + SInteger64;
    SIntegerInv8No64 = Invalid8 + SInteger16 + SInteger32;
    SIntegerNo16 = SInteger8 + SInteger32 + SInteger64;
    SIntegerNo64 = SInteger8 + SInteger16 + SInteger32;
    SIntegerNo16Inv64 = SInteger8 + SInteger32 + Invalid64;
    SIntegerNo16No64 = SInteger8 + SInteger32;




    LDInteger "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", "U.128";
    LDInteger_nU128 "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", "INVALIDSIZE7";
    LDSInteger "8"=0, "U.8", "16"=4, "U.16", "U8"=0, "U.U8", "S8", "U.S8",
        "U16", "U.U16", "S16", "U.S16", "32", "U.32", "64", "U.64",
                      "128", "U.128", "INVALIDSIZE7", "U.INVALIDSIZE7";
    CInteger SD=0, "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", INVALIDSIZE7;

    CInteger_n64_n128 SD=0, "8"=0, "16"=2, U8=0, S8=1, U16=2, S16=3, "32"=4, INVALIDSIZE6=6, INVALIDSIZE7=7;
    CInteger_64 "64"=5;
    Ofmt U32=0, S32=1, U8=2, S8=3;
    Ofmt_FP16 F16_V2=0, F32=1, MRG_H0=2, MRG_H1=3;

    AInteger "32", "64", "96", "128";
    QInteger "32", "64";
    BQInteger "64", "128";
    SQInteger U8=7, S8=7, U16=7, S16=7, S128=7, F16=7, F64=7,
                      INVALIDATOMICSIZE13=7, INVALIDATOMICSIZE14=7, INVALIDATOMICSIZE15=7,
                      "32"=0, "64"=2, F32, "F16x2.FTZ.RN", U32=0, S32, U64, "F32.FTZ.RN", S64=5, INVALIDATOMICSIZE(6..7);
    AtomicInteger "32"=0, "64"=2, F32,
        "U32" = 0, "S32", "U64", "F32.FTZ.RN", "F16x2.FTZ.RN", "S64", "SD32", "SD64";
    CASInteger U32, U64, S32=0, S64, "32"=0, "64";
    ISBERDInteger U8, U16, "32";
    maxShift "32"=0, INVALIDMAXSHIFT3, U64, S64;
    DFormat UD,SD;







    Test FALSE=0, ZFF=5, ZF0=5, LEG=7, U=8, ZFT=10, ZF1=10, TRUE=15, NOT_OVERFLOW=16, "0FF"=16,
              CFF=17, CARRY=17, ABOVE=18, SF0=18, SIGN=19, SF1=21, CFT=22, CF1=22, OF1=23, OVERFLOW=23,
              NOT_SIGN=28, BELOW_OR_EQUAL=29, NOT_CARRY=30, "1E"=30, "1F"=31,
              F=0, LT, EQ, LE, GT, NE, GE, NUM, NAN, LTU, EQU, LEU, GTU,
              NEU, GEU, T, OFF, LO, SFF, LS, HI, SFT, HS, OFT, CSM_TA,
              CSM_TR, CSM_MX, FCSM_TA, FCSM_TR, FCSM_MX, RLE, RGT;

    Scale NONE, D2, D4, D8, M8, M4, M2, INVALIDSCALE37;

    ISWZ H1_H0=0, F32, H0_H0, H1_H1;

    ICmpAll F, LT, EQ, LE, GT, NE, GE, T;
    ICmpU LO=1, LS=3, HI=4, HS=6;

    IDEAction EN,DI;
    IDEActionENOnly EN=0;
    IDEActionDIOnly DI=1;

    TPhase noPhase,T,P,INVALIDPHASE3;
    ITypeI I;
    ITypeF F;
    BVal BM, BF;

    PR PR;
    H1H0 H0,H1;
    Partsel "32", H0, H1;
    B1B0 H0, H1=2, B(0..3)=(0..3);
    B3B0 B(0..3)=(0..3);
    I2XH H0=0, INVALIDSIZE1, H1=2, INVALIDSIZE3;
    HILO LO,HI;
    LOOnly LO;
    HIOnly HI;
    RelOpt REL;

    X noX, X;
    XMode noX, XLO, XMED, XHI;
    SHFXMode NONE, HI, X, XHI;
    XXHI noX, INVALIDSHRXMODE1, X, XHI;
    SHF_L L;
    SHF_R R;


    LDGcop1 CT;
    LDGcop2 CG, CS;
    XMADcop C32, CLO, CHI, CSFU, CBCC;
    XMADcop2 C32, CLO, CHI, CSFU;
    DIR NS, RS, LS;

    C C, c=0;
    V V, v=0;
    A A, a=0;
    CWMode C,W;
    B noB, B;
    P noP, P;
    Phys PHYS;
    CAS CAS;
    CAST CAST;
    VTG VTG;
    E noE, E;
    LDG_E noE, E=2;
    U noU, U;
    S noS, S;
    DC noDC, DC;
    MS noMS, MS;
    CL noCL, CL;
    PO noPO, PO;
    PSL noPSL, PSL;
    SH noSH, SH;
    MRG noMRG, MRG;
    NDV noNDV, NDV;
    LMT noLMT, LMT;
    FTZ noFTZ, FTZ;
    H_AND noH_AND, H_AND;
    SAT noSAT, SAT;
    AVRG noAVRG, AVRG;
    TOFF1 noTOFF, AOFFI;
    TOFF2 noTOFF, AOFFI, PTP=2, INVALIDBTOFF03;
    BREV noBREV, BREV;
    NODEP noNODEP, NODEP;
    SKEW noSKEW, SKEW;

    LUTOnly LUT;
    BOnly B;
    DOnly D;
    POnly P;
    LEOnly LE;
    ALLOnly ALL;
    BA noBA, BA;





    FMZ noFTZ, FTZ, FMZ, INVALIDFMZ3;
    LOD noLOD, LZ, LB, LL, INVALIDBLOD(4..5), LBA, LLA;
    LOD1 LZ,LL;
    LOD2 noLOD, LZ, LL;
    LODOnly LOD;
    LC noLC, LC;

    PMode IDX, F4E, B4E, RC8, ECL, ECR, RC16, INVALIDPMODE7;
    VoteOp ALL,ANY,EQ,INVALIDVMODE3;
    VTGMode R, A, RA, INVALIDVTGMODE3;

    BPTMode DRAIN_ILLEGAL,CAL,PAUSE,TRAP,INT,DRAIN;
    BPTModeN DRAIN,CAL,PAUSE;
    BPTModeN2 TRAP=3;

    KeepRefCount noKEEPREFCOUNT, KEEPREFCOUNT;

    ChkMode DIVIDE, INVALIDCHKMODE(1..63);


    AdMode IA, IL, IS, ISL;
    MN MN,MX;

    Shflmd IDX=0, UP, DOWN, BFLY;

    Barmd BAR, RESULT, WARP, INVALID;
    BarmdBAR BAR = 0, INVALID=3;
    BarmdRESULT RESULT = 1;
    BarmdWARP WARP = 2;

    OutType INVALIDOUTSTYPE0, EMIT, CUT, EMIT_THEN_CUT;

    PixMode MSCOUNT,COVMASK,COVERED,OFFSET,CENTROID_OFFSET,MY_INDEX,INVALIDPIXMODE(6..7),INVALID(0..1)=(6..7);
    MSI C=0,INVALIDMSI3=3,CENTER=0,CENTROID,OFFSET,INVALID;


    MufuOp COS, SIN, EX2, LG2, RCP, RSQ, RCP64H, RSQ64H, SQRT,
                   INVALIDMUFUOPCODE9, INVALIDMUFUOPCODEA, INVALIDMUFUOPCODEB, INVALIDMUFUOPCODEC,
                   INVALIDMUFUOPCODED, INVALIDMUFUOPCODEE, INVALIDMUFUOPCODEF;
    BarSyncArv SYNC, ARV;
    BarSync SYNC = 0;
    BarArv ARV = 1;
    BarRED RED = 2;
    BarSCAN SCAN = 3;
    BarSYNCALL SYNCALL = 4;


    Arv SYNC,ARV;
    RTTOp POPCRS, TERMINATE, FALLTHROUGH, PREEMPTED;
    RROOp SINCOS, EX2;
    AIO I, O;
    Trig TRIG = 1;
    STPMode noWAIT, WAIT;
    ISBERDIO I, O;

    OnlyNoDep NODEP;
    OnlyT T;

    LoadCacheOp CS=0, CA=0, LU=1, CG=1, CI=2, CV=3;
    LLoadCacheOp CS=0, CA=0, LU=1, CI=2, CV=3;
    StoreCacheOp WB, CG, CS, WT;
    OnlyQry QRY1;
    CCTLOp PF1=1, PF1.5, PF2, WB, IV, RS=7, RSLB=9, INVALIDCCTLOP(10..15);
    CCTLTOpIVALL IVALL=0;
    CCTLTOp IVTH=1, INVALIDCCTLTOP(2..3);
    CCTLOpRSLB RSLB=9;
    OnlyIvall IVALL=6;
    CCTLLOp2 IVALL=6;
    CCTLLOp3 WBALL=8;

    RGBA INVALIDRGBAMASK(1..15)=(1..15),
                   R=1, G, RG, B, RB, GB, RGB, A, RA, GA, RGA, BA, RBA, GBA, RGBA;
    TEXWmsk2C R=0, G, B, A, RG, RA, GA, BA;
    TEXWmsk34C RGB=0, RGA, RBA, GBA, RGBA, INVALID5=5, INVALID6=6, INVALID7=7;
    Dim "1D", "2D", INVALIDSURFACEDIM2, "3D"=2, "E2D";
    Dim1 "1D", "1D_BUFFER", "1D_ARRAY", "2D", "2D_ARRAY", "3D", "INVALIDSURFACEDIM6", "INVALIDSURFACEDIM7";

    BDim "1D", "MD";
    ThreeD "2D", "3D";
    Clamp1 IGN,NEAR,TRAP,INVALIDSURFACECLAMP3;






    TexComp R,G,B,A;

    TXQMode TEX_HEADER_DIMENSION, TEX_HEADER_TEXTURE_TYPE, TEX_HEADER_SAMPLER_POS, "3", "4", "5", "6", "7",
                   TEX_SAMPLER_FILTER, TEX_SAMPLER_LOD, TEX_SAMPLER_WRAP, TEX_SAMPLER_BORDER_COLOR, "12", "13",
                   "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
                   "30", "31";

    ParamA "_1D" = 0b00_0,
                   "1D" = 0b00_0,
                   RECT = 0b01_0,
                   "_2D" = 0b01_0,
                   "2D" = 0b01_0,
                   "_3D" = 0b10_0,
                   "3D" = 0b10_0,
                   CUBE = 0b11_0,
                   ARRAY_1D = 0b00_1,
                   ARRAY_RECT = 0b01_1,
                   ARRAY_2D = 0b01_1,
                   ARRAY_3D = 0b10_1,
                   CUBEARRAY = 0b11_1,
                   ARRAY_CUBE = 0b11_1;

    MemBarLevel CTA,GL,SYS,VC;
    MemBarIvall NOIVALL, IVALLD, IVALLT, IVALLTD;

    Cache D,U,C,I;
    Cache3 D,U,C,I,CRS,INVALIDCCTLCACHEOP5=5,INVALIDCCTLCACHEOP6=6,INVALIDCCTLCACHEOP7=7,INVALIDCACHETYPE5=5,INVALIDCACHETYPE6=6,INVALIDCACHETYPE7=7;
    Cache3NoCI D,U,CRS=4,INVALIDCCTLCACHEOP5=5,INVALIDCCTLCACHEOP6=6,INVALIDCCTLCACHEOP7=7,INVALIDCACHETYPE5=5,INVALIDCACHETYPE6=6,INVALIDCACHETYPE7=7;
    Cache3CI C=2,I;
    LCache D,INVALIDLCACHETYPE2=2,INVALIDLCACHETYPE3;
    CRSOnly CRS=1;




    LaneMask2
        X = 0b01,
        Y = 0b10,
        XY = 0b11;

    LaneMask4
        X = 0b0100,
        Y = 0b1000,
        Z = 0b0001,
        W = 0b0010,
        XW = 0b0110,
        YW = 0b1010,
        ZW = 0b0011,
        XZ = 0b0101,
        YZ = 0b1001,
        XY = 0b1100,
        YZW = 0b1011,
        XZW = 0b0111,
        XYW = 0b1110,
        XYZ = 0b1101,
        XYZW = 0b1111
        ;




   ASel4
        "0000","1111","2222","3333","3210","4321","5432","6543","3201","3012","0213","3120","1230","2310",
        ASEL4E, ASEL4F, INVALIDASEL4E=14, INVALIDASEL4F;

   BSel4
        "4444","5555","6666","7777","7654","6543","5432","4321","4567","6745","5476",BSEL4B,BSEL4C,BSEL4D,
        BSEL4E, INVALIDBSEL4B=11, INVALIDBSEL4C, INVALIDBSEL4D, INVALIDBSEL4E;

   Sel2
        "00","01","02","03",
        "10","11","12","13",
        "20","21","22","23",
        "30","31","32","33";


   Sel2hi
        "00","01",
        "10","11";


    PNWord
        PPPPPPPP,PPPPPPNP,PPPPPPPN,PPPPPPZP,PPPPNPPP,PPPPNPNP,PPPPNPPN,PPPPNPZP,
        PPPPPNPP,PPPPPNNP,PPPPPNPN,PPPPPNZP,PPPPZPPP,PPPPZPNP,PPPPZPPN,PPPPZPZP,
        PPNPPPPP,PPNPPPNP,PPNPPPPN,PPNPPPZP,PPNPNPPP,PPNPNPNP,PPNPNPPN,PPNPNPZP,
        PPNPPNPP,PPNPPNNP,PPNPPNPN,PPNPPNZP,PPNPZPPP,PPNPZPNP,PPNPZPPN,PPNPZPZP,
        PPPNPPPP,PPPNPPNP,PPPNPPPN,PPPNPPZP,PPPNNPPP,PPPNNPNP,PPPNNPPN,PPPNNPZP,
        PPPNPNPP,PPPNPNNP,PPPNPNPN,PPPNPNZP,PPPNZPPP,PPPNZPNP,PPPNZPPN,PPPNZPZP,
        PPZPPPPP,PPZPPPNP,PPZPPPPN,PPZPPPZP,PPZPNPPP,PPZPNPNP,PPZPNPPN,PPZPNPZP,
        PPZPPNPP,PPZPPNNP,PPZPPNPN,PPZPPNZP,PPZPZPPP,PPZPZPNP,PPZPZPPN,PPZPZPZP,
        NPPPPPPP,NPPPPPNP,NPPPPPPN,NPPPPPZP,NPPPNPPP,NPPPNPNP,NPPPNPPN,NPPPNPZP,
        NPPPPNPP,NPPPPNNP,NPPPPNPN,NPPPPNZP,NPPPZPPP,NPPPZPNP,NPPPZPPN,NPPPZPZP,
        NPNPPPPP,NPNPPPNP,NPNPPPPN,NPNPPPZP,NPNPNPPP,NPNPNPNP,NPNPNPPN,NPNPNPZP,
        NPNPPNPP,NPNPPNNP,NPNPPNPN,NPNPPNZP,NPNPZPPP,NPNPZPNP,NPNPZPPN,NPNPZPZP,
        NPPNPPPP,NPPNPPNP,NPPNPPPN,NPPNPPZP,NPPNNPPP,NPPNNPNP,NPPNNPPN,NPPNNPZP,
        NPPNPNPP,NPPNPNNP,NPPNPNPN,NPPNPNZP,NPPNZPPP,NPPNZPNP,NPPNZPPN,NPPNZPZP,
        NPZPPPPP,NPZPPPNP,NPZPPPPN,NPZPPPZP,NPZPNPPP,NPZPNPNP,NPZPNPPN,NPZPNPZP,
        NPZPPNPP,NPZPPNNP,NPZPPNPN,NPZPPNZP,NPZPZPPP,NPZPZPNP,NPZPZPPN,NPZPZPZP,
        PNPPPPPP,PNPPPPNP,PNPPPPPN,PNPPPPZP,PNPPNPPP,PNPPNPNP,PNPPNPPN,PNPPNPZP,
        PNPPPNPP,PNPPPNNP,PNPPPNPN,PNPPPNZP,PNPPZPPP,PNPPZPNP,PNPPZPPN,PNPPZPZP,
        PNNPPPPP,PNNPPPNP,PNNPPPPN,PNNPPPZP,PNNPNPPP,PNNPNPNP,PNNPNPPN,PNNPNPZP,
        PNNPPNPP,PNNPPNNP,PNNPPNPN,PNNPPNZP,PNNPZPPP,PNNPZPNP,PNNPZPPN,PNNPZPZP,
        PNPNPPPP,PNPNPPNP,PNPNPPPN,PNPNPPZP,PNPNNPPP,PNPNNPNP,PNPNNPPN,PNPNNPZP,
        PNPNPNPP,PNPNPNNP,PNPNPNPN,PNPNPNZP,PNPNZPPP,PNPNZPNP,PNPNZPPN,PNPNZPZP,
        PNZPPPPP,PNZPPPNP,PNZPPPPN,PNZPPPZP,PNZPNPPP,PNZPNPNP,PNZPNPPN,PNZPNPZP,
        PNZPPNPP,PNZPPNNP,PNZPPNPN,PNZPPNZP,PNZPZPPP,PNZPZPNP,PNZPZPPN,PNZPZPZP,
        ZPPPPPPP,ZPPPPPNP,ZPPPPPPN,ZPPPPPZP,ZPPPNPPP,ZPPPNPNP,ZPPPNPPN,ZPPPNPZP,
        ZPPPPNPP,ZPPPPNNP,ZPPPPNPN,ZPPPPNZP,ZPPPZPPP,ZPPPZPNP,ZPPPZPPN,ZPPPZPZP,
        ZPNPPPPP,ZPNPPPNP,ZPNPPPPN,ZPNPPPZP,ZPNPNPPP,ZPNPNPNP,ZPNPNPPN,ZPNPNPZP,
        ZPNPPNPP,ZPNPPNNP,ZPNPPNPN,ZPNPPNZP,ZPNPZPPP,ZPNPZPNP,ZPNPZPPN,ZPNPZPZP,
        ZPPNPPPP,ZPPNPPNP,ZPPNPPPN,ZPPNPPZP,ZPPNNPPP,ZPPNNPNP,ZPPNNPPN,ZPPNNPZP,
        ZPPNPNPP,ZPPNPNNP,ZPPNPNPN,ZPPNPNZP,ZPPNZPPP,ZPPNZPNP,ZPPNZPPN,ZPPNZPZP,
        ZPZPPPPP,ZPZPPPNP,ZPZPPPPN,ZPZPPPZP,ZPZPNPPP,ZPZPNPNP,ZPZPNPPN,ZPZPNPZP,
        ZPZPPNPP,ZPZPPNNP,ZPZPPNPN,ZPZPPNZP,ZPZPZPPP,ZPZPZPNP,ZPZPZPPN,ZPZPZPZP;

    BASE MAP, PATCH, PRIM, ATTR;
hfma2__v2_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hfma2__v2_fmz "nofmz"=0 , "FTZ"=1 , "FMZ"=2 , "INVALID"=3;
hfma2__v2_sat "nosat"=0 , "SAT"=1;
hfma2__v2_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v2_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v2_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hfma2__v2_Rb "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v2_Sb_iswz_Rb_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hfma2__v2_Rc "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v2_Rc_iswz_Rc_reg_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hfma2__v1_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hfma2__v1_fmz "nofmz"=0 , "FTZ"=1 , "FMZ"=2 , "INVALID"=3;
hfma2__v1_sat "nosat"=0 , "SAT"=1;
hfma2__v1_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v1_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v1_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hfma2__v1_Rc "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v1_Rc_iswz_Rc_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hfma2__v0_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hfma2__v0_fmz "nofmz"=0 , "FTZ"=1 , "FMZ"=2 , "INVALID"=3;
hfma2__v0_sat "nosat"=0 , "SAT"=1;
hfma2__v0_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v0_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v0_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hfma2__v0_Rc "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hfma2__v0_Rc_iswz_Rc_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2__v2_bval "BM"=0 , "BF"=1;
hset2__v2_cmp "LE"=3 , "GE"=6 , "GEU"=14 , "LTU"=9 , "F"=0 , "EQU"=10 , "NAN"=8 , "NE"=5 , "T"=15 , "LT"=1 , "GT"=4 , "LEU"=11 , "NUM"=7 , "NEU"=13 , "EQ"=2 , "GTU"=12;
hset2__v2_ftz "noftz"=0 , "FTZ"=1;
hset2__v2_bop "AND"=0 , "XOR"=2 , "OR"=1;
hset2__v2_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2__v2_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2__v2_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2__v2_Rb "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2__v2_Sb_iswz_Rb_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2__v1_bval "BM"=0 , "BF"=1;
hset2__v1_cmp "LE"=3 , "GE"=6 , "GEU"=14 , "LTU"=9 , "F"=0 , "EQU"=10 , "NAN"=8 , "NE"=5 , "T"=15 , "LT"=1 , "GT"=4 , "LEU"=11 , "NUM"=7 , "NEU"=13 , "EQ"=2 , "GTU"=12;
hset2__v1_ftz "noftz"=0 , "FTZ"=1;
hset2__v1_bop "AND"=0 , "XOR"=2 , "OR"=1;
hset2__v1_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2__v1_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2__v1_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2__v0_bval "BM"=0 , "BF"=1;
hset2__v0_cmp "LE"=3 , "GE"=6 , "GEU"=14 , "LTU"=9 , "F"=0 , "EQU"=10 , "NAN"=8 , "NE"=5 , "T"=15 , "LT"=1 , "GT"=4 , "LEU"=11 , "NUM"=7 , "NEU"=13 , "EQ"=2 , "GTU"=12;
hset2__v0_ftz "noftz"=0 , "FTZ"=1;
hset2__v0_bop "AND"=0 , "XOR"=2 , "OR"=1;
hset2__v0_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2__v0_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2__v0_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2_bop__v1_bval "BM"=0 , "BF"=1;
hset2_bop__v1_cmp "LE"=3 , "GE"=6 , "GEU"=14 , "LTU"=9 , "F"=0 , "EQU"=10 , "NAN"=8 , "NE"=5 , "T"=15 , "LT"=1 , "GT"=4 , "LEU"=11 , "NUM"=7 , "NEU"=13 , "EQ"=2 , "GTU"=12;
hset2_bop__v1_ftz "noftz"=0 , "FTZ"=1;
hset2_bop__v1_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2_bop__v1_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2_bop__v1_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2_bop__v0_bval "BM"=0 , "BF"=1;
hset2_bop__v0_cmp "LE"=3 , "GE"=6 , "GEU"=14 , "LTU"=9 , "F"=0 , "EQU"=10 , "NAN"=8 , "NE"=5 , "T"=15 , "LT"=1 , "GT"=4 , "LEU"=11 , "NUM"=7 , "NEU"=13 , "EQ"=2 , "GTU"=12;
hset2_bop__v0_ftz "noftz"=0 , "FTZ"=1;
hset2_bop__v0_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2_bop__v0_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2_bop__v0_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hmul2_32i__fmz "nofmz"=0 , "FTZ"=1 , "FMZ"=2 , "INVALID"=3;
hmul2_32i__sat "nosat"=0 , "SAT"=1;
hmul2_32i__Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2_32i__Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2_32i__Ra_iswz_Ra_32i_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2_bop__v2_bval "BM"=0 , "BF"=1;
hset2_bop__v2_cmp "LE"=3 , "GE"=6 , "GEU"=14 , "LTU"=9 , "F"=0 , "EQU"=10 , "NAN"=8 , "NE"=5 , "T"=15 , "LT"=1 , "GT"=4 , "LEU"=11 , "NUM"=7 , "NEU"=13 , "EQ"=2 , "GTU"=12;
hset2_bop__v2_ftz "noftz"=0 , "FTZ"=1;
hset2_bop__v2_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2_bop__v2_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2_bop__v2_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hset2_bop__v2_Rb "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hset2_bop__v2_Sb_iswz_Rb_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hadd2__v0_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hadd2__v0_ftz "noftz"=0 , "FTZ"=1;
hadd2__v0_sat "nosat"=0 , "SAT"=1;
hadd2__v0_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2__v0_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2__v0_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hadd2__v1_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hadd2__v1_ftz "noftz"=0 , "FTZ"=1;
hadd2__v1_sat "nosat"=0 , "SAT"=1;
hadd2__v1_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2__v1_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2__v1_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hadd2__v2_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hadd2__v2_ftz "noftz"=0 , "FTZ"=1;
hadd2__v2_sat "nosat"=0 , "SAT"=1;
hadd2__v2_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2__v2_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2__v2_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hadd2__v2_Rb "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2__v2_Sb_iswz_Rb_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hmul2__v2_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hmul2__v2_fmz "nofmz"=0 , "FTZ"=1 , "FMZ"=2 , "INVALID"=3;
hmul2__v2_sat "nosat"=0 , "SAT"=1;
hmul2__v2_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2__v2_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2__v2_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hmul2__v2_Rb "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2__v2_Sb_iswz_Rb_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hadd2_32i__ftz "noftz"=0 , "FTZ"=1;
hadd2_32i__sat "nosat"=0 , "SAT"=1;
hadd2_32i__Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2_32i__Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hadd2_32i__Ra_iswz_Ra_32i_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hmul2__v1_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hmul2__v1_fmz "nofmz"=0 , "FTZ"=1 , "FMZ"=2 , "INVALID"=3;
hmul2__v1_sat "nosat"=0 , "SAT"=1;
hmul2__v1_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2__v1_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2__v1_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;
hmul2__v0_ofmt "MRG_H1"=3 , "MRG_H0"=2 , "F32"=1 , "F16_V2"=0;
hmul2__v0_fmz "nofmz"=0 , "FTZ"=1 , "FMZ"=2 , "INVALID"=3;
hmul2__v0_sat "nosat"=0 , "SAT"=1;
hmul2__v0_Rd "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2__v0_Ra "R147"=147 , "R146"=146 , "R145"=145 , "R144"=144 , "R143"=143 , "R142"=142 , "R141"=141 , "R140"=140 , "R254"=254 , "R253"=253 , "R178"=178 , "R149"=149 , "R148"=148 , "R231"=231 , "R179"=179 , "RZ"=255 , "R183"=183 , "R38"=38 , "R39"=39 , "R34"=34 , "R35"=35 , "R36"=36 , "R37"=37 , "R30"=30 , "R31"=31 , "R32"=32 , "R33"=33 , "R4"=4 , "R5"=5 , "R6"=6 , "R7"=7 , "R0"=0 , "R1"=1 , "R2"=2 , "R3"=3 , "R8"=8 , "R9"=9 , "R182"=182 , "R89"=89 , "R88"=88 , "R170"=170 , "R171"=171 , "R176"=176 , "R177"=177 , "R174"=174 , "R175"=175 , "R81"=81 , "R80"=80 , "R83"=83 , "R82"=82 , "R85"=85 , "R84"=84 , "R87"=87 , "R86"=86 , "R205"=205 , "R248"=248 , "R169"=169 , "R168"=168 , "R98"=98 , "R99"=99 , "R96"=96 , "R97"=97 , "R94"=94 , "R95"=95 , "R92"=92 , "R93"=93 , "R90"=90 , "R91"=91 , "R16"=16 , "R17"=17 , "R14"=14 , "R15"=15 , "R12"=12 , "R13"=13 , "R10"=10 , "R11"=11 , "R181"=181 , "R18"=18 , "R19"=19 , "R180"=180 , "R251"=251 , "R187"=187 , "R250"=250 , "R186"=186 , "R200"=200 , "R201"=201 , "R202"=202 , "R203"=203 , "R204"=204 , "R185"=185 , "R206"=206 , "R207"=207 , "R208"=208 , "R209"=209 , "R184"=184 , "R118"=118 , "R119"=119 , "R110"=110 , "R111"=111 , "R112"=112 , "R113"=113 , "R114"=114 , "R115"=115 , "R116"=116 , "R117"=117 , "R63"=63 , "R62"=62 , "R61"=61 , "R60"=60 , "R67"=67 , "R66"=66 , "R65"=65 , "R64"=64 , "R193"=193 , "R69"=69 , "R68"=68 , "R162"=162 , "R249"=249 , "R213"=213 , "R212"=212 , "R211"=211 , "R210"=210 , "R217"=217 , "R216"=216 , "R215"=215 , "R214"=214 , "R219"=219 , "R218"=218 , "R109"=109 , "R108"=108 , "R194"=194 , "R103"=103 , "R102"=102 , "R101"=101 , "R100"=100 , "R107"=107 , "R106"=106 , "R105"=105 , "R104"=104 , "R190"=190 , "R247"=247 , "R220"=220 , "R191"=191 , "R240"=240 , "R252"=252 , "R192"=192 , "R241"=241 , "R70"=70 , "R71"=71 , "R72"=72 , "R73"=73 , "R74"=74 , "R75"=75 , "R76"=76 , "R77"=77 , "R78"=78 , "R79"=79 , "R195"=195 , "R136"=136 , "R137"=137 , "R134"=134 , "R135"=135 , "R132"=132 , "R133"=133 , "R130"=130 , "R131"=131 , "R226"=226 , "R227"=227 , "R224"=224 , "R197"=197 , "R222"=222 , "R223"=223 , "R138"=138 , "R139"=139 , "R238"=238 , "R198"=198 , "R196"=196 , "R199"=199 , "R45"=45 , "R44"=44 , "R47"=47 , "R46"=46 , "R41"=41 , "R40"=40 , "R43"=43 , "R42"=42 , "R189"=189 , "R188"=188 , "R49"=49 , "R48"=48 , "R121"=121 , "R120"=120 , "R123"=123 , "R122"=122 , "R125"=125 , "R124"=124 , "R127"=127 , "R126"=126 , "R129"=129 , "R128"=128 , "R233"=233 , "R232"=232 , "R235"=235 , "R234"=234 , "R237"=237 , "R236"=236 , "R165"=165 , "R164"=164 , "R239"=239 , "R167"=167 , "R166"=166 , "R228"=228 , "R161"=161 , "R229"=229 , "R160"=160 , "R58"=58 , "R59"=59 , "R163"=163 , "R52"=52 , "R53"=53 , "R50"=50 , "R51"=51 , "R56"=56 , "R57"=57 , "R54"=54 , "R55"=55 , "R225"=225 , "R154"=154 , "R155"=155 , "R156"=156 , "R157"=157 , "R150"=150 , "R151"=151 , "R152"=152 , "R153"=153 , "R244"=244 , "R245"=245 , "R246"=246 , "R221"=221 , "R158"=158 , "R159"=159 , "R242"=242 , "R243"=243 , "R172"=172 , "R230"=230 , "R173"=173 , "R29"=29 , "R28"=28 , "R27"=27 , "R26"=26 , "R25"=25 , "R24"=24 , "R23"=23 , "R22"=22 , "R21"=21 , "R20"=20;
hmul2__v0_Ra_iswz_Ra_mod "H1_H1"=3 , "H1_H0"=0 , "F32"=1 , "H0_H0"=2;





TABLES

   FixLatDestMap
         '&' 0 -> 0
         '&' 1 -> 1
         '&' 2 -> 2
         '&' 3 -> 3
         '&' 4 -> 4
         '&' 5 -> 5
         '&' 6 -> 6
         '&' 7 -> 6
         '&' 8 -> 7
         '/' 0 -> 8
         '/' 1 -> 9
         '/' 2 -> 10
         '/' 3 -> 11
         '/' 4 -> 12
         '/' 5 -> 13
         '/' 6 -> 14
         '/' 7 -> 14
         '/' 8 -> 7
         ;



    VarLatOperandEnc
         0 -> 0
         1 -> 1
         2 -> 2
         3 -> 3
         4 -> 4
         5 -> 5
         6 -> 6
         7 -> 7
         0xffff -> 7
         ;

    DestPred
        Predicate@P0 -> 7
        Predicate@P1 -> 6
        Predicate@P2 -> 5
        Predicate@P3 -> 4
        Predicate@P4 -> 3
        Predicate@P5 -> 2
        Predicate@P6 -> 1
        Predicate@P7 -> 0
        Predicate@PT -> 0
        ;

   IntSize
          Integer@U8 -> 0b0_00
          Integer@S8 -> 0b1_00
          Integer@U16 -> 0b0_01
          Integer@S16 -> 0b1_01
          Integer@U32 -> 0b0_10
          Integer@S32 -> 0b1_10
          Integer@U64 -> 0b0_11
          Integer@S64 -> 0b1_11
          ;

   IsSigned16
          Integer16@U16 -> 0
          Integer16@S16 -> 1
   ;

   IsSigned
          Integer32@U32 -> 0
          Integer32@S32 -> 1
          ;

   IsSPASigned
          IntegerSPA@U32 -> 0
          IntegerSPA@U24 -> 0
          IntegerSPA@U16H0 -> 0
          IntegerSPA@U16H1 -> 0
          IntegerSPA@S32 -> 1
          IntegerSPA@S24 -> 1
          IntegerSPA@S16H0 -> 1
          IntegerSPA@S16H1 -> 1
          ;

   IsSPBSigned
          IntegerSPB@U24 -> 0
          IntegerSPB@U16H0 -> 0
          IntegerSPB@S24 -> 1
          IntegerSPB@S16H0 -> 1
          ;

   IsSPCSigned
          IntegerSPC@U32 -> 0
          IntegerSPC@U24 -> 0
          IntegerSPC@U16H0 -> 0
          IntegerSPC@S32 -> 1
          IntegerSPC@S24 -> 1
          IntegerSPC@S16H0 -> 1
          ;

   GetSPExtract
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_00_000
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_00_000
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_00_010
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_00_010
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_00_100
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_00_100
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_00_110
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_00_110

          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_01_000
          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_01_000
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_01_010
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_01_010
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_01_100
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_01_100
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_01_110
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_01_110

          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_10_000
          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_10_000
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_10_010
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_10_010
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_10_110
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_10_110

          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_00_000
          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_00_000
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_00_010
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_00_010
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_00_100
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_00_100
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_00_110
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_00_110

          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_00_001
          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_00_001
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_00_011
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_00_011
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_00_101
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_00_101
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_00_111
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_00_111

          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_00_001
          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_00_001
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_00_011
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_00_011
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_00_101
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_00_101
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_00_111
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_00_111

          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_01_000
          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_01_000
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_01_010
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_01_010
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_01_100
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_01_100
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_01_110
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_01_110

          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_01_001
          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_01_001
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_01_011
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_01_011
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_01_101
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_01_101
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_01_111
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_01_111

          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_01_001
          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_01_001
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_01_011
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_01_011
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_01_101
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_01_101
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_01_111
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_01_111

          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_10_000
          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_10_000
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_10_010
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_10_010
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_10_110
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_10_110

          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_10_001
          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_10_001
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_10_011
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_10_011
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_10_111
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_10_111

          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_10_001
          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_10_001
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_10_011
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_10_011
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_10_111
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_10_111


          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_00_000
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_00_000
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_00_010
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_00_010
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_00_100
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_00_100
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_00_110
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_00_110

          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_00_001
          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_00_001
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_00_011
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_00_011
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_00_101
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_00_101
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_00_111
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_00_111

          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_00_001
          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_00_001
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_00_011
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_00_011
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_00_101
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_00_101
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_00_111
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_00_111

          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_01_000
          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_01_000
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_01_010
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_01_010
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_01_100
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_01_100
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_01_110
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_01_110

          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_01_001
          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_01_001
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_01_011
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_01_011
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_01_101
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_01_101
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_01_111
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_01_111

          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_01_001
          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_01_001
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_01_011
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_01_011
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_01_101
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_01_101
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_01_111
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_01_111

          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_10_000
          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_10_000
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_10_010
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_10_010
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_10_110
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_10_110

          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_10_001
          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_10_001
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_10_011
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_10_011
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_10_111
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_10_111

          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_10_001
          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_10_001
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_10_011
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_10_011
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_10_111
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_10_111

          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_00_000
          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_00_000
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_00_010
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_00_010
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_00_100
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_00_100
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_00_110
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_00_110

          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_01_000
          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_01_000
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_01_010
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_01_010
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_01_100
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_01_100
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_01_110
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_01_110

          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_10_000
          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_10_000
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_10_010
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_10_010
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_10_110
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_10_110
        ;

   IsSameSigned
          Integer32@U32 Integer32@U32 -> 0
          Integer32@S32 Integer32@S32 -> 1
          Integer32@S32 Integer32@U32 -> 0
          Integer32@U32 Integer32@S32 -> 0
          ;

   I2I_N_Sizes
          Integer1632@U16 Integer1632@U16 -> 0b0000
          Integer1632@S16 Integer1632@U16 -> 0b0010
          Integer1632@U32 Integer1632@U16 -> 0b0100
          Integer1632@S32 Integer1632@U16 -> 0b0110

          Integer1632@U16 Integer1632@S16 -> 0b0001
          Integer1632@S16 Integer1632@S16 -> 0b0011
          Integer1632@U32 Integer1632@S16 -> 0b0101
          Integer1632@S32 Integer1632@S16 -> 0b0111

          Integer1632@U16 Integer1632@U32 -> 0b1000
          Integer1632@S16 Integer1632@U32 -> 0b1010
          Integer1632@U32 Integer1632@U32 -> 0b1100
          Integer1632@S32 Integer1632@U32 -> 0b1110

          Integer1632@U16 Integer1632@S32 -> 0b1001
          Integer1632@S16 Integer1632@S32 -> 0b1011
          Integer1632@U32 Integer1632@S32 -> 0b1101
          Integer1632@S32 Integer1632@S32 -> 0b1111
          ;

Integer8Signed
          Integer8@U8 -> 0
          Integer8@S8 -> 1
          ;

Integer16Signed
          Integer16@U16 -> 0
          Integer16@S16 -> 1
          ;

IntegerSigned
          Integer@U16 -> 0
          Integer@S16 -> 1
          Integer@U8 -> 0
          Integer@S8 -> 1
          Integer@U32 -> 0
          Integer@S32 -> 1
          Integer@U64 -> 0
          Integer@S64 -> 1
          ;

Integer8x8Signed
          Integer8@U8 Integer8@U8 -> 0
          Integer8@S8 Integer8@S8 -> 1
          Integer8@S8 Integer8@U8 -> 0
          Integer8@U8 Integer8@S8 -> 0
          ;

Integer16x16Signed
          Integer16@U16 Integer16@U16 -> 0
          Integer16@S16 Integer16@S16 -> 1
          Integer16@S16 Integer16@U16 -> 0
          Integer16@U16 Integer16@S16 -> 0
          ;

    PSign
       PO@noPO 0 0 -> 0b00
       PO@noPO 0 1 -> 0b01
       PO@noPO 1 0 -> 0b10
       PO@noPO 1 1 -> 0b00
         PO@PO 0 0 -> 0b11
         PO@PO 0 1 -> 0b11
         PO@PO 1 0 -> 0b11
         PO@PO 1 1 -> 0b11
          ;

    VMode
        AVRG@noAVRG 0 0 -> 0
        AVRG@noAVRG 0 1 -> 1
        AVRG@noAVRG 1 0 -> 2
        AVRG@noAVRG 1 1 -> 0
          AVRG@AVRG 0 0 -> 3
          AVRG@AVRG 0 1 -> 3
          AVRG@AVRG 1 0 -> 3
          AVRG@AVRG 1 1 -> 3
          ;

    PSign32
        PO@noPO 0 -> 0b00
        PO@noPO 1 -> 0b10
          PO@PO 0 -> 0b11
          PO@PO 1 -> 0b00
          ;

    PSignFFMA
          0 0 -> 0
          0 1 -> 1
          1 0 -> 1
          1 1 -> 0
          ;

    PSignMAD
       PO@noPO 0 0 0 -> 0b00
       PO@noPO 1 1 0 -> 0b00
       PO@noPO 0 0 1 -> 0b01
       PO@noPO 1 0 0 -> 0b10
       PO@noPO 0 1 0 -> 0b10
       PO@noPO 1 1 1 -> 0b01
       PO@noPO 0 1 1 -> 0b00
       PO@noPO 1 0 1 -> 0b00
         PO@PO 0 0 0 -> 0b11
         PO@PO 0 0 1 -> 0b11
         PO@PO 0 1 0 -> 0b11
         PO@PO 0 1 1 -> 0b11
         PO@PO 1 0 0 -> 0b11
         PO@PO 1 0 1 -> 0b11
         PO@PO 1 1 0 -> 0b11
         PO@PO 1 1 1 -> 0b11
          ;

    CombineBP
          1 0 -> 0
          0 1 -> 1
          0 0 -> 0
          1 1 -> 0
          ;

    RCIConstBank
          0 -> 0b010
          1 -> 0b100
         16 -> 0b110
          2 -> 0b010
          3 -> 0b010
          4 -> 0b010
          5 -> 0b010
          6 -> 0b010
          7 -> 0b010
          8 -> 0b010
          9 -> 0b010
         10 -> 0b010
         11 -> 0b010
         12 -> 0b010
         13 -> 0b010
         14 -> 0b010
         15 -> 0b010
         17 -> 0b010
         18 -> 0b010
         19 -> 0b010
         20 -> 0b010
         21 -> 0b010
         22 -> 0b010
         23 -> 0b010
         24 -> 0b010
         25 -> 0b010
         26 -> 0b010
         27 -> 0b010
         28 -> 0b010
         29 -> 0b010
         30 -> 0b010
         31 -> 0b010
          ;

    CNSConstBank
          0 -> 0b01
          1 -> 0b10
         16 -> 0b11
          2 -> 0b01
          3 -> 0b01
          4 -> 0b01
          5 -> 0b01
          6 -> 0b01
          7 -> 0b01
          8 -> 0b01
          9 -> 0b01
         10 -> 0b01
         11 -> 0b01
         12 -> 0b01
         13 -> 0b01
         14 -> 0b01
         15 -> 0b01
         17 -> 0b01
         18 -> 0b01
         19 -> 0b01
         20 -> 0b01
         21 -> 0b01
         22 -> 0b01
         23 -> 0b01
         24 -> 0b01
         25 -> 0b01
         26 -> 0b01
         27 -> 0b01
         28 -> 0b01
         29 -> 0b01
         30 -> 0b01
         31 -> 0b01
          ;

    LDCNConstBank
          0 -> 0b000
          1 -> 0b001
          2 -> 0b010
          3 -> 0b011
          4 -> 0b100
          5 -> 0b101
          6 -> 0b110
         16 -> 0b111
          7 -> 0b000
          8 -> 0b000
          9 -> 0b000
         10 -> 0b000
         11 -> 0b000
         12 -> 0b000
         13 -> 0b000
         14 -> 0b000
         15 -> 0b000
         17 -> 0b000
         18 -> 0b000
         19 -> 0b000
         20 -> 0b000
         21 -> 0b000
         22 -> 0b000
         23 -> 0b000
         24 -> 0b000
         25 -> 0b000
         26 -> 0b000
         27 -> 0b000
         28 -> 0b000
         29 -> 0b000
         30 -> 0b000
         31 -> 0b000
          ;

    CRegAlignment
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 1
          CInteger@S16 -> 1
          CInteger@"32" -> 1
          CInteger@"64" -> 2
          CInteger@"128" -> 4
          CInteger@INVALIDSIZE7 -> 1
          ;

    LDGSizeMask
          CInteger@U8 -> 0b0000000000_000_0001
          CInteger@S8 -> 0b0000000000_001_0001
          CInteger@U16 -> 0b0000000000_010_0001
          CInteger@S16 -> 0b0000000000_011_0001
          CInteger@"32" -> 0b0000000000_100_0001
          CInteger@"64" -> 0b0000000000_101_0011
          CInteger@"128" -> 0b0000000000_110_1111
          CInteger@INVALIDSIZE7 -> 0b0000000000_111_0001
          ;

    LDRegAlignment
          LDInteger@U8 -> 1
          LDInteger@S8 -> 1
          LDInteger@U16 -> 1
          LDInteger@S16 -> 1
          LDInteger@"32" -> 1
          LDInteger@"64" -> 2
          LDInteger@"128" -> 4
          LDInteger@"U.128" -> 4
          ;

    BQRegAlignment
          BQInteger@"64" -> 2
          BQInteger@"128" -> 4
          ;

    ARegAlignment
          AInteger@"32" -> 1
          AInteger@"64" -> 2
          AInteger@"96" -> 4
          AInteger@"128" -> 4
          ;

    QRegAlignment
          QInteger@"32" -> 1
          QInteger@"64" -> 2
          ;

    SQRegAlignment
          SQInteger@U32 -> 1
          SQInteger@S32 -> 1
          SQInteger@"F32.FTZ.RN" -> 1
          SQInteger@"F16x2.FTZ.RN" -> 1
          SQInteger@INVALIDATOMICSIZE6 -> 1
          SQInteger@INVALIDATOMICSIZE7 -> 1
          SQInteger@U64 -> 2
          SQInteger@S64 -> 2
          ;

    CASRegAlignment
          CASInteger@"32" -> 1
          CASInteger@"64" -> 2
          ;

    CIntSize
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 2
          CInteger@S16 -> 2
          CInteger@"32" -> 4
          CInteger@"64" -> 8
          CInteger@"128" -> 16
          ;

    Video4ImmSel
          ASel4@"0000" -> 1
          ASel4@"1111" -> 1
          ASel4@"2222" -> 1
          ASel4@"3333" -> 1
          ASel4@"3210" -> 1
          ASel4@"4321" -> 1
          ASel4@"5432" -> 1
          ASel4@"6543" -> 1
          ASel4@"3201" -> 1
          ASel4@"3012" -> 1
          ASel4@"0213" -> 1
          ASel4@"3120" -> 1
          ASel4@"1230" -> 1
          ASel4@"2310" -> 1
          ASel4@INVALIDASEL4E -> 1
          ASel4@INVALIDASEL4F -> 1
          ;

    TXQModeDim
          TXQMode@TEX_HEADER_DIMENSION -> 0b00000_1
          TXQMode@TEX_HEADER_TEXTURE_TYPE -> 0b00001_0
          TXQMode@TEX_HEADER_SAMPLER_POS -> 0b00010_1
          TXQMode@"3" -> 0b00011_0
          TXQMode@"4" -> 0b00100_0
          TXQMode@"5" -> 0b00101_0
          TXQMode@"6" -> 0b00110_0
          TXQMode@"7" -> 0b00111_0
          TXQMode@TEX_SAMPLER_FILTER -> 0b01000_0
          TXQMode@TEX_SAMPLER_LOD -> 0b01001_0
          TXQMode@TEX_SAMPLER_WRAP -> 0b01010_0
          TXQMode@TEX_SAMPLER_BORDER_COLOR -> 0b01011_0
          TXQMode@"12" -> 0b01100_0
          TXQMode@"13" -> 0b01101_0
          TXQMode@"14" -> 0b01110_0
          TXQMode@"15" -> 0b01111_0
          TXQMode@"16" -> 0b10000_0
          TXQMode@"17" -> 0b10001_0
          TXQMode@"18" -> 0b10010_0
          TXQMode@"19" -> 0b10011_0
          TXQMode@"20" -> 0b10100_0
          TXQMode@"21" -> 0b10101_0
          TXQMode@"22" -> 0b10110_0
          TXQMode@"23" -> 0b10111_0
          TXQMode@"24" -> 0b11000_0
          TXQMode@"25" -> 0b11001_0
          TXQMode@"26" -> 0b11010_0
          TXQMode@"27" -> 0b11011_0
          TXQMode@"28" -> 0b11100_0
          TXQMode@"29" -> 0b11101_0
          TXQMode@"30" -> 0b11110_0
          TXQMode@"31" -> 0b11111_0
          ;

    abSize
          CInteger@U8 CInteger@U8 -> 0
          CInteger@U8 CInteger@S8 -> 1
          CInteger@U8 CInteger@U16 -> 2
          CInteger@U8 CInteger@S16 -> 3
          CInteger@U8 CInteger@"32" -> 4

          CInteger@S8 CInteger@U8 -> 5
          CInteger@S8 CInteger@S8 -> 6
          CInteger@S8 CInteger@U16 -> 7
          CInteger@S8 CInteger@S16 -> 8
          CInteger@S8 CInteger@"32" -> 9

          CInteger@U16 CInteger@U8 -> 10
          CInteger@U16 CInteger@S8 -> 11
          CInteger@U16 CInteger@U16 -> 12
          CInteger@U16 CInteger@S16 -> 13
          CInteger@U16 CInteger@"32" -> 14

          CInteger@S16 CInteger@U8 -> 15
          CInteger@S16 CInteger@S8 -> 16
          CInteger@S16 CInteger@U16 -> 17
          CInteger@S16 CInteger@S16 -> 18
          CInteger@S16 CInteger@"32" -> 19

          CInteger@"32" CInteger@U8 -> 20
          CInteger@"32" CInteger@S8 -> 21
          CInteger@"32" CInteger@U16 -> 22
          CInteger@"32" CInteger@S16 -> 23
          CInteger@"32" CInteger@"32" -> 24
          CInteger@"32" CInteger@"64" -> 25
          CInteger@"32" CInteger@"128" -> 26

          CInteger@"64" CInteger@"32" -> 27
          CInteger@"64" CInteger@"64" -> 28
          CInteger@"64" CInteger@"128" -> 29

          CInteger@"128" CInteger@"32" -> 30
          CInteger@"128" CInteger@"64" -> 31

          CInteger@U8 CInteger@"64" -> 0
          CInteger@U8 CInteger@"128" -> 0
          CInteger@S8 CInteger@"64" -> 0
          CInteger@S8 CInteger@"128" -> 0
          CInteger@U16 CInteger@"64" -> 0
          CInteger@U16 CInteger@"128" -> 0
          CInteger@S16 CInteger@"64" -> 0
          CInteger@S16 CInteger@"128" -> 0
          CInteger@"64" CInteger@U8 -> 0
          CInteger@"64" CInteger@S8 -> 0
          CInteger@"64" CInteger@U16 -> 0
          CInteger@"64" CInteger@S16 -> 0
          CInteger@"128" CInteger@U8 -> 0
          CInteger@"128" CInteger@S8 -> 0
          CInteger@"128" CInteger@U16 -> 0
          CInteger@"128" CInteger@S16 -> 0
          CInteger@"128" CInteger@"128" -> 0
          ;

    VFormat8
          Integer@U8 B1B0@B0 -> 0b0_000
          Integer@U8 B1B0@B1 -> 0b0_001
          Integer@U8 B1B0@B2 -> 0b0_010
          Integer@U8 B1B0@B3 -> 0b0_011
          Integer@S8 B1B0@B0 -> 0b1_000
          Integer@S8 B1B0@B1 -> 0b1_001
          Integer@S8 B1B0@B2 -> 0b1_010
          Integer@S8 B1B0@B3 -> 0b1_011
          ;

    VFormat16
          Integer@U16 H1H0@H0 -> 0b0_100
          Integer@U16 H1H0@H1 -> 0b0_101
          Integer@S16 H1H0@H0 -> 0b1_100
          Integer@S16 H1H0@H1 -> 0b1_101
          ;

    VFormat32
          VInteger32@U32 -> 0b0_110
          VInteger32@S32 -> 0b1_110
          6 -> 0b0_111
          7 -> 0b1_111
          ;

    VFormatU8
          U8@U8 B1B0@B0 -> 0b000
          U8@U8 B1B0@B1 -> 0b001
          U8@U8 B1B0@B2 -> 0b010
          U8@U8 B1B0@B3 -> 0b011
          ;

    VFormatU16
          U16@U16 H1H0@H0 -> 0b100
          U16@U16 H1H0@H1 -> 0b101
          ;

    VFormatU32
          U32@U32 -> 0b110
          U32@INVALIDSEL7 -> 0b111
          ;






    VFormat8_N
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b0_0_00000
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b0_0_00001
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b0_0_00010
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b0_0_00011
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b0_0_00100
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b0_0_00101
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b0_0_00110
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b0_0_00111
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b0_0_01000
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b0_0_01001
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b0_0_01010
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b0_0_01011
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b0_0_01100
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b0_0_01101
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b0_0_01110
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b0_0_01111
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b0_1_00000
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b0_1_00001
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b0_1_00010
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b0_1_00011
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b0_1_00100
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b0_1_00101
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b0_1_00110
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b0_1_00111
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b0_1_01000
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b0_1_01001
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b0_1_01010
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b0_1_01011
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b0_1_01100
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b0_1_01101
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b0_1_01110
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b0_1_01111
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b1_0_00000
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b1_0_00001
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b1_0_00010
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b1_0_00011
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b1_0_00100
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b1_0_00101
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b1_0_00110
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b1_0_00111
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b1_0_01000
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b1_0_01001
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b1_0_01010
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b1_0_01011
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b1_0_01100
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b1_0_01101
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b1_0_01110
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b1_0_01111
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b1_1_00000
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b1_1_00001
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b1_1_00010
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b1_1_00011
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b1_1_00100
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b1_1_00101
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b1_1_00110
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b1_1_00111
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b1_1_01000
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b1_1_01001
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b1_1_01010
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b1_1_01011
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b1_1_01100
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b1_1_01101
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b1_1_01110
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b1_1_01111
          ;

    VFormat32_8_N
          Integer@U32 Integer@U8 B1B0@B0 -> 0b0_0_10000
          Integer@U32 Integer@U8 B1B0@B1 -> 0b0_0_10001
          Integer@U32 Integer@U8 B1B0@B2 -> 0b0_0_10010
          Integer@U32 Integer@U8 B1B0@B3 -> 0b0_0_10011
          Integer@U32 Integer@S8 B1B0@B0 -> 0b0_1_10000
          Integer@U32 Integer@S8 B1B0@B1 -> 0b0_1_10001
          Integer@U32 Integer@S8 B1B0@B2 -> 0b0_1_10010
          Integer@U32 Integer@S8 B1B0@B3 -> 0b0_1_10011
          Integer@S32 Integer@U8 B1B0@B0 -> 0b1_0_10000
          Integer@S32 Integer@U8 B1B0@B1 -> 0b1_0_10001
          Integer@S32 Integer@U8 B1B0@B2 -> 0b1_0_10010
          Integer@S32 Integer@U8 B1B0@B3 -> 0b1_0_10011
          Integer@S32 Integer@S8 B1B0@B0 -> 0b1_1_10000
          Integer@S32 Integer@S8 B1B0@B1 -> 0b1_1_10001
          Integer@S32 Integer@S8 B1B0@B2 -> 0b1_1_10010
          Integer@S32 Integer@S8 B1B0@B3 -> 0b1_1_10011
          ;

    VFormat8_32_N
          Integer@U8 B1B0@B0 Integer@U32 -> 0b0_0_10100
          Integer@U8 B1B0@B1 Integer@U32 -> 0b0_0_10101
          Integer@U8 B1B0@B2 Integer@U32 -> 0b0_0_10110
          Integer@U8 B1B0@B3 Integer@U32 -> 0b0_0_10111
          Integer@U8 B1B0@B0 Integer@S32 -> 0b0_1_10100
          Integer@U8 B1B0@B1 Integer@S32 -> 0b0_1_10101
          Integer@U8 B1B0@B2 Integer@S32 -> 0b0_1_10110
          Integer@U8 B1B0@B3 Integer@S32 -> 0b0_1_10111
          Integer@S8 B1B0@B0 Integer@U32 -> 0b1_0_10100
          Integer@S8 B1B0@B1 Integer@U32 -> 0b1_0_10101
          Integer@S8 B1B0@B2 Integer@U32 -> 0b1_0_10110
          Integer@S8 B1B0@B3 Integer@U32 -> 0b1_0_10111
          Integer@S8 B1B0@B0 Integer@S32 -> 0b1_1_10100
          Integer@S8 B1B0@B1 Integer@S32 -> 0b1_1_10101
          Integer@S8 B1B0@B2 Integer@S32 -> 0b1_1_10110
          Integer@S8 B1B0@B3 Integer@S32 -> 0b1_1_10111
          ;

    VFormat16_N
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b0_0_11000
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b0_0_11001
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b0_0_11010
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b0_0_11011
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b0_1_11000
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b0_1_11001
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b0_1_11010
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b0_1_11011
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b1_0_11000
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b1_0_11001
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b1_0_11010
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b1_0_11011
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b1_1_11000
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b1_1_11001
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b1_1_11010
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b1_1_11011
          ;

    VFormat32_16_N
          Integer@U32 Integer@U16 H1H0@H0 -> 0b0_0_11100
          Integer@U32 Integer@U16 H1H0@H1 -> 0b0_0_11101
          Integer@U32 Integer@S16 H1H0@H0 -> 0b0_1_11100
          Integer@U32 Integer@S16 H1H0@H1 -> 0b0_1_11101
          Integer@S32 Integer@U16 H1H0@H0 -> 0b1_0_11100
          Integer@S32 Integer@U16 H1H0@H1 -> 0b1_0_11101
          Integer@S32 Integer@S16 H1H0@H0 -> 0b1_1_11100
          Integer@S32 Integer@S16 H1H0@H1 -> 0b1_1_11101
          ;

    VFormat16_32_N
          Integer@U16 H1H0@H0 Integer@U32 -> 0b0_0_11110
          Integer@U16 H1H0@H1 Integer@U32 -> 0b0_0_11111
          Integer@U16 H1H0@H0 Integer@S32 -> 0b0_1_11110
          Integer@U16 H1H0@H1 Integer@S32 -> 0b0_1_11111
          Integer@S16 H1H0@H0 Integer@U32 -> 0b1_0_11110
          Integer@S16 H1H0@H1 Integer@U32 -> 0b1_0_11111
          Integer@S16 H1H0@H0 Integer@S32 -> 0b1_1_11110
          Integer@S16 H1H0@H1 Integer@S32 -> 0b1_1_11111
          ;

    ConsecutiveReg8
          Register@R0 Register@R1 CASInteger@"32" -> 0b0_00000000
          Register@R1 Register@R2 CASInteger@"32" -> 0b0_00000001
          Register@R2 Register@R3 CASInteger@"32" -> 0b0_00000010
          Register@R3 Register@R4 CASInteger@"32" -> 0b0_00000011
          Register@R4 Register@R5 CASInteger@"32" -> 0b0_00000100
          Register@R5 Register@R6 CASInteger@"32" -> 0b0_00000101
          Register@R6 Register@R7 CASInteger@"32" -> 0b0_00000110
          Register@R7 Register@R8 CASInteger@"32" -> 0b0_00000111
          Register@R8 Register@R9 CASInteger@"32" -> 0b0_00001000
          Register@R9 Register@R10 CASInteger@"32" -> 0b0_00001001
          Register@R10 Register@R11 CASInteger@"32" -> 0b0_00001010
          Register@R11 Register@R12 CASInteger@"32" -> 0b0_00001011
          Register@R12 Register@R13 CASInteger@"32" -> 0b0_00001100
          Register@R13 Register@R14 CASInteger@"32" -> 0b0_00001101
          Register@R14 Register@R15 CASInteger@"32" -> 0b0_00001110
          Register@R15 Register@R16 CASInteger@"32" -> 0b0_00001111
          Register@R16 Register@R17 CASInteger@"32" -> 0b0_00010000
          Register@R17 Register@R18 CASInteger@"32" -> 0b0_00010001
          Register@R18 Register@R19 CASInteger@"32" -> 0b0_00010010
          Register@R19 Register@R20 CASInteger@"32" -> 0b0_00010011
          Register@R20 Register@R21 CASInteger@"32" -> 0b0_00010100
          Register@R21 Register@R22 CASInteger@"32" -> 0b0_00010101
          Register@R22 Register@R23 CASInteger@"32" -> 0b0_00010110
          Register@R23 Register@R24 CASInteger@"32" -> 0b0_00010111
          Register@R24 Register@R25 CASInteger@"32" -> 0b0_00011000
          Register@R25 Register@R26 CASInteger@"32" -> 0b0_00011001
          Register@R26 Register@R27 CASInteger@"32" -> 0b0_00011010
          Register@R27 Register@R28 CASInteger@"32" -> 0b0_00011011
          Register@R28 Register@R29 CASInteger@"32" -> 0b0_00011100
          Register@R29 Register@R30 CASInteger@"32" -> 0b0_00011101
          Register@R30 Register@R31 CASInteger@"32" -> 0b0_00011110
          Register@R31 Register@R32 CASInteger@"32" -> 0b0_00011111
          Register@R32 Register@R33 CASInteger@"32" -> 0b0_00100000
          Register@R33 Register@R34 CASInteger@"32" -> 0b0_00100001
          Register@R34 Register@R35 CASInteger@"32" -> 0b0_00100010
          Register@R35 Register@R36 CASInteger@"32" -> 0b0_00100011
          Register@R36 Register@R37 CASInteger@"32" -> 0b0_00100100
          Register@R37 Register@R38 CASInteger@"32" -> 0b0_00100101
          Register@R38 Register@R39 CASInteger@"32" -> 0b0_00100110
          Register@R39 Register@R40 CASInteger@"32" -> 0b0_00100111
          Register@R40 Register@R41 CASInteger@"32" -> 0b0_00101000
          Register@R41 Register@R42 CASInteger@"32" -> 0b0_00101001
          Register@R42 Register@R43 CASInteger@"32" -> 0b0_00101010
          Register@R43 Register@R44 CASInteger@"32" -> 0b0_00101011
          Register@R44 Register@R45 CASInteger@"32" -> 0b0_00101100
          Register@R45 Register@R46 CASInteger@"32" -> 0b0_00101101
          Register@R46 Register@R47 CASInteger@"32" -> 0b0_00101110
          Register@R47 Register@R48 CASInteger@"32" -> 0b0_00101111
          Register@R48 Register@R49 CASInteger@"32" -> 0b0_00110000
          Register@R49 Register@R50 CASInteger@"32" -> 0b0_00110001
          Register@R50 Register@R51 CASInteger@"32" -> 0b0_00110010
          Register@R51 Register@R52 CASInteger@"32" -> 0b0_00110011
          Register@R52 Register@R53 CASInteger@"32" -> 0b0_00110100
          Register@R53 Register@R54 CASInteger@"32" -> 0b0_00110101
          Register@R54 Register@R55 CASInteger@"32" -> 0b0_00110110
          Register@R55 Register@R56 CASInteger@"32" -> 0b0_00110111
          Register@R56 Register@R57 CASInteger@"32" -> 0b0_00111000
          Register@R57 Register@R58 CASInteger@"32" -> 0b0_00111001
          Register@R58 Register@R59 CASInteger@"32" -> 0b0_00111010
          Register@R59 Register@R60 CASInteger@"32" -> 0b0_00111011
          Register@R60 Register@R61 CASInteger@"32" -> 0b0_00111100
          Register@R61 Register@R62 CASInteger@"32" -> 0b0_00111101
          Register@R62 Register@R63 CASInteger@"32" -> 0b0_00111110
          Register@R63 Register@R64 CASInteger@"32" -> 0b0_00111111
          Register@R64 Register@R65 CASInteger@"32" -> 0b0_01000000
          Register@R65 Register@R66 CASInteger@"32" -> 0b0_01000001
          Register@R66 Register@R67 CASInteger@"32" -> 0b0_01000010
          Register@R67 Register@R68 CASInteger@"32" -> 0b0_01000011
          Register@R68 Register@R69 CASInteger@"32" -> 0b0_01000100
          Register@R69 Register@R70 CASInteger@"32" -> 0b0_01000101
          Register@R70 Register@R71 CASInteger@"32" -> 0b0_01000110
          Register@R71 Register@R72 CASInteger@"32" -> 0b0_01000111
          Register@R72 Register@R73 CASInteger@"32" -> 0b0_01001000
          Register@R73 Register@R74 CASInteger@"32" -> 0b0_01001001
          Register@R74 Register@R75 CASInteger@"32" -> 0b0_01001010
          Register@R75 Register@R76 CASInteger@"32" -> 0b0_01001011
          Register@R76 Register@R77 CASInteger@"32" -> 0b0_01001100
          Register@R77 Register@R78 CASInteger@"32" -> 0b0_01001101
          Register@R78 Register@R79 CASInteger@"32" -> 0b0_01001110
          Register@R79 Register@R80 CASInteger@"32" -> 0b0_01001111
          Register@R80 Register@R81 CASInteger@"32" -> 0b0_01010000
          Register@R81 Register@R82 CASInteger@"32" -> 0b0_01010001
          Register@R82 Register@R83 CASInteger@"32" -> 0b0_01010010
          Register@R83 Register@R84 CASInteger@"32" -> 0b0_01010011
          Register@R84 Register@R85 CASInteger@"32" -> 0b0_01010100
          Register@R85 Register@R86 CASInteger@"32" -> 0b0_01010101
          Register@R86 Register@R87 CASInteger@"32" -> 0b0_01010110
          Register@R87 Register@R88 CASInteger@"32" -> 0b0_01010111
          Register@R88 Register@R89 CASInteger@"32" -> 0b0_01011000
          Register@R89 Register@R90 CASInteger@"32" -> 0b0_01011001
          Register@R90 Register@R91 CASInteger@"32" -> 0b0_01011010
          Register@R91 Register@R92 CASInteger@"32" -> 0b0_01011011
          Register@R92 Register@R93 CASInteger@"32" -> 0b0_01011100
          Register@R93 Register@R94 CASInteger@"32" -> 0b0_01011101
          Register@R94 Register@R95 CASInteger@"32" -> 0b0_01011110
          Register@R95 Register@R96 CASInteger@"32" -> 0b0_01011111
          Register@R96 Register@R97 CASInteger@"32" -> 0b0_01100000
          Register@R97 Register@R98 CASInteger@"32" -> 0b0_01100001
          Register@R98 Register@R99 CASInteger@"32" -> 0b0_01100010
          Register@R99 Register@R100 CASInteger@"32" -> 0b0_01100011
          Register@R100 Register@R101 CASInteger@"32" -> 0b0_01100100
          Register@R101 Register@R102 CASInteger@"32" -> 0b0_01100101
          Register@R102 Register@R103 CASInteger@"32" -> 0b0_01100110
          Register@R103 Register@R104 CASInteger@"32" -> 0b0_01100111
          Register@R104 Register@R105 CASInteger@"32" -> 0b0_01101000
          Register@R105 Register@R106 CASInteger@"32" -> 0b0_01101001
          Register@R106 Register@R107 CASInteger@"32" -> 0b0_01101010
          Register@R107 Register@R108 CASInteger@"32" -> 0b0_01101011
          Register@R108 Register@R109 CASInteger@"32" -> 0b0_01101100
          Register@R109 Register@R110 CASInteger@"32" -> 0b0_01101101
          Register@R110 Register@R111 CASInteger@"32" -> 0b0_01101110
          Register@R111 Register@R112 CASInteger@"32" -> 0b0_01101111
          Register@R112 Register@R113 CASInteger@"32" -> 0b0_01110000
          Register@R113 Register@R114 CASInteger@"32" -> 0b0_01110001
          Register@R114 Register@R115 CASInteger@"32" -> 0b0_01110010
          Register@R115 Register@R116 CASInteger@"32" -> 0b0_01110011
          Register@R116 Register@R117 CASInteger@"32" -> 0b0_01110100
          Register@R117 Register@R118 CASInteger@"32" -> 0b0_01110101
          Register@R118 Register@R119 CASInteger@"32" -> 0b0_01110110
          Register@R119 Register@R120 CASInteger@"32" -> 0b0_01110111
          Register@R120 Register@R121 CASInteger@"32" -> 0b0_01111000
          Register@R121 Register@R122 CASInteger@"32" -> 0b0_01111001
          Register@R122 Register@R123 CASInteger@"32" -> 0b0_01111010
          Register@R123 Register@R124 CASInteger@"32" -> 0b0_01111011
          Register@R124 Register@R125 CASInteger@"32" -> 0b0_01111100
          Register@R125 Register@R126 CASInteger@"32" -> 0b0_01111101
          Register@R126 Register@R127 CASInteger@"32" -> 0b0_01111110
          Register@R127 Register@R128 CASInteger@"32" -> 0b0_01111111
          Register@R128 Register@R129 CASInteger@"32" -> 0b0_10000000
          Register@R129 Register@R130 CASInteger@"32" -> 0b0_10000001
          Register@R130 Register@R131 CASInteger@"32" -> 0b0_10000010
          Register@R131 Register@R132 CASInteger@"32" -> 0b0_10000011
          Register@R132 Register@R133 CASInteger@"32" -> 0b0_10000100
          Register@R133 Register@R134 CASInteger@"32" -> 0b0_10000101
          Register@R134 Register@R135 CASInteger@"32" -> 0b0_10000110
          Register@R135 Register@R136 CASInteger@"32" -> 0b0_10000111
          Register@R136 Register@R137 CASInteger@"32" -> 0b0_10001000
          Register@R137 Register@R138 CASInteger@"32" -> 0b0_10001001
          Register@R138 Register@R139 CASInteger@"32" -> 0b0_10001010
          Register@R139 Register@R140 CASInteger@"32" -> 0b0_10001011
          Register@R140 Register@R141 CASInteger@"32" -> 0b0_10001100
          Register@R141 Register@R142 CASInteger@"32" -> 0b0_10001101
          Register@R142 Register@R143 CASInteger@"32" -> 0b0_10001110
          Register@R143 Register@R144 CASInteger@"32" -> 0b0_10001111
          Register@R144 Register@R145 CASInteger@"32" -> 0b0_10010000
          Register@R145 Register@R146 CASInteger@"32" -> 0b0_10010001
          Register@R146 Register@R147 CASInteger@"32" -> 0b0_10010010
          Register@R147 Register@R148 CASInteger@"32" -> 0b0_10010011
          Register@R148 Register@R149 CASInteger@"32" -> 0b0_10010100
          Register@R149 Register@R150 CASInteger@"32" -> 0b0_10010101
          Register@R150 Register@R151 CASInteger@"32" -> 0b0_10010110
          Register@R151 Register@R152 CASInteger@"32" -> 0b0_10010111
          Register@R152 Register@R153 CASInteger@"32" -> 0b0_10011000
          Register@R153 Register@R154 CASInteger@"32" -> 0b0_10011001
          Register@R154 Register@R155 CASInteger@"32" -> 0b0_10011010
          Register@R155 Register@R156 CASInteger@"32" -> 0b0_10011011
          Register@R156 Register@R157 CASInteger@"32" -> 0b0_10011100
          Register@R157 Register@R158 CASInteger@"32" -> 0b0_10011101
          Register@R158 Register@R159 CASInteger@"32" -> 0b0_10011110
          Register@R159 Register@R160 CASInteger@"32" -> 0b0_10011111
          Register@R160 Register@R161 CASInteger@"32" -> 0b0_10100000
          Register@R161 Register@R162 CASInteger@"32" -> 0b0_10100001
          Register@R162 Register@R163 CASInteger@"32" -> 0b0_10100010
          Register@R163 Register@R164 CASInteger@"32" -> 0b0_10100011
          Register@R164 Register@R165 CASInteger@"32" -> 0b0_10100100
          Register@R165 Register@R166 CASInteger@"32" -> 0b0_10100101
          Register@R166 Register@R167 CASInteger@"32" -> 0b0_10100110
          Register@R167 Register@R168 CASInteger@"32" -> 0b0_10100111
          Register@R168 Register@R169 CASInteger@"32" -> 0b0_10101000
          Register@R169 Register@R170 CASInteger@"32" -> 0b0_10101001
          Register@R170 Register@R171 CASInteger@"32" -> 0b0_10101010
          Register@R171 Register@R172 CASInteger@"32" -> 0b0_10101011
          Register@R172 Register@R173 CASInteger@"32" -> 0b0_10101100
          Register@R173 Register@R174 CASInteger@"32" -> 0b0_10101101
          Register@R174 Register@R175 CASInteger@"32" -> 0b0_10101110
          Register@R175 Register@R176 CASInteger@"32" -> 0b0_10101111
          Register@R176 Register@R177 CASInteger@"32" -> 0b0_10110000
          Register@R177 Register@R178 CASInteger@"32" -> 0b0_10110001
          Register@R178 Register@R179 CASInteger@"32" -> 0b0_10110010
          Register@R179 Register@R180 CASInteger@"32" -> 0b0_10110011
          Register@R180 Register@R181 CASInteger@"32" -> 0b0_10110100
          Register@R181 Register@R182 CASInteger@"32" -> 0b0_10110101
          Register@R182 Register@R183 CASInteger@"32" -> 0b0_10110110
          Register@R183 Register@R184 CASInteger@"32" -> 0b0_10110111
          Register@R184 Register@R185 CASInteger@"32" -> 0b0_10111000
          Register@R185 Register@R186 CASInteger@"32" -> 0b0_10111001
          Register@R186 Register@R187 CASInteger@"32" -> 0b0_10111010
          Register@R187 Register@R188 CASInteger@"32" -> 0b0_10111011
          Register@R188 Register@R189 CASInteger@"32" -> 0b0_10111100
          Register@R189 Register@R190 CASInteger@"32" -> 0b0_10111101
          Register@R190 Register@R191 CASInteger@"32" -> 0b0_10111110
          Register@R191 Register@R192 CASInteger@"32" -> 0b0_10111111
          Register@R192 Register@R193 CASInteger@"32" -> 0b0_11000000
          Register@R193 Register@R194 CASInteger@"32" -> 0b0_11000001
          Register@R194 Register@R195 CASInteger@"32" -> 0b0_11000010
          Register@R195 Register@R196 CASInteger@"32" -> 0b0_11000011
          Register@R196 Register@R197 CASInteger@"32" -> 0b0_11000100
          Register@R197 Register@R198 CASInteger@"32" -> 0b0_11000101
          Register@R198 Register@R199 CASInteger@"32" -> 0b0_11000110
          Register@R199 Register@R200 CASInteger@"32" -> 0b0_11000111
          Register@R200 Register@R201 CASInteger@"32" -> 0b0_11001000
          Register@R201 Register@R202 CASInteger@"32" -> 0b0_11001001
          Register@R202 Register@R203 CASInteger@"32" -> 0b0_11001010
          Register@R203 Register@R204 CASInteger@"32" -> 0b0_11001011
          Register@R204 Register@R205 CASInteger@"32" -> 0b0_11001100
          Register@R205 Register@R206 CASInteger@"32" -> 0b0_11001101
          Register@R206 Register@R207 CASInteger@"32" -> 0b0_11001110
          Register@R207 Register@R208 CASInteger@"32" -> 0b0_11001111
          Register@R208 Register@R209 CASInteger@"32" -> 0b0_11010000
          Register@R209 Register@R210 CASInteger@"32" -> 0b0_11010001
          Register@R210 Register@R211 CASInteger@"32" -> 0b0_11010010
          Register@R211 Register@R212 CASInteger@"32" -> 0b0_11010011
          Register@R212 Register@R213 CASInteger@"32" -> 0b0_11010100
          Register@R213 Register@R214 CASInteger@"32" -> 0b0_11010101
          Register@R214 Register@R215 CASInteger@"32" -> 0b0_11010110
          Register@R215 Register@R216 CASInteger@"32" -> 0b0_11010111
          Register@R216 Register@R217 CASInteger@"32" -> 0b0_11011000
          Register@R217 Register@R218 CASInteger@"32" -> 0b0_11011001
          Register@R218 Register@R219 CASInteger@"32" -> 0b0_11011010
          Register@R219 Register@R220 CASInteger@"32" -> 0b0_11011011
          Register@R220 Register@R221 CASInteger@"32" -> 0b0_11011100
          Register@R221 Register@R222 CASInteger@"32" -> 0b0_11011101
          Register@R222 Register@R223 CASInteger@"32" -> 0b0_11011110
          Register@R223 Register@R224 CASInteger@"32" -> 0b0_11011111
          Register@R224 Register@R225 CASInteger@"32" -> 0b0_11100000
          Register@R225 Register@R226 CASInteger@"32" -> 0b0_11100001
          Register@R226 Register@R227 CASInteger@"32" -> 0b0_11100010
          Register@R227 Register@R228 CASInteger@"32" -> 0b0_11100011
          Register@R228 Register@R229 CASInteger@"32" -> 0b0_11100100
          Register@R229 Register@R230 CASInteger@"32" -> 0b0_11100101
          Register@R230 Register@R231 CASInteger@"32" -> 0b0_11100110
          Register@R231 Register@R232 CASInteger@"32" -> 0b0_11100111
          Register@R232 Register@R233 CASInteger@"32" -> 0b0_11101000
          Register@R233 Register@R234 CASInteger@"32" -> 0b0_11101001
          Register@R234 Register@R235 CASInteger@"32" -> 0b0_11101010
          Register@R235 Register@R236 CASInteger@"32" -> 0b0_11101011
          Register@R236 Register@R237 CASInteger@"32" -> 0b0_11101100
          Register@R237 Register@R238 CASInteger@"32" -> 0b0_11101101
          Register@R238 Register@R239 CASInteger@"32" -> 0b0_11101110
          Register@R239 Register@R240 CASInteger@"32" -> 0b0_11101111
          Register@R240 Register@R241 CASInteger@"32" -> 0b0_11110000
          Register@R241 Register@R242 CASInteger@"32" -> 0b0_11110001
          Register@R242 Register@R243 CASInteger@"32" -> 0b0_11110010
          Register@R243 Register@R244 CASInteger@"32" -> 0b0_11110011
          Register@R244 Register@R245 CASInteger@"32" -> 0b0_11110100
          Register@R245 Register@R246 CASInteger@"32" -> 0b0_11110101
          Register@R246 Register@R247 CASInteger@"32" -> 0b0_11110110
          Register@R247 248 CASInteger@"32" -> 0b0_11110111
          248 249 CASInteger@"32" -> 0b0_11111000
          249 250 CASInteger@"32" -> 0b0_11111001
          250 251 CASInteger@"32" -> 0b0_11111010
          251 252 CASInteger@"32" -> 0b0_11111011
          252 253 CASInteger@"32" -> 0b0_11111100
          253 254 CASInteger@"32" -> 0b0_11111101
          254 Register@RZ CASInteger@"32" -> 0b0_11111110
          Register@RZ Register@RZ CASInteger@"32" -> 0b0_11111111
          Register@R0 Register@R2 CASInteger@"64" -> 0b1_00000000
          Register@R1 Register@R3 CASInteger@"64" -> 0b1_00000001
          Register@R2 Register@R4 CASInteger@"64" -> 0b1_00000010
          Register@R3 Register@R5 CASInteger@"64" -> 0b1_00000011
          Register@R4 Register@R6 CASInteger@"64" -> 0b1_00000100
          Register@R5 Register@R7 CASInteger@"64" -> 0b1_00000101
          Register@R6 Register@R8 CASInteger@"64" -> 0b1_00000110
          Register@R7 Register@R9 CASInteger@"64" -> 0b1_00000111
          Register@R8 Register@R10 CASInteger@"64" -> 0b1_00001000
          Register@R9 Register@R11 CASInteger@"64" -> 0b1_00001001
          Register@R10 Register@R12 CASInteger@"64" -> 0b1_00001010
          Register@R11 Register@R13 CASInteger@"64" -> 0b1_00001011
          Register@R12 Register@R14 CASInteger@"64" -> 0b1_00001100
          Register@R13 Register@R15 CASInteger@"64" -> 0b1_00001101
          Register@R14 Register@R16 CASInteger@"64" -> 0b1_00001110
          Register@R15 Register@R17 CASInteger@"64" -> 0b1_00001111
          Register@R16 Register@R18 CASInteger@"64" -> 0b1_00010000
          Register@R17 Register@R19 CASInteger@"64" -> 0b1_00010001
          Register@R18 Register@R20 CASInteger@"64" -> 0b1_00010010
          Register@R19 Register@R21 CASInteger@"64" -> 0b1_00010011
          Register@R20 Register@R22 CASInteger@"64" -> 0b1_00010100
          Register@R21 Register@R23 CASInteger@"64" -> 0b1_00010101
          Register@R22 Register@R24 CASInteger@"64" -> 0b1_00010110
          Register@R23 Register@R25 CASInteger@"64" -> 0b1_00010111
          Register@R24 Register@R26 CASInteger@"64" -> 0b1_00011000
          Register@R25 Register@R27 CASInteger@"64" -> 0b1_00011001
          Register@R26 Register@R28 CASInteger@"64" -> 0b1_00011010
          Register@R27 Register@R29 CASInteger@"64" -> 0b1_00011011
          Register@R28 Register@R30 CASInteger@"64" -> 0b1_00011100
          Register@R29 Register@R31 CASInteger@"64" -> 0b1_00011101
          Register@R30 Register@R32 CASInteger@"64" -> 0b1_00011110
          Register@R31 Register@R33 CASInteger@"64" -> 0b1_00011111
          Register@R32 Register@R34 CASInteger@"64" -> 0b1_00100000
          Register@R33 Register@R35 CASInteger@"64" -> 0b1_00100001
          Register@R34 Register@R36 CASInteger@"64" -> 0b1_00100010
          Register@R35 Register@R37 CASInteger@"64" -> 0b1_00100011
          Register@R36 Register@R38 CASInteger@"64" -> 0b1_00100100
          Register@R37 Register@R39 CASInteger@"64" -> 0b1_00100101
          Register@R38 Register@R40 CASInteger@"64" -> 0b1_00100110
          Register@R39 Register@R41 CASInteger@"64" -> 0b1_00100111
          Register@R40 Register@R42 CASInteger@"64" -> 0b1_00101000
          Register@R41 Register@R43 CASInteger@"64" -> 0b1_00101001
          Register@R42 Register@R44 CASInteger@"64" -> 0b1_00101010
          Register@R43 Register@R45 CASInteger@"64" -> 0b1_00101011
          Register@R44 Register@R46 CASInteger@"64" -> 0b1_00101100
          Register@R45 Register@R47 CASInteger@"64" -> 0b1_00101101
          Register@R46 Register@R48 CASInteger@"64" -> 0b1_00101110
          Register@R47 Register@R49 CASInteger@"64" -> 0b1_00101111
          Register@R48 Register@R50 CASInteger@"64" -> 0b1_00110000
          Register@R49 Register@R51 CASInteger@"64" -> 0b1_00110001
          Register@R50 Register@R52 CASInteger@"64" -> 0b1_00110010
          Register@R51 Register@R53 CASInteger@"64" -> 0b1_00110011
          Register@R52 Register@R54 CASInteger@"64" -> 0b1_00110100
          Register@R53 Register@R55 CASInteger@"64" -> 0b1_00110101
          Register@R54 Register@R56 CASInteger@"64" -> 0b1_00110110
          Register@R55 Register@R57 CASInteger@"64" -> 0b1_00110111
          Register@R56 Register@R58 CASInteger@"64" -> 0b1_00111000
          Register@R57 Register@R59 CASInteger@"64" -> 0b1_00111001
          Register@R58 Register@R60 CASInteger@"64" -> 0b1_00111010
          Register@R59 Register@R61 CASInteger@"64" -> 0b1_00111011
          Register@R60 Register@R62 CASInteger@"64" -> 0b1_00111100
          Register@R61 Register@R63 CASInteger@"64" -> 0b1_00111101
          Register@R62 Register@R64 CASInteger@"64" -> 0b1_00111110
          Register@R63 Register@R65 CASInteger@"64" -> 0b1_00111111
          Register@R64 Register@R66 CASInteger@"64" -> 0b1_01000000
          Register@R65 Register@R67 CASInteger@"64" -> 0b1_01000001
          Register@R66 Register@R68 CASInteger@"64" -> 0b1_01000010
          Register@R67 Register@R69 CASInteger@"64" -> 0b1_01000011
          Register@R68 Register@R70 CASInteger@"64" -> 0b1_01000100
          Register@R69 Register@R71 CASInteger@"64" -> 0b1_01000101
          Register@R70 Register@R72 CASInteger@"64" -> 0b1_01000110
          Register@R71 Register@R73 CASInteger@"64" -> 0b1_01000111
          Register@R72 Register@R74 CASInteger@"64" -> 0b1_01001000
          Register@R73 Register@R75 CASInteger@"64" -> 0b1_01001001
          Register@R74 Register@R76 CASInteger@"64" -> 0b1_01001010
          Register@R75 Register@R77 CASInteger@"64" -> 0b1_01001011
          Register@R76 Register@R78 CASInteger@"64" -> 0b1_01001100
          Register@R77 Register@R79 CASInteger@"64" -> 0b1_01001101
          Register@R78 Register@R80 CASInteger@"64" -> 0b1_01001110
          Register@R79 Register@R81 CASInteger@"64" -> 0b1_01001111
          Register@R80 Register@R82 CASInteger@"64" -> 0b1_01010000
          Register@R81 Register@R83 CASInteger@"64" -> 0b1_01010001
          Register@R82 Register@R84 CASInteger@"64" -> 0b1_01010010
          Register@R83 Register@R85 CASInteger@"64" -> 0b1_01010011
          Register@R84 Register@R86 CASInteger@"64" -> 0b1_01010100
          Register@R85 Register@R87 CASInteger@"64" -> 0b1_01010101
          Register@R86 Register@R88 CASInteger@"64" -> 0b1_01010110
          Register@R87 Register@R89 CASInteger@"64" -> 0b1_01010111
          Register@R88 Register@R90 CASInteger@"64" -> 0b1_01011000
          Register@R89 Register@R91 CASInteger@"64" -> 0b1_01011001
          Register@R90 Register@R92 CASInteger@"64" -> 0b1_01011010
          Register@R91 Register@R93 CASInteger@"64" -> 0b1_01011011
          Register@R92 Register@R94 CASInteger@"64" -> 0b1_01011100
          Register@R93 Register@R95 CASInteger@"64" -> 0b1_01011101
          Register@R94 Register@R96 CASInteger@"64" -> 0b1_01011110
          Register@R95 Register@R97 CASInteger@"64" -> 0b1_01011111
          Register@R96 Register@R98 CASInteger@"64" -> 0b1_01100000
          Register@R97 Register@R99 CASInteger@"64" -> 0b1_01100001
          Register@R98 Register@R100 CASInteger@"64" -> 0b1_01100010
          Register@R99 Register@R101 CASInteger@"64" -> 0b1_01100011
          Register@R100 Register@R102 CASInteger@"64" -> 0b1_01100100
          Register@R101 Register@R103 CASInteger@"64" -> 0b1_01100101
          Register@R102 Register@R104 CASInteger@"64" -> 0b1_01100110
          Register@R103 Register@R105 CASInteger@"64" -> 0b1_01100111
          Register@R104 Register@R106 CASInteger@"64" -> 0b1_01101000
          Register@R105 Register@R107 CASInteger@"64" -> 0b1_01101001
          Register@R106 Register@R108 CASInteger@"64" -> 0b1_01101010
          Register@R107 Register@R109 CASInteger@"64" -> 0b1_01101011
          Register@R108 Register@R110 CASInteger@"64" -> 0b1_01101100
          Register@R109 Register@R111 CASInteger@"64" -> 0b1_01101101
          Register@R110 Register@R112 CASInteger@"64" -> 0b1_01101110
          Register@R111 Register@R113 CASInteger@"64" -> 0b1_01101111
          Register@R112 Register@R114 CASInteger@"64" -> 0b1_01110000
          Register@R113 Register@R115 CASInteger@"64" -> 0b1_01110001
          Register@R114 Register@R116 CASInteger@"64" -> 0b1_01110010
          Register@R115 Register@R117 CASInteger@"64" -> 0b1_01110011
          Register@R116 Register@R118 CASInteger@"64" -> 0b1_01110100
          Register@R117 Register@R119 CASInteger@"64" -> 0b1_01110101
          Register@R118 Register@R120 CASInteger@"64" -> 0b1_01110110
          Register@R119 Register@R121 CASInteger@"64" -> 0b1_01110111
          Register@R120 Register@R122 CASInteger@"64" -> 0b1_01111000
          Register@R121 Register@R123 CASInteger@"64" -> 0b1_01111001
          Register@R122 Register@R124 CASInteger@"64" -> 0b1_01111010
          Register@R123 Register@R125 CASInteger@"64" -> 0b1_01111011
          Register@R124 Register@R126 CASInteger@"64" -> 0b1_01111100
          Register@R125 Register@R127 CASInteger@"64" -> 0b1_01111101
          Register@R126 Register@R128 CASInteger@"64" -> 0b1_01111110
          Register@R127 Register@R129 CASInteger@"64" -> 0b1_01111111
          Register@R128 Register@R130 CASInteger@"64" -> 0b1_10000000
          Register@R129 Register@R131 CASInteger@"64" -> 0b1_10000001
          Register@R130 Register@R132 CASInteger@"64" -> 0b1_10000010
          Register@R131 Register@R133 CASInteger@"64" -> 0b1_10000011
          Register@R132 Register@R134 CASInteger@"64" -> 0b1_10000100
          Register@R133 Register@R135 CASInteger@"64" -> 0b1_10000101
          Register@R134 Register@R136 CASInteger@"64" -> 0b1_10000110
          Register@R135 Register@R137 CASInteger@"64" -> 0b1_10000111
          Register@R136 Register@R138 CASInteger@"64" -> 0b1_10001000
          Register@R137 Register@R139 CASInteger@"64" -> 0b1_10001001
          Register@R138 Register@R140 CASInteger@"64" -> 0b1_10001010
          Register@R139 Register@R141 CASInteger@"64" -> 0b1_10001011
          Register@R140 Register@R142 CASInteger@"64" -> 0b1_10001100
          Register@R141 Register@R143 CASInteger@"64" -> 0b1_10001101
          Register@R142 Register@R144 CASInteger@"64" -> 0b1_10001110
          Register@R143 Register@R145 CASInteger@"64" -> 0b1_10001111
          Register@R144 Register@R146 CASInteger@"64" -> 0b1_10010000
          Register@R145 Register@R147 CASInteger@"64" -> 0b1_10010001
          Register@R146 Register@R148 CASInteger@"64" -> 0b1_10010010
          Register@R147 Register@R149 CASInteger@"64" -> 0b1_10010011
          Register@R148 Register@R150 CASInteger@"64" -> 0b1_10010100
          Register@R149 Register@R151 CASInteger@"64" -> 0b1_10010101
          Register@R150 Register@R152 CASInteger@"64" -> 0b1_10010110
          Register@R151 Register@R153 CASInteger@"64" -> 0b1_10010111
          Register@R152 Register@R154 CASInteger@"64" -> 0b1_10011000
          Register@R153 Register@R155 CASInteger@"64" -> 0b1_10011001
          Register@R154 Register@R156 CASInteger@"64" -> 0b1_10011010
          Register@R155 Register@R157 CASInteger@"64" -> 0b1_10011011
          Register@R156 Register@R158 CASInteger@"64" -> 0b1_10011100
          Register@R157 Register@R159 CASInteger@"64" -> 0b1_10011101
          Register@R158 Register@R160 CASInteger@"64" -> 0b1_10011110
          Register@R159 Register@R161 CASInteger@"64" -> 0b1_10011111
          Register@R160 Register@R162 CASInteger@"64" -> 0b1_10100000
          Register@R161 Register@R163 CASInteger@"64" -> 0b1_10100001
          Register@R162 Register@R164 CASInteger@"64" -> 0b1_10100010
          Register@R163 Register@R165 CASInteger@"64" -> 0b1_10100011
          Register@R164 Register@R166 CASInteger@"64" -> 0b1_10100100
          Register@R165 Register@R167 CASInteger@"64" -> 0b1_10100101
          Register@R166 Register@R168 CASInteger@"64" -> 0b1_10100110
          Register@R167 Register@R169 CASInteger@"64" -> 0b1_10100111
          Register@R168 Register@R170 CASInteger@"64" -> 0b1_10101000
          Register@R169 Register@R171 CASInteger@"64" -> 0b1_10101001
          Register@R170 Register@R172 CASInteger@"64" -> 0b1_10101010
          Register@R171 Register@R173 CASInteger@"64" -> 0b1_10101011
          Register@R172 Register@R174 CASInteger@"64" -> 0b1_10101100
          Register@R173 Register@R175 CASInteger@"64" -> 0b1_10101101
          Register@R174 Register@R176 CASInteger@"64" -> 0b1_10101110
          Register@R175 Register@R177 CASInteger@"64" -> 0b1_10101111
          Register@R176 Register@R178 CASInteger@"64" -> 0b1_10110000
          Register@R177 Register@R179 CASInteger@"64" -> 0b1_10110001
          Register@R178 Register@R180 CASInteger@"64" -> 0b1_10110010
          Register@R179 Register@R181 CASInteger@"64" -> 0b1_10110011
          Register@R180 Register@R182 CASInteger@"64" -> 0b1_10110100
          Register@R181 Register@R183 CASInteger@"64" -> 0b1_10110101
          Register@R182 Register@R184 CASInteger@"64" -> 0b1_10110110
          Register@R183 Register@R185 CASInteger@"64" -> 0b1_10110111
          Register@R184 Register@R186 CASInteger@"64" -> 0b1_10111000
          Register@R185 Register@R187 CASInteger@"64" -> 0b1_10111001
          Register@R186 Register@R188 CASInteger@"64" -> 0b1_10111010
          Register@R187 Register@R189 CASInteger@"64" -> 0b1_10111011
          Register@R188 Register@R190 CASInteger@"64" -> 0b1_10111100
          Register@R189 Register@R191 CASInteger@"64" -> 0b1_10111101
          Register@R190 Register@R192 CASInteger@"64" -> 0b1_10111110
          Register@R191 Register@R193 CASInteger@"64" -> 0b1_10111111
          Register@R192 Register@R194 CASInteger@"64" -> 0b1_11000000
          Register@R193 Register@R195 CASInteger@"64" -> 0b1_11000001
          Register@R194 Register@R196 CASInteger@"64" -> 0b1_11000010
          Register@R195 Register@R197 CASInteger@"64" -> 0b1_11000011
          Register@R196 Register@R198 CASInteger@"64" -> 0b1_11000100
          Register@R197 Register@R199 CASInteger@"64" -> 0b1_11000101
          Register@R198 Register@R200 CASInteger@"64" -> 0b1_11000110
          Register@R199 Register@R201 CASInteger@"64" -> 0b1_11000111
          Register@R200 Register@R202 CASInteger@"64" -> 0b1_11001000
          Register@R201 Register@R203 CASInteger@"64" -> 0b1_11001001
          Register@R202 Register@R204 CASInteger@"64" -> 0b1_11001010
          Register@R203 Register@R205 CASInteger@"64" -> 0b1_11001011
          Register@R204 Register@R206 CASInteger@"64" -> 0b1_11001100
          Register@R205 Register@R207 CASInteger@"64" -> 0b1_11001101
          Register@R206 Register@R208 CASInteger@"64" -> 0b1_11001110
          Register@R207 Register@R209 CASInteger@"64" -> 0b1_11001111
          Register@R208 Register@R210 CASInteger@"64" -> 0b1_11010000
          Register@R209 Register@R211 CASInteger@"64" -> 0b1_11010001
          Register@R210 Register@R212 CASInteger@"64" -> 0b1_11010010
          Register@R211 Register@R213 CASInteger@"64" -> 0b1_11010011
          Register@R212 Register@R214 CASInteger@"64" -> 0b1_11010100
          Register@R213 Register@R215 CASInteger@"64" -> 0b1_11010101
          Register@R214 Register@R216 CASInteger@"64" -> 0b1_11010110
          Register@R215 Register@R217 CASInteger@"64" -> 0b1_11010111
          Register@R216 Register@R218 CASInteger@"64" -> 0b1_11011000
          Register@R217 Register@R219 CASInteger@"64" -> 0b1_11011001
          Register@R218 Register@R220 CASInteger@"64" -> 0b1_11011010
          Register@R219 Register@R221 CASInteger@"64" -> 0b1_11011011
          Register@R220 Register@R222 CASInteger@"64" -> 0b1_11011100
          Register@R221 Register@R223 CASInteger@"64" -> 0b1_11011101
          Register@R222 Register@R224 CASInteger@"64" -> 0b1_11011110
          Register@R223 Register@R225 CASInteger@"64" -> 0b1_11011111
          Register@R224 Register@R226 CASInteger@"64" -> 0b1_11100000
          Register@R225 Register@R227 CASInteger@"64" -> 0b1_11100001
          Register@R226 Register@R228 CASInteger@"64" -> 0b1_11100010
          Register@R227 Register@R229 CASInteger@"64" -> 0b1_11100011
          Register@R228 Register@R230 CASInteger@"64" -> 0b1_11100100
          Register@R229 Register@R231 CASInteger@"64" -> 0b1_11100101
          Register@R230 Register@R232 CASInteger@"64" -> 0b1_11100110
          Register@R231 Register@R233 CASInteger@"64" -> 0b1_11100111
          Register@R232 Register@R234 CASInteger@"64" -> 0b1_11101000
          Register@R233 Register@R235 CASInteger@"64" -> 0b1_11101001
          Register@R234 Register@R236 CASInteger@"64" -> 0b1_11101010
          Register@R235 Register@R237 CASInteger@"64" -> 0b1_11101011
          Register@R236 Register@R238 CASInteger@"64" -> 0b1_11101100
          Register@R237 Register@R239 CASInteger@"64" -> 0b1_11101101
          Register@R238 Register@R240 CASInteger@"64" -> 0b1_11101110
          Register@R239 Register@R241 CASInteger@"64" -> 0b1_11101111
          Register@R240 Register@R242 CASInteger@"64" -> 0b1_11110000
          Register@R241 Register@R243 CASInteger@"64" -> 0b1_11110001
          Register@R242 Register@R244 CASInteger@"64" -> 0b1_11110010
          Register@R243 Register@R245 CASInteger@"64" -> 0b1_11110011
          Register@R244 Register@R246 CASInteger@"64" -> 0b1_11110100
          Register@R245 Register@R247 CASInteger@"64" -> 0b1_11110101
          Register@R246 248 CASInteger@"64" -> 0b1_11110110
          Register@R247 249 CASInteger@"64" -> 0b1_11110111
          248 250 CASInteger@"64" -> 0b1_11111000
          249 251 CASInteger@"64" -> 0b1_11111001
          250 252 CASInteger@"64" -> 0b1_11111010
          251 253 CASInteger@"64" -> 0b1_11111011
          252 254 CASInteger@"64" -> 0b1_11111100
          253 Register@RZ CASInteger@"64" -> 0b1_11111101
          254 Register@RZ CASInteger@"64" -> 0b1_11111110
          Register@RZ Register@RZ CASInteger@"64" -> 0b1_11111111
          ;



    SM5vshlCW
          CWMode@C UInteger_old@U16 -> 0b0
          CWMode@C UInteger_old@U8 -> 0b0
          CWMode@C UInteger_old@U32 -> 0b0
          CWMode@W UInteger_old@U16 -> 0b1
          CWMode@W UInteger_old@U8 -> 0b1
          CWMode@W UInteger_old@U32 -> 0b1
          ;

    Tex2D4
          ParamA@"1D" DC@noDC LOD2@LZ -> 0
          ParamA@"1D" DC@noDC LOD2@noLOD -> 0
          ParamA@"1D" DC@noDC LOD2@LL -> 0
          ParamA@"1D" DC@DC LOD2@noLOD -> 0
          ParamA@"1D" DC@DC LOD2@LZ -> 0
          ParamA@"1D" DC@DC LOD2@LL -> 0
          ParamA@"2D" DC@noDC LOD2@noLOD -> 1
          ParamA@"2D" DC@noDC LOD2@LZ -> 2
          ParamA@"2D" DC@noDC LOD2@LL -> 3
          ParamA@"2D" DC@DC LOD2@noLOD -> 4
          ParamA@"2D" DC@DC LOD2@LZ -> 6
          ParamA@"2D" DC@DC LOD2@LL -> 5
          ParamA@"3D" DC@noDC LOD2@noLOD -> 10
          ParamA@"3D" DC@noDC LOD2@LZ -> 11
          ParamA@"3D" DC@noDC LOD2@LL -> 0
          ParamA@"3D" DC@DC LOD2@noLOD -> 0
          ParamA@"3D" DC@DC LOD2@LZ -> 0
          ParamA@"3D" DC@DC LOD2@LL -> 0
          ParamA@CUBE DC@noDC LOD2@noLOD -> 12
          ParamA@CUBE DC@noDC LOD2@LZ -> 0
          ParamA@CUBE DC@noDC LOD2@LL -> 13
          ParamA@CUBE DC@DC LOD2@noLOD -> 0
          ParamA@CUBE DC@DC LOD2@LZ -> 0
          ParamA@CUBE DC@DC LOD2@LL -> 0
          ParamA@ARRAY_1D DC@noDC LOD2@noLOD -> 0
          ParamA@ARRAY_1D DC@noDC LOD2@LZ -> 0
          ParamA@ARRAY_1D DC@noDC LOD2@LL -> 0
          ParamA@ARRAY_1D DC@DC LOD2@noLOD -> 0
          ParamA@ARRAY_1D DC@DC LOD2@LZ -> 0
          ParamA@ARRAY_1D DC@DC LOD2@LL -> 0
          ParamA@ARRAY_2D DC@noDC LOD2@noLOD -> 7
          ParamA@ARRAY_2D DC@noDC LOD2@LZ -> 8
          ParamA@ARRAY_2D DC@noDC LOD2@LL -> 0
          ParamA@ARRAY_2D DC@DC LOD2@noLOD -> 0
          ParamA@ARRAY_2D DC@DC LOD2@LZ -> 9
          ParamA@ARRAY_2D DC@DC LOD2@LL -> 0
          ParamA@ARRAY_3D DC@noDC LOD2@noLOD -> 0
          ParamA@ARRAY_3D DC@noDC LOD2@LZ -> 0
          ParamA@ARRAY_3D DC@noDC LOD2@LL -> 0
          ParamA@ARRAY_3D DC@DC LOD2@noLOD -> 0
          ParamA@ARRAY_3D DC@DC LOD2@LZ -> 0
          ParamA@ARRAY_3D DC@DC LOD2@LL -> 0
          ParamA@CUBEARRAY DC@noDC LOD2@noLOD -> 0
          ParamA@CUBEARRAY DC@noDC LOD2@LZ -> 0
          ParamA@CUBEARRAY DC@noDC LOD2@LL -> 0
          ParamA@CUBEARRAY DC@DC LOD2@noLOD -> 0
          ParamA@CUBEARRAY DC@DC LOD2@LZ -> 0
          ParamA@CUBEARRAY DC@DC LOD2@LL -> 0
          ;

    Tld2D4
          ParamA@"1D" MS@noMS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@"1D" MS@noMS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@"1D" MS@noMS LOD1@LL TOFF1@noTOFF -> 1
          ParamA@"1D" MS@noMS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@"1D" MS@MS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@"1D" MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@"1D" MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@"1D" MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@"2D" MS@noMS LOD1@LZ TOFF1@noTOFF -> 2
          ParamA@"2D" MS@noMS LOD1@LZ TOFF1@AOFFI -> 4
          ParamA@"2D" MS@noMS LOD1@LL TOFF1@noTOFF -> 5
          ParamA@"2D" MS@noMS LOD1@LL TOFF1@AOFFI -> 12
          ParamA@"2D" MS@MS LOD1@LZ TOFF1@noTOFF -> 6
          ParamA@"2D" MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@"2D" MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@"2D" MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@"3D" MS@noMS LOD1@LZ TOFF1@noTOFF -> 7
          ParamA@"3D" MS@noMS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@"3D" MS@noMS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@"3D" MS@noMS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@"3D" MS@MS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@"3D" MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@"3D" MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@"3D" MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@CUBE MS@noMS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@CUBE MS@noMS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@CUBE MS@noMS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@CUBE MS@noMS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@CUBE MS@MS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@CUBE MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@CUBE MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@CUBE MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@ARRAY_1D MS@noMS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@ARRAY_1D MS@noMS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@ARRAY_1D MS@noMS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@ARRAY_1D MS@noMS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@ARRAY_1D MS@MS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@ARRAY_1D MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@ARRAY_1D MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@ARRAY_1D MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@ARRAY_2D MS@noMS LOD1@LZ TOFF1@noTOFF -> 8
          ParamA@ARRAY_2D MS@noMS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@ARRAY_2D MS@noMS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@ARRAY_2D MS@noMS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@ARRAY_2D MS@MS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@ARRAY_2D MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@ARRAY_2D MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@ARRAY_2D MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@ARRAY_3D MS@noMS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@ARRAY_3D MS@noMS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@ARRAY_3D MS@noMS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@ARRAY_3D MS@noMS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@ARRAY_3D MS@MS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@ARRAY_3D MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@ARRAY_3D MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@ARRAY_3D MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@CUBEARRAY MS@noMS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@CUBEARRAY MS@noMS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@CUBEARRAY MS@noMS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@CUBEARRAY MS@noMS LOD1@LL TOFF1@AOFFI -> 0
          ParamA@CUBEARRAY MS@MS LOD1@LZ TOFF1@noTOFF -> 0
          ParamA@CUBEARRAY MS@MS LOD1@LZ TOFF1@AOFFI -> 0
          ParamA@CUBEARRAY MS@MS LOD1@LL TOFF1@noTOFF -> 0
          ParamA@CUBEARRAY MS@MS LOD1@LL TOFF1@AOFFI -> 0
          ;

    LutImm8
          LOP@AND 0 0 0 -> 0b10000000
          LOP@AND 0 0 1 -> 0b01000000
          LOP@AND 0 1 0 -> 0b00100000
          LOP@AND 0 1 1 -> 0b00010000
          LOP@AND 1 0 0 -> 0b00001000
          LOP@AND 1 0 1 -> 0b00000100
          LOP@AND 1 1 0 -> 0b00000010
          LOP@AND 1 1 1 -> 0b00000001
          LOP@OR 0 0 0 -> 0b11111110
          LOP@OR 0 0 1 -> 0b11111101
          LOP@OR 0 1 0 -> 0b11111011
          LOP@OR 0 1 1 -> 0b11110111
          LOP@OR 1 0 0 -> 0b11101111
          LOP@OR 1 0 1 -> 0b11011111
          LOP@OR 1 1 0 -> 0b10111111
          LOP@OR 1 1 1 -> 0b01111111
          LOP@XOR 0 0 0 -> 0b10010110
          LOP@XOR 0 0 1 -> 0b01101001
          LOP@XOR 0 1 0 -> 0b01101001
          LOP@XOR 0 1 1 -> 0b10010110
          LOP@XOR 1 0 0 -> 0b01101001
          LOP@XOR 1 0 1 -> 0b10010110
          LOP@XOR 1 1 0 -> 0b10010110
          LOP@XOR 1 1 1 -> 0b01101001
          LOP@PASS_B 0 0 0 -> 0b11001100
          LOP@PASS_B 0 0 1 -> 0b11001100
          LOP@PASS_B 0 1 0 -> 0b00110011
          LOP@PASS_B 0 1 1 -> 0b00110011
          LOP@PASS_B 1 0 0 -> 0b11001100
          LOP@PASS_B 1 0 1 -> 0b11001100
          LOP@PASS_B 1 1 0 -> 0b00110011
          LOP@PASS_B 1 1 1 -> 0b00110011
          ;
hfma2__v2_nAB
0 1 -> 1
1 0 -> 1
0 0 -> 0
1 1 -> 0
;
hfma2__v0_nAB
0 1 -> 1
1 0 -> 1
0 0 -> 0
1 1 -> 0
;
hmul2__v2_nAB
0 1 -> 1
1 0 -> 1
0 0 -> 0
1 1 -> 0
;
hmul2__v0_nAB
0 1 -> 1
1 0 -> 1
0 0 -> 0
1 1 -> 0
;

OPERATION PROPERTIES
    IWIDTH
    ITYPE
    SPA
    SECONDARY
    TERTIARY
    BRANCH_TARGET_INDEX
    CC_BYPASS_ALLOWED
    MIN_WAIT_NEEDED
    OPERATION_TYPE
    IMM_INDEX
    VALID_IN_SHADERS
    IERRORS
    IDEST_OPERAND_MAP
    IDEST2_OPERAND_MAP
    ISRC_A_OPERAND_MAP
    ISRC_B_OPERAND_MAP
    ISRC_C_OPERAND_MAP
    IDEST_OPERAND_TYPE
    IDEST2_OPERAND_TYPE
    ISRC_A_OPERAND_TYPE
    ISRC_B_OPERAND_TYPE
    ISRC_C_OPERAND_TYPE
    INSTRUCTION_TYPE
    BRANCH_TYPE
    CC_INDEX
    SINGLETON
    SIDL_NAME
    ;

OPERATION PREDICATES
    ISRC_A_SIZE
    ISRC_B_SIZE
    ISRC_C_SIZE
    IDEST_SIZE
    IDEST2_SIZE
    DOES_READ_CC
    VIRTUAL_QUEUE
    ;



FUNIT uC
    ISSUE_SLOTS 0 1;
   ENCODING WIDTH 88;




  KeepRefCnt '..................................................................................X.....'
  CCC_1 '...................................................................................XXXXX'
  Imm32 '....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....................'
  Sync '........................X...............................................................'
  PredNot '....................................................................X...................'
  Pred '.....................................................................XXX................'
  QuadMask '.............................................XXXX.......................................'
  QuadMask2 '........................................................................XXXX............'
  Dest '................................................................................XXXXXXXX'
  Dest2 '....................................................XXXXXXXX............................'
  RegA '........................................................................XXXXXXXX........'
  RegB '............................................................XXXXXXXX....................'
  RegC '.........................................XXXXXXXX.......................................'

  RegBALD '.........................................XXXXXXXX.......................................'
  RegBAST '................................................................................XXXXXXXX'

  NODEP '......................................X.................................................'
  Phase '.........................................................XX.............................'
  Wmsk '.....................................................XXXX...............................'
  Wmsk3 '...................................XXX..................................................'
  tex2d_4 '...............................XXXX.....................................................'
  ParamA '.........................................................XXX............................'
  TOFF1 '....................................................X...................................'
  CL '.................................X......................................................'
  CLB '...................................................X....................................'
  MS '.....................................X..................................................'
  LOD1 '................................X.......................................................'
  LOD1B '..................................................X.....................................'
  TidB '.......................................XXXXXXXXXXXXX....................................'
  TidBTEX '............................................XXXXXXXX....................................'
  TidBSAMP '.......................................XXXXX............................................'
  TidBWmsk '...............................XXXXXXXXXXXXX.........XXXX...............................'
  TidBWmsk2 '.................................XXXXXXXXXXXXX.......XXXX...............................'
  TidBTEX3 '..........................................XXXXXXXX......................................'
  TidBSAMP3 '.....................................XXXXX..............................................'
  LOD '..............................XXX.......................................................'
  LODB '................................................XXX.....................................'
  AOFFI '.................................X......................................................'
  AOFFI2 '....................................X...................................................'
  AOFFIB '...................................................X....................................'
  DC '.....................................X..................................................'
  NDV '....................................................X...................................'
  NDV2 '.................................................X......................................'
  TexQuery '............................................................XXXXXX......................'
  STPMode '........................................................X...............................'
  LC '.............................X..........................................................'
  LCB '...............................................X........................................'
  LCD '.....................................X..................................................'
  PredDst '..................................XXX...................................................'
  PredDstLop '.....................................XXX................................................'




  TexComp '..............................XX........................................................'
  TexComp2 '..................................XX....................................................'
  TOFF2 '................................XX......................................................'
  TexCompB '................................................XX......................................'
  TOFF2B '..................................................XX....................................'

  Sat '.....................................X..................................................'
  PSign '......................................XX................................................'
  WriteCC '........................................X...............................................'
  Xm '............................................X...........................................'

  ALSize '.......................................XX...............................................'
  AIO '.......................................................X................................'
  P '........................................................X...............................'
  Imm10 '..........................................................XXXXXXXXXX....................'
  Imm11 '.........................................................XXXXXXXXXXX....................'
  msbImm11 '.........................................................X..............................'

  FMZ '.................................XX.....................................................'
  Rnd '...................................XX...................................................'
  nC '......................................X.................................................'
  nAB '.......................................X................................................'

  FMZ_H '...............................XX.......................................................'
  FMZ_H2 '.............................XX.........................................................'
  nAB_H '...............................X........................................................'
  vBmux_H '.................................XX.....................................................'
  vAmux_H '.................................XX.....................................................'
  vAmux_H2 '.......................................XX...............................................'
  sat_H '...................................X....................................................'
  nC_H '...................................X....................................................'
  nC_H2 '....................................X...................................................'
  FimmH0 '....................................................XXXXXXXXXXXXXXXX....................'
  FimmH1 '....................................XXXXXXXXXXXXXXXX....................................'

  FMZLow '..........................................XX............................................'
  ScaleLow '............................................XXX.........................................'
  RndLow '...............................................XX.......................................'

  SatLow '....................................X...................................................'
  IPAOp '................................XX......................................................'
  MSI '..................................XX....................................................'
  IPAIDX '.................................................X......................................'
  IPAImm10 '..................................................XXXXXXXXXX............................'
  IPAImm11 '.................................................XXXXXXXXXXX............................'
  PredSrc '......................................XXX...............................................'
  PredSrcldst '...........................XXX..........................................................'
  PredSrcNot '.....................................X..................................................'




  nC2 '..............................X.........................................................'
  nAB2 '...............................X........................................................'
  SatHigh '................................X.......................................................'
  FMZHigh '.................................XX.....................................................'
  WriteCCI '...................................X....................................................'

  PSign2 '...............................XX.......................................................'
  Sat2 '.................................X......................................................'
  Xm2 '..................................X.....................................................'

  MufuOp '................................................................XXXX....................'

  BSigned '..............................................X.........................................'
  ASigned '...............................................X........................................'
  HILO '................................................X.......................................'

  BSigned2 '................................X.......................................................'
  ASigned2 '.................................X......................................................'
  HILO2 '..................................X.....................................................'
  XMADCop '...................................XXX..................................................'
  XMADCop2 '....................................XX..................................................'




  BSigned4 '..............................X.........................................................'
  BSigned5 '......................................X.................................................'
  ASigned5 '.......................................X................................................'
  Xm7 '.................................................X......................................'
  Xm8 '.................................X......................................................'
  MRG '..................................................X.....................................'
  MRG2 '...............................X........................................................'
  PSL '...................................................X....................................'
  PSL2 '................................X.......................................................'
  HILO4 '....................................................X...................................'
  HILO5 '...................................X....................................................'
  XMADFiller '.....................................................XXXXXXX............................'
  XMADImmFiller '...............................X........................................................'

  Imm24sh '.................................XXXXXXXXXXXXXXXXXXXXXXXX...............................'
  Imm32sh '........................X................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
  Imm4n '.................................XXXX...................................................'
  Imm4m '.....................................XXXX...............................................'
  Imm4l '.........................................XXXX...........................................'
  Imm4k '.............................................XXXX.......................................'
  Imm4j '.................................................XXXX...................................'
  Imm4i '.....................................................XXXX...............................'
  Imm4h '.........................................................XXXX...........................'
  Imm4g '.............................................................XXXX.......................'
  Imm4f '........................X........................................XXX....................'
  Imm4e '....................................................................XXXX................'
  Imm4d '........................................................................XXXX............'
  Imm4c '............................................................................XXXX........'
  Imm4b '................................................................................XXXX....'
  Imm4a '....................................................................................XXXX'




  nA1 '.......................................X................................................'
  aA2 '.........................................X..............................................'
  nB2 '..........................................X.............................................'
  FComp '....................................XXXX................................................'
  FComp2 '.................................................XXXX...................................'
  FComp3 '...................................XXXX.................................................'
  H_and '......................................X.................................................'
  H_and2 '..................................X.....................................................'
  vAmux '.......................................XX...............................................'
  vBmux '..........................................................XX............................'
  nA2 '............................................X...........................................'
  aB2 '...........................................X............................................'
  aAH '...........................................X............................................'
  aA3 '.................................X......................................................'
  nB3 '..................................X.....................................................'
  aA4 '................................................................................X.......'
  nB4 '.................................................................................X......'
  nBH '........................................................X...............................'
  aBH '.........................................................X..............................'
  nBH2 '...............................X........................................................'
  aBH2 '.................................X......................................................'
  FTZ '...........................................X............................................'
  FTZ2 '........................................X...............................................'
  FTZ3 '................................X.......................................................'
  FTZH '.................................................................................X......'
  SrcNot '.............................................X..........................................'
  SrcPred '..............................................XXX.......................................'
  Src1Not '.......................................................X................................'
  Src1Pred '........................................................XXX.............................'
  Src2Not '........................................................................X...............'
  Src2Pred '.........................................................................XXX............'
  PDest '..................................................................................XXX...'
  PNDest '.....................................................................................XXX'

  nA3 '............................................X...........................................'
  nA4 '..........................................X.............................................'
  nA5 '..................................................X.....................................'
  nA6 '...............................X........................................................'
  BVal '...........................................X............................................'
  BVal1 '...................................X....................................................'

  SReg '............................................................XXXXXXXX....................'
  nA7 '....................................X...................................................'
  nB7 '.....................................X..................................................'
  nC7 '......................................X.................................................'
  Xm9 '.......................................X................................................'
  LRS '.................................................XX.....................................'
  Apart '...................................................XX...................................'
  Bpart '.....................................................XX.................................'
  Cpart '.......................................................XX...............................'




  LE '..........................................................X.............................'
  SBID '...........................................................XXX..........................'
  PendCnt '..............................................................XXXXXX....................'
  Imm6 '..................................................................................XXXXXX'
  ImmU5 '............................................XXXXX.......................................'
  ImmU5_2 '.......................................................XXXXX............................'
  ImmU5_3 '................................XXXXX...................................................'


  COP '..............................XX........................................................'
  COP1 '...................................XX...................................................'
  LSSize '................................XXX.....................................................'
  Rf '.................................XX.....................................................'
  E '...................................X....................................................'

  AdMode '..........................................XX............................................'
  LSSize2 '.....................................XXX................................................'
  COP2 '..........................................XX............................................'

  SABCExt '.................................XXXXXXX................................................'
  SBExt '.................................X......................................................'
  SCExt '...................................XX...................................................'
  SAExt '.....................................XX.................................................'
  AtomOp '................................XXXX....................................................'
  AtomOp2 '........................................XXXX............................................'
  satmOp '.......................................................XXXX.............................'
  satmBA '...........................................................X............................'
  satmSize1 '..................................XXX...................................................'
  satmSize2 '.................................................XXX....................................'
  AtomSize '....................................XXX.................................................'
  bcRZ '....................................XX..................................................'
  atomsbcRZ '..........................................................XX............................'
  AtomSize1 '......................................X.................................................'
  Size1RegBC '......................................X.....................XXXXXXXX....................'
  asSize1RegBC '...................................X........................XXXXXXXX....................'
  AtomE '.......................................X................................................'
  Imm20a '........................................XXXXXXXXXXXXXXXXXXXX............................'
  Imm22atoms '....................................XXXXXXXXXXXXXXXXXXXXXX..............................'
  AtomsSize '..........................................................XX............................'
  RedOp '..............................................................XXX.......................'
  SURedOp '.............................................................XXX........................'
  PopcSz '......................................XX................................................'
  AtomsSize1 '...................................X....................................................'
  atomscSPIN '..................................X.....................................................'
  RedSize '.................................................................XXX....................'




  Imm20 '................................................XXXXXXXXXXXXXXXXXXXX....................'
  Bpt '...............................................................................XXX......'

  Imm5I '............................................XXXXX.......................................'
  Imm5Ib '..............................XXXXX.....................................................'

  CA '..................................................................................X.....'
  LMT '.................................................................................X......'
  INC '.................................................................................X......'
  U '................................................................................X.......'
  LDSU '...........................................X............................................'
  LDSSize '.....................................XXX...X............................................'
  Imm24 '............................................XXXXXXXXXXXXXXXXXXXXXXXX....................'
  CBank '...............................................XXXXX....................................'
  Imm16 '....................................................XXXXXXXXXXXXXXXX....................'
  Imm16b '........................................................................XXXXXXXXXXXXXXXX'

  IComp '....................................XXX.................................................'
  Signed '.......................................X................................................'
  Bop '.........................................XX.............................................'
  Bop0 '..............................................................XX........................'

  PixMode '......................................................XXX...............................'
  Imm8 '............................................................XXXXXXXX....................'




  LOP '.............................................XX.........................................'
  POP '..........................................XX............................................'
  nB_L '...............................................X........................................'
  nA_L '................................................X.......................................'
  POP2 '..................................................XX....................................'
  LOPImm '....................................................XXXXXXXX............................'
  LOPImm2 '................................XXXXXXXX................................................'
  Xm10 '...............................X........................................................'

  M_H '.....................................X..................................................'
  XmdSHF '......................................XX................................................'
  MaxShift '.................................................XX.....................................'
  Imm06_shf '..............................................................XXXXXX....................'

  M '................................................X.......................................'
  XMode '...........................................XX...........................................'
  Brev '...............................................X........................................'

  Xm_I '..............................X.........................................................'
  nB_L2 '...............................X........................................................'
  nA_L2 '................................X.......................................................'
  LOP_I '.................................XX.....................................................'

  Imm06Tex '..............................................................XXXXXX....................'

  HILO3 '.................................X......................................................'
  BSigned3 '..................................X.....................................................'
  PSign3 '...................................XX...................................................'
  Xm3 '......................................X.................................................'
  ASigned3 '.......................................X................................................'
  Xm4 '.........................................X..............................................'
  Xm5 '.................................................X......................................'
  Xm6 '..............................X.........................................................'



  aB '......................................X.................................................'
  nB '..........................................X.............................................'
  By '.............................................XX.........................................'
  ISrcFmt '..........................................................................X.XX..........'
  DstFmt '..............................................................................XX........'

  Byte '.............................................XX.........................................'
  CCPR '...............................................X........................................'

  OutType '...............................................XX.......................................'

  VMode '......................................XX................................................'
  Imm28 '........................................XXXXXXXXXXXXXXXXXXXXXXXXXXXX....................'
  VPDest '........................................XXX.............................................'

  MembarL '..............................................................................XX........'
  Ivall '......................................................................................XX'

  AFix_BAR '...........................................X............................................'
  BFix_BAR '............................................X...........................................'
  BarRedOp '...................................................XX...................................'
  BarOp '.....................................................XXX................................'
  BarFiller '........................................................XXXX............................'
  Imm12 '........................................................XXXXXXXXXXXX....................'

  Trig '..........................................................................X.............'
  Trig2 '...................................................................X....................'
  CCC_2 '...........................................................................XXXXX........'




  SrcDstFmt '............................................................................XXXX........'
  IR '.............................................X..........................................'
  IRRnd '.............................................X.XX.......................................'
  Rnd_1 '...............................................XX.......................................'
  SH '..............................................X.........................................'

  IDstFmt '...........................................................................X..XX........'
  SrcFmt '............................................................................XX..........'
  SrcFmt2 '..........................................................................X.XX..........'

  PMode '....................................XXXX................................................'
  RROOp '................................................X.......................................'

  Barmd '......................................................XX................................'
  DstPred '........................................XXX.............................................'
  DstPred1 '.........................................XXX............................................'
  BarName '........................................................XXXX............................'

  Imm13 '.........................................XXXXXXXXXXXXX..................................'
  PredDest '.....................................XXX................................................'
  PredDest2 '.......................................................XXX..............................'
  PredDest3 '..................................XXX...................................................'
  PredDest4 '............................................XXX.........................................'
  SHFLFiller '.................................................XXXXX..................................'
  Shflmd '........................................................XX..............................'
  CFix_SHFL '..........................................................X.............................'
  BFix_SHFL '...........................................................X............................'
  shfl_imm5 '...............................................................XXXXX....................'
  bit6_RegB '............................................................XXX.........................'

  RTTOp '......................................................................................XX'




  Imm22a '............................................XXXXXXXXXXXXXXXXXXXXXX......................'
  Cache '..................................................................................XX....'
  CCTLOp '....................................................................................XXXX'
  CCTLTOp '......................................................................................XX'
  TsIdx13 '.......................................XXXXXXXXXXXXX....................................'
  Imm30a '....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX......................'
  Cache3 '.................................................................................XXX....'

  SWZMode '............................................XXX.........................................'
  PNWord '....................................................XXXXXXXX............................'

  SUPDest '.....................................XXX................................................'
  BDim '........................................X...............................................'

  BDim2 '..................................X.....................................................'
  SMode '...................................XXXX.................................................'
  Imm06 '...........................................XXXXXX.......................................'

  Rnd3 '....................................XX..................................................'
  CMode '................................................................................XX......'
  ChkModeF '...........................................XXXXXX.......................................'

  DI '..................................................................................X.....'





  Ofmt '.....................................XX.................................................'
  RGBAb '.......................................XXXX.............................................'
  Clamp '...........................................XX...........................................'
  LSSize3 '.......................................................XXX..............................'
  Rf3 '........................................................XX..............................'

  COP3 '..........................................................XX............................'
  Ofmt2 '............................................................XX..........................'
  RGBAa '..............................................................XXXX......................'
  Clamp2 '..................................................................XX....................'

  SrcNotSU '.....................................X..................................................'
  SrcPredSU '......................................XXX...............................................'
  Ofmt3 '................................................................................XX......'
  RGBAc '..................................................................................XXXX..'
  Clamp3 '......................................................................................XX'
  Clamp4 '.....................................XX.................................................'
  SUDim '....................................................XXX.................................'

  COP4 '........................................XX..............................................'
  COP5 '..............................................................XX........................'
  BA '................................................................X.......................'
  SUSize '.................................................................XXX....................'
  SURGBA '................................................................XXXX....................'
  E2 '..........................................X.............................................'

  DFormat '.................................................X......................................'
  DFormat2 '.................................X......................................................'
  safmt '.......................................X................................................'
  sbfmt '......................................X.................................................'
  sbfmt2 '................................X.......................................................'
  sbfmt3 '..................................X.....................................................'
  VRed '.................................XX.....................................................'
  VRed2 '......................................XX................................................'
  LaneMask4 '...................................XX.............XX....................................'
  asel4 '....................................................XXXX................................'
  bsel4 '........................................................XXXX............................'
  AVGMode '...............................XX.......................................................'
  AVGMode2 '..............................XX........................................................'
  AVGMode3 '.................................XX.....................................................'
  MN '................................X.......................................................'
  MN2 '...............................X........................................................'
  VComp '.....................................XXX................................................'
  VComp2 '...............................XXX......................................................'
  VComp3 '........................................X..XX...........................................'
  VRed3 '.........................................XX.............................................'
  LaneMask4b '...........................................XX.....XX....................................'
  BFiller2 '..........................................................XX............................'
  LaneMask2 '...................................XX...................................................'
  LaneMask2b '...........................................XX...........................................'
  asel2 '..................................................XXXX..................................'
  bsel2 '......................................................XXXX..............................'
  asel2hi '..................................................XX....................................'
  BVideo '.....................................X..................................................'
  aSelect '.......................................X.........XXX....................................'
  bSelect '......................................X..................XXX............................'
  bSelectU '.........................................................XXX............................'
  BFiller3 '....................................................XXXXX...............................'
  VOP '..................................XXX...................................................'
  MV '......................................X.................................................'
  VScale '...................................XX...................................................'
  Sat3 '....................................X...................................................'
  IBase '.....................................................XX.................................'

  Bconst '...............................X.................XXXXXXXXXXXXXXXXXXX....................'
  BimmH0 '..........................................................XXXXXXXXXX....................'
  BimmH1 '...............................X.................XXXXXXXXX..............................'
  Bcbank '.................................................XXXXX..................................'
  Bcaddr '......................................................XXXXXXXXXXXXXX....................'
  BFiller '.................................................XXXXXXXXXXX............................'
  Canvas32 '...........................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.............................'
  Opcode32 '.........................XXXXX..........................................................'
  Opcode42 '........................XXXXX...........................................................'
  Opcode52 '.........................XXXXXXX........................................................'
  Opcode362 '.........................XXXXXXXXXXX....................................................'
  Opcode542 '.........................XXXXXXXXXXX....................................................'
  Opcode532 '.........................XXXXXXXXXX.....................................................'
  Opcode512 '.........................XXXXXXXX.......................................................'
  Opcode552 '........................XXXXXXXXXX......................................................'





  Opcode3 '........................XXX.............................................................'
  Opcode5 '........................XXXXX...........................................................'
  Opcode5b1 '........................XXXXX...X.......................................................'
  Opcode6 '........................XXXXXX..........................................................'
  Opcode7 '........................XXXXXXX.........................................................'
  Opcode8 '........................XXXXXXXX........................................................'
  Opcode9 '........................XXXXXXXXX.......................................................'
  Opcode10 '........................XXXXXXXXXX......................................................'
  Opcode11 '........................XXXXXXXXXXX.....................................................'
  Opcode12 '........................XXXXXXXXXXXX....................................................'
  Opcode13 '........................XXXXXXXXXXXXX...................................................'
  Opcode7b1 '........................XXXXXXX.X.......................................................'
  Opcode7b2 '........................XXXXXXX.XX......................................................'
  Opcode7b5 '........................XXXXXXX.XXXXX...................................................'
  Opcode7b4 '........................XXXXXXX.XXXX....................................................'




  Opcode352_N '.........................XX................................XXXXXXXX.....................'

  SubOpcodeX5X '................................XXXXX...................................................'
  SubOpcodeX4X '................................XXXX....................................................'
  SubOpcodeX1X '................................X.......................................................'
  SubOpcodeX2X '................................XX......................................................'
  Opcode2X2 '.........................XXXX...........................................................'
  ABCOpcodeX3X_1 '.............................XXX........................................................'
  Opcode1X2 '.........................XXX............................................................'
  ABCOpcodeX3X_2 '............................XXX.........................................................'




  NencATOM '...............................................XXXXXXXXXXXXX............................'
  NencATOM2 '........................................XXXX...XXXXXXXXXXXXX............................'
  NencIADD3 '.........................................................XXX............................'
  NencLDG '...........................................X............................................'
  NencLDG2 '...........................................X...X........................................'
  NencLDS '........................................XXX.............................................'
  NencMOV32I '............................................................................XXXX........'
  NencMOV '.....................................XXXXXXXX...........................XXXXXXXX........'
  NencEXIT '....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXX......'
  NencPEXIT '....................................XXXXXXXX........................XXXXXXXXXXXXXXXXXXXX'
  NencIADD '.........................................XXX.XXXX.......................................'
  NencISCADD '.....................................X...XXX............................................'
  NencPOPC '.....................................XXXXXXXXXX.........................................'
  NencTLDB '.......................................XXXXXXXXXXXXX....................................'
  NencTEXB '.......................................XXXXXXXX.........................................'
  NencALD '.....................................XX..........XXXXXX.................................'
  NencAL2P '.....................................XX.....XXXXXXXXXXX.X...............................'
  NencFMUL '......................................X..X..............................................'
  NencMUFU '......................................X.X.XXXXXXXXXXXXXXXXXXXXXX........................'
  NencIMUL '.....................................XXX.XXXXX..........................................'
  NencSHINT '................................X.......................................................'
  NencS2R '.....................................XXXXXXXXXXXXXXXXXXXXXXX............XXXXXXXX........'
  NencBRA '....................................XXXXXXXX............................................'
  NencISETP '........................................X..X....................................XX......'
  NencPSETP '.....................................XXXX..XX....XXXXXX....XXX..XXXX........XXXXXX......'
  NencPSET '.....................................XXX....X....XXXXXX....XXX..XXXX........XXXX........'
  NencCSETP '.....................................XXXX..XX....XXXXXXXXXXXXXXXXXXX....XXX.....XX......'
  NencCSET '.....................................XXX....X....XXXXXXXXXXXXXXXXXXX....XXX.............'
  NencHSETP2 '.....................................X...............XXX........................X.......'
  NencHSETP3 '................................................................................X.......'
  NencHSETP '.................................X..............................................X.......'
  NencVSETP '................................................................................XX......'
  NencLOP '.........................................X..............................................'
  NencSHL '.....................................XXX.XXX.XXX........................................'
  NencSHR '.....................................XX..XX..XX.........................................'
  NencP2R '.....................................XXXXXXXX...X.......................................'
  NencTEXDEPBAR '.....................................XXXXXXXXXXXXXXXXXXXXXXXXX..........XXXXXXXXXXXXXXXX'
  NencSEL '.....................................XXXXXXXX...........................................'
  NencOUT '.....................................XXXXXXXXXX.........................................'
  NencI2F '.....................................X.X.X.XX...........................XX.X............'
  NencMEMBAR '.....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXX..XXXXXX..'
  NencBAR2 '.....................................XXXXXXXX....XX.....................................'
  NencBAR '.....................................XXXXXX......XX.....................................'
  NencCCTLL '.....................................XXXXXXX......................XX............XX......'
  NencCCTL '..................................................................XX............X.......'
  NencCCTLTReg '.....................................XXXX........XXXXXXXXXXXXXXXXXXX....XXXXXXXXXXXXXX..'
  NencCCTLTIDx '.....................................XX.............XXXXXXXXXXXXXXXX....XXXXXXXXXXXXXX..'
  NencNOP '.....................................XXXXXXXXXXXXXXX....................XX......XXXXXXXX'
  NencF2F '.......................................X.X..X...........................XXXX............'
  NencF2I '.....................................X.X.X..XX..........................XXX.............'
  NencJMP '....................................XXXXXXXXXXX.........................................'
  NencFSWZADD '.....................................XXX.XX.XXX...XX....................................'
  NencVOTEVTG '.....................................X..................................XXXXXXXXXXXXXXXX'
  NencVOTE '.....................................X.....XX....XXXXXXXXXXXXXXXXXXX....XXXXXXXX........'
  NencSULDGA '.................................................XXXXXX.................................'
  NencSULD1 '.......................................XX........XXX...XXXXXXX..........................'
  NencSULD2 '.......................................................XXXXXXX..........................'
  NencSULD3 '.......................................XX........XXX......XXXX..........................'
  NencSULD4 '..........................................................XXXX..........................'
  NencSURED1 '.......................................XX........XXX...XXXXXX...........................'
  NencSURED2 '.......................................................XXXXXX...........................'
  NencSURED3 '.......................................XX........XXX...XXXXXX...XXXX....................'
  NencSURED4 '.......................................................XXXXXX...XXXX....................'
  NencSUATOM1 '.......................................XX...............................................'
  NencSUATOM2 '.......................................XX........XXX.......X............................'
  NencSUATOM3 '...........................................................X............................'
  NencSUATOM4 '.......................................XX.................X.............................'
  NencSUATOM5 '..........................................................X.............................'
  NencBPT '....................................XXXXXXXXXXXX....................XXXXXXXXXXX...XXXXXX'
  NencFLO '.....................................XX..XXXXX..X.......................................'
  NencI2I '.......................................X.X.XX..XX.......................XX..............'
  NencB2R '.....................................XXX...XXXXXXXXXXX..XXXXXXXXXXXX....................'
  NencRTT '....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..'
  NencSHFL '........................................X.............XX................................'
  NencPIXLD '.....................................XXX...XXXXXXXXXXX...XXX............................'
  NencTXQ '.....................................X..............X....XXX......XX....................'
  NencTXA '.....................................X...................XXXXXXXXXXX....................'
  NencTMML '.....................................X......................XXXXXXXX....................'
  NencTMMLB '.....................................X.XXXXXXXXXXXXX....................................'
  NencSTP '.....................................XXXXXXXXXXXXXXXXXXX.XXX........XXXXXXXXXXXXXXXXXXXX'
  NencCRSLMEM '....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX................'
  NencLDC '........................................XX..XXX.........................................'
  NencBFE '.....................................XX..XXXXXX.X.......................................'
  NencBFI '.....................................XXX................................................'
  NencR2B '.....................................XXXXXXXXXXXXXXXXX..................................'
  NencVILD '.....................................XXXXXXXXXXXXXXXXXXXXXXX............................'
  NencIDE '....................................XXXXXXXXXXXXXXXX................XXXXXXXXXXXXXX.XXXXX'
  NencSHF '...............................X...................XXXXXXXXXXX..........................'
  NencSHF2 '...................................................XXXXXXXXX............................'
  NencSync '.....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXXX.....'
  NencRPI '.....................................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXXXXXXXX'
  NencRed '.....................................XX.....................XX..........................'
  NencDEPBAR '.....................................XXXXXXXXXXXXXXXXXXXXX..............XXXXXXXXXX......'
  NencISBERD '.....................................XX..XXXXXXXXXXXX....XXXXXXXXXXX....................'
  NencLEA_LO '...........................................X............................................'
  NencLEA_HI_REG '...................................................XXXX.................................'




  OEUSchedInfo '...................XXXXX................................................................'
  OECoupled '...X....................................................................................'
  OEVarLatDest '................XXX.....................................................................'
  OEVarLatSrc '.............XXX........................................................................'
  OEWaitOnSb '.......XXXXXX...........................................................................'
  OEReserved '...XX...................................................................................'
  OETexPhase '.....XX.................................................................................'
  OEReuseA '......X.................................................................................'
  OEReuseB '.....X..................................................................................'
  OEReuseC '....X...................................................................................'
  OEReserved1 'XXX.....................................................................................'

  ALL '.........................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'


hfma2__v2_PgNot '....................................................................X...................'
hfma2__v2_Pg '.....................................................................XXX................'
hfma2__v2_opcode '........................XXXXXXXXXXXXX...................................................'
hfma2__v2_ofmt '.....................................XX.................................................'
hfma2__v2_fmz '.................................................XX.....................................'
hfma2__v2_sat '.......................................................X................................'
hfma2__v2_Rd '................................................................................XXXXXXXX'
hfma2__v2_Ra '........................................................................XXXXXXXX........'
hfma2__v2_Ra_iswz_Ra_mod '.......................................XX...............................................'
hfma2__v2_Sb '............................................................XXXXXXXX....................'
hfma2__v2_Sb_iswz_Rb_mod '..........................................................XX............................'
hfma2__v2_Rc '.........................................XXXXXXXX.......................................'
hfma2__v2_Rc_negate '.........................................................X..............................'
hfma2__v2_Rc_iswz_Rc_reg_mod '...................................................XX...................................'
hfma2__v2_req_sb_bitset '.......XXXXXX...........................................................................'
hfma2__v2_src_rel_sb '.............XXX........................................................................'
hfma2__v2_dst_wr_sb '................XXX.....................................................................'
hfma2__v2_usched_info '...................XXXXX................................................................'
hfma2__v2_nAB '........................................................X...............................'
hfma2__v2_unused 'XXXX.................................................XX.................................'
hfma2__v1_PgNot '....................................................................X...................'
hfma2__v1_Pg '.....................................................................XXX................'
hfma2__v1_opcode '........................XXXXX...X.......................................................'
hfma2__v1_ofmt '.....................................XX.................................................'
hfma2__v1_fmz '.............................XX.........................................................'
hfma2__v1_sat '...................................X....................................................'
hfma2__v1_Rd '................................................................................XXXXXXXX'
hfma2__v1_Ra '........................................................................XXXXXXXX........'
hfma2__v1_Ra_iswz_Ra_mod '.......................................XX...............................................'
hfma2__v1_Sb '...............................X.................XXXXXXXXX..............................'
hfma2__v1_Sb2 '..........................................................XXXXXXXXXX....................'
hfma2__v1_Rc '.........................................XXXXXXXX.......................................'
hfma2__v1_Rc_negate '....................................X...................................................'
hfma2__v1_Rc_iswz_Rc_mod '.................................XX.....................................................'
hfma2__v1_req_sb_bitset '.......XXXXXX...........................................................................'
hfma2__v1_src_rel_sb '.............XXX........................................................................'
hfma2__v1_dst_wr_sb '................XXX.....................................................................'
hfma2__v1_usched_info '...................XXXXX................................................................'
hfma2__v1_unused 'XXXX....................................................................................'
hfma2__v0_PgNot '....................................................................X...................'
hfma2__v0_Pg '.....................................................................XXX................'
hfma2__v0_opcode '........................XXXXX...X.......................................................'
hfma2__v0_ofmt '.....................................XX.................................................'
hfma2__v0_fmz '.............................XX.........................................................'
hfma2__v0_sat '...................................X....................................................'
hfma2__v0_Rd '................................................................................XXXXXXXX'
hfma2__v0_Ra '........................................................................XXXXXXXX........'
hfma2__v0_Ra_iswz_Ra_mod '.......................................XX...............................................'
hfma2__v0_Rc '.........................................XXXXXXXX.......................................'
hfma2__v0_Rc_negate '....................................X...................................................'
hfma2__v0_Rc_iswz_Rc_mod '.................................XX.....................................................'
hfma2__v0_req_sb_bitset '.......XXXXXX...........................................................................'
hfma2__v0_src_rel_sb '.............XXX........................................................................'
hfma2__v0_dst_wr_sb '................XXX.....................................................................'
hfma2__v0_usched_info '...................XXXXX................................................................'
hfma2__v0_nAB '...............................X........................................................'
hfma2__v0_unused 'XXXX....................................................................................'
hset2__v2_PgNot '....................................................................X...................'
hset2__v2_Pg '.....................................................................XXX................'
hset2__v2_opcode '........................XXXXXXXXXXXXX...................................................'
hset2__v2_bval '......................................X.................................................'
hset2__v2_cmp '.................................................XXXX...................................'
hset2__v2_ftz '.....................................X..................................................'
hset2__v2_bop '.........................................XX.............................................'
hset2__v2_Rd '................................................................................XXXXXXXX'
hset2__v2_Ra '........................................................................XXXXXXXX........'
hset2__v2_Ra_absolute '...........................................X............................................'
hset2__v2_Ra_negate '............................................X...........................................'
hset2__v2_Ra_iswz_Ra_mod '.......................................XX...............................................'
hset2__v2_Sb '............................................................XXXXXXXX....................'
hset2__v2_Sb_absolute '.........................................................X..............................'
hset2__v2_Sb_negate '........................................................X...............................'
hset2__v2_Sb_iswz_Rb_mod '..........................................................XX............................'
hset2__v2_PsNot '.............................................X..........................................'
hset2__v2_Ps '..............................................XXX.......................................'
hset2__v2_req_sb_bitset '.......XXXXXX...........................................................................'
hset2__v2_src_rel_sb '.............XXX........................................................................'
hset2__v2_dst_wr_sb '................XXX.....................................................................'
hset2__v2_usched_info '...................XXXXX................................................................'
hset2__v2_unused 'XXXX.................................................XXX................................'
hset2__v1_PgNot '....................................................................X...................'
hset2__v1_Pg '.....................................................................XXX................'
hset2__v1_opcode '........................XXXXXXX.X.......................................................'
hset2__v1_bval '..................................X.....................................................'
hset2__v1_cmp '...................................XXXX.................................................'
hset2__v1_ftz '.................................X......................................................'
hset2__v1_bop '.........................................XX.............................................'
hset2__v1_Rd '................................................................................XXXXXXXX'
hset2__v1_Ra '........................................................................XXXXXXXX........'
hset2__v1_Ra_absolute '...........................................X............................................'
hset2__v1_Ra_negate '............................................X...........................................'
hset2__v1_Ra_iswz_Ra_mod '.......................................XX...............................................'
hset2__v1_Sb '...............................X.................XXXXXXXXX..............................'
hset2__v1_Sb2 '..........................................................XXXXXXXXXX....................'
hset2__v1_PsNot '.............................................X..........................................'
hset2__v1_Ps '..............................................XXX.......................................'
hset2__v1_req_sb_bitset '.......XXXXXX...........................................................................'
hset2__v1_src_rel_sb '.............XXX........................................................................'
hset2__v1_dst_wr_sb '................XXX.....................................................................'
hset2__v1_usched_info '...................XXXXX................................................................'
hset2__v1_unused 'XXXX....................................................................................'
hset2__v0_PgNot '....................................................................X...................'
hset2__v0_Pg '.....................................................................XXX................'
hset2__v0_opcode '........................XXXXXXX.X.......................................................'
hset2__v0_bval '..................................X.....................................................'
hset2__v0_cmp '...................................XXXX.................................................'
hset2__v0_ftz '.................................X......................................................'
hset2__v0_bop '.........................................XX.............................................'
hset2__v0_Rd '................................................................................XXXXXXXX'
hset2__v0_Ra '........................................................................XXXXXXXX........'
hset2__v0_Ra_absolute '...........................................X............................................'
hset2__v0_Ra_negate '............................................X...........................................'
hset2__v0_Ra_iswz_Ra_mod '.......................................XX...............................................'
hset2__v0_Sb_negate '...............................X........................................................'
hset2__v0_PsNot '.............................................X..........................................'
hset2__v0_Ps '..............................................XXX.......................................'
hset2__v0_req_sb_bitset '.......XXXXXX...........................................................................'
hset2__v0_src_rel_sb '.............XXX........................................................................'
hset2__v0_dst_wr_sb '................XXX.....................................................................'
hset2__v0_usched_info '...................XXXXX................................................................'
hset2__v0_unused 'XXXX....................................................................................'
hset2_bop__v1_PgNot '....................................................................X...................'
hset2_bop__v1_Pg '.....................................................................XXX................'
hset2_bop__v1_opcode '........................XXXXXXX.X.......................................................'
hset2_bop__v1_bval '..................................X.....................................................'
hset2_bop__v1_cmp '...................................XXXX.................................................'
hset2_bop__v1_ftz '.................................X......................................................'
hset2_bop__v1_bop '.........................................XX.............................................'
hset2_bop__v1_Rd '................................................................................XXXXXXXX'
hset2_bop__v1_Ra '........................................................................XXXXXXXX........'
hset2_bop__v1_Ra_absolute '...........................................X............................................'
hset2_bop__v1_Ra_negate '............................................X...........................................'
hset2_bop__v1_Ra_iswz_Ra_mod '.......................................XX...............................................'
hset2_bop__v1_Sb '...............................X.................XXXXXXXXX..............................'
hset2_bop__v1_Sb2 '..........................................................XXXXXXXXXX....................'
hset2_bop__v1_PsNot '.............................................X..........................................'
hset2_bop__v1_Ps '..............................................XXX.......................................'
hset2_bop__v1_req_sb_bitset '.......XXXXXX...........................................................................'
hset2_bop__v1_src_rel_sb '.............XXX........................................................................'
hset2_bop__v1_dst_wr_sb '................XXX.....................................................................'
hset2_bop__v1_usched_info '...................XXXXX................................................................'
hset2_bop__v1_unused 'XXXX....................................................................................'
hset2_bop__v0_PgNot '....................................................................X...................'
hset2_bop__v0_Pg '.....................................................................XXX................'
hset2_bop__v0_opcode '........................XXXXXXX.X.......................................................'
hset2_bop__v0_bval '..................................X.....................................................'
hset2_bop__v0_cmp '...................................XXXX.................................................'
hset2_bop__v0_ftz '.................................X......................................................'
hset2_bop__v0_bop '.........................................XX.............................................'
hset2_bop__v0_Rd '................................................................................XXXXXXXX'
hset2_bop__v0_Ra '........................................................................XXXXXXXX........'
hset2_bop__v0_Ra_absolute '...........................................X............................................'
hset2_bop__v0_Ra_negate '............................................X...........................................'
hset2_bop__v0_Ra_iswz_Ra_mod '.......................................XX...............................................'
hset2_bop__v0_Sb_negate '...............................X........................................................'
hset2_bop__v0_PsNot '.............................................X..........................................'
hset2_bop__v0_Ps '..............................................XXX.......................................'
hset2_bop__v0_req_sb_bitset '.......XXXXXX...........................................................................'
hset2_bop__v0_src_rel_sb '.............XXX........................................................................'
hset2_bop__v0_dst_wr_sb '................XXX.....................................................................'
hset2_bop__v0_usched_info '...................XXXXX................................................................'
hset2_bop__v0_unused 'XXXX....................................................................................'
hmul2_32i__PgNot '....................................................................X...................'
hmul2_32i__Pg '.....................................................................XXX................'
hmul2_32i__opcode '........................XXXXXXX.........................................................'
hmul2_32i__fmz '...............................XX.......................................................'
hmul2_32i__sat '...................................X....................................................'
hmul2_32i__Rd '................................................................................XXXXXXXX'
hmul2_32i__Ra '........................................................................XXXXXXXX........'
hmul2_32i__Ra_iswz_Ra_32i_mod '.................................XX.....................................................'
hmul2_32i__imm '....................................XXXXXXXXXXXXXXXX....................................'
hmul2_32i__imm2 '....................................................XXXXXXXXXXXXXXXX....................'
hmul2_32i__req_sb_bitset '.......XXXXXX...........................................................................'
hmul2_32i__src_rel_sb '.............XXX........................................................................'
hmul2_32i__dst_wr_sb '................XXX.....................................................................'
hmul2_32i__usched_info '...................XXXXX................................................................'
hmul2_32i__unused 'XXXX....................................................................................'
hset2_bop__v2_PgNot '....................................................................X...................'
hset2_bop__v2_Pg '.....................................................................XXX................'
hset2_bop__v2_opcode '........................XXXXXXXXXXXXX...................................................'
hset2_bop__v2_bval '......................................X.................................................'
hset2_bop__v2_cmp '.................................................XXXX...................................'
hset2_bop__v2_ftz '.....................................X..................................................'
hset2_bop__v2_bop '.........................................XX.............................................'
hset2_bop__v2_Rd '................................................................................XXXXXXXX'
hset2_bop__v2_Ra '........................................................................XXXXXXXX........'
hset2_bop__v2_Ra_absolute '...........................................X............................................'
hset2_bop__v2_Ra_negate '............................................X...........................................'
hset2_bop__v2_Ra_iswz_Ra_mod '.......................................XX...............................................'
hset2_bop__v2_Sb '............................................................XXXXXXXX....................'
hset2_bop__v2_Sb_absolute '.........................................................X..............................'
hset2_bop__v2_Sb_negate '........................................................X...............................'
hset2_bop__v2_Sb_iswz_Rb_mod '..........................................................XX............................'
hset2_bop__v2_PsNot '.............................................X..........................................'
hset2_bop__v2_Ps '..............................................XXX.......................................'
hset2_bop__v2_req_sb_bitset '.......XXXXXX...........................................................................'
hset2_bop__v2_src_rel_sb '.............XXX........................................................................'
hset2_bop__v2_dst_wr_sb '................XXX.....................................................................'
hset2_bop__v2_usched_info '...................XXXXX................................................................'
hset2_bop__v2_unused 'XXXX.................................................XXX................................'
hadd2__v0_PgNot '....................................................................X...................'
hadd2__v0_Pg '.....................................................................XXX................'
hadd2__v0_opcode '........................XXXXXXX.X.......................................................'
hadd2__v0_ofmt '.....................................XX.................................................'
hadd2__v0_ftz '................................................X.......................................'
hadd2__v0_sat '...................................X....................................................'
hadd2__v0_Rd '................................................................................XXXXXXXX'
hadd2__v0_Ra '........................................................................XXXXXXXX........'
hadd2__v0_Ra_absolute '...........................................X............................................'
hadd2__v0_Ra_negate '............................................X...........................................'
hadd2__v0_Ra_iswz_Ra_mod '.......................................XX...............................................'
hadd2__v0_Sb_absolute '.................................X......................................................'
hadd2__v0_Sb_negate '...............................X........................................................'
hadd2__v0_req_sb_bitset '.......XXXXXX...........................................................................'
hadd2__v0_src_rel_sb '.............XXX........................................................................'
hadd2__v0_dst_wr_sb '................XXX.....................................................................'
hadd2__v0_usched_info '...................XXXXX................................................................'
hadd2__v0_unused 'XXXX..............................X.X....XX..XXX........................................'
hadd2__v1_PgNot '....................................................................X...................'
hadd2__v1_Pg '.....................................................................XXX................'
hadd2__v1_opcode '........................XXXXXXX.X.......................................................'
hadd2__v1_ofmt '.....................................XX.................................................'
hadd2__v1_ftz '................................................X.......................................'
hadd2__v1_sat '...................................X....................................................'
hadd2__v1_Rd '................................................................................XXXXXXXX'
hadd2__v1_Ra '........................................................................XXXXXXXX........'
hadd2__v1_Ra_absolute '...........................................X............................................'
hadd2__v1_Ra_negate '............................................X...........................................'
hadd2__v1_Ra_iswz_Ra_mod '.......................................XX...............................................'
hadd2__v1_Sb '...............................X.................XXXXXXXXX..............................'
hadd2__v1_Sb2 '..........................................................XXXXXXXXXX....................'
hadd2__v1_req_sb_bitset '.......XXXXXX...........................................................................'
hadd2__v1_src_rel_sb '.............XXX........................................................................'
hadd2__v1_dst_wr_sb '................XXX.....................................................................'
hadd2__v1_usched_info '...................XXXXX................................................................'
hadd2__v1_unused 'XXXX.............................XX.X....XX..XXX........................................'
hadd2__v2_PgNot '....................................................................X...................'
hadd2__v2_Pg '.....................................................................XXX................'
hadd2__v2_opcode '........................XXXXXXXXXXXXX...................................................'
hadd2__v2_ofmt '.....................................XX.................................................'
hadd2__v2_ftz '................................................X.......................................'
hadd2__v2_sat '.......................................................X................................'
hadd2__v2_Rd '................................................................................XXXXXXXX'
hadd2__v2_Ra '........................................................................XXXXXXXX........'
hadd2__v2_Ra_absolute '...........................................X............................................'
hadd2__v2_Ra_negate '............................................X...........................................'
hadd2__v2_Ra_iswz_Ra_mod '.......................................XX...............................................'
hadd2__v2_Sb '............................................................XXXXXXXX....................'
hadd2__v2_Sb_absolute '.........................................................X..............................'
hadd2__v2_Sb_negate '........................................................X...............................'
hadd2__v2_Sb_iswz_Rb_mod '..........................................................XX............................'
hadd2__v2_req_sb_bitset '.......XXXXXX...........................................................................'
hadd2__v2_src_rel_sb '.............XXX........................................................................'
hadd2__v2_dst_wr_sb '................XXX.....................................................................'
hadd2__v2_usched_info '...................XXXXX................................................................'
hadd2__v2_unused 'XXXX.....................................XX..XXX.XXXXXX.................................'
hmul2__v2_PgNot '....................................................................X...................'
hmul2__v2_Pg '.....................................................................XXX................'
hmul2__v2_opcode '........................XXXXXXXXXXXXX...................................................'
hmul2__v2_ofmt '.....................................XX.................................................'
hmul2__v2_fmz '...............................................XX.......................................'
hmul2__v2_sat '.......................................................X................................'
hmul2__v2_Rd '................................................................................XXXXXXXX'
hmul2__v2_Ra '........................................................................XXXXXXXX........'
hmul2__v2_Ra_absolute '...........................................X............................................'
hmul2__v2_Ra_iswz_Ra_mod '.......................................XX...............................................'
hmul2__v2_Sb '............................................................XXXXXXXX....................'
hmul2__v2_Sb_absolute '.........................................................X..............................'
hmul2__v2_Sb_iswz_Rb_mod '..........................................................XX............................'
hmul2__v2_req_sb_bitset '.......XXXXXX...........................................................................'
hmul2__v2_src_rel_sb '.............XXX........................................................................'
hmul2__v2_dst_wr_sb '................XXX.....................................................................'
hmul2__v2_usched_info '...................XXXXX................................................................'
hmul2__v2_nAB '........................................................X...............................'
hmul2__v2_unused 'XXXX.....................................XX.XXX..XXXXXX.................................'
hadd2_32i__PgNot '....................................................................X...................'
hadd2_32i__Pg '.....................................................................XXX................'
hadd2_32i__opcode '........................XXXXXXX.........................................................'
hadd2_32i__ftz '................................X.......................................................'
hadd2_32i__sat '...................................X....................................................'
hadd2_32i__Rd '................................................................................XXXXXXXX'
hadd2_32i__Ra '........................................................................XXXXXXXX........'
hadd2_32i__Ra_negate '...............................X........................................................'
hadd2_32i__Ra_iswz_Ra_32i_mod '.................................XX.....................................................'
hadd2_32i__imm '....................................XXXXXXXXXXXXXXXX....................................'
hadd2_32i__imm2 '....................................................XXXXXXXXXXXXXXXX....................'
hadd2_32i__req_sb_bitset '.......XXXXXX...........................................................................'
hadd2_32i__src_rel_sb '.............XXX........................................................................'
hadd2_32i__dst_wr_sb '................XXX.....................................................................'
hadd2_32i__usched_info '...................XXXXX................................................................'
hadd2_32i__unused 'XXXX....................................................................................'
hmul2__v1_PgNot '....................................................................X...................'
hmul2__v1_Pg '.....................................................................XXX................'
hmul2__v1_opcode '........................XXXXXXX.X.......................................................'
hmul2__v1_ofmt '.....................................XX.................................................'
hmul2__v1_fmz '...............................................XX.......................................'
hmul2__v1_sat '...................................X....................................................'
hmul2__v1_Rd '................................................................................XXXXXXXX'
hmul2__v1_Ra '........................................................................XXXXXXXX........'
hmul2__v1_Ra_absolute '...........................................X............................................'
hmul2__v1_Ra_negate '............................................X...........................................'
hmul2__v1_Ra_iswz_Ra_mod '.......................................XX...............................................'
hmul2__v1_Sb '...............................X.................XXXXXXXXX..............................'
hmul2__v1_Sb2 '..........................................................XXXXXXXXXX....................'
hmul2__v1_req_sb_bitset '.......XXXXXX...........................................................................'
hmul2__v1_src_rel_sb '.............XXX........................................................................'
hmul2__v1_dst_wr_sb '................XXX.....................................................................'
hmul2__v1_usched_info '...................XXXXX................................................................'
hmul2__v1_unused 'XXXX.............................XX.X....XX..XX.........................................'
hmul2__v0_PgNot '....................................................................X...................'
hmul2__v0_Pg '.....................................................................XXX................'
hmul2__v0_opcode '........................XXXXXXX.X.......................................................'
hmul2__v0_ofmt '.....................................XX.................................................'
hmul2__v0_fmz '...............................................XX.......................................'
hmul2__v0_sat '...................................X....................................................'
hmul2__v0_Rd '................................................................................XXXXXXXX'
hmul2__v0_Ra '........................................................................XXXXXXXX........'
hmul2__v0_Ra_absolute '...........................................X............................................'
hmul2__v0_Ra_iswz_Ra_mod '.......................................XX...............................................'
hmul2__v0_Sb_absolute '.................................X......................................................'
hmul2__v0_req_sb_bitset '.......XXXXXX...........................................................................'
hmul2__v0_src_rel_sb '.............XXX........................................................................'
hmul2__v0_dst_wr_sb '................XXX.....................................................................'
hmul2__v0_usched_info '...................XXXXX................................................................'
hmul2__v0_nAB '............................................X...........................................'
hmul2__v0_unused 'XXXX...........................X..X.X....XX..XX.........................................'

NOP_ENCODING
    ALL = 0;






 CLASS "FFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [-] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FFMAfmai_pipe =  0b010110011;
        FFMAfxu_pipe =  0b010110011;
        FFMA =  0b010110011;

    ENCODING
      Opcode9 = Opcode;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_FFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           $( RegisterFAU:Rd /optCC(noCC):writeCC )$
           ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
           ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg
           ',' $( [-] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
           ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FFMAfmai_pipe =  0b0011001_1;
        FFMAfxu_pipe =  0b0011001_1;
        FFMA =  0b0011001_1;

    ENCODING
      Opcode7b1 = Opcode;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_FFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-] C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' $( [-] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FFMAfmai_pipe =  0b010010011;
        FFMAfxu_pipe =  0b010010011;
        FFMA =  0b010010011;

    ENCODING
      Opcode9 = Opcode;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);
      WriteCC = writeCC;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const1_FFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
',' [-] C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FFMAfmai_pipe =  0b010100011;
        FFMAfxu_pipe =  0b010100011;
        FFMA =  0b010100011;

    ENCODING
      Opcode9 = Opcode;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = srcConst@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FFMA32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):fImm
             ',' $( [-] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
           Rd == Rc :
             "Output register must be the same as last input register"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(fImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


   OPCODES
        FFMA32Ifmai_pipe =  0b000011;
        FFMA32Ifxu_pipe =  0b000011;
        FFMA32I =  0b000011;

   ENCODING
      Opcode6 = Opcode;
      nC2 = Rc@negate;
      nAB2 = Ra@negate;
      SatHigh = SAT;
      FMZHigh = FMZ;
      WriteCCI = writeCC;
      Imm32 = fImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = IDENTICAL(Rd,Rc);


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 ALTERNATE CLASS "FFMA32I_2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):fImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;



    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(fImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rd));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FFMA32Ifmai_pipe =  0b000011;
        FFMA32Ifxu_pipe =  0b000011;
        FFMA32I =  0b000011;

    ENCODING
      Opcode6 = Opcode;
      nC2 = 0;
      nAB2 = Ra@negate;
      SatHigh = SAT;
      FMZHigh = FMZ;
      WriteCCI = writeCC;
      Imm32 = fImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd
            /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FADDfmai_pipe =  0b0101110001011;
        FADDfxu_pipe =  0b0101110001011;
        FADD =  0b0101110001011;

    ENCODING
      Opcode13 = Opcode;
      Sat = SAT;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      FTZ = FTZ;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !ScaleLow;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_b;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_FADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd
             /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FADDfmai_pipe =  0b0011100_01011;
        FADDfxu_pipe =  0b0011100_01011;
        FADD =  0b0011100_01011;

    ENCODING
      Opcode7b5 = Opcode;
      Sat = SAT;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      FTZ = FTZ;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !ScaleLow;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;




 CLASS "Const_FADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd
             /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FADDfmai_pipe =  0b0100110001011;
        FADDfxu_pipe =  0b0100110001011;
        FADD =  0b0100110001011;

    ENCODING
      Opcode13 = Opcode;
      Sat = SAT;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      FTZ = FTZ;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !ScaleLow;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FADD32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):fImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(fImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FADD32Ifmai_pipe =  0b000010;
        FADD32Ifxu_pipe =  0b000010;
        FADD32I =  0b000010;

    ENCODING
      Opcode6 = Opcode;
      nC2 = UnaryAbs;
      nAB2 = Ra@negate;
      FTZ3 = FTZ;
      aA3 = Ra@absolute;
      nB3 = UnaryNeg;
      WriteCCI = writeCC;
      Imm32 = fImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FCMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FCMPfxu_pipe =  0b010110111010;
        FCMP =  0b010110111010;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_FCMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):uImm
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
           ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FCMPfxu_pipe =  0b0011011_1010;
        FCMP =  0b0011011_1010;

    ENCODING
      Opcode7b4= Opcode;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_FCMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FCMPfxu_pipe =  0b010010111010;
        FCMP =  0b010010111010;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const1_FCMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS


        ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        FCMPfxu_pipe =  0b010100111010;
        FCMP =  0b010100111010;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FSWZADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /NDV(noNDV):ndv
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' PNWord:uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSWZADDfxu_pipe =  0b0101000011111;
        FSWZADD =  0b0101000011111;

    ENCODING
      Opcode13 = Opcode;
      WriteCC = writeCC;
      FTZ = FTZ;
      RndLow = Round1;
      NDV2 = NDV;
      PNWord = PNWord;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Dest = Rd;

      !NencFSWZADD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_b;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
             /Round1(RN):rnd /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (scale != `Scale@INVALIDSCALE37):
                "Invalid Scale (scale) field value INVALIDSCALE37"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FMULfmai_pipe =  0b0101110001101;
        FMULfxu_pipe =  0b0101110001101;
        FMUL =  0b0101110001101;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;

      FMZLow = FMZ;
      ScaleLow = Scale;
      RndLow = Round1;
      Sat = SAT;
      nAB = PSignFFMA(Ra@negate,Rb@negate);

      !BFiller;
      !NencFMUL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_FMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
             /Round1(RN):rnd /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (scale != `Scale@INVALIDSCALE37):
                "Invalid Scale (scale) field value INVALIDSCALE37"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FMULfmai_pipe =  0b0011100_01101;
        FMULfxu_pipe =  0b0011100_01101;
        FMUL =  0b0011100_01101;

    ENCODING
      Opcode7b5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      FMZLow = FMZ;
      ScaleLow = Scale;
      RndLow = Round1;
      Sat = SAT;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);
      !NencFMUL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_FMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-] C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (scale != `Scale@INVALIDSCALE37):
                "Invalid Scale (scale) field value INVALIDSCALE37"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FMULfmai_pipe =  0b0100110001101;
        FMULfxu_pipe =  0b0100110001101;
        FMUL =  0b0100110001101;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      FMZLow = FMZ;
      ScaleLow = Scale;
      RndLow = Round1;
      Sat = SAT;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);
      !NencFMUL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FMUL32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):fImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(fImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FMUL32Ifmai_pipe =  0b00011110;
        FMUL32Ifxu_pipe =  0b00011110;
        FMUL32I =  0b00011110;

    ENCODING
      Opcode8 = Opcode;
      SatHigh = SAT;
      FMZHigh = FMZ;
      WriteCCI = writeCC;
      Imm32 = fImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FMNMXfxu_pipe =  0b0101110001100;
        FMNMX =  0b0101110001100;

    ENCODING
      Opcode13 = Opcode;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      FTZ = FTZ;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !BFiller;
      !Sat;
      !Xm;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_FMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz
           $( RegisterFAU:Rd /optCC(noCC):writeCC )$
           ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
           ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
           ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
           ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FMNMXfxu_pipe =  0b0011100_01100;
        FMNMX =  0b0011100_01100;

    ENCODING
      Opcode7b5 = Opcode;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      FTZ = FTZ;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !Sat;
      !Xm;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_FMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||] C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
           ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FMNMXfxu_pipe =  0b0100110001100;
        FMNMX =  0b0100110001100;

    ENCODING
      Opcode13 = Opcode;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      FTZ = FTZ;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Sat;
      !Xm;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;

CLASS "FSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETfxu_pipe =  0b01011000;
        FSET =  0b01011000;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA3 = Ra@negate;
      nB3 = Rb@negate;
      aA3 = Ra@absolute;
      aB2 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      FTZ3 = FTZ;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_FSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETfxu_pipe =  0b01011000;
        FSET =  0b01011000;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA3 = Ra@negate;
      nB3 = Rb@negate;
      aA3 = Ra@absolute;
      aB2 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      FTZ3 = FTZ;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_FSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETfxu_pipe =  0b0011000;
        FSET =  0b0011000;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA3 = Ra@negate;
      nB3 = UnaryNeg;
      aA3 = Ra@absolute;
      aB2 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      FTZ3 = FTZ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_FSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETfxu_pipe =  0b0011000;
        FSET =  0b0011000;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA3 = Ra@negate;
      nB3 = UnaryNeg;
      aA3 = Ra@absolute;
      aB2 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      FTZ3 = FTZ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_FSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

             ILLEGAL_INSTR_ENCODING_ERROR Test <= `Test@T : "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETfxu_pipe =  0b01001000;
        FSET =  0b01001000;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA3 = Ra@negate;
      nB3 = srcConst@negate;
      aA3 = Ra@absolute;
      aB2 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      FTZ3 = FTZ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_FSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR Test <= `Test@T : "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETfxu_pipe =  0b01001000;
        FSET =  0b01001000;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA3 = Ra@negate;
      nB3 = srcConst@negate;
      aA3 = Ra@absolute;
      aB2 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      FTZ3 = FTZ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "FSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETPfxu_pipe =  0b010110111011;
        FSETP =  0b010110111011;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      FTZ2 = FTZ;
      aB2 = Rb@absolute;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_FSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz
             Predicate:Pd
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETPfxu_pipe =  0b010110111011;
        FSETP =  0b010110111011;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      FTZ2 = FTZ;
      aB2 = Rb@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_FSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETPfxu_pipe =  0b0011011_1011;
        FSETP =  0b0011011_1011;

    ENCODING
      Opcode7b4 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      FTZ2 = FTZ;
      aB2 = UnaryAbs;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst=uImm;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_FSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz
             Predicate:Pd
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETPfxu_pipe =  0b0011011_1011;
        FSETP =  0b0011011_1011;

    ENCODING
      Opcode7b4 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      FTZ2 = FTZ;
      aB2 = UnaryAbs;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst=uImm;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_FSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETPfxu_pipe =  0b010010111011;
        FSETP =  0b010010111011;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      FTZ2 = FTZ;
      aB2 = srcConst@absolute;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_FSETP"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz
             Predicate:Pd
             ',' $( [-][||] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FSETPfxu_pipe =  0b010010111011;
        FSETP =  0b010010111011;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      FTZ2 = FTZ;
      aB2 = srcConst@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "IPA_1"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IDXOnly:idx /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat
             Register:Rd
             ',' A:srcAttr[Register:Ra]
             ',' Register:Rb
             ',' Register(RZ):Rc
             ',' [!]Predicate:Ps

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "Can only be used with pixel shader"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) -> (Rb == `Register@RZ):
                "Illegal instruction encoding"

        ILLEGAL_INSTR_ENCODING_ERROR
            (msi != `MSI@OFFSET) -> (Rc == `Register@RZ):
                "Illegal instruction encoding"

        ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
            (Ra != `Register@RZ) :
            "Ra cannot be RZ for IPA.IDX"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (msi != `MSI@INVALIDMSI3):
                "Invalid MSI (msi) field value INVALIDMSI3"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TRAM_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        IPAmio_pipe =  0b11100000;
        IPA =  0b11100000;

    ENCODING
      Opcode8 = Opcode;
      IPAOp = IPAOp;
      PredSrc = Ps;
      PredSrcNot = Ps@not;
      MSI = MSI;
      SatLow = SAT;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      IPAIDX = 1;
      !IPAImm10;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_IPA_1"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat
             Register:Rd
             ',' A:srcAttr[UImm(10/0)*:uImm]
             ',' Register:Rb
             ',' Register(RZ):Rc
             ',' [!]Predicate(PT):Ps

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "Can only be used with pixel shader"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) -> (Rb == `Register@RZ):
                "Illegal instruction encoding"

        ILLEGAL_INSTR_ENCODING_ERROR
            (msi != `MSI@OFFSET) -> (Rc == `Register@RZ):
                "Illegal instruction encoding"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (msi != `MSI@INVALIDMSI3):
                "Invalid MSI (msi) field value INVALIDMSI3"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TRAM_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
  VIRTUAL_QUEUE = (((sat == `SAT@SAT) || (ipaop == `IPAOp@MUL)) ? $VQ_IPA_MUL : (((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) ? $VQ_IPA_PASS : $VQ_IPA_SC));


    OPCODES
        IPAmio_pipe =  0b11100000;
        IPA =  0b11100000;

    ENCODING
      Opcode8 = Opcode;
      IPAOp = IPAOp;
      PredSrc = Ps;
      PredSrcNot = Ps@not;
      MSI = MSI;
      SatLow = SAT;
      RegA = `Register@RZ;
      RegB = Rb;
      RegC = Rc;
      IPAIDX = 0;
      IPAImm10 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 ALTERNATE CLASS "IPA_2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IDXOnly:idx /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat
             Register:Rd
             ',' A:srcAttr[Register:Ra]
             ',' [!]Predicate:Ps

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "Can only be used with pixel shader"

        ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
            (Ra != `Register@RZ) :
            "Ra cannot be RZ for IPA.IDX"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (msi != `MSI@INVALIDMSI3):
                "Invalid MSI (msi) field value INVALIDMSI3"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TRAM_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        IPAmio_pipe =  0b11100000;
        IPA =  0b11100000;

    ENCODING
      Opcode8 = Opcode;
      IPAOp = IPAOp;
      PredSrc = Ps;
      PredSrcNot = Ps@not;
      MSI = MSI;
      SatLow = SAT;
      RegA = Ra;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      IPAIDX = 1;
      !IPAImm10;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 ALTERNATE CLASS "I_IPA_2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat
             Register:Rd
             ',' A:srcAttr[UImm(10/0)*:uImm]
             ',' [!]Predicate(PT):Ps

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "Can only be used with pixel shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (msi != `MSI@INVALIDMSI3):
                "Invalid MSI (msi) field value INVALIDMSI3"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TRAM_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
  VIRTUAL_QUEUE = (((sat == `SAT@SAT) || (ipaop == `IPAOp@MUL)) ? $VQ_IPA_MUL : (((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) ? $VQ_IPA_PASS : $VQ_IPA_SC));


    OPCODES
        IPAmio_pipe =  0b11100000;
        IPA =  0b11100000;

    ENCODING
      Opcode8 = Opcode;
      IPAOp = IPAOp;
      PredSrc = Ps;
      PredSrcNot = Ps@not;
      MSI = MSI;
      SatLow = SAT;
      RegA = `Register@RZ;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      IPAIDX = 0;
      IPAImm10 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "RRO"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop
             $( Register:Rd )$
             ',' $( [-][||] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        RROfxu_pipe =  0b0101110010010;
        RRO =  0b0101110010010;

    ENCODING
      Opcode13 = Opcode;
      aB = Rb@absolute;
      nB = Rb@negate;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      !RegA;
      !Sat;
      !nAB;
      !WriteCC;
      !aA2;
      !XMode;
      !LOP;
      !nB_L;
      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_RRO"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop
             $( Register:Rd )$
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        RROfxu_pipe =  0b0011100_10010;
        RRO =  0b0011100_10010;

    ENCODING
      Opcode7b5 = Opcode;
      aB = UnaryAbs;
      nB = UnaryNeg;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      !RegA;
      !Sat;
      !nAB;
      !WriteCC;
      !aA2;
      !XMode;
      !LOP;
      !nB_L;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_RRO"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop
             $( Register:Rd )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        RROfxu_pipe =  0b0100110010010;
        RRO =  0b0100110010010;

    ENCODING
      Opcode13 = Opcode;
      aB = srcConst@absolute;
      nB = srcConst@negate;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !RegA;
      !Sat;
      !nAB;
      !WriteCC;
      !aA2;
      !XMode;
      !LOP;
      !nB_L;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "MUFU"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MufuOp:mufu /SAT(noSAT):sat
             Register:Rd
             ',' [-] [||]Register:Ra

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mufu != `MufuOp@INVALIDMUFUOPCODE9):
                "Invalid MufuOp (mufu) field value INVALIDMUFUOPCODE9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mufu != `MufuOp@INVALIDMUFUOPCODEA):
                "Invalid MufuOp (mufu) field value INVALIDMUFUOPCODEA"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mufu != `MufuOp@INVALIDMUFUOPCODEB):
                "Invalid MufuOp (mufu) field value INVALIDMUFUOPCODEB"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mufu != `MufuOp@INVALIDMUFUOPCODEC):
                "Invalid MufuOp (mufu) field value INVALIDMUFUOPCODEC"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mufu != `MufuOp@INVALIDMUFUOPCODED):
                "Invalid MufuOp (mufu) field value INVALIDMUFUOPCODED"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mufu != `MufuOp@INVALIDMUFUOPCODEE):
                "Invalid MufuOp (mufu) field value INVALIDMUFUOPCODEE"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mufu != `MufuOp@INVALIDMUFUOPCODEF):
                "Invalid MufuOp (mufu) field value INVALIDMUFUOPCODEF"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        MUFUmio_pipe =  0b0101000010000;
        MUFU =  0b0101000010000;

    ENCODING
      Opcode13= Opcode;
      Sat = SAT;
      aA2 = Ra@absolute;
      nA1 = Ra@negate;
      MufuOp = MufuOp;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      !NencMUFU;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "FCHK"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode
            Predicate:Pd
            ',' $( [-][||] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( [-][||] Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mode == `Chkmode@DIVIDE) :
                "FCHK check mode must be DIVIDE"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FCHKfxu_pipe =  0b0101110010001;
        FCHK =  0b0101110010001;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            nAB = Ra@negate;
            aA2 = Ra@absolute;
            nB2 = Rb@negate;
            ChkModeF = mode;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            RegA = Ra;
            RegB = Rb;
            !BFiller;
            !WriteCC;
            !Sat;
            !PNDest;
            !aA4;
            !nB4;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;




CLASS "Imm_FCHK"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode
            Predicate:Pd
            ',' $( [-][||] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mode == `Chkmode@DIVIDE) :
                "FCHK check mode must be DIVIDE"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FCHKfxu_pipe =  0b0011100_10001;
        FCHK =  0b0011100_10001;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            nAB = Ra@negate;
            aA2 = Ra@absolute;
            nB2 = UnaryNeg;
            ChkModeF = mode;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            RegA = Ra;
            Bconst=uImm;
            !WriteCC;
            !Sat;
            !PNDest;
            !aA4;
            !nB4;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_FCHK"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode
            Predicate:Pd
            ',' $( [-][||] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (mode == `Chkmode@DIVIDE) :
                "FCHK check mode must be DIVIDE"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        FCHKfxu_pipe =  0b0100110010001;
        FCHK =  0b0100110010001;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            nAB = Ra@negate;
            aA2 = Ra@absolute;
            nB2 = srcConst@negate;
            ChkModeF = mode;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            !WriteCC;
            !Sat;
            !PNDest;
            !aA4;
            !nB4;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "DFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rc)+((Rc)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2))) :
                "Register Rc is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 64;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DFMAfma64lite_pipe =  0b01011_011_0111;
        DFMA =  0b01011_011_0111;

    ENCODING
      Opcode12 = Opcode;
      Rnd3 = Round1;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_DFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
           $( Register:Rd /optCC(noCC):writeCC )$
           ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
           ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg
           ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rc)+((Rc)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2))) :
                "Register Rc is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 64;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DFMAfma64lite_pipe =  0b0011011_0111;
        DFMA =  0b0011011_0111;

    ENCODING
      Opcode7b4 = Opcode;
      Rnd3 = Round1;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_DFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            MISALIGNED_REG_ERROR
                IsEven(((Rc)+((Rc)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2))) :
                "Register Rc is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 64;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DFMAfma64lite_pipe =  0b01001_011_0111;
        DFMA =  0b01001_011_0111;

    ENCODING
      Opcode12 = Opcode;
      Rnd3 = Round1;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "Const1_DFMA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb {/REUSE(noreuse):reuse_src_b} )$
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 64;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DFMAfma64lite_pipe =  0b01010_011_0111;
        DFMA =  0b01010_011_0111;

    ENCODING
      Opcode12 = Opcode;
      Rnd3 = Round1;
      nC = srcConst@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "DADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DADDfma64lite_pipe =  0b01011_100_01110;
        DADD =  0b01011_100_01110;

    ENCODING
      Opcode13 = Opcode;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !BFiller;
      !Sat;
      !XMode;
      !LOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_b;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_DADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;



    OPCODES
        DADDfma64lite_pipe =  0b0011100_01110;
        DADD =  0b0011100_01110;

    ENCODING
      Opcode7b5 = Opcode;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      !Sat;
      !XMode;
      !LOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_DADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-][||] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DADDfma64lite_pipe =  0b01001_100_01110;
        DADD =  0b01001_100_01110;

    ENCODING
      Opcode13 = Opcode;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      !Sat;
      !XMode;
      !LOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "DMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DMULfma64lite_pipe =  0b01011_100_10000;
        DMUL =  0b01011_100_10000;

    ENCODING
      Opcode13 = Opcode;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !BFiller;
      !Sat;
      !Bop;
      !aB;
      !XMode;
      !LOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_DMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DMULfma64lite_pipe =  0b0011100_10000;
        DMUL =  0b0011100_10000;

    ENCODING
      Opcode7b5 = Opcode;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);
      WriteCC = writeCC;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      !Sat;
      !Bop;
      !aB;
      !XMode;
      !LOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_DMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd
             $( Register:Rd /optCC(noCC):writeCC )$
',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$ ',' [-] C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE;


    OPCODES
        DMULfma64lite_pipe =  0b01001_100_10000;
        DMUL =  0b01001_100_10000;

    ENCODING
      Opcode13 = Opcode;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);
      WriteCC = writeCC;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      !Sat;
      !Bop;
      !aB;
      !XMode;
      !LOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "DMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DMNMXmio_pipe =  0b0101110001010;
        DMNMX =  0b0101110001010;

    ENCODING
      Opcode13 = Opcode;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !BFiller;
      !Sat;
      !XMode;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Imm_DMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DMNMXmio_pipe =  0b0011100_01010;
        DMNMX =  0b0011100_01010;

    ENCODING
      Opcode7b5 = Opcode;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      !Sat;
      !XMode;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const_DMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DMNMXmio_pipe =  0b0100110001010;
        DMNMX =  0b0100110001010;

    ENCODING
      Opcode13 = Opcode;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      !Sat;
      !XMode;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "DSET"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt
            Register:Rd /optCC(noCC):writeCC
            ',' [-][||]Register:Ra
            ',' [-][||]Register:Rb
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETmio_pipe =  0b010110010;
        DSET =  0b010110010;

    ENCODING
      Opcode9 = Opcode;
      aA3 = Ra@absolute;
      nB3 = Rb@negate;
      BVal1 = bval;
      FComp = fcomp;
      WriteCC = writeCC;
      Bop = bopopt;
      aB2 = Rb@absolute;
      nA3 = Ra@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Dest = Rd;


      !BFiller;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



ALTERNATE CLASS "NoBop_DSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp
            Register:Rd /optCC(noCC):writeCC
            ',' [-][||]Register:Ra
            ',' [-][||]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETmio_pipe =  0b010110010;
        DSET =  0b010110010;

    ENCODING
      Opcode9 = Opcode;
      Bop = `Bop@AND;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = Rb@negate;
      BVal1 = bval;
      aB2 = Rb@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;

      !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_DSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt
            Register:Rd /optCC(noCC):writeCC
            ',' [-][||]Register:Ra
            ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETmio_pipe =  0b0011001_0;
        DSET =  0b0011001_0;

    ENCODING
      Opcode7b1 = Opcode;
      Bop = bopopt;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = UnaryNeg;
      BVal1 = bval;
      aB2 = UnaryAbs;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




ALTERNATE CLASS "NoBop_Imm_DSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp
            Register:Rd /optCC(noCC):writeCC
            ',' [-][||]Register:Ra
            ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETmio_pipe =  0b0011001_0;
        DSET =  0b0011001_0;

    ENCODING
      Opcode7b1 = Opcode;
      Bop = `Bop@AND;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = UnaryNeg;
      BVal1 = bval;
      aB2 = UnaryAbs;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_DSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt
            Register:Rd /optCC(noCC):writeCC
            ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETmio_pipe =  0b010010010;
        DSET =  0b010010010;

    ENCODING
      Opcode9 = Opcode;
      Bop = bopopt;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = srcConst@negate;
      BVal1 = bval;
      aB2 = srcConst@absolute;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_DSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp
            Register:Rd /optCC(noCC):writeCC
            ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETmio_pipe =  0b010010010;
        DSET =  0b010010010;

    ENCODING
      Opcode9 = Opcode;
      Bop = `Bop@AND;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = srcConst@negate;
      BVal1 = bval;
      aB2 = srcConst@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "DSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt
              Predicate:Pd ',' Predicate:nPd
             ',' [-][||]Register:Ra
             ',' [-][||]Register:Rb
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETPmio_pipe =  0b010110111000;
        DSETP =  0b010110111000;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      Bop = bopopt;
      aB2 = Rb@absolute;
      nA2 = Ra@negate;
      SrcNot = Pa@not;
      SrcPred = Pa;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      RegB = Rb;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;

      !BFiller;
      !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



ALTERNATE CLASS "NoBop_DSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp
             Predicate:Pd
             ',' [-][||]Register:Ra
             ',' [-][||]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                IsEven(((Rb)+((Rb)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETPmio_pipe =  0b010110111000;
        DSETP =  0b010110111000;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      aB2 = Rb@absolute;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      RegB = Rb;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;

      !BFiller;
      !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_DSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' [-][||]Register:Ra
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETPmio_pipe =  0b0011011_1000;
        DSETP =  0b0011011_1000;

    ENCODING
      Opcode7b4 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      aB2 = UnaryAbs;
      SrcNot = Pa@not;
      SrcPred = Pa;
      Bconst=uImm;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;

      !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_DSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp
             Predicate:Pd
             ',' [-][||]Register:Ra
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETPmio_pipe =  0b0011011_1000;
        DSETP =  0b0011011_1000;

    ENCODING
      Opcode7b4 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      aB2 = UnaryAbs;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      Bconst=uImm;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;

      !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_DSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETPmio_pipe =  0b010010111000;
        DSETP =  0b010010111000;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      aB2 = srcConst@absolute;
      SrcNot = Pa@not;
      SrcPred = Pa;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;

      !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_DSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp
             Predicate:Pd
             ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS
            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


         ILLEGAL_INSTR_ENCODING_ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        DSETPmio_pipe =  0b010010111000;
        DSETP =  0b010010111000;

    ENCODING
      Opcode12 = Opcode;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      aB2 = srcConst@absolute;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;

      !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;





 CLASS "IMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             /HILO(LO):hib /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ILLEGAL_INSTR_ENCODING_ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADmio_pipe =  0b010110100;
        IMAD =  0b010110100;

    ENCODING
      Opcode9 = Opcode;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      RegC = Rc;
      !BFiller;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Imm_IMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             /HILO(LO):hib /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ILLEGAL_INSTR_ENCODING_ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADmio_pipe =  0b0011010_0;
        IMAD =  0b0011010_0;

    ENCODING
      Opcode7b1 = Opcode;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,UnaryNeg,Rc@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const_IMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             /HILO(LO):hib /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ILLEGAL_INSTR_ENCODING_ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADmio_pipe =  0b010010100;
        IMAD =  0b010010100;

    ENCODING
      Opcode9 = Opcode;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,srcConst@negate,Rc@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const1_IMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             /HILO(LO):hib /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ILLEGAL_INSTR_ENCODING_ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ILLEGAL_INSTR_ENCODING_ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADmio_pipe =  0b010100100;
        IMAD =  0b010100100;

    ENCODING
      Opcode9 = Opcode;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,Rb@negate,srcConst@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "IMAD32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SImm(32):sImm
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
            Rd == Rc :
             "Destination register must be the same as input register 3"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"




    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMAD32Imio_pipe =  0b000100;
        IMAD32I =  0b000100;

    ENCODING
      Opcode6 = Opcode;
      BSigned4 = IsSigned(us32b);
      PSign2 = PSign(PO,Ra@negate,Rc@negate);
      ASigned2 = IsSigned(us32);
      WriteCCI = writeCC;
      Imm32 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = IDENTICAL(Rd,Rc);
      RegA = Ra;
      HILO2 = HILO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "IMADSP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:spa /IntegerSPB:spb /IntegerSPC:spc
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

        ILLEGAL_INSTR_ENCODING_ERROR
                !((IsSPASigned(spa) || IsSPBSigned(spb)) && !IsSPCSigned(spc)):
                "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

                ILLEGAL_INSTR_ENCODING_ERROR
                !(!IsSPASigned(spa) && !IsSPBSigned(spb) && IsSPCSigned(spc)):
                "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADSPmio_pipe =  0b010110101;
        IMADSP =  0b010110101;

    ENCODING
      Opcode9 = Opcode;
      SABCExt =* GetSPExtract(spc, spa, spb);
      WriteCC = writeCC;
      RegC = Rc;
      !BFiller;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Imm_IMADSP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:spa /IntegerSPB:spb /IntegerSPC:spc
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' SImm(20):uImm
             ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

        ILLEGAL_INSTR_ENCODING_ERROR
                !((IsSPASigned(spa) || IsSPBSigned(spb)) && !IsSPCSigned(spc)):
                "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

                ILLEGAL_INSTR_ENCODING_ERROR
                !(!IsSPASigned(spa) && !IsSPBSigned(spb) && IsSPCSigned(spc)):
                "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADSPmio_pipe =  0b0011010_1;
        IMADSP =  0b0011010_1;

    ENCODING
      Opcode7b1 = Opcode;
      SABCExt =* GetSPExtract(spc, spa, spb);
      WriteCC = writeCC;
      RegC = Rc;
      Bconst=uImm ;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const_IMADSP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:spa /IntegerSPB:spb /IntegerSPC:spc
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

        ILLEGAL_INSTR_ENCODING_ERROR
                !((IsSPASigned(spa) || IsSPBSigned(spb)) && !IsSPCSigned(spc)):
                "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

                ILLEGAL_INSTR_ENCODING_ERROR
                !(!IsSPASigned(spa) && !IsSPBSigned(spb) && IsSPCSigned(spc)):
                "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADSPmio_pipe =  0b010010101;
        IMADSP =  0b010010101;

    ENCODING
      Opcode9 = Opcode;
      SABCExt =* GetSPExtract(spc, spa, spb);
      WriteCC = writeCC;
      RegC = Rc;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const1_IMADSP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:spa /IntegerSPB:spb /IntegerSPC:spc
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


        ILLEGAL_INSTR_ENCODING_ERROR
                !((IsSPASigned(spa) || IsSPBSigned(spb)) && !IsSPCSigned(spc)):
                "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

                ILLEGAL_INSTR_ENCODING_ERROR
                !(!IsSPASigned(spa) && !IsSPBSigned(spb) && IsSPCSigned(spc)):
                "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."


    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMADSPmio_pipe =  0b010100101;
        IMADSP =  0b010100101;

    ENCODING
      Opcode9 = Opcode;
      SABCExt =* GetSPExtract(spc, spa, spb);
      WriteCC = writeCC;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "IMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra
             ',' RegisterFAU:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMULmio_pipe =  0b0101110000111;
        IMUL =  0b0101110000111;

    ENCODING
      Opcode13 = Opcode;
      WriteCC = writeCC;
      BSigned = IsSigned(us32b);
      ASigned = IsSigned(us32);
      HILO = HILO;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !BFiller;
      !NencIMUL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Imm_IMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra
             ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMULmio_pipe =  0b0011100_00111;
        IMUL =  0b0011100_00111;

    ENCODING
      Opcode7b5 = Opcode;
      WriteCC = writeCC;
      BSigned = IsSigned(us32b);
      ASigned = IsSigned(us32);
      HILO = HILO;
      Bconst=uImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !NencIMUL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const_IMUL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMULmio_pipe =  0b0100110000111;
        IMUL =  0b0100110000111;

    ENCODING
      Opcode13 = Opcode;
      WriteCC = writeCC;
      BSigned = IsSigned(us32b);
      ASigned = IsSigned(us32);
      HILO = HILO;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !NencIMUL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "IMUL32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra
             ',' SImm(32):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        IMUL32Imio_pipe =  0b00011111;
        IMUL32I =  0b00011111;

    ENCODING
      Opcode8 = Opcode;
      BSigned2 = IsSigned(us32b);
      ASigned2 = IsSigned(us32);
      HILO2 = HILO;
      WriteCCI = writeCC;
      Imm32 = sImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "IADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
            ) ) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (X -> (!Ra@negate || !Rb@negate)) :
             ".X cannot be used with '-' on both of the inputs"

         ILLEGAL_INSTR_ENCODING_ERROR
             (!Ra@negate || !Rb@negate) :
             "Ra and Rb  cannot both be negated"


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        IADDfmai_pipe =  0b0101110000010;
        IADDfxu_pipe =  0b0101110000010;
        IADD =  0b0101110000010;

    ENCODING
      Opcode13 = Opcode;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,Rb@negate);
      WriteCC = writeCC;
      Xm = xmode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !BFiller;
      !NencIADD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_IADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate && !jneg) ) :
             ".PO cannot be used with '-' on either input"

         ILLEGAL_INSTR_ENCODING_ERROR
             (!Ra@negate || !jneg ) :
             "Ra and Sb cannot both be negated"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        IADDfmai_pipe =  0b0011100_00010;
        IADDfxu_pipe =  0b0011100_00010;
        IADD =  0b0011100_00010;

    ENCODING
      Opcode7b5 = Opcode;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,UnaryNeg);
      WriteCC = writeCC;
      Xm = xmode;
      Bconst=uImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !NencIADD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_IADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
        ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate && !srcConst@negate ) ) :
             ".PO cannot be used with '-' on either input"
        ILLEGAL_INSTR_ENCODING_ERROR
           (X -> (!Ra@negate || !srcConst@negate)) :
             ".X cannot be used with '-' on both of the inputs"

         ILLEGAL_INSTR_ENCODING_ERROR
             (!Ra@negate || !srcConst@negate) :
             "Ra and Sb cannot both be negated"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        IADDfmai_pipe =  0b0100110000010;
        IADDfxu_pipe =  0b0100110000010;
        IADD =  0b0100110000010;


    ENCODING
      Opcode13 = Opcode;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,srcConst@negate);
      WriteCC = writeCC;
      Xm = xmode;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !NencIADD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "IADD3"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DIR(NS):dir /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra/Partsel("32"):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] RegisterFAU:Rb/Partsel("32"):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [-] RegisterFAU:Rc/Partsel("32"):csel {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (!(Ra@negate && Rb@negate)):
                "Ra and Rb cannot both be negated"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        IADD3fmai_pipe =  0b010111001100;
        IADD3fxu_pipe =  0b010111001100;
        IADD3 =  0b010111001100;

    ENCODING
      Opcode12 = Opcode;
      nA7 = Ra@negate;
      nB7 = Rb@negate;
      nC7 = Rc@negate;
      Xm9 = xmode;
      WriteCC = writeCC;
      RegC = Rc;
      LRS = dir;
      Apart = asel;
      Bpart = bsel;
      Cpart = csel;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !NencIADD3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "BImm_IADD3"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(20):uImm20 /UnaryNeg(noNEG):jneg
             ',' $( [-] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (!(Ra@negate && jneg)):
                "Ra and Sb (imm) cannot both be negated"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm20));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        IADD3fmai_pipe =  0b0011100_1100;
        IADD3fxu_pipe =  0b0011100_1100;
        IADD3 =  0b0011100_1100;

    ENCODING
      Opcode7b4 = Opcode;
      nA7 = Ra@negate;
      nB7 = jneg;
      nC7 = Rc@negate;
      Xm9 = xmode;
      WriteCC = writeCC;
      RegC = Rc;
      Bconst = uImm20;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "BConst_IADD3"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' $( [-] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (!(Ra@negate && srcConst@negate)):
                "Ra and Sb (const) cannot both be negated"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        IADD3fmai_pipe =  0b010011001100;
        IADD3fxu_pipe =  0b010011001100;
        IADD3 =  0b010011001100;

    ENCODING
      Opcode12 = Opcode;
      nA7 = Ra@negate;
      nB7 = srcConst@negate;
      nC7 = Rc@negate;
      Xm9 = xmode;
      WriteCC = writeCC;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "IADD32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [-] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(32):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> !Ra@negate) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        IADD32Ifmai_pipe =  0b0001110;
        IADD32Ifxu_pipe =  0b0001110;
        IADD32I =  0b0001110;

    ENCODING
      Opcode7 = Opcode;
      PSign2 = PSign32(PO,Ra@negate);
      Sat2 = SAT;
      Xm2 = xmode;
      WriteCCI = writeCC;
      Imm32 = sImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "ISCADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' UImm(5):shift

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        ISCADDfxu_pipe =  0b0101110000011;
        ISCADD =  0b0101110000011;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign = PSign(PO,Ra@negate,Rb@negate);
      !BFiller;
      !NencISCADD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_ISCADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg
             ',' UImm(5):shift

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        ISCADDfxu_pipe =  0b0011100_00011;
        ISCADD =  0b0011100_00011;

    ENCODING
      Opcode7b5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign = PSign(PO,Ra@negate,UnaryNeg);
      !NencISCADD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_ISCADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' UImm(5):shift

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS


            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        ISCADDfxu_pipe =  0b0100110000011;
        ISCADD =  0b0100110000011;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Imm5I = shift;
      PSign = PSign(PO,Ra@negate,srcConst@negate);
      !NencISCADD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "ISCADD32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(32):sImm
             ',' UImm(5):shift

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        ISCADD32Ifxu_pipe =  0b000101;
        ISCADD32I =  0b000101;

    ENCODING
      Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      Imm5Ib = shift;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "IMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((xmode==`XMode@XMED)||(xmode==`XMode@XLO));


    OPCODES
        IMNMXfxu_pipe =  0b0101110000100;
        IMNMX =  0b0101110000100;

    ENCODING
      Opcode13 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !BFiller;
      !Sat;
      !aB;
      !nB;
      !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_IMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((xmode==`XMode@XMED)||(xmode==`XMode@XLO));


    OPCODES
        IMNMXfxu_pipe =  0b0011100_00100;
        IMNMX =  0b0011100_00100;

    ENCODING
      Opcode7b5 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Sat;
      !aB;
      !nB;
      !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_IMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((xmode==`XMode@XMED)||(xmode==`XMode@XLO));


    OPCODES
        IMNMXfxu_pipe =  0b0100110000100;
        IMNMX =  0b0100110000100;

    ENCODING
      Opcode13 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Sat;
      !aB;
      !nB;
      !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "BFE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        BFEfxu_pipe =  0b0101110000000;
        BFE =  0b0101110000000;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      !BFiller;
      !NencBFE;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_BFE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        BFEfxu_pipe =  0b0011100_00000;
        BFE =  0b0011100_00000;

    ENCODING
      Opcode7b5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      !NencBFE;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_BFE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        BFEfxu_pipe =  0b0100110000000;
        BFE =  0b0100110000000;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      !NencBFE;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "BFI"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
              $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        BFIfxu_pipe =  0b0101101111110;
        BFI =  0b0101101111110;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      !BFiller;
      !NencBFI;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_BFI"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        BFIfxu_pipe =  0b0011011_11110;
        BFI =  0b0011011_11110;

    ENCODING
      Opcode7b5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      !NencBFI;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_BFI"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        BFIfxu_pipe =  0b0100101111110;
        BFI =  0b0100101111110;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      !NencBFI;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const1_BFI"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        BFIfxu_pipe =  0b0101001111110;
        BFI =  0b0101001111110;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      !NencBFI;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "SHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (xmode != `XXHI@INVALIDSHRXMODE1):
                "Invalid XXHI (xmode) field value INVALIDSHRXMODE1"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `XXHI@X)||(xmode == `XXHI@XHI)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X or .XHI option is used in SHR"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((xmode==`XXHI@X)||(xmode==`XXHI@XHI));


    OPCODES
        SHRfxu_pipe =  0b0101110000101;
        SHR =  0b0101110000101;

    ENCODING
      Opcode13 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XXHI;
      Brev = BREV;
      M = CWMode;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !BFiller;
      !NencSHR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_SHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (xmode != `XXHI@INVALIDSHRXMODE1):
                "Invalid XXHI (xmode) field value INVALIDSHRXMODE1"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `XXHI@X)||(xmode == `XXHI@XHI)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X or .XHI option is used in SHR"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((xmode==`XXHI@X)||(xmode==`XXHI@XHI));


    OPCODES
        SHRfxu_pipe =  0b0011100_00101;
        SHR =  0b0011100_00101;

    ENCODING
      Opcode7b5 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XXHI;
      Brev = BREV;
      M = CWMode;
      Bconst=uImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !NencSHR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_SHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (xmode != `XXHI@INVALIDSHRXMODE1):
                "Invalid XXHI (xmode) field value INVALIDSHRXMODE1"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `XXHI@X)||(xmode == `XXHI@XHI)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X or .XHI option is used in SHR"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((xmode==`XXHI@X)||(xmode==`XXHI@XHI));


    OPCODES
        SHRfxu_pipe =  0b0100110000101;
        SHR =  0b0100110000101;

    ENCODING
      Opcode13 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XXHI;
      Brev = BREV;
      M = CWMode;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !NencSHR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "SHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `X@X)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X option is used in SHL"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        SHLfxu_pipe =  0b0101110001001;
        SHL =  0b0101110001001;

    ENCODING
      Opcode13= Opcode;
      WriteCC = writeCC;
      Xm = X;
      M = CWMode;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !BFiller;
      !NencSHL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_SHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `X@X)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X option is used in SHL"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        SHLfxu_pipe =  0b0011100_01001;
        SHL =  0b0011100_01001;

    ENCODING
      Opcode7b5 = Opcode;
      WriteCC = writeCC;
      Xm = X;
      M = CWMode;
      RegA = Ra;
      Bconst=uImm;
      PredNot = Pg@not;
      Pred = Pg;
      Dest = Rd;
      !NencSHL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_SHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `X@X)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X option is used in SHL"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        SHLfxu_pipe =  0b0100110001001;
        SHL =  0b0100110001001;

    ENCODING
      Opcode13 = Opcode;
      WriteCC = writeCC;
      Xm = X;
      M = CWMode;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;
      !NencSHL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "SHF_L_imm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_L:shfl /CWMode(C):wmode
            /maxShift("32"):maxshift /SHFXMode(NONE):xmode
            $( Register:Rd /optCC(noCC):writeCC )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' UImm(32):uImm
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR (xmode != `SHFXMode@HI) && (xmode != `SHFXMode@XHI) :
                "Illegal instruction encoding: .HI and .XHI are only allowed with .dir = .R  "

                ILLEGAL_INSTR_ENCODING_ERROR (maxshift != `maxShift@S64) :
                "Illegal instruction encoding: .S64 can only be specified with .dir = .R  "
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (maxshift != `maxShift@INVALIDMAXSHIFT3):
                "Invalid maxShift (maxshift) field value INVALIDMAXSHIFT3"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `SHFXMode@X)||(xmode == `SHFXMode@XHI)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X or .XHI option is used in SHF.L"



    PROPERTIES SECONDARY;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 8;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = ((xmode==`SHFXMode@X)||(xmode==`SHFXMode@XHI));


    OPCODES
        SHFfxu_pipe =  0b0011011_11111;
        SHF =  0b0011011_11111;

    ENCODING
            Opcode7b5 = Opcode;
            M_H = CWMode;
            XmdSHF = xmode;
            WriteCC = writeCC;
            RegC = Rc;
            MaxShift = maxshift;
            Imm06_shf = uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            !NencSHF;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "SHF_R_imm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_R:shfr /CWMode(C):wmode
            /maxShift("32"):maxshift /SHFXMode(NONE):xmode
            $( Register:Rd /optCC(noCC):writeCC )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' UImm(32):uImm
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (maxshift != `maxShift@INVALIDMAXSHIFT3):
                "Invalid maxShift (maxshift) field value INVALIDMAXSHIFT3"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `SHFXMode@X)||(xmode == `SHFXMode@XHI)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X or .XHI option is used in SHF.L"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = ((xmode==`SHFXMode@X)||(xmode==`SHFXMode@XHI));


    OPCODES
        SHFfxu_pipe =  0b0011100_11111;
        SHF =  0b0011100_11111;

    ENCODING
            Opcode7b5 = Opcode;
            M_H = CWMode;
            XmdSHF = xmode;
            WriteCC = writeCC;
            RegC = Rc;
            MaxShift = maxshift;
            Imm06_shf = uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            !NencSHF;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "SHF_L_reg"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_L:shfl /CWMode(C):wmode
            /maxShift("32"):maxshift /SHFXMode(NONE):xmode
            $( Register:Rd /optCC(noCC):writeCC )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR (xmode != `SHFXMode@HI) && (xmode != `SHFXMode@XHI) :
                "Illegal instruction encoding: .HI and .XHI are only allowed with .dir = .R  "

                ILLEGAL_INSTR_ENCODING_ERROR (maxshift != `maxShift@S64) :
                "Illegal instruction encoding: .S64 can only be specified with .dir = .R  "
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (maxshift != `maxShift@INVALIDMAXSHIFT3):
                "Invalid maxShift (maxshift) field value INVALIDMAXSHIFT3"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `SHFXMode@X)||(xmode == `SHFXMode@XHI)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X or .XHI option is used in SHF.L"



    PROPERTIES SECONDARY;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = ((xmode==`SHFXMode@X)||(xmode==`SHFXMode@XHI));


    OPCODES
        SHFfxu_pipe =  0b0101101111111;
        SHF =  0b0101101111111;

    ENCODING
            Opcode13 = Opcode;
            M_H = CWMode;
            XmdSHF = xmode;
            WriteCC = writeCC;
            RegC = Rc;
            MaxShift = maxshift;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            !NencSHF2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "SHF_R_reg"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_R:shfr /CWMode(C):wmode
            /maxShift("32"):maxshift /SHFXMode(NONE):xmode
            $( Register:Rd /optCC(noCC):writeCC )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (maxshift != `maxShift@INVALIDMAXSHIFT3):
                "Invalid maxShift (maxshift) field value INVALIDMAXSHIFT3"



            UNPREDICTABLE_BEHAVIOR_WARNING
                (((xmode == `SHFXMode@X)||(xmode == `SHFXMode@XHI)) -> (writeCC == `optCC@CC)) :
                "Unpredictable Behavior Error: .CC option must be used when .X or .XHI option is used in SHF.L"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = ((xmode==`SHFXMode@X)||(xmode==`SHFXMode@XHI));


    OPCODES
        SHFfxu_pipe =  0b0101110011111;
        SHF =  0b0101110011111;

    ENCODING
            Opcode13 = Opcode;
            M_H = CWMode;
            XmdSHF = xmode;
            WriteCC = writeCC;
            RegC = Rc;
            MaxShift = maxshift;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            !NencSHF2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "LOP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /POP(F):pop
             Predicate(PT):Pd
             ',' $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [~] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [~] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOPfmai_pipe =  0b0101110001000;
        LOPfxu_pipe =  0b0101110001000;
        LOP =  0b0101110001000;

    ENCODING
      Opcode13= Opcode;
      PredDstLop = Pd;
      POP = POP;
      Xm = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = Rb@invert;
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !BFiller;
      !NencLOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_LOP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /POP(F):pop
             Predicate(PT):Pd
             ',' $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [~] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm /UnaryInv(noINV):jinv

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOPfmai_pipe =  0b0011100_01000;
        LOPfxu_pipe =  0b0011100_01000;
        LOP =  0b0011100_01000;

    ENCODING
      Opcode7b5 = Opcode;
      PredDstLop = Pd;
      POP = POP;
      Xm = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = UnaryInv;
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !NencLOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_LOP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /POP(F):pop
             Predicate(PT):Pd
             ',' $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [~] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOPfmai_pipe =  0b0100110001000;
        LOPfxu_pipe =  0b0100110001000;
        LOP =  0b0100110001000;

    ENCODING
      Opcode13 = Opcode;
      PredDstLop = Pd;
      POP = POP;
      Xm = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = srcConst@invert;
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !NencLOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "LOP32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [~] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(32):uImm /UnaryInv(noINV):jinv

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOP32Ifmai_pipe =  0b000001;
        LOP32Ifxu_pipe =  0b000001;
        LOP32I =  0b000001;

    ENCODING
      Opcode6 = Opcode;
      Xm_I = X;
      nB_L2 = UnaryInv;
      nA_L2 = Ra@invert;
      LOP_I = LOP;
      WriteCCI = writeCC;
      Imm32 = uImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "LOP3_LUT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LUTOnly:lut /X(noX):xmode /POP(F):pop
             Predicate(PT):Pd
             ',' $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$
             ',' UImm(8):Imm8

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOP3fmai_pipe =  0b0101101111100;
        LOP3fxu_pipe =  0b0101101111100;
        LOP3 =  0b0101101111100;

    ENCODING
      Opcode13= Opcode;
      PredDstLop = Pd;
      WriteCC = writeCC;
      RegC = Rc;
      POP2 = pop;
      Xm5 = xmode;
      LOPImm = Imm8;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "LOP3_LUT_BImm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LUTOnly:lut /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$
             ',' UImm(8):Imm8

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"




    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOP3fmai_pipe =  0b001111;
        LOP3fxu_pipe =  0b001111;
        LOP3 =  0b001111;

    ENCODING
      Opcode6= Opcode;
      WriteCC = writeCC;
      RegC = Rc;
      Xm6 = xmode;
      LOPImm2 = Imm8;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst = uImm;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "LOP3_LUT_BConst"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LUTOnly:lut /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$
             ',' UImm(8):Imm8

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOP3fmai_pipe =  0b0000001;
        LOP3fxu_pipe =  0b0000001;
        LOP3 =  0b0000001;

    ENCODING
      Opcode7= Opcode;
      WriteCC = writeCC;
      RegC = Rc;
      Xm10 = xmode;
      LOPImm2 = Imm8;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




ALTERNATE CLASS "LOP3"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /POP(F):pop
             Predicate(PT):Pd
             ',' $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [~] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [~] RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [~] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOP3fmai_pipe =  0b0101101111100;
        LOP3fxu_pipe =  0b0101101111100;
        LOP3 =  0b0101101111100;

    ENCODING
      Opcode13= Opcode;
      PredDstLop = Pd;
      WriteCC = writeCC;
      RegC = Rc;
      POP2 = pop;
      Xm5 = xmode;
      LOPImm = LutImm8(lop,Ra@invert,Rb@invert,Rc@invert);
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




ALTERNATE CLASS "LOP3_BImm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [~] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(20):uImm /UnaryInv(noINV):jinv
             ',' $( [~] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOP3fmai_pipe =  0b001111;
        LOP3fxu_pipe =  0b001111;
        LOP3 =  0b001111;

    ENCODING
      Opcode6= Opcode;
      WriteCC = writeCC;
      RegC = Rc;
      Xm6 = xmode;
      LOPImm2 = LutImm8(lop,Ra@invert,jinv,Rc@invert);
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst = uImm;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




ALTERNATE CLASS "LOP3_Bconst"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( [~] RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' $( [~] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        LOP3fmai_pipe =  0b0000001;
        LOP3fxu_pipe =  0b0000001;
        LOP3 =  0b0000001;

    ENCODING
      Opcode7= Opcode;
      WriteCC = writeCC;
      RegC = Rc;
      Xm10 = xmode;
      LOPImm2 = LutImm8(lop,Ra@invert,srcConst@invert,Rc@invert);
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "FLO"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        FLOmio_pipe =  0b0101110000110;
        FLO =  0b0101110000110;

    ENCODING
      Opcode13 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      SH = SH;
      nB_L = Rb@invert;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      !BFiller;
      !RegA;
      !NencFLO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Imm_FLO"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryInv(noINV):jinv

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        FLOmio_pipe =  0b0011100_00110;
        FLO =  0b0011100_00110;

    ENCODING
      Opcode7b5 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      SH = SH;
      nB_L = UnaryInv;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      !RegA;
      !NencFLO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const_FLO"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh
             Register:Rd /optCC(noCC):writeCC
',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        FLOmio_pipe =  0b0100110000110;
        FLO =  0b0100110000110;

    ENCODING
      Opcode13 = Opcode;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      SH = SH;
      nB_L = srcConst@invert;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !RegA;
      !NencFLO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "ISET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32
            /X(noX):xmode /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010110110101;
        ISET =  0b010110110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
            RegB = Rb;
            IComp = ICmpAll;
            SrcPred = Pa;
            SrcNot = Pa@not;
            BVal = BVal;
            Bop = bopopt;
            Xm = X;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_ISET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp
            /Integer32(S32):us32 /X(noX):xmode
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010110110101;
        ISET =  0b010110110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
            RegB = Rb;
            IComp = ICmpAll;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            BVal = BVal;
            Bop = `Bop@AND;
            Xm = X;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_ISET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32
            /X(noX):xmode /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b0011011_0101;
        ISET =  0b0011011_0101;

    ENCODING
            Opcode7b4 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
            Bconst=uImm;
            IComp = ICmpAll;
            SrcPred = Pa;
            SrcNot = Pa@not;
            BVal = BVal;
            Bop = bopopt;
            Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_ISET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32
            /X(noX):xmode
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b0011011_0101;
        ISET =  0b0011011_0101;

    ENCODING
            Opcode7b4 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
            Bconst=uImm;
            IComp = ICmpAll;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            BVal = BVal;
            Bop = `Bop@AND;
            Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_ISET"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32
            /X(noX):xmode /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010010110101;
        ISET =  0b010010110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            IComp = ICmpAll;
            SrcPred = Pa;
            SrcNot = Pa@not;
            BVal = BVal;
            Bop = bopopt;
            Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_ISET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32
            /X(noX):xmode
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010010110101;
        ISET =  0b010010110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            IComp = ICmpAll;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            BVal = BVal;
            Bop = `Bop@AND;
            Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "ISET_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(S32):us32
            /X(noX):xmode /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010110110101;
        ISET =  0b010110110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
            RegB = Rb;
            IComp = ICmpU;
            SrcPred = Pa;
            SrcNot = Pa@not;
            BVal = BVal;
            Bop = bopopt;
            Xm = X;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_ISET_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp
            /Integer32(S32):us32 /X(noX):xmode
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010110110101;
        ISET =  0b010110110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
            RegB = Rb;
            IComp = ICmpU;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            BVal = BVal;
            Bop = `Bop@AND;
            Xm = X;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Imm_ISET_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(S32):us32
            /X(noX):xmode /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b0011011_0101;
        ISET =  0b0011011_0101;

    ENCODING
            Opcode7b4 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
            Bconst=uImm;
            IComp = ICmpU;
            SrcPred = Pa;
            SrcNot = Pa@not;
            BVal = BVal;
            Bop = bopopt;
            Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_ISET_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(S32):us32
            /X(noX):xmode
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b0011011_0101;
        ISET =  0b0011011_0101;

    ENCODING
      Opcode7b4 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Const_ISET_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(S32):us32
            /X(noX):xmode /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010010110101;
        ISET =  0b010010110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            IComp = ICmpU;
            SrcPred = Pa;
            SrcNot = Pa@not;
            BVal = BVal;
            Bop = bopopt;
            Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_ISET_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(S32):us32
            /X(noX):xmode
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETfxu_pipe =  0b010010110101;
        ISET =  0b010010110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Signed = IsSigned(Integer32);
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            IComp = ICmpU;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            BVal = BVal;
            Bop = `Bop@AND;
            Xm = X;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "ISETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
            /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
            Predicate:Pd ',' Predicate:nPd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010110110110;
        ISETP =  0b010110110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            Bop = bopopt;
            Xm = X;
            SrcPred = Pa;
            SrcNot = Pa@not;
            RegA = Ra;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            !NencISETP;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_ISETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
            /Integer32(S32):us32 /X(noX):xmode
            Predicate:Pd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010110110110;
        ISETP =  0b010110110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            Bop = `Bop@AND;
            Xm = X;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            RegA = Ra;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            !NencISETP;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_ISETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
            /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
            Predicate:Pd ',' Predicate:nPd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b0011011_0110;
        ISETP =  0b0011011_0110;

    ENCODING
            Opcode7b4 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            Bop = bopopt;
            Xm = X;
            SrcPred = Pa;
            SrcNot = Pa@not;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_ISETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
            /Integer32(S32):us32 /X(noX):xmode
            Predicate:Pd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b0011011_0110;
        ISETP =  0b0011011_0110;

    ENCODING
            Opcode7b4 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            Bop = `Bop@AND;
            Xm = X;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_ISETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
            /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
            Predicate:Pd ',' Predicate:nPd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010010110110;
        ISETP =  0b010010110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            Bop = bopopt;
            Xm = X;
            SrcPred = Pa;
            SrcNot = Pa@not;
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_ISETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
            /Integer32(S32):us32 /X(noX):xmode
            Predicate:Pd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010010110110;
        ISETP =  0b010010110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            Bop = `Bop@AND;
            Xm = X;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;




ALTERNATE CLASS "ISETP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
            /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
            Predicate:Pd ',' Predicate:nPd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

    ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (us32 != `Integer32@S32):
                    ".fmt cannot be S32 for unsigned only comparisons"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010110110110;
        ISETP =  0b010110110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            Bop = bopopt;
            Xm = X;
            SrcPred = Pa;
            SrcNot = Pa@not;
            RegA = Ra;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            !NencISETP;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_ISETP_U"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
            /Integer32(U32):us32 /X(noX):xmode
            Predicate:Pd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

    ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (us32 != `Integer32@S32):
                    ".fmt cannot be S32 for unsigned only comparisons"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010110110110;
        ISETP =  0b010110110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            Bop = `Bop@AND;
            Xm = X;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            RegA = Ra;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            !NencISETP;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Imm_ISETP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
            /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
            Predicate:Pd ',' Predicate:nPd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

    ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (us32 != `Integer32@S32):
                    ".fmt cannot be S32 for unsigned only comparisons"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b0011011_0110;
        ISETP =  0b0011011_0110;

    ENCODING
            Opcode7b4 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            Bop = bopopt;
            Xm = X;
            SrcPred = Pa;
            SrcNot = Pa@not;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_ISETP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
            /Integer32(U32):us32 /X(noX):xmode
            Predicate:Pd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

    ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (us32 != `Integer32@S32):
                    ".fmt cannot be S32 for unsigned only comparisons"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b0011011_0110;
        ISETP =  0b0011011_0110;

    ENCODING
            Opcode7b4 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            Bop = `Bop@AND;
            Xm = X;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Const_ISETP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
            /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
            Predicate:Pd ',' Predicate:nPd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

    ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (us32 != `Integer32@S32):
                    ".fmt cannot be S32 for unsigned only comparisons"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010010110110;
        ISETP =  0b010010110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            Bop = bopopt;
            Xm = X;
            SrcPred = Pa;
            SrcNot = Pa@not;
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_ISETP_U"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
            /Integer32(U32):us32 /X(noX):xmode
            Predicate:Pd
            ',' $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

    ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (us32 != `Integer32@S32):
                    ".fmt cannot be S32 for unsigned only comparisons"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        ISETPfxu_pipe =  0b010010110110;
        ISETP =  0b010010110110;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            Bop = `Bop@AND;
            Xm = X;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            !NencISETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "ICMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b010110110100;
        ICMP =  0b010110110100;


    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            RegC = Rc;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            RegB = Rb;
            Dest = Rd;
            !BFiller;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_ICMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b0011011_0100;
        ICMP =  0b0011011_0100;

    ENCODING
            Opcode7b4 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            RegC = Rc;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            Bconst=uImm;
            Dest = Rd;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_ICMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b010010110100;
        ICMP =  0b010010110100;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            RegC = Rc;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Dest = Rd;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const1_ICMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b010100110100;
        ICMP =  0b010100110100;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpAll;
            Signed = IsSigned(Integer32);
            RegC = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Dest = Rd;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "ICMP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b010110110100;
        ICMP =  0b010110110100;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            RegC = Rc;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            RegB = Rb;
            Dest = Rd;
            !BFiller;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Imm_ICMP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b0011011_0100;
        ICMP =  0b0011011_0100;

    ENCODING
            Opcode7b4 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            RegC = Rc;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            Bconst=uImm;
            Dest = Rd;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Const_ICMP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
            ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b010010110100;
        ICMP =  0b010010110100;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            RegC = Rc;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Dest = Rd;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Const1_ICMP_U"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(S32):us32
            $( Register:Rd )$
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        ICMPfxu_pipe =  0b010100110100;
        ICMP =  0b010100110100;

    ENCODING
            Opcode12 = Opcode;
            IComp = ICmpU;
            Signed = IsSigned(Integer32);
            RegC = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Dest = Rd;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "POPC"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd
             ',' [~]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        POPCmio_pipe =  0b0101110000001;
        POPC =  0b0101110000001;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      !RegA;
      RegB = Rb;
      !nA_L;
      nB_L = Rb@invert;
      !BFiller;
      !NencPOPC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Imm_POPC"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd
             ',' SImm(20):uImm /UnaryInv(noINV):jinv

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        POPCmio_pipe =  0b0011100_00001;
        POPC =  0b0011100_00001;

    ENCODING
      Opcode7b5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      !RegA;
      Bconst=uImm;
      !nA_L;
      nB_L = UnaryInv;
      !NencPOPC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "Const_POPC"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd
',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        POPCmio_pipe =  0b0100110000001;
        POPC =  0b0100110000001;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      !RegA;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !nA_L;
      nB_L = srcConst@invert;
      !NencPOPC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "XMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer16(U16):us16 /Integer16(U16):us16b }
             /PSL(noPSL):psl /XMADcop(C32):cop /MRG(noMRG):mrg /X(noX):xmode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        XMADfmai_pipe =  0b0101101100;
        XMADfxu_pipe =  0b0101101100;
        XMAD =  0b0101101100;

    ENCODING
      Opcode10 = Opcode;
      HILO2 = asel;
      XMADCop = cop;
      BSigned5 = IsSigned16(us16b);
      ASigned5 = IsSigned16(us16);
      WriteCC = writeCC;
      RegC = Rc;
      Xm7 = xmode;
      MRG = mrg;
      PSL = psl;
      HILO4 = bsel;
      !XMADFiller;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "ImmB_XMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer16(U16):us16 /U16(U16):us16b }
             /PSL(noPSL):psl /XMADcop(C32):cop /MRG(noMRG):mrg /X(noX):xmode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        XMADfmai_pipe =  0b0011011_00;
        XMADfxu_pipe =  0b0011011_00;
        XMAD =  0b0011011_00;

    ENCODING
      Opcode7b2 = Opcode;
      HILO2 = asel;
      XMADCop = cop;
      BSigned5 = 0;
      ASigned5 = IsSigned16(us16);
      WriteCC = writeCC;
      RegC = Rc;
      Xm7 = xmode;
      MRG = mrg;
      PSL = psl;
      !XMADImmFiller;
      Imm16 = uImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "SImmB_XMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer16:us16 /S16:us16b
             /PSL(noPSL):psl /XMADcop(C32):cop /MRG(noMRG):mrg /X(noX):xmode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        XMADfmai_pipe =  0b0011011_00;
        XMADfxu_pipe =  0b0011011_00;
        XMAD =  0b0011011_00;

    ENCODING
      Opcode7b2 = Opcode;
      HILO2 = asel;
      XMADCop = cop;
      BSigned5 = 1;
      ASigned5 = IsSigned16(us16);
      WriteCC = writeCC;
      RegC = Rc;
      Xm7 = xmode;
      MRG = mrg;
      PSL = psl;
      !XMADImmFiller;
      Imm16 = uImm;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




  CLASS "ConstB_XMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer16(U16):us16 /Integer16(U16):us16b }
              /PSL(noPSL):psl /XMADcop2(C32):cop /MRG(noMRG):mrg /X(noX):xmode
              $( Register:Rd /optCC(noCC):writeCC )$
              ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):bsel
              ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
              ;

     CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


     OPCODES
        XMADfmai_pipe =  0b0100111;
        XMADfxu_pipe =  0b0100111;
        XMAD =  0b0100111;

     ENCODING
       Opcode7 = Opcode;
       MRG2 = mrg;
       PSL2 = psl;
       Xm8 = xmode;
       HILO2 = asel;
       HILO5 = bsel;
       XMADCop2 = cop;
       BSigned5 = IsSigned16(us16b);
       ASigned5 = IsSigned16(us16);
       WriteCC = writeCC;
       RegC = Rc;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
       PredNot = Pg@not;
       Pred = Pg;
       RegA = Ra;
       Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





 CLASS "ConstC_XMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer16(U16):us16 /Integer16(U16):us16b }
             /XMADcop2(C32):cop /X(noX):xmode
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = (xmode==`X@X);


    OPCODES
        XMADfmai_pipe =  0b010100010;
        XMADfxu_pipe =  0b010100010;
        XMAD =  0b010100010;

    ENCODING
      Opcode9 = Opcode;
      Xm8 = xmode;
      HILO2 = asel;
      HILO5 = bsel;
      XMADCop2 = cop;
      BSigned5 = IsSigned16(us16b);
      ASigned5 = IsSigned16(us16);
      WriteCC = writeCC;
      RegC = Rb;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "a32_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb /H1H0(H0):bsel
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "b8_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_b8_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




 CLASS "a32_b8_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb /B1B0(B0):bsel
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "b32_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra /H1H0(H0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "a8_b32_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra /B1B0(B0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "a32_b32_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "Imm_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Integer16:safmt /UInteger:sbfmt
             /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,0,Rc@negate);
      VScale = VMadScale;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "SImm_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Integer16:safmt /SInteger:sbfmt
             /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(16):sImm
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !sImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,sImm@sign,Rc@negate);
      VScale = VMadScale;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_Imm_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Integer8:safmt /UInteger:sbfmt
             /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(17):uImm
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      VScale = VMadScale;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_SImm_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Integer8:safmt /SInteger:sbfmt
             /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(16):sImm
             ',' $( [-] Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !sImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,sImm@sign,Rc@negate);
      VScale = VMadScale;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_Imm_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /VInteger32:safmt /UInteger:sbfmt
             /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(17):uImm
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      VScale = VMadScale;

      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "a32_SImm_VMAD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           { /VInteger32(S32):safmt /SInteger(S16):sbfmt }
             /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(16):sImm
             ',' [-]Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !sImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vscale != `VMadScale@INVALIDVMADSCALE3):
                "Invalid VMadScale (vscale) field value INVALIDVMADSCALE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        VMADmio_pipe =  0b01011111;
        VMAD =  0b01011111;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,sImm@sign,Rc@negate);
      VScale = VMadScale;

      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "b8_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_b8_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_b8_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "b32_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_b32_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_b32_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "Imm_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer16:safmt /UInteger:sbfmt
             /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(17):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,uImm@sign);


      BVideo=0;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "SImm_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer16:safmt /SInteger:sbfmt
             /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !sImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !sImm@sign) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,sImm@sign);


      BVideo=0;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_Imm_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer8:safmt /UInteger:sbfmt
             /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(17):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,uImm@sign);


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_SImm_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer8:safmt /SInteger:sbfmt
             /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !sImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !sImm@sign) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,sImm@sign);


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_Imm_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(SD):dfmt /VInteger32:safmt /UInteger:sbfmt
             /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(17):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,uImm@sign);


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_SImm_VADD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(SD):dfmt { /VInteger32(S32):safmt /SInteger(S16):sbfmt }
             /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SSImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (PO -> (!Ra@negate && !sImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ILLEGAL_INSTR_ENCODING_ERROR
           (!Ra@negate || !sImm@sign) :
             "Cannot use '-' on both of the inputs"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VADDfxu_pipe =  0b001000;
        VADD =  0b001000;

    ENCODING
  Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,sImm@sign);


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
CLASS "VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;




      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "b8_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_b8_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_b8_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "b32_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;




      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_b32_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_b32_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(UD):dfmt /Integer16:safmt /UInteger16:sbfmt
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "SImm_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(UD):dfmt /Integer16:safmt /SInteger16:sbfmt
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_Imm_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(UD):dfmt /Integer8:safmt /UInteger16:sbfmt
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_SImm_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(UD):dfmt /Integer8:safmt /SInteger16:sbfmt
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_Imm_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(UD):dfmt /VInteger32:safmt /UInteger:sbfmt
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_SImm_VABSDIFF"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(UD):dfmt { /VInteger32(S32):safmt /SInteger16(S16):sbfmt }
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFFfxu_pipe =  0b01010100;
        VABSDIFF =  0b01010100;

    ENCODING
  Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
CLASS "VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "b8_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_b8_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_b8_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "b32_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_b32_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_b32_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=1;
      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Imm_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /UInteger16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "SImm_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /SInteger16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_Imm_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /UInteger16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a8_SImm_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /SInteger16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_Imm_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /UInteger16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "a32_SImm_VMNMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /SInteger16(S16):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VMNMXfxu_pipe =  0b0011101;
        VMNMX =  0b0011101;

    ENCODING
  Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;


      BVideo=0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /Integer16:sbfmt
             /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "b8_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_b8_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_b8_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /Integer8:sbfmt
             /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "b32_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /VInteger32:sbfmt
             /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_b32_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /VInteger32:sbfmt
             /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_b32_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
           { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
             /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      RegC = Rc;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "Imm_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /UInteger16:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm16 = uImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "SImm_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /SInteger16:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm16 = sImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_Imm_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /UInteger16:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm16 = uImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_SImm_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /SInteger16:sbfmt /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm16 = sImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_Imm_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
           /VInteger32:safmt /UInteger16:sbfmt
             /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 0;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm16 = uImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_SImm_VSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
           { /VInteger32(S32):safmt /SInteger16(S16):sbfmt }
             /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;




    OPCODES
        VSETfxu_pipe =  0b0100000;
        VSET =  0b0100000;

    ENCODING
      Opcode7 = Opcode;
      VComp2 = ICmpAll;
      VOP = VOP;
      BVideo = 0;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      WriteCC = writeCC;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm16 = sImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
ALTERNATE CLASS "VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /Integer16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "a8_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /Integer16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "a32_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /Integer16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "b8_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /Integer8:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;




ALTERNATE CLASS "a8_b8_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /Integer8:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "a32_b8_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /Integer8:sbfmt
             Predicate:Pd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "b32_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /VInteger32:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "a8_b32_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /VInteger32:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "a32_b32_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
           { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
             Predicate:Pd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
ALTERNATE CLASS "Imm_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /UInteger16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = uImm;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
ALTERNATE CLASS "SImm_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /SInteger16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = sImm;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
ALTERNATE CLASS "a8_Imm_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /UInteger16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = uImm;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
ALTERNATE CLASS "a8_SImm_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /SInteger16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = sImm;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
ALTERNATE CLASS "a32_Imm_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /UInteger16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = uImm;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
ALTERNATE CLASS "a32_SImm_VSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /SInteger16:sbfmt
             Predicate:Pd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = `Bop@AND;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = sImm;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /Integer16:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "a8_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /Integer16:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "a32_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /Integer16:sbfmt
             /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "b8_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /Integer8:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;




 CLASS "a8_b8_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /Integer8:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "a32_b8_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /Integer8:sbfmt
             /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb /B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "b32_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /VInteger32:sbfmt
             /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "a8_b32_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /VInteger32:sbfmt
             /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





 CLASS "a32_b32_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
           { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
             /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 1;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      PDest = Pd;
      PNDest = nPd;
      !BFiller3;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "Imm_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /UInteger16:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = uImm;
      PDest = Pd;
      PNDest = nPd;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "SImm_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer16:safmt /SInteger16:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = sImm;
      PDest = Pd;
      PNDest = nPd;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_Imm_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /UInteger16:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = uImm;
      PDest = Pd;
      PNDest = nPd;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a8_SImm_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /Integer8:safmt /SInteger16:sbfmt /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra /B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = sImm;
      PDest = Pd;
      PNDest = nPd;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_Imm_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /UInteger16:sbfmt
             /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = uImm;
      PDest = Pd;
      PNDest = nPd;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "a32_SImm_VSETP_bop"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
             /VInteger32:safmt /SInteger16:sbfmt
             /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VSETPfxu_pipe =  0b0101000011110;
        VSETP =  0b0101000011110;

    ENCODING
      Opcode13 = Opcode;
      BVideo = 0;
      aSelect =* VFormat32(safmt);
      sbfmt =* IntegerSigned(sbfmt);
      VComp3 = ICmpAll;
      Bop = bopopt;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Imm16 = sImm;
      PDest = Pd;
      PNDest = nPd;
      !NencVSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




CLASS "a8_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a32_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "b8_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a8_b8_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a32_b8_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "b32_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `U32@INVALIDASEL7):
                "Invalid U32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a8_b32_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `U32@INVALIDASEL7):
                "Invalid U32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a32_b32_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt
           { /VInteger32(S32):safmt /U32(U32):sbfmt }
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `U32@INVALIDASEL7):
                "Invalid U32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;


CLASS "Imm_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer16:safmt /UInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;

CLASS "SImm_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer16:safmt /SInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;

CLASS "a8_Imm_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer8:safmt /UInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;


CLASS "a8_SImm_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer8:safmt /SInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;


CLASS "a32_Imm_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(SD):dfmt { /VInteger32(S32):safmt /UInteger16(U16):sbfmt }
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;

CLASS "a32_SImm_VSHL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(SD):dfmt /VInteger32:safmt /SInteger16:sbfmt
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHLfxu_pipe =  0b01010111;
        VSHL =  0b01010111;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
CLASS "VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;




CLASS "a8_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a32_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt
             /VInteger32:safmt /U16:sbfmt
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/H1H0(H0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "b8_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a8_b8_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a32_b8_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt
             /VInteger32:safmt /U8:sbfmt
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb/B1B0(B0):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "b32_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `U32@INVALIDASEL7):
                "Invalid U32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a8_b32_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `U32@INVALIDASEL7):
                "Invalid U32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "a32_b32_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt
           { /VInteger32(S32):safmt /U32(U32):sbfmt }
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (safmt != `VInteger32@INVALIDASEL7):
                "Invalid VInteger32 (safmt) field value INVALIDASEL7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (sbfmt != `U32@INVALIDASEL7):
                "Invalid U32 (sbfmt) field value INVALIDASEL7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;
      BVideo = 1;

      !BFiller3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;


CLASS "Imm_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer16:safmt /UInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;

CLASS "SImm_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer16:safmt /SInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/H1H0(H0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;

CLASS "a8_Imm_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer8:safmt /UInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;


CLASS "a8_SImm_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt /Integer8:safmt /SInteger16:sbfmt /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra/B1B0(B0):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;


CLASS "a32_Imm_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt
           { /VInteger32(S32):safmt /UInteger16(U16):sbfmt }
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(16):uImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;

CLASS "a32_SImm_VSHR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /DFormat(SD):dfmt
           /VInteger32:safmt /SInteger16:sbfmt
             /CWMode(C):wrap
             /SAT(noSAT):sat /VOP(PASS):vop
             $( Register:Rd /optCC(noCC):writeCC )$
             ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(16):sImm
             ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
        ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VSHRfxu_pipe =  0b01010110;
        VSHR =  0b01010110;

   ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = sImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV =* SM5vshlCW(CWMode,sbfmt);
      BVideo = 0;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;
CLASS "VABSDIFF4"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
             /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra/ASel4("3210"):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' $( RegisterFAU:Rb/BSel4("7654"):bsel {/REUSE(noreuse):reuse_src_b} )$
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (asel != `ASel4@INVALIDASEL4E):
                "Invalid ASel4 (asel) field value INVALIDASEL4E"

            ILLEGAL_INSTR_ENCODING_ERROR
                (asel != `ASel4@INVALIDASEL4F):
                "Invalid ASel4 (asel) field value INVALIDASEL4F"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vred != `VRed2@INVALIDRED2):
                "Invalid VRed2 (vred) field value INVALIDRED2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vred != `VRed2@INVALIDRED3):
                "Invalid VRed2 (vred) field value INVALIDRED3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bsel != `BSel4@INVALIDBSEL4B):
                "Invalid BSel4 (bsel) field value INVALIDBSEL4B"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bsel != `BSel4@INVALIDBSEL4C):
                "Invalid BSel4 (bsel) field value INVALIDBSEL4C"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bsel != `BSel4@INVALIDBSEL4D):
                "Invalid BSel4 (bsel) field value INVALIDBSEL4D"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bsel != `BSel4@INVALIDBSEL4E):
                "Invalid BSel4 (bsel) field value INVALIDBSEL4E"


        ILLEGAL_INSTR_ENCODING_ERROR
            (sat == `SAT@noSAT):
                ".SAT is not allowed in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (dfmt == `DFormat@UD):
                ".SD is not allowed in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (laneMsk == `LaneMask4@XYZW):
                "Invalid lanemask in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (asel == `ASel4@"3210"):
                "Invalid asel in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (bsel == `BSel4@"7654"):
                "Invalid bsel in Maxwell VABSDIFF4"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFF4fmai_pipe =  0b010100000;
        VABSDIFF4fxu_pipe =  0b010100000;
        VABSDIFF4 =  0b010100000;

    ENCODING
      Opcode9 = Opcode;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      Sat = SAT;
      sbfmt = Integer8Signed(sbfmt);
      safmt = Integer8Signed(safmt);
      WriteCC = writeCC;
      DFormat = DFormat;
      asel4 = asel;
      bsel4 =* bsel;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_VABSDIFF4"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(UD):dfmt /Integer8:safmt /UInteger8:sbfmt
             /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra/ASel4("3210"):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' UImm(8):uImm
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (asel != `ASel4@INVALIDASEL4E):
                "Invalid ASel4 (asel) field value INVALIDASEL4E"

            ILLEGAL_INSTR_ENCODING_ERROR
                (asel != `ASel4@INVALIDASEL4F):
                "Invalid ASel4 (asel) field value INVALIDASEL4F"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vred != `VRed2@INVALIDRED2):
                "Invalid VRed2 (vred) field value INVALIDRED2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vred != `VRed2@INVALIDRED3):
                "Invalid VRed2 (vred) field value INVALIDRED3"


        ILLEGAL_INSTR_ENCODING_ERROR
            (sat == `SAT@noSAT):
                ".SAT is not allowed in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (dfmt == `DFormat@UD):
                ".SD is not allowed in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (laneMsk == `LaneMask4@XYZW):
                "Invalid lanemask in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (asel == `ASel4@"3210"):
                "Invalid asel in Maxwell VABSDIFF4"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 8;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFF4fmai_pipe =  0b010100000;
        VABSDIFF4fxu_pipe =  0b010100000;
        VABSDIFF4 =  0b010100000;

    ENCODING
      Opcode9 = Opcode;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      Sat = SAT;
      sbfmt =* Integer8Signed(sbfmt);
      safmt =* Integer8Signed(safmt);
      WriteCC = writeCC;
      DFormat = DFormat;
      asel4 = asel;
      bsel4 = 0xf;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = uImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



CLASS "SImm_VABSDIFF4"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
           /DFormat(UD):dfmt { /Integer8(S8):safmt /SInteger8(S8):sbfmt }
             /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk
             $( RegisterFAU:Rd /optCC(noCC):writeCC )$
             ',' $( RegisterFAU:Ra/ASel4("3210"):asel {/REUSE(noreuse):reuse_src_a} )$
             ',' SImm(8):sImm
             ',' $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
  ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (asel != `ASel4@INVALIDASEL4E):
                "Invalid ASel4 (asel) field value INVALIDASEL4E"

            ILLEGAL_INSTR_ENCODING_ERROR
                (asel != `ASel4@INVALIDASEL4F):
                "Invalid ASel4 (asel) field value INVALIDASEL4F"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vred != `VRed2@INVALIDRED2):
                "Invalid VRed2 (vred) field value INVALIDRED2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (vred != `VRed2@INVALIDRED3):
                "Invalid VRed2 (vred) field value INVALIDRED3"


        ILLEGAL_INSTR_ENCODING_ERROR
            (sat == `SAT@noSAT):
                ".SAT is not allowed in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (dfmt == `DFormat@UD):
                ".SD is not allowed in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (laneMsk == `LaneMask4@XYZW):
                "Invalid lanemask in Maxwell VABSDIFF4"

        ILLEGAL_INSTR_ENCODING_ERROR
            (asel == `ASel4@"3210"):
                "Invalid asel in Maxwell VABSDIFF4"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 8;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        VABSDIFF4fmai_pipe =  0b010100000;
        VABSDIFF4fxu_pipe =  0b010100000;
        VABSDIFF4 =  0b010100000;

    ENCODING
      Opcode9 = Opcode;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      Sat = SAT;
      sbfmt =* Integer8Signed(sbfmt);
      safmt =* Integer8Signed(safmt);
      WriteCC = writeCC;
      DFormat = DFormat;
      asel4 = asel;
      bsel4 = 0xf;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = sImm;
      RegC = Rc;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "F2F_1"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"/PRINT):fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;


    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            !SH;


            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2F_2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;

            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2F_2_64_32"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64_32:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


         ILLEGAL_INSTR_ENCODING_ERROR
           ( fmts == `F2Ffmts2_64_32@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"




    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;

            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2F_1_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 16;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            SH = halfsel;


            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2F_2_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"




    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            SH = halfsel;

            !IR;

            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2F_2_64_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
            (fmts != `F2Ffmts2_64_16@"F64.F16") :
            "F16 cannot be converted to F64"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"




    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            SH = halfsel;

            !IR;

            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2F_1_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         MISALIGNED_REG_ERROR
         ((Rb%2==0)||(Rb==`Register@RZ)):
             "Rb must be aligned to 64bits when srcfmt is F64"



            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"

            MISALIGNED_REG_ERROR
                ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==255))) :
                "F64 as destination format requires an even destination register"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rb)+((Rb)==255))) :
                "F64 as source format requires an even source register"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"




    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            !SH;


            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2F_2_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;



    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

         ILLEGAL_INSTR_ENCODING_ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         MISALIGNED_REG_ERROR
         ((Rb%2==0)||(Rb==`Register@RZ)):
             "Rb must be aligned to 64bits when srcfmt is F64"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rb)+((Rb)==255))) :
                "F64 as source format requires an even source register"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"




    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((fmts==`F2Ffmts2_64@F16.F64)*16) + ((fmts==`F2Ffmts2_64@F32.F64)*32));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0101110010101;
        F2F =  0b0101110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;

            !BFiller;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_1"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"/PRINT):fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;


    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            !SH;

            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;

    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_2_64_32"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64_32:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           ( fmts == `F2Ffmts2_64_32@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"




    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;

    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_1_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 16;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;

    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            SH = halfsel;

            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_2_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;

    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            SH = halfsel;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_2_64_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"



            ILLEGAL_INSTR_ENCODING_ERROR
            (fmts != `F2Ffmts2_64_16@"F64.F16") :
            "F16 cannot be converted to F64"

            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;

    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            SH = halfsel;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_1_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

            MISALIGNED_REG_ERROR
                ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==255))) :
                "F64 as destination format requires an even destination register"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;

    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            !SH;

            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2F_2_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;



    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

         ILLEGAL_INSTR_ENCODING_ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((fmts==`F2Ffmts2_64@F16.F64)*16) + ((fmts==`F2Ffmts2_64@F32.F64)*32));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0011100_10101;
        F2F =  0b0011100_10101;

    ENCODING
            Opcode7b5 = Opcode;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_1"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"/PRINT):fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;


    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            !SH;

            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_2_64_32"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64_32:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


CONDITIONS

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


         ILLEGAL_INSTR_ENCODING_ERROR
           ( fmts == `F2Ffmts2_64_32@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"

            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_1_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 16;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            SH = halfsel;

            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_2_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            SH = halfsel;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_2_64_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           ( fmts != `F2Ffmts2_64_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            SH = halfsel;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_1_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

            MISALIGNED_REG_ERROR
                ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==255))) :
                "F64 as destination format requires an even destination register"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            IRRnd = rnd;
            !SH;

            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2F_2_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;



CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

         ILLEGAL_INSTR_ENCODING_ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (fmts == 10)) :
                "Warning: .FTZ is ignored unless .dfmt.sfmt is F32.F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((fmts==`F2Ffmts2_64@F16.F64)*16) + ((fmts==`F2Ffmts2_64@F32.F64)*32));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Fmio_pipe =  0b0100110010101;
        F2F =  0b0100110010101;

    ENCODING
            Opcode13 = Opcode;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SrcDstFmt =* fmts;
            Dest = Rd;
            Rnd_1 = rnd;
            !SH;

            !IR;
            !NencF2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "F2I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /IntegerInv8No64(S32/PRINT):dstfmt /Float32(F32/PRINT):srcfmt }
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (srcfmt != `Float32@INVALIDFPDEST0):
                "Invalid Float32 (srcfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (srcfmt == `Float32@F32)) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Imio_pipe =  0b0101110010110;
        F2I =  0b0101110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt =* IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;



            !BFiller;
            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2I_I64"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer64:dstfmt /Float32:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (srcfmt != `Float32@INVALIDFPDEST0):
                "Invalid Float32 (srcfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (srcfmt == `Float32@F32)) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Imio_pipe =  0b0101110010110;
        F2I =  0b0101110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt =* IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;



            !BFiller;
            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2I_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /IntegerNo8:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                (ftz != `FTZ@FTZ) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Imio_pipe =  0b0101110010110;
        F2I =  0b0101110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt = IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;



            !BFiller;
            !NencF2I;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "F2I_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /IntegerNo8:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (srcfmt == `Float64@F64) -> IsEven(((Rb)+((Rb)==255))) :
                "F64 as source format requires an even source register"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) :
                "Register Rb is out of range"


         ILLEGAL_INSTR_ENCODING_ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"


            ILLEGAL_INSTR_ENCODING_WARNING
                (ftz != `FTZ@FTZ) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Imio_pipe =  0b0101110010110;
        F2I =  0b0101110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            FTZ = FTZ;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt = IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;



            !BFiller;
            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /IntegerInv8No64(S32/PRINT):dstfmt /Float32(F32/PRINT):srcfmt }
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (srcfmt != `Float32@INVALIDFPDEST0):
                "Invalid Float32 (srcfmt) field value INVALIDFPDEST0"



            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (srcfmt == `Float32@F32)) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Imio_pipe =  0b0011100_10110;
        F2I =  0b0011100_10110;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt =* IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;




            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2I_I64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer64:dstfmt /Float32:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (srcfmt != `Float32@INVALIDFPDEST0):
                "Invalid Float32 (srcfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (srcfmt == `Float32@F32)) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Imio_pipe =  0b0011100_10110;
        F2I =  0b0011100_10110;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt =* IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;




            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2I_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /IntegerNo8:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"





         OOR_REG_ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
             "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_WARNING
                (ftz != `FTZ@FTZ) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Imio_pipe =  0b0011100_10110;
        F2I =  0b0011100_10110;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt = IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;




            !NencF2I;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_F2I_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /IntegerNo8:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                (ftz != `FTZ@FTZ) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Imio_pipe =  0b0011100_10110;
        F2I =  0b0011100_10110;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            FTZ = FTZ;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt = IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;




            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /IntegerInv8No64(S32/PRINT):dstfmt /Float32(F32/PRINT):srcfmt }
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


CONDITIONS


         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (srcfmt != `Float32@INVALIDFPDEST0):
                "Invalid Float32 (srcfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (srcfmt == `Float32@F32)) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Imio_pipe =  0b0100110010110;
        F2I =  0b0100110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt =* IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;


            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2I_I64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer64:dstfmt /Float32:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


CONDITIONS


         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (srcfmt != `Float32@INVALIDFPDEST0):
                "Invalid Float32 (srcfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((ftz == `FTZ@FTZ) -> (srcfmt == `Float32@F32)) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Imio_pipe =  0b0100110010110;
        F2I =  0b0100110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt =* IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;


            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2I_16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /IntegerNo8:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS


         ILLEGAL_INSTR_ENCODING_ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                (ftz != `FTZ@FTZ) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        F2Imio_pipe =  0b0100110010110;
        F2I =  0b0100110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt = IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;


            !NencF2I;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_F2I_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /IntegerNo8:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


CONDITIONS

         ILLEGAL_INSTR_ENCODING_ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ILLEGAL_INSTR_ENCODING_ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

            MISALIGNED_REG_ERROR
                (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
                "U64/S64 as destination format requires an even destination register"

            OOR_REG_ERROR
                ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register D is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


            ILLEGAL_INSTR_ENCODING_WARNING
                (ftz != `FTZ@FTZ) :
                "Warning: .FTZ is ignored unless sfmt is F32"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_DOUBLE);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        F2Imio_pipe =  0b0100110010110;
        F2I =  0b0100110010110;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            SH = halfsel;
            IDstFmt = IntSize( dstfmt );
            SrcFmt =* srcfmt;
            Rnd_1 = rnd;
            Dest = Rd;


            !NencF2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "I2F"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /FloatNo64(F32/PRINT):dstfmt /IntegerNo16No64(S32/PRINT):srcfmt }
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            MISALIGNED_REG_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (IsEven(((Rb)+((Rb)==255)))) :
                ".U64 requires an even source register"

            OOR_REG_ERROR
                ((srcfmt == `IntegerNo16@U64) || (srcfmt == `IntegerNo16@S64)) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `FloatNo64@INVALIDFPDEST0):
                "Invalid FloatNo64 (dstfmt) field value INVALIDFPDEST0"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Fmio_pipe =  0b0101110010111;
        I2F =  0b0101110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt =* dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegB = Rb;
            !NencI2F;

            !BFiller;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I2F_F64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float64:dstfmt /IntegerNo16No64:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            MISALIGNED_REG_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (IsEven(((Rb)+((Rb)==255)))) :
                ".U64 requires an even source register"

            OOR_REG_ERROR
                ((srcfmt == `IntegerNo16@U64) || (srcfmt == `IntegerNo16@S64)) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        I2Fmio_pipe =  0b0101110010111;
        I2F =  0b0101110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt =* dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegB = Rb;
            !NencI2F;

            !BFiller;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I2F64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer64:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            MISALIGNED_REG_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (IsEven(((Rb)+((Rb)==255)))) :
                ".U64 requires an even source register"

            OOR_REG_ERROR
                ((srcfmt == `IntegerNo16@U64) || (srcfmt == `IntegerNo16@S64)) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@INVALIDFPDEST0):
                "Invalid Float (dstfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

             ILLEGAL_INSTR_ENCODING_ERROR
                 ((srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
                 "No byte select can be combined with 32/64 bit src formats"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        I2Fmio_pipe =  0b0101110010111;
        I2F =  0b0101110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt = dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegB = Rb;
            !NencI2F;

            !BFiller;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I2F16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@F64):
                ".U16/.S16 to .F64 is not supported"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (halfsel != `I2XH@INVALIDSIZE1):
                "Invalid I2XH (halfsel) field value INVALIDSIZE1"

            ILLEGAL_INSTR_ENCODING_ERROR
                (halfsel != `I2XH@INVALIDSIZE3):
                "Invalid I2XH (halfsel) field value INVALIDSIZE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@INVALIDFPDEST0):
                "Invalid Float (dstfmt) field value INVALIDFPDEST0"




    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Fmio_pipe =  0b0101110010111;
        I2F =  0b0101110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            By = I2XH;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt = dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegB = Rb;
            !NencI2F;


            !BFiller;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_I2F"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /FloatNo64(F32/PRINT):dstfmt /IntegerNo16No64(S32/PRINT):srcfmt }
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `FloatNo64@INVALIDFPDEST0):
                "Invalid FloatNo64 (dstfmt) field value INVALIDFPDEST0"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Fmio_pipe =  0b0011100_10111;
        I2F =  0b0011100_10111;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt =* dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            Bconst=uImm;
            !NencI2F;





      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_I2F_F64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float64:dstfmt /IntegerNo16No64:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        I2Fmio_pipe =  0b0011100_10111;
        I2F =  0b0011100_10111;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt =* dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            Bconst=uImm;
            !NencI2F;





      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_I2F64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer64:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@INVALIDFPDEST0):
                "Invalid Float (dstfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

             ILLEGAL_INSTR_ENCODING_ERROR
                 ((srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
                 "No byte select can be combined with 32/64 bit src formats"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        I2Fmio_pipe =  0b0011100_10111;
        I2F =  0b0011100_10111;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt = dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            Bconst=uImm;
            !NencI2F;





      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_I2F16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@F64):
                ".U16/.S16 to .F64 is not supported"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (halfsel != `I2XH@INVALIDSIZE1):
                "Invalid I2XH (halfsel) field value INVALIDSIZE1"

            ILLEGAL_INSTR_ENCODING_ERROR
                (halfsel != `I2XH@INVALIDSIZE3):
                "Invalid I2XH (halfsel) field value INVALIDSIZE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@INVALIDFPDEST0):
                "Invalid Float (dstfmt) field value INVALIDFPDEST0"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Fmio_pipe =  0b0011100_10111;
        I2F =  0b0011100_10111;

    ENCODING
            Opcode7b5 = Opcode;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            By = I2XH;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt = dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            Bconst=uImm;
            !NencI2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_I2F"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /FloatNo64(F32/PRINT):dstfmt /IntegerNo16No64(S32/PRINT):srcfmt }
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `FloatNo64@INVALIDFPDEST0):
                "Invalid FloatNo64 (dstfmt) field value INVALIDFPDEST0"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Fmio_pipe =  0b0100110010111;
        I2F =  0b0100110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt =* dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            !NencI2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_I2F_F64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float64:dstfmt /IntegerNo16No64:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        I2Fmio_pipe =  0b0100110010111;
        I2F =  0b0100110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt =* dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            !NencI2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_I2F64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer64:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

            MISALIGNED_REG_ERROR
                (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
                ".F64 requires an even destination register"

            OOR_REG_ERROR
                ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) || ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))):
                "Register D is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
                ".U8/.S8 to .F64 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
                ".U32/.S32 to .F16 is not supported"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@INVALIDFPDEST0):
                "Invalid Float (dstfmt) field value INVALIDFPDEST0"


            ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
                ".U64/.S64 to .F16 is not supported"

             ILLEGAL_INSTR_ENCODING_ERROR
                 ((srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
                 "No byte select can be combined with 32/64 bit src formats"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 64;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_FMA64;


    OPCODES
        I2Fmio_pipe =  0b0100110010111;
        I2F =  0b0100110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            By = B1B0;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt = dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            !NencI2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_I2F16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@F64):
                ".U16/.S16 to .F64 is not supported"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (halfsel != `I2XH@INVALIDSIZE1):
                "Invalid I2XH (halfsel) field value INVALIDSIZE1"

            ILLEGAL_INSTR_ENCODING_ERROR
                (halfsel != `I2XH@INVALIDSIZE3):
                "Invalid I2XH (halfsel) field value INVALIDSIZE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dstfmt != `Float@INVALIDFPDEST0):
                "Invalid Float (dstfmt) field value INVALIDFPDEST0"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Float@F64)*64) + ((dstfmt==`Float@F32)*32) + ((dstfmt==`Float@F16)*16));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Fmio_pipe =  0b0100110010111;
        I2F =  0b0100110010111;

    ENCODING
            Opcode13 = Opcode;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            By = I2XH;
            RndLow = Round1;
            ISrcFmt =* IntSize ( srcfmt );
            DstFmt = dstfmt;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            !NencI2F;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "I2I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /IntegerNo64(S32/PRINT):dstfmt /IntegerNo16Inv64(S32/PRINT):srcfmt }
                                /SAT(noSAT):sat
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-][||]RegisterFAU:Rb /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            MISALIGNED_REG_ERROR
                ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (IsEven(((Rb)+((Rb)==255)))) :
                ".U64 requires an even source register"

            OOR_REG_ERROR
                ((srcfmt == `IntegerNo16@U64) || (srcfmt == `IntegerNo16@S64)) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Imio_pipe =  0b0101110011100;
        I2I =  0b0101110011100;

    ENCODING
            Opcode13 = Opcode;

            Pred = Pg;
            PredNot = Pg@not;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            By = B1B0;
            IDstFmt = IntSize( dstfmt );
            SrcFmt2 =* IntSize( srcfmt );
            Dest = Rd;
            RegB = Rb;


            !BFiller;
            !NencI2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I2I16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerNo64:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"




    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Imio_pipe =  0b0101110011100;
        I2I =  0b0101110011100;

    ENCODING
            Opcode13 = Opcode;

            Pred = Pg;
            PredNot = Pg@not;
            Sat = SAT;
            aB = Rb@absolute;
            WriteCC = writeCC;
            nB = Rb@negate;
            By = I2XH;
            IDstFmt = IntSize( dstfmt );
            SrcFmt2 =* IntSize( srcfmt );
            Dest = Rd;
            RegB = Rb;


            !BFiller;
            !NencI2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_I2I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /IntegerNo64(S32/PRINT):dstfmt /IntegerNo16Inv64(S32/PRINT):srcfmt }
                                /SAT(noSAT):sat
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Imio_pipe =  0b0011100_11100;
        I2I =  0b0011100_11100;

    ENCODING
            Opcode7b5 = Opcode;

            Pred = Pg;
            PredNot = Pg@not;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            By = B1B0;
            IDstFmt = IntSize( dstfmt );
            SrcFmt2 =* IntSize( srcfmt );
            Dest = Rd;
            Bconst=uImm;

            !NencI2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "Imm_I2I16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerNo64:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Imio_pipe =  0b0011100_11100;
        I2I =  0b0011100_11100;

    ENCODING
            Opcode7b5 = Opcode;

            Pred = Pg;
            PredNot = Pg@not;
            Sat = SAT;
            aB = UnaryAbs;
            WriteCC = writeCC;
            nB = UnaryNeg;
            By = I2XH;
            IDstFmt = IntSize( dstfmt );
            SrcFmt2 =* IntSize( srcfmt );
            Dest = Rd;
            Bconst=uImm;

            !NencI2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_I2I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /IntegerNo64(S32/PRINT):dstfmt /IntegerNo16Inv64(S32/PRINT):srcfmt }
                                /SAT(noSAT):sat
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS


            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

     ILLEGAL_INSTR_ENCODING_ERROR
                ((srcfmt == `Integer@S32) || (srcfmt == `Integer@U32) || (srcfmt == `Integer@S64) || (srcfmt == `Integer@U64)) -> (bytesel == `B1B0@B0) :
  "No byte select can be combined with 32/64 bit src formats"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = (((srcfmt==`IntegerNo16@U8)*8) + ((srcfmt==`IntegerNo16@S8)*8) + ((srcfmt==`IntegerNo16@U32)*32) + ((srcfmt==`IntegerNo16@S32)*32) + ((srcfmt==`IntegerNo16@U64)*64) + ((srcfmt==`IntegerNo16@S64)*64));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Imio_pipe =  0b0100110011100;
        I2I =  0b0100110011100;

    ENCODING
            Opcode13 = Opcode;

            Pred = Pg;
            PredNot = Pg@not;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            By = B1B0;
            IDstFmt = IntSize( dstfmt );
            SrcFmt2 =* IntSize( srcfmt );
            Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

            !NencI2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "Const_I2I16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerNo64:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((dstfmt==`Integer@U8)*8) + ((dstfmt==`Integer@S8)*8) + ((dstfmt==`Integer@U16)*16) + ((dstfmt==`Integer@S16)*16) + ((dstfmt==`Integer@U32)*32) + ((dstfmt==`Integer@S32)*32) + ((dstfmt==`Integer@U64)*64) + ((dstfmt==`Integer@S64)*64));
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 16;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_XU;


    OPCODES
        I2Imio_pipe =  0b0100110011100;
        I2I =  0b0100110011100;

    ENCODING
            Opcode13 = Opcode;

            Pred = Pg;
            PredNot = Pg@not;
            Sat = SAT;
            aB = srcConst@absolute;
            WriteCC = writeCC;
            nB = srcConst@negate;
            By = I2XH;
            IDstFmt = IntSize( dstfmt );
            SrcFmt2 =* IntSize( srcfmt );
            Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

            !NencI2I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;





CLASS "MOV"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( RegisterFAU:Rd )$
             ',' $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' UImm(4/0xf):quadMask

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        MOVfmai_pipe =  0b0101110010011;
        MOVfxu_pipe =  0b0101110010011;
        MOV =  0b0101110010011;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      QuadMask = quadMask;

      !BFiller;
      !NencMOV;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_MOV"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( RegisterFAU:Rd )$
             ',' SImm(20):uImm
             ',' UImm(4/0xf):quadMask

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        MOVfmai_pipe =  0b0011100_10011;
        MOVfxu_pipe =  0b0011100_10011;
        MOV =  0b0011100_10011;

    ENCODING
      Opcode7b5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      QuadMask = quadMask;
      !NencMOV;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_MOV"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( RegisterFAU:Rd )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' UImm(4/0xf):quadMask

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        MOVfmai_pipe =  0b0100110010011;
        MOVfxu_pipe =  0b0100110010011;
        MOV =  0b0100110010011;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      QuadMask = quadMask;
      !NencMOV;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "MOV32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( RegisterFAU:Rd )$
             ',' UImm(32)*:uImm
             ',' UImm(4/0xf):quadMask

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        MOV32Ifmai_pipe =  0b000000010000;
        MOV32Ifxu_pipe =  0b000000010000;
        MOV32I =  0b000000010000;

    ENCODING
      Opcode12= Opcode;
      Imm32 = uImm;
      PredNot = Pg@not;
      Pred = Pg;
      Dest = Rd;
      QuadMask2 = quadMask;
      !NencMOV32I;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;






CLASS "SEL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
            $( RegisterFAU:Rd )$ ','
            $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$ ','
            $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$ ','
            [!] Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        SELfxu_pipe =  0b0101110010100;
        SEL =  0b0101110010100;

    ENCODING
           Opcode13 = Opcode;
        RegA = Ra;
        RegB = Rb;
        Pred = Pg;
        PredNot = Pg@not;
        Dest = Rd;
        SrcPred = Pa;
        SrcNot = Pa@not;

        !NencSEL;
        !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_SEL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( RegisterFAU:Rd )$ ','
             $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$ ','
             SImm(20):uImm ','
             [!] Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        SELfxu_pipe =  0b0011100_10100;
        SEL =  0b0011100_10100;

    ENCODING
            Opcode7b5 = Opcode;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            SrcPred = Pa;
            SrcNot = Pa@not;

            !NencSEL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_SEL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             $( RegisterFAU:Rd )$ ','
             $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$ ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             [!] Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        SELfxu_pipe =  0b0100110010100;
        SEL =  0b0100110010100;


    ENCODING
            Opcode13 = Opcode;
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            SrcPred = Pa;
            SrcNot = Pa@not;

            !NencSEL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "PRMT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt
             $( RegisterFAU:Rd )$ ','
             $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$ ','
             $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$ ','
             $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (prmt != `PMode@INVALIDPMODE7):
                "Invalid PMode (prmt) field value INVALIDPMODE7"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        PRMTfmai_pipe =  0b010110111100;
        PRMT =  0b010110111100;

    ENCODING
            Opcode12 = Opcode;
            PMode = PMode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            RegB = Rb;
            RegC = Rc;

            !BFiller;
            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;





CLASS "Imm_PRMT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt
             $( RegisterFAU:Rd )$ ','
             $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$ ','
             SImm(20):uImm ','
             $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (prmt != `PMode@INVALIDPMODE7):
                "Invalid PMode (prmt) field value INVALIDPMODE7"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        PRMTfmai_pipe =  0b0011011_1100;
        PRMT =  0b0011011_1100;

    ENCODING
            Opcode7b4 = Opcode;
            PMode = PMode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            Bconst=uImm;
            RegC = Rc;

            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const_PRMT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt
             $( RegisterFAU:Rd )$ ','
             $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$ ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             $( RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (prmt != `PMode@INVALIDPMODE7):
                "Invalid PMode (prmt) field value INVALIDPMODE7"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        PRMTfmai_pipe =  0b010010111100;
        PRMT =  0b010010111100;

    ENCODING
            Opcode12 = Opcode;
            PMode = PMode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            RegC = Rc;

            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "Const1_PRMT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt
             $( RegisterFAU:Rd )$ ','
             $( RegisterFAU:Ra {/REUSE(noreuse):reuse_src_a} )$ ','
             $( RegisterFAU:Rb {/REUSE(noreuse):reuse_src_b} )$ ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (prmt != `PMode@INVALIDPMODE7):
                "Invalid PMode (prmt) field value INVALIDPMODE7"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;


    OPCODES
        PRMTfmai_pipe =  0b010100111100;
        PRMT =  0b010100111100;

    ENCODING
            Opcode12 = Opcode;
            PMode = PMode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            RegC = Rb;


            !WriteCC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





CLASS "SHFL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        SHFLmio_pipe =  0b1110111100010;
        SHFL =  0b1110111100010;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            RegB = Rb;
            RegC = Rc;
            Shflmd = shflmd;

            !SHFLFiller;
            CFix_SHFL=0;
            BFix_SHFL=0;
            PredDest = Pd;
            !NencSHFL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;

CLASS "b_SHFL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             UImm(5):uImm5 ','
             Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm5));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 5;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        SHFLmio_pipe =  0b1110111100010;
        SHFL =  0b1110111100010;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            shfl_imm5 = uImm5;
            !bit6_RegB;
            RegC = Rc;
            Shflmd = shflmd;

            !SHFLFiller;
            CFix_SHFL=0;
            BFix_SHFL=1;
            PredDest = Pd;

            !NencSHFL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "c_b_SHFL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             UImm(5):uImm5 ','
             UImm(13):uImm13

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm5));
         ISRC_C_OPERAND_MAP = (1<<INDEX(uImm13));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 5;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        SHFLmio_pipe =  0b1110111100010;
        SHFL =  0b1110111100010;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            shfl_imm5 = uImm5;
            !bit6_RegB;
            Imm13 = uImm13;
            Shflmd = shflmd;


            CFix_SHFL=1;
            BFix_SHFL=1;
            PredDest = Pd;
            !NencSHFL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "c_SHFL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             UImm(13):uImm13

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(uImm13));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        SHFLmio_pipe =  0b1110111100010;
        SHFL =  0b1110111100010;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = Ra;
            RegB = Rb;
            Imm13 = uImm13;
            Shflmd = shflmd;


            CFix_SHFL=1;
            BFix_SHFL=0;
            PredDest = Pd;
            !NencSHFL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;





CLASS "P2R"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /B3B0(B0):extract
            $( Register:Rd )$
            ',' CCPR:Pr
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (Pr==`CCPR@CC);


    OPCODES
        P2Rfxu_pipe =  0b0101110011101;
        P2R =  0b0101110011101;

    ENCODING
            Opcode13 = Opcode;
            RegA = Ra;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            Byte = B3B0;
            CCPR = CCPR;
            !NencP2R;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_P2R"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /B3B0(B0):extract
            $( Register:Rd )$
            ',' CCPR:Pr
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
            ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (Pr==`CCPR@CC);


    OPCODES
        P2Rfxu_pipe =  0b0011100_11101;
        P2R =  0b0011100_11101;

    ENCODING
            Opcode7b5 = Opcode;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            Byte = B3B0;
            CCPR = CCPR;
            !NencP2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_P2R"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /B3B0(B0):extract
            $( Register:Rd )$
            ',' CCPR:Pr
            ',' $( Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (Pr==`CCPR@CC);


    OPCODES
        P2Rfxu_pipe =  0b0100110011101;
        P2R =  0b0100110011101;

    ENCODING
            Opcode13 = Opcode;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            Byte = B3B0;
            CCPR = CCPR;
            !NencP2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "Simple_P2R"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /B3B0(B0):extract
            $( Register:Rd )$
            ',' CCPR:Pr

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (Pr==`CCPR@CC);


    OPCODES
        P2Rfxu_pipe =  0b0011100_11101;
        P2R =  0b0011100_11101;

    ENCODING
            Opcode7b5 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = `Register@RZ;
            Bconst = 0xFFFF;
            Byte = B3B0;
            CCPR = CCPR;
            !NencP2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "R2P"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
            CCPR:Pr
            ',' $( Register:Ra /B3B0(B0):extract {/REUSE(noreuse):reuse_src_a} )$
            ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (Pr==`CCPR@CC);


    OPCODES
        R2Pfxu_pipe =  0b0101110011110;
        R2P =  0b0101110011110;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            RegB = Rb;
            Byte = B3B0;
            CCPR = CCPR;
            !NencP2R;
            !Dest;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_R2P"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
            CCPR:Pr
            ',' $( Register:Ra /B3B0(B0):extract {/REUSE(noreuse):reuse_src_a} )$
            ',' UImm(20/0xffff):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (Pr==`CCPR@CC);


    OPCODES
        R2Pfxu_pipe =  0b0011100_11110;
        R2P =  0b0011100_11110;

    ENCODING
            Opcode7b5 = Opcode;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Byte = B3B0;
            CCPR = CCPR;
            !NencP2R;
            !Dest;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_R2P"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
            CCPR:Pr
            ',' $( Register:Ra /B3B0(B0):extract {/REUSE(noreuse):reuse_src_a} )$

',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (Pr==`CCPR@CC);


    OPCODES
        R2Pfxu_pipe =  0b0100110011110;
        R2P =  0b0100110011110;

    ENCODING
            Opcode13 = Opcode;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            Byte = B3B0;
            CCPR = CCPR;
            !NencP2R;
            !Dest;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "CSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' CC:dummyCC
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));


    OPCODES
        CSETfxu_pipe =  0b0101000010011;
        CSET =  0b0101000010011;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            CCC_2 = CCTest;
            SrcPred = Pa;
            SrcNot = Pa@not;
            BVal = BVal;
            Bop = bopopt;
            !NencCSET;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_CSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' CC:dummyCC

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));


    OPCODES
        CSETfxu_pipe =  0b0101000010011;
        CSET =  0b0101000010011;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            CCC_2 = CCTest;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            BVal = BVal;
            Bop = `Bop@AND;
            !NencCSET;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "CSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest /Bop:bopopt
            Predicate:Pd
            ',' Predicate:nPd
            ',' CC:inputCC
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));


    OPCODES
        CSETPfxu_pipe =  0b0101000010100;
        CSETP =  0b0101000010100;


    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            CCC_2 = CCTest;
            SrcPred = Pa;
            SrcNot = Pa@not;
            Bop = bopopt;
            !NencCSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_CSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest
            Predicate:Pd
            ',' CC:inputCC

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS



    PROPERTIES

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));


    OPCODES
        CSETPfxu_pipe =  0b0101000010100;
        CSETP =  0b0101000010100;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            CCC_2 = CCTest;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            Bop = `Bop@AND;
            !NencCSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "PSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0 /Bop:bopopt
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' [!]Predicate:Pc
            ',' [!]Predicate:Pb
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bop0 != `Bop@INVALIDBOP03):
                "Invalid Bop (bop0) field value INVALIDBOP03"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        PSETfxu_pipe =  0b0101000010001;
        PSET =  0b0101000010001;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Src2Pred = Pc;
            Src2Not = Pc@not;
            Src1Pred = Pb;
            Src1Not = Pb@not;
            SrcPred = Pa;
            SrcNot = Pa@not;
            Bop0 = bop0;
            Bop = bopopt;
            BVal = BVal;
            !NencPSET;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





ALTERNATE CLASS "NoBop_PSET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0
            $( RegisterFAU:Rd /optCC(noCC):writeCC )$
            ',' [!]Predicate:Pc
            ',' [!]Predicate:Pb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bop0 != `Bop@INVALIDBOP03):
                "Invalid Bop (bop0) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        PSETfxu_pipe =  0b0101000010001;
        PSET =  0b0101000010001;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            WriteCC = writeCC;
            Src2Pred = Pc;
            Src2Not = Pc@not;
            Src1Pred = Pb;
            Src1Not = Pb@not;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            Bop0 = bop0;
            Bop = `Bop@AND;
            BVal = BVal;
            !NencPSET;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "PSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0 /Bop:bopopt
            Predicate:Pd
            ',' Predicate:nPd
            ',' [!]Predicate:Pc
            ',' [!]Predicate:Pb
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (bop0 != `Bop@INVALIDBOP03):
                "Invalid Bop (bop0) field value INVALIDBOP03"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        PSETPfxu_pipe =  0b0101000010010;
        PSETP =  0b0101000010010;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = nPd;
            Src2Pred = Pc;
            Src2Not = Pc@not;
            Src1Pred = Pb;
            Src1Not = Pb@not;
            SrcPred = Pa;
            SrcNot = Pa@not;
            Bop0 = bop0;
            Bop = bopopt;
            !NencPSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_PSETP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0
            Predicate:Pd
            ',' [!]Predicate:Pc
            ',' [!]Predicate:Pb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (bop0 != `Bop@INVALIDBOP03):
                "Invalid Bop (bop0) field value INVALIDBOP03"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        PSETPfxu_pipe =  0b0101000010010;
        PSETP =  0b0101000010010;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            PDest = Pd;
            PNDest = `Predicate@PT;
            Src2Pred = Pc;
            Src2Not = Pc@not;
            Src1Pred = Pb;
            Src1Not = Pb@not;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            Bop0 = bop0;
            Bop = `Bop@AND;
            !NencPSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;





    CLASS "STP"

    FORMAT Opcode /STPMode(noWAIT):stpmode /TPhase(noPhase):phase UImm(8):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_STP_INDEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 20;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        STPmio_pipe =  0b111_01110_10100;
        STP =  0b111_01110_10100;

    ENCODING
      Opcode13 = Opcode;
      STPMode = STPMode;
      Imm8 = uImm;

      !NencSTP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "TEX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD(noLOD):lod /LC(noLC):lc /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd ','
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
             UImm(13):tid ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

                ILLEGAL_INSTR_ENCODING_ERROR (DC == `DC@DC) -> (ParamA != `ParamA@"_3D") :
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD4):
                "Invalid LOD (lod) field value INVALIDBLOD4"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD5):
                "Invalid LOD (lod) field value INVALIDBLOD5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) )) * 32;
         ISRC_B_SIZE = (( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXmio_pipe =  0b11000;
        TEX =  0b11000;

    ENCODING
      Opcode5 = Opcode;
      LC = lc;
      PredDst = Pd;
      TidB = tid;
      LOD = LOD;
      AOFFI = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 ALTERNATE CLASS "TEX_legacy_style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD(noLOD):lod /LC(noLC):lc /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd ','
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
             UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

                ILLEGAL_INSTR_ENCODING_ERROR (DC == `DC@DC) -> (ParamA != `ParamA@"_3D") :
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD4):
                "Invalid LOD (lod) field value INVALIDBLOD4"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD5):
                "Invalid LOD (lod) field value INVALIDBLOD5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) )) * 32;
         ISRC_B_SIZE = (( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXmio_pipe =  0b11000;
        TEX =  0b11000;

    ENCODING
      Opcode5 = Opcode;
      LC = lc;
      PredDst = Pd;
      TidBTEX = tid;
      TidBSAMP = smp;
      LOD = LOD;
      AOFFI = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TEX_B"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /LOD(noLOD):lod /LC(noLC):lc /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd ','
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
             UImm(13)@:tid ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

                ILLEGAL_INSTR_ENCODING_ERROR (DC == `DC@DC) -> (ParamA != `ParamA@"_3D") :
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD4):
                "Invalid LOD (lod) field value INVALIDBLOD4"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD5):
                "Invalid LOD (lod) field value INVALIDBLOD5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"



    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) )) * 32;
         ISRC_B_SIZE = ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1)) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXmio_pipe =  0b1101111010;
        TEX =  0b1101111010;

    ENCODING
      Opcode10 = Opcode;
      LCB = lc;
      PredDst = Pd;
      LODB = LOD;
      AOFFIB = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !NencTEXB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 ALTERNATE CLASS "TEX_B_legacy_style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /LOD(noLOD):lod /LC(noLC):lc /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd ','
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
             UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;
    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

                ILLEGAL_INSTR_ENCODING_ERROR (DC == `DC@DC) -> (ParamA != `ParamA@"_3D") :
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD4):
                "Invalid LOD (lod) field value INVALIDBLOD4"

            ILLEGAL_INSTR_ENCODING_ERROR
                (lod != `LOD@INVALIDBLOD5):
                "Invalid LOD (lod) field value INVALIDBLOD5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"



    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (((ParamA == `ParamA@"_1D") || (ParamA == `ParamA@RECT) || (ParamA == `ParamA@CUBE) || (ParamA == `ParamA@"_3D")) && (LC==`LC@LC)) )) * 32;
         ISRC_B_SIZE = ((( (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )+1)) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXmio_pipe =  0b1101111010;
        TEX =  0b1101111010;

    ENCODING
      Opcode10 = Opcode;
      LCB = lc;
      PredDst = Pd;
      LODB = LOD;
      AOFFIB = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !NencTEXB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "TEXS_RZ"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD2(noLOD):lod /DC(noDC):dc /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             ZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk2C:wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

      ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (LOD2 == `LOD2@LZ):
                "Illegal instruction encoding: 1D is only supported with LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 1D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"ARRAY_2D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: Array 2D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((ParamA == `ParamA@"ARRAY_2D") && (LOD2 == `LOD2@noLOD)) -> (DC!=`DC@DC) :
                "Illegal instruction encoding: Array 2D with noLOD only supports noDC set"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 3D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: 3D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (DC == `DC@noDC):
                "Illegal instruction encoding: CUBE is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (LOD2 != `LOD2@LZ):
                "Illegal instruction encoding: CUBE does not support the LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,dc) for TEXS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
      MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Ra%2==0)):
                "Misaligned Ra register  in TEXS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Rb%2==0)):
                "Misaligned Rb register  in TEXS"
      MISALIGNED_REG_ERROR
          ((( ( (wmsk == `TEXWmsk2C@R ) * 32 ) + ( (wmsk == `TEXWmsk2C@G ) * 32 ) + ( (wmsk == `TEXWmsk2C@B ) * 32 ) + ( (wmsk == `TEXWmsk2C@A ) * 32 ) + ( (wmsk == `TEXWmsk2C@RG ) * 64 ) + ( (wmsk == `TEXWmsk2C@RA ) * 64 ) + ( (wmsk == `TEXWmsk2C@GA ) * 64 ) + ( (wmsk == `TEXWmsk2C@BA ) * 64 ) ) == 64) -> ((Rd == `Register@RZ)||(Rd%2==0))):
          "Misaligned Rd register in TEXS"
      OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TEXS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TEXS"
      OOR_REG_ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-( ( (wmsk == `TEXWmsk2C@R ) * 32 ) + ( (wmsk == `TEXWmsk2C@G ) * 32 ) + ( (wmsk == `TEXWmsk2C@B ) * 32 ) + ( (wmsk == `TEXWmsk2C@A ) * 32 ) + ( (wmsk == `TEXWmsk2C@RG ) * 64 ) + ( (wmsk == `TEXWmsk2C@RA ) * 64 ) + ( (wmsk == `TEXWmsk2C@GA ) * 64 ) + ( (wmsk == `TEXWmsk2C@BA ) * 64 ) )/32))) :
          "Register Rd is out of range in TEXS"






    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( ( (wmsk == `TEXWmsk2C@R ) * 32 ) + ( (wmsk == `TEXWmsk2C@G ) * 32 ) + ( (wmsk == `TEXWmsk2C@B ) * 32 ) + ( (wmsk == `TEXWmsk2C@A ) * 32 ) + ( (wmsk == `TEXWmsk2C@RG ) * 64 ) + ( (wmsk == `TEXWmsk2C@RA ) * 64 ) + ( (wmsk == `TEXWmsk2C@GA ) * 64 ) + ( (wmsk == `TEXWmsk2C@BA ) * 64 ) );
         IDEST2_SIZE = (0);
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXSmio_pipe =  0b1101100;
        TEXS =  0b1101100;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tex2D4(paramA,dc,lod);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TEXS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD2(noLOD):lod /DC(noDC):dc /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             NonZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk34C(RGBA/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (LOD2 == `LOD2@LZ):
                "Illegal instruction encoding: 1D is only supported with LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 1D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"ARRAY_2D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: Array 2D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((ParamA == `ParamA@"ARRAY_2D") && (LOD2 == `LOD2@noLOD)) -> (DC!=`DC@DC) :
                "Illegal instruction encoding: Array 2D with noLOD only supports noDC set"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 3D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: 3D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (DC == `DC@noDC):
                "Illegal instruction encoding: CUBE is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (LOD2 != `LOD2@LZ):
                "Illegal instruction encoding: CUBE does not support the LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,dc) for TEXS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
        MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Ra%2==0)):
                "Misaligned Ra register  in TEXS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Rb%2==0)):
                "Misaligned Rb register  in TEXS"
        MISALIGNED_REG_ERROR
            ((( ( (wmsk == `TEXWmsk34C@RGB ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@GBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGBA) * 64 ) ) == 64) -> ((Rd2 == `Register@RZ)||(Rd2%2==0))):
            "Misaligned Rd2 register in TEXS"
        MISALIGNED_REG_ERROR
            ((Rd == `Register@RZ)||(Rd%2==0)):
            "Misaligned Rd register in TEXS"
        OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TEXS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TEXS"
        OOR_REG_ERROR
            ((((Rd2)==`Register@RZ)||((Rd2)<=%MAX_REG_COUNT-( ( (wmsk == `TEXWmsk34C@RGB ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@GBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGBA) * 64 ) )/32))) :
            "Register Rd2 is out of range in TEXS"
        OOR_REG_ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-64/32))) :
            "Register Rd is out of range in TEXS"





    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (64);
         IDEST2_SIZE = ( ( (wmsk == `TEXWmsk34C@RGB ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@GBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGBA) * 64 ) );
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXSmio_pipe =  0b1101100;
        TEXS =  0b1101100;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tex2D4(paramA,dc,lod);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TEXS_F16_RZ"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Float16:f16 /LOD2(noLOD):lod /DC(noDC):dc /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             ZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk2C:wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

      ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (LOD2 == `LOD2@LZ):
                "Illegal instruction encoding: 1D is only supported with LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 1D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"ARRAY_2D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: Array 2D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((ParamA == `ParamA@"ARRAY_2D") && (LOD2 == `LOD2@noLOD)) -> (DC!=`DC@DC) :
                "Illegal instruction encoding: Array 2D with noLOD only supports noDC set"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 3D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: 3D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (DC == `DC@noDC):
                "Illegal instruction encoding: CUBE is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (LOD2 != `LOD2@LZ):
                "Illegal instruction encoding: CUBE does not support the LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,dc) for TEXS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
      MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Ra%2==0)):
                "Misaligned Ra register  in TEXS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Rb%2==0)):
                "Misaligned Rb register  in TEXS"
      OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TEXS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TEXS"
      OOR_REG_ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-32/32))) :
          "Register Rd is out of range in TEXS"






    PROPERTIES
        SIDL_NAME = `SIDL_NAMES@TEXS16;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (32);
         IDEST2_SIZE = (0);
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXSmio_pipe =  0b1101000;
        TEXS =  0b1101000;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tex2D4(paramA,dc,lod);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TEXS_F16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Float16:f16 /LOD2(noLOD):lod /DC(noDC):dc /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             NonZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk34C(RGBA/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (LOD2 == `LOD2@LZ):
                "Illegal instruction encoding: 1D is only supported with LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"1D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 1D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"ARRAY_2D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: Array 2D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((ParamA == `ParamA@"ARRAY_2D") && (LOD2 == `LOD2@noLOD)) -> (DC!=`DC@DC) :
                "Illegal instruction encoding: Array 2D with noLOD only supports noDC set"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (DC == `DC@noDC):
                "Illegal instruction encoding: 3D is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@"3D") -> (LOD2 != `LOD2@LL):
                "Illegal instruction encoding: 3D does not support the LL LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (DC == `DC@noDC):
                "Illegal instruction encoding: CUBE is only supported with the no DC option"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA == `ParamA@CUBE) -> (LOD2 != `LOD2@LZ):
                "Illegal instruction encoding: CUBE does not support the LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,dc) for TEXS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (ParamA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
        MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Ra%2==0)):
                "Misaligned Ra register  in TEXS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ) == 64 ) -> (Rb%2==0)):
                "Misaligned Rb register  in TEXS"
        OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TEXS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TEXS"
        OOR_REG_ERROR
            ((((Rd2)==`Register@RZ)||((Rd2)<=%MAX_REG_COUNT-32/32))) :
            "Register Rd2 is out of range in TEXS"
        OOR_REG_ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-32/32))) :
            "Register Rd is out of range in TEXS"





    PROPERTIES
        SIDL_NAME = `SIDL_NAMES@TEXS16;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (32);
         IDEST2_SIZE = (32);
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 64 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 0 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LL) ) && (dc == `DC@DC ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@DC ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD2@LZ) ) && (dc == `DC@DC) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD2@LZ) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@noLOD) ) && (dc == `DC@noDC) ) * 32 ) + ( ( ( (paramA == `ParamA@"CUBE" ) && (lod == `LOD2@LL) ) && (dc == `DC@noDC) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TEXSmio_pipe =  0b1101000;
        TEXS =  0b1101000;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tex2D4(paramA,dc,lod);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "TLDS_RZ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             ZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk2C:wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

      MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Ra%2==0)) :
                "Misaligned Ra register  in TLDS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Rb%2==0)) :
                "Misaligned Rb register  in TLDS"
      MISALIGNED_REG_ERROR
        ((( ( (wmsk == `TEXWmsk2C@R ) * 32 ) + ( (wmsk == `TEXWmsk2C@G ) * 32 ) + ( (wmsk == `TEXWmsk2C@B ) * 32 ) + ( (wmsk == `TEXWmsk2C@A ) * 32 ) + ( (wmsk == `TEXWmsk2C@RG ) * 64 ) + ( (wmsk == `TEXWmsk2C@RA ) * 64 ) + ( (wmsk == `TEXWmsk2C@GA ) * 64 ) + ( (wmsk == `TEXWmsk2C@BA ) * 64 ) ) == 64) -> ((Rd==`Register@RZ)||(Rd%2==0))):
            "Misaligned Rd register in TLDS"
      ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,toff,ms) for TLDS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
      OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TLDS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TLDS"
      OOR_REG_ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-( ( (wmsk == `TEXWmsk2C@R ) * 32 ) + ( (wmsk == `TEXWmsk2C@G ) * 32 ) + ( (wmsk == `TEXWmsk2C@B ) * 32 ) + ( (wmsk == `TEXWmsk2C@A ) * 32 ) + ( (wmsk == `TEXWmsk2C@RG ) * 64 ) + ( (wmsk == `TEXWmsk2C@RA ) * 64 ) + ( (wmsk == `TEXWmsk2C@GA ) * 64 ) + ( (wmsk == `TEXWmsk2C@BA ) * 64 ) )/32))) :
          "Register Rd is out of range in TLDS"





    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( ( (wmsk == `TEXWmsk2C@R ) * 32 ) + ( (wmsk == `TEXWmsk2C@G ) * 32 ) + ( (wmsk == `TEXWmsk2C@B ) * 32 ) + ( (wmsk == `TEXWmsk2C@A ) * 32 ) + ( (wmsk == `TEXWmsk2C@RG ) * 64 ) + ( (wmsk == `TEXWmsk2C@RA ) * 64 ) + ( (wmsk == `TEXWmsk2C@GA ) * 64 ) + ( (wmsk == `TEXWmsk2C@BA ) * 64 ) );
         IDEST2_SIZE = (0);
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLDSmio_pipe =  0b1101101;
        TLDS =  0b1101101;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tld2D4(paramA, ms, lod, toff);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TLDS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             NonZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk34C(RGBA/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (wmsk != `TEXWmsk34C@INVALID5):
                "Invalid TEXWmsk34C (wmsk) field value INVALID5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (wmsk != `TEXWmsk34C@INVALID6):
                "Invalid TEXWmsk34C (wmsk) field value INVALID6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (wmsk != `TEXWmsk34C@INVALID7):
                "Invalid TEXWmsk34C (wmsk) field value INVALID7"

        MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Ra%2==0)) :
                "Misaligned Ra register  in TLDS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Rb%2==0)) :
                "Misaligned Rb register  in TLDS"
        MISALIGNED_REG_ERROR
            ((( ( (wmsk == `TEXWmsk34C@RGB ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@GBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGBA) * 64 ) ) == 64) -> ((Rd2==`Register@RZ)||(Rd2%2==0))):
            "Misaligned Rd2 register in TLDS"
        MISALIGNED_REG_ERROR
        ((Rd==`Register@RZ)||(Rd%2==0)):
            "Misaligned Rd register in TLDS"
        ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,toff,ms) for TLDS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
        OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TLDS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TLDS"
        OOR_REG_ERROR
            ((((Rd2)==`Register@RZ)||((Rd2)<=%MAX_REG_COUNT-( ( (wmsk == `TEXWmsk34C@RGB ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@GBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGBA) * 64 ) )/32))) :
            "Register Rd2 is out of range in TLDS"
        OOR_REG_ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-64/32))) :
            "Register Rd is out of range in TLDS"





    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (64);
         IDEST2_SIZE = ( ( (wmsk == `TEXWmsk34C@RGB ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@GBA ) * 32 ) + ( (wmsk == `TEXWmsk34C@RGBA) * 64 ) );
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLDSmio_pipe =  0b1101101;
        TLDS =  0b1101101;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tld2D4(paramA, ms, lod, toff);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TLDS_F16_RZ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Float16:f16 /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             ZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk2C:wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

      MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Ra%2==0)) :
                "Misaligned Ra register  in TLDS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Rb%2==0)) :
                "Misaligned Rb register  in TLDS"
      ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,toff,ms) for TLDS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
      OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TLDS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TLDS"
      OOR_REG_ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-32/32))) :
          "Register Rd is out of range in TLDS"





    PROPERTIES
        SIDL_NAME = `SIDL_NAMES@TLDS16;
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (32);
         IDEST2_SIZE = (0);
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLDSmio_pipe =  0b1101001;
        TLDS =  0b1101001;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tld2D4(paramA, ms, lod, toff);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TLDS_F16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Float16:f16 /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             NonZeroRegister:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register(RZ):Rb
             ',' UImm(13):tid
             ',' ParamA:paramA
             ',' TEXWmsk34C(RGBA/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (wmsk != `TEXWmsk34C@INVALID5):
                "Invalid TEXWmsk34C (wmsk) field value INVALID5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (wmsk != `TEXWmsk34C@INVALID6):
                "Invalid TEXWmsk34C (wmsk) field value INVALID6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (wmsk != `TEXWmsk34C@INVALID7):
                "Invalid TEXWmsk34C (wmsk) field value INVALID7"

        MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Ra%2==0)) :
                "Misaligned Ra register  in TLDS"

                MISALIGNED_REG_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 64 ) -> (Rb%2==0)) :
                "Misaligned Rb register  in TLDS"
        ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR (( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) ) ) == 1):
                "Illegal instruction encoding: Invalid combination of (paramA,lod,toff,ms) for TLDS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((( ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (ParamA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (ParamA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (ParamA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ) == 0 ) -> (Rb == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
        OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TLDS"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TLDS"
        OOR_REG_ERROR
            ((((Rd2)==`Register@RZ)||((Rd2)<=%MAX_REG_COUNT-32/32))) :
            "Register Rd2 is out of range in TLDS"
        OOR_REG_ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-32/32))) :
            "Register Rd is out of range in TLDS"





    PROPERTIES
        SIDL_NAME = `SIDL_NAMES@TLDS16;
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (32);
         IDEST2_SIZE = (32);
         ISRC_A_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 0 ) + ( ( ( (paramA == `ParamA@"1D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@MS ) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"3D" ) && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 32 ) + ( ( ( (paramA == `ParamA@"ARRAY_2D") && (lod == `LOD1@LZ) && (toff == `TOFF1@noTOFF) && (ms == `MS@noMS) ) ) * 64 ) + ( ( ( (paramA == `ParamA@"2D" ) && (lod == `LOD1@LL) && (toff == `TOFF1@AOFFI ) && (ms == `MS@noMS) ) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLDSmio_pipe =  0b1101001;
        TLDS =  0b1101001;

    ENCODING
      Opcode7 = Opcode;
      tex2d_4 = Tld2D4(paramA, ms, lod, toff);
      Wmsk3 = wmsk;
      NODEP = NODEP;
      TidB = tid;
      Dest2 =* Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
  CLASS "TLD4S"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /TOFF1(noTOFF):toff /DC(noDC):dc /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register:Rb
             ',' UImm(13):tid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

        MISALIGNED_REG_ERROR ((Rd==`Register@RZ)||(Rd%2==0)):
                "Misaligned Rd register in TLD4S"

                MISALIGNED_REG_ERROR ((Rd2==`Register@RZ)||(Rd2%2==0)):
                "Misaligned Rd2 register in TLD4S"

                MISALIGNED_REG_ERROR ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 64 ) -> (Ra%2==0)) :
                "Misaligned Ra register  in TLD4S"

                MISALIGNED_REG_ERROR ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 64 ) -> (Rb%2==0)) :
                "Misaligned Rb register  in TLD4S"
        ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_WARNING ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_WARNING ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
        OOR_REG_ERROR ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2))) :
                "Register Rd is out of range in TLD4S"

                OOR_REG_ERROR ((((Rd2)==`Register@RZ)||((Rd2)<=%MAX_REG_COUNT-2))) :
                "Register Rd2 is out of range in TLD4S"

                OOR_REG_ERROR ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ))/32)))) :
                "Register Ra is out of range in TLD4S"

                OOR_REG_ERROR ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ))/32)))) :
                "Register Rb is out of range in TLD4S"


    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         IDEST2_SIZE = 64;
         ISRC_A_SIZE = ( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLD4Smio_pipe =  0b1101111100;
        TLD4S =  0b1101111100;

    ENCODING
      Opcode10 = Opcode;
      TexComp2 = TexComp;
      AOFFI2 = toff;
      DC = DC;
      NODEP = NODEP;
      TidB = tid;
      Dest2 = Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  CLASS "TLD4S_F16"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /Float16:f16 /TexComp:tcomp /TOFF1(noTOFF):toff /DC(noDC):dc /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd2
             ',' Register:Rd
             ',' Register:Ra
             ',' Register:Rb
             ',' UImm(13):tid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

        MISALIGNED_REG_ERROR
            ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 64 ) -> (Ra%2==0)) :
            "Misaligned Ra register  in TLD4S"
        MISALIGNED_REG_ERROR
            ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 64 ) -> (Rb%2==0)) :
             "Misaligned Rb register  in TLD4S"
        ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) > 0 ) -> (Ra != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "

                ILLEGAL_INSTR_ENCODING_ERROR ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) > 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ "

                ILLEGAL_INSTR_ENCODING_WARNING ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 0 ) -> (Ra == `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Ra is == 0, then Ra must be RZ "

                ILLEGAL_INSTR_ENCODING_WARNING ((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ) == 0 ) -> (Rb != `Register@RZ)) :
                "Illegal instruction encoding: If the number of coordinates of Rb is == 0, then Rb must be RZ "
        OOR_REG_ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ))/32)))) :
            "Register Ra is out of range in TLD4S"
        OOR_REG_ERROR
            ((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) ))/32)))) :
            "Register Rb is out of range in TLD4S"
        OOR_REG_ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1))) :
            "Register Rd is out of range in TLD4S"
        OOR_REG_ERROR
            ((((Rd2)==`Register@RZ)||((Rd2)<=%MAX_REG_COUNT-1))) :
            "Register Rd2 is out of range in TLD4S"

    PROPERTIES
        SIDL_NAME = `SIDL_NAMES@TLD4S16;
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         IDEST2_OPERAND_MAP = (1<<INDEX(Rd2));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         IDEST2_SIZE = 32;
         ISRC_A_SIZE = ( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 64 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) );
         ISRC_B_SIZE = ( ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@noTOFF) && ( dc == `DC@DC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@noDC ) ) * 32 ) + ( ( (toff == `TOFF1@AOFFI ) && ( dc == `DC@DC ) ) * 64 ) );
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLD4Smio_pipe =  0b1101111110;
        TLD4S =  0b1101111110;

    ENCODING
      Opcode10 = Opcode;
      TexComp2 = TexComp;
      AOFFI2 = toff;
      DC = DC;
      NODEP = NODEP;
      TidB = tid;
      Dest2 = Rd2;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "TLD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms
             /CL(noCL):clamp /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(13):tid ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@CUBE):
                "Illegal instruction encoding: CUBE is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_CUBE) :
                "Illegal instruction encoding: ARRAY_3D is not supported"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: ARRAY_CUBE is not supported"

                ILLEGAL_INSTR_ENCODING_ERROR (MS == `MS@MS) -> (LOD1 == `LOD1@LZ):
                "Illegal instruction encoding: .MS can only be used with the .LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (MS == `MS@MS) -> (CL != `CL@CL):
                "Illegal instruction encoding: .MS can not be used with the CL option"

                ILLEGAL_INSTR_ENCODING_ERROR (MS == `MS@MS) -> (ParamA == `ParamA@"2D" || ParamA == `ParamA@ARRAY_2D):
                "Illegal instruction encoding: .MS can only be used with 2D/ARRAY_2D textures"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = (( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLDmio_pipe =  0b110_11100;
        TLD =  0b110_11100;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB = tid;
      Wmsk = wmsk;
      LOD1 = LOD1;
      TOFF1 = TOFF1;
      MS = MS;
      CL = CL;
      NODEP = NODEP;
      PredDst = Pd;
      ParamA = ParamA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "TLD_B"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms
             /CL(noCL):clamp /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(13)@:tid
             ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;



    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) )+1) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) )+1) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) )+1))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@CUBE):
                "Illegal instruction encoding: CUBE is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_CUBE) :
                "Illegal instruction encoding: ARRAY_3D is not supported"

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: ARRAY_CUBE is not supported"

                ILLEGAL_INSTR_ENCODING_ERROR (MS == `MS@MS) -> (LOD1 == `LOD1@LZ):
                "Illegal instruction encoding: .MS can only be used with the .LZ LOD option"

                ILLEGAL_INSTR_ENCODING_ERROR (MS == `MS@MS) -> (CL != `CL@CL):
                "Illegal instruction encoding: .MS can not be used with the CL option"

                ILLEGAL_INSTR_ENCODING_ERROR (MS == `MS@MS) -> (ParamA == `ParamA@"2D" || ParamA == `ParamA@ARRAY_2D):
                "Illegal instruction encoding: .MS can only be used with 2D/ARRAY_2D textures"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) )+1) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = ((( (TOFF1 == `TOFF1@AOFFI) + ( MS == `MS@MS) + (LOD1 == `LOD1@LL) )+1)) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLDmio_pipe =  0b110_11101;
        TLD =  0b110_11101;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !NencTLDB;
      Wmsk = wmsk;
      LOD1 = LOD1;
      TOFF1 = TOFF1;
      MS = MS;
      CL = CL;
      NODEP = NODEP;
      PredDst = Pd;
      ParamA = paramA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
  CLASS "TLD4"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(13):tid ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (toff != `TOFF2@INVALIDBTOFF03):
                "Invalid TOFF2 (toff) field value INVALIDBTOFF03"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: PTP is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"1D") :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_1D) :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: 3D is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = (( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLD4mio_pipe =  0b11001;
        TLD4 =  0b11001;

    ENCODING
      Opcode5 = Opcode;
      LC = 0;
      PredDst = Pd;
      TidB = tid;
      TexComp = TexComp;
      TOFF2 = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = paramA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  CLASS "TLD4_B"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /BOnly:b /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(13)@:tid ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (toff != `TOFF2@INVALIDBTOFF03):
                "Invalid TOFF2 (toff) field value INVALIDBTOFF03"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: PTP is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"1D") :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_1D) :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: 3D is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1)) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLD4mio_pipe =  0b11011_11011;
        TLD4 =  0b11011_11011;

    ENCODING
      Opcode10 = Opcode;
      LCB = 0;
      PredDst = Pd;
      TexCompB = TexComp;
      TOFF2B = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = paramA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !NencTEXB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TLD4_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (toff != `TOFF2@INVALIDBTOFF03):
                "Invalid TOFF2 (toff) field value INVALIDBTOFF03"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: PTP is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"1D") :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_1D) :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: 3D is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = (( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLD4mio_pipe =  0b11001;
        TLD4 =  0b11001;

    ENCODING
      Opcode5 = Opcode;
      LC = 0;
      PredDst = Pd;
      TidBTEX = tid;
      TidBSAMP = smp;
      TexComp = TexComp;
      TOFF2 = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TLD4_B_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /BOnly:b /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (toff != `TOFF2@INVALIDBTOFF03):
                "Invalid TOFF2 (toff) field value INVALIDBTOFF03"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: PTP is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)) :
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"1D") :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_1D) :
                "Illegal instruction encoding: 1D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (ParamA != `ParamA@ARRAY_3D) :
                "Illegal instruction encoding: 3D is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = ((( (TOFF2 == `TOFF2@AOFFI ) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )+1)) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TLD4mio_pipe =  0b11011_11011;
        TLD4 =  0b11011_11011;

    ENCODING
      Opcode10 = Opcode;
      LCB = 0;
      PredDst = Pd;
      TexCompB = TexComp;
      TOFF2B = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !NencTEXB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
  CLASS "TMML"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' Register(RZ)@:Rb
             ',' UImm(13):tid ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (0 > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (0 == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-0)) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR ((ParamA != `ParamA@ARRAY_3D)) :
                "Illegal instruction encoding: ARRAY_3D is not supported "



        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((0 >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = (0) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TMMLmio_pipe =  0b110_11111_01011;
        TMML =  0b110_11111_01011;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidB = tid;
      NDV = NDV;
      Wmsk = wmsk;
      ParamA = ParamA;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      !NencTMML;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;





  ALTERNATE CLASS "TMML_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' Register(RZ)@:Rb
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (0 > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (0 == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-0)) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR ((ParamA != `ParamA@ARRAY_3D)) :
                "Illegal instruction encoding: ARRAY_3D is not supported "



        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((0 >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = (0) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TMMLmio_pipe =  0b110_11111_01011;
        TMML =  0b110_11111_01011;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidBTEX = tid;
      TidBSAMP = smp;
      NDV = NDV;
      Wmsk = wmsk;
      ParamA = ParamA;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      !NencTMML;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;





  CLASS "TMML_B"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(13)@:tid ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((0 +1) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((0 +1) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(0 +1))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR ((ParamA != `ParamA@ARRAY_3D)) :
                "Illegal instruction encoding: ARRAY_3D is not supported "



        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((0 +1) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = ((0 +1)) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TMMLmio_pipe =  0b110_11111_01100;
        TMML =  0b110_11111_01100;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      NDV = NDV;
      Wmsk = wmsk;
      ParamA = ParamA;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !NencTMMLB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;





  ALTERNATE CLASS "TMML_B_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((0 +1) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((0 +1) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(0 +1))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR ((ParamA != `ParamA@ARRAY_3D)) :
                "Illegal instruction encoding: ARRAY_3D is not supported "



        ILLEGAL_INSTR_ENCODING_ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((0 +1) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )) * 32;
         ISRC_B_SIZE = ((0 +1)) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TMMLmio_pipe =  0b110_11111_01100;
        TMML =  0b110_11111_01100;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      NDV = NDV;
      Wmsk = wmsk;
      ParamA = ParamA;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !NencTMMLB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
  CLASS "TXD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LC(noLC):lc /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(13):tid ',' ParamA:paramA
             ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@CUBE) :
                "Illegal instruction encoding: Cube is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_3D) :
                "(Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_CUBE) :
                "Illegal instruction encoding: Cube is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ( ( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )) * 32;
         ISRC_B_SIZE = ( ( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXDmio_pipe =  0b11011_11000;
        TXD =  0b11011_11000;

    ENCODING
      Opcode10 = Opcode;
      PredDst = Pd;
      LCD = lc;
      NODEP = NODEP;
      TidB = tid;
      TOFF1 = TOFF1;
      Wmsk = wmsk;
      ParamA = ParamA;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXD_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LC(noLC):lc /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA
             ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@CUBE) :
                "Illegal instruction encoding: Cube is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_3D) :
                "(Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_CUBE) :
                "Illegal instruction encoding: Cube is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) ) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ( ( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )) * 32;
         ISRC_B_SIZE = ( ( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXDmio_pipe =  0b11011_11000;
        TXD =  0b11011_11000;

    ENCODING
      Opcode10 = Opcode;
      PredDst = Pd;
      LCD = lc;
      NODEP = NODEP;
      TidBTEX = tid;
      TidBSAMP = smp;
      TOFF1 = TOFF1;
      Wmsk = wmsk;
      ParamA = ParamA;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  CLASS "TXD.B"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /LC(noLC):lc /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(13)@:tid ',' ParamA:paramA
             ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                ((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@CUBE) :
                "Illegal instruction encoding: Cube is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_3D) :
                "(Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_CUBE) :
                "Illegal instruction encoding: Cube is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            (((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ( (( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1)) * 32;
         ISRC_B_SIZE = ( ( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXDmio_pipe =  0b11011_11001;
        TXD =  0b11011_11001;

    ENCODING
      Opcode10 = Opcode;
      PredDst = Pd;
      LCD = lc;
      NODEP = NODEP;
      TOFF1 = TOFF1;
      Wmsk = wmsk;
      ParamA = ParamA;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !TidB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXD_B_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /LC(noLC):lc /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Predicate(PT):Pd
             ',' Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA
             ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                ((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1) > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                ((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1))) :
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) > 2 ) -> ((((Rb)+((Rb)==255)) & 0x3) == 0) :
                "Register B should be aligned to 4 if the number of coordinates is > 2"

            MISALIGNED_REG_ERROR
                (( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) == 2) -> ((((Rb)+((Rb)==255)) & 0x1) == 0) :
                "Register B should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ))) :
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@CUBE) :
                "Illegal instruction encoding: Cube is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@"3D") :
                "Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_3D) :
                "(Illegal instruction encoding: 3D is not supported "

                ILLEGAL_INSTR_ENCODING_ERROR (paramA != `ParamA@ARRAY_CUBE) :
                "Illegal instruction encoding: Cube is not supported "

        ILLEGAL_INSTR_ENCODING_ERROR
            (((( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) ) >0 ) -> (Rb != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Rb is > 0, then Rb cannot be RZ"
    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ( (( ((ParamA == `ParamA@"1D")*1) + ((ParamA == `ParamA@"2D")*2 ) + (((ParamA == `ParamA@"1D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + (((ParamA == `ParamA@"2D")&&((TOFF1 == `TOFF1@AOFFI) || (LC == `LC@LC)))) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*3) )+1)) * 32;
         ISRC_B_SIZE = ( ( ((ParamA == `ParamA@"1D")*2) + ((ParamA == `ParamA@"2D")*4 ) + ((ParamA == `ParamA@"ARRAY_1D")*2) + ((ParamA == `ParamA@"ARRAY_2D")*4) )) * 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXDmio_pipe =  0b11011_11001;
        TXD =  0b11011_11001;

    ENCODING
      Opcode10 = Opcode;
      PredDst = Pd;
      LCD = lc;
      NODEP = NODEP;
      TOFF1 = TOFF1;
      Wmsk = wmsk;
      ParamA = ParamA;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !TidB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
  CLASS "TXQ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' TXQMode:query
             ',' UImm(13):tid ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"

        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01001;
        TXQ =  0b110_11111_01001;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidB = tid;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(TXQMode);

      !NencTXQ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXQ_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' TXQMode:query
             ',' UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01001;
        TXQ =  0b110_11111_01001;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(TXQMode);

      !NencTXQ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXQ_Imm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' UImm(5):query
             ',' UImm(13):tid ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01001;
        TXQ =  0b110_11111_01001;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidB = tid;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(query);

      !NencTXQ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXQ_Imm_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' UImm(5):query
             ',' UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = (((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01001;
        TXQ =  0b110_11111_01001;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(query);

      !NencTXQ;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  CLASS "TXQ_B"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' TXQMode:query
             ',' UImm(13)@:tid ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


        MISALIGNED_REG_ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        OOR_REG_ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "
    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1)) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01010;
        TXQ =  0b110_11111_01010;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(TXQMode);

      !NencTXQ;
      !TidB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXQ_B_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' TXQMode:query
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' UImm(4):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


        MISALIGNED_REG_ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        OOR_REG_ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "
    PROPERTIES SECONDARY;
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1)) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01010;
        TXQ =  0b110_11111_01010;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(TXQMode);

      !NencTXQ;
      !TidB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXQ_B_Imm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' UImm(5):query
             ',' UImm(13)@:tid ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


        MISALIGNED_REG_ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        OOR_REG_ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "







    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1)) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01010;
        TXQ =  0b110_11111_01010;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(query);

      !NencTXQ;
      !TidB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXQ_B_Imm_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:b /NODEP(noNODEP):ndp /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' UImm(5):query
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' UImm(4):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS


        MISALIGNED_REG_ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        OOR_REG_ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0) :
                "Register A should be aligned to 2 if the number of coordinates is == 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1))) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"


        ILLEGAL_INSTR_ENCODING_ERROR ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) :
                "Illegal instruction encoding: Queue mode not supported"

        ILLEGAL_INSTR_ENCODING_ERROR
            (((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1) >0 ) -> (Ra != `Register@RZ)) :
            "Illegal instruction encoding: If the number of coordinates of Ra is > 0, then Ra cannot be RZ "
    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = ((((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS))+1)) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXQmio_pipe =  0b110_11111_01010;
        TXQ =  0b110_11111_01010;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      Wmsk = wmsk;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TexQuery = TXQModeDim(query);

      !NencTXQ;
      !TidB;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
  CLASS "TXA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ',' UImm(13):tid ',' UImm(4/15/PRINT):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS




                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS) :
                "Can only be used with pixel shader"

        ILLEGAL_INSTR_ENCODING_ERROR
            (Ra != `Register@RZ) :
            "Ra cannot be RZ for TXA instruction"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (4 > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-4)) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = 128;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;



    OPCODES
        TXAmio_pipe =  0b110_11111_01000;
        TXA =  0b110_11111_01000;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidB = tid;
      NDV = NDV;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Wmsk = wmsk;

      !NencTXA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;



  ALTERNATE CLASS "TXA_Legacy_Style"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase
             Register:Rd ',' Register:Ra ','
             UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS



                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS) :
                "Can only be used with pixel shader"

        ILLEGAL_INSTR_ENCODING_ERROR
            (Ra != `Register@RZ) :
            "Ra cannot be RZ for TXA instruction"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0) :
                "Register D should be aligned to 4 if sz is greater than 64"

            MISALIGNED_REG_ERROR
                ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0) :
                "Register D should be aligned to 2 if sz is 64"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)))) :
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                (4 > 2 ) -> ((((Ra)+((Ra)==255)) & 0x3) == 0) :
                "Register A should be aligned to 4 if the number of coordinates is > 2"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-4)) :
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (phase != `TPhase@INVALIDPHASE3):
                "Invalid TPhase (phase) field value INVALIDPHASE3"




    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FLOAT);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = ( (((wmsk)&0x1) + ((wmsk>>1)&0x1) + ((wmsk>>2)&0x1) + ((wmsk>>3)&0x1)) ) * 32;
         ISRC_A_SIZE = 128;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        TXAmio_pipe =  0b110_11111_01000;
        TXA =  0b110_11111_01000;

    ENCODING
      Opcode13 = Opcode;
      NODEP = NODEP;
      TidBTEX = tid;
      TidBSAMP = smp;
      NDV = NDV;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Wmsk = wmsk;

      !NencTXA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OETexPhase = TPhase;
       !OEReserved;
   !OEReserved1;
CLASS "DEPBAR_LE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LEOnly:le Scoreboard:sbidx ',' UImm(6):cnt ',' BITSET(6/0x0000):dep_scbd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;



    CONDITIONS
        ILLEGAL_INSTR_ENCODING_ERROR
            ((dep_scbd & (1 << sbidx)) == 0):
            "In DEPBAR.LE s, m, S, the scoreboard s cannot be in the set of scorboards S"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        DEPBARfe_pipe =  0b1111000011110;
        DEPBAR =  0b1111000011110;

    ENCODING
      Opcode13 = Opcode;
      LE = 1;
      SBID = sbidx;
      PendCnt = cnt;
      Pred = Pg;
      PredNot = Pg@not;
      Imm6=dep_scbd;
      !NencDEPBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "DEPBAR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode BITSET(6/0x0000):dep_scbd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;



    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        DEPBARfe_pipe =  0b1111000011110;
        DEPBAR =  0b1111000011110;

    ENCODING
      Opcode13 = Opcode;
      LE = 0;
      !SBID;
      !PendCnt;
      Pred = Pg;
      PredNot = Pg@not;
      Imm6 = dep_scbd;
      !NencDEPBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



ALTERNATE CLASS "DEPBAR_ALL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ALLOnly:all

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        DEPBARfe_pipe =  0b1111000011110;
        DEPBAR =  0b1111000011110;

    ENCODING
      Opcode13 = Opcode;
      LE = 0;
      !SBID;
      !PendCnt;
      Pred = Pg;
      PredNot = Pg@not;
      Imm6 = 0b111111;
      !NencDEPBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;





CLASS "AL2P"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /AInteger("32"):size
            Predicate(PT):Pd
            ',' Register:Rd
            ',' NonZeroRegister:Ra
            ',' SImm(11/0):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS) :
                "Can't use instruction AL2P with shader type CS)"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS) + (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOGICAL_ATTR_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        AL2Pmio_pipe =  0b1110111110100;
        AL2P =  0b1110111110100;

    ENCODING
            Opcode13= Opcode;
            ALSize = AInteger;
            AIO = AIO;
            Imm11 = sImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA =* Ra;
            DstPred1 = Pd;
            !NencAL2P;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_AL2P"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /AInteger("32"):size
            Predicate(PT):Pd
            ',' Register:Rd
            ',' ZeroRegister(RZ):Ra
            ',' UImm(10/0):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS) :
                "Can't use instruction AL2P with shader type CS)"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS) + (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOGICAL_ATTR_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_ADU;


    OPCODES
        AL2Pmio_pipe =  0b1110111110100;
        AL2P =  0b1110111110100;

    ENCODING
            Opcode13 = Opcode;
            ALSize = AInteger;
            AIO = AIO;
            Imm10 = uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA = `Register@RZ;
            DstPred1 = Pd;
            !NencAL2P;
            !msbImm11;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "I_ALD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /AInteger("32"):size
             Register:Rd
             ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register(RZ):Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS) :
                "Can't use instruction ALD with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS) :
                "Can't use instruction ALD with shader type CS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_GS) -> (AIO != `AIO@O)) :
                "Can't use instruction ALD with shader type GS and .O modifier)"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_VSA || %SHADER_TYPE == $ST_VSB) -> (Rb == `Register@RZ)) :
                "Register B must be Rz when using with shader type VSa or VSb)"

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOGICAL_ATTR_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ALDmio_pipe =  0b1110111111011;
        ALD =  0b1110111111011;

    ENCODING
      Opcode13 = Opcode;
      AIO = AIO;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegBALD = Rb;
      Imm10 = uImm;
      ALSize = AInteger;

      !NencALD;
      !msbImm11;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_ALD_PATCH"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /POnly:p /AInteger("32"):size
             Register:Rd
             ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register(RZ):Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS) :
                "Can't use instruction ALD with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS) :
                "Can't use instruction ALD with shader type CS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_GS) -> (AIO != `AIO@O)) :
                "Can't use instruction ALD with shader type GS and .O modifier)"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_VSA || %SHADER_TYPE == $ST_VSB) -> (Rb == `Register@RZ)) :
                "Register B must be Rz when using with shader type VSa or VSb)" ILLEGAL_INSTR_ENCODING_ERROR
                (p == `POnly@P) -> (Rb == `Register@RZ) :
                ".P modifier can only be used with Rb equal to Rz"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (((p == `POnly@P) && (io == `AIO@O)) -> (%SHADER_TYPE == $ST_TI)) :
                ".P and .O modifier can only be used together when shader type is TI"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((p == `POnly@P) -> ((io == `AIO@O) || (%SHADER_TYPE == $ST_TS) || (%SHADER_TYPE == $ST_GS))) :
                ".P modifer can only be used with .O modifier or shader type TS or shader type GS"
            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PATCH_OFFSET_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ALDmio_pipe =  0b1110111111011;
        ALD =  0b1110111111011;

    ENCODING
      Opcode13 = Opcode;
      AIO = AIO;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegBALD = Rb;
      Imm10 = uImm;
      ALSize = AInteger;

      !NencALD;
      !msbImm11;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "ALD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /POnly:p /AInteger("32"):size
             Register:Rd
             ',' A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register(RZ):Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS) :
                "Can't use instruction ALD with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS) :
                "Can't use instruction ALD with shader type CS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_GS) -> (AIO != `AIO@O)) :
                "Can't use instruction ALD with shader type GS and .O modifier)"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_VSA || %SHADER_TYPE == $ST_VSB) -> (Rb == `Register@RZ)) :
                "Register B must be Rz when using with shader type VSa or VSb)" ILLEGAL_INSTR_ENCODING_ERROR
                (p == `POnly@P) -> (Rb == `Register@RZ) :
                ".P modifier can only be used with Rb equal to Rz"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (((p == `POnly@P) && (io == `AIO@O)) -> (%SHADER_TYPE == $ST_TI)) :
                ".P and .O modifier can only be used together when shader type is TI"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((p == `POnly@P) -> ((io == `AIO@O) || (%SHADER_TYPE == $ST_TS) || (%SHADER_TYPE == $ST_GS))) :
                ".P modifer can only be used with .O modifier or shader type TS or shader type GS"

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PATCH_OFFSET_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ALDmio_pipe =  0b1110111111011;
        ALD =  0b1110111111011;

    ENCODING
      Opcode13 = Opcode;
      AIO = AIO;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegBALD = Rb;
      Imm11 = sImm;
      ALSize = AInteger;

      !NencALD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "ALD_PHYS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /Phys:phys /AInteger("32"):size
             Register:Rd
             ',' A:srcAttr[NonZeroRegister:Ra]
             ',' Register(RZ):Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS) :
                "Can't use instruction ALD with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS) :
                "Can't use instruction ALD with shader type CS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_GS) -> (AIO != `AIO@O)) :
                "Can't use instruction ALD with shader type GS and .O modifier)"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_VSA || %SHADER_TYPE == $ST_VSB) -> (Rb == `Register@RZ)) :
                "Register B must be Rz when using with shader type VSa or VSb)"
        ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
            (Ra != `Register@RZ) :
            "Ra cannot be RZ for ALD.PHYS"

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PHYSICAL_ATTR_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ALDmio_pipe =  0b1110111111011;
        ALD =  0b1110111111011;

    ENCODING
      Opcode13 = Opcode;
      AIO = AIO;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegBALD = Rb;
      Imm11 = 0;
      ALSize = AInteger;

      !NencALD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "I_AST"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AInteger("32"):size
             A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register:Rb
             ',' Register(RZ):Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS):
                "Can't use with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS):
                "Can't use with shader type CS)"


        UNPREDICTABLE_BEHAVIOR_WARNING
                ((%SHADER_TYPE != $ST_GS)->(Rc==`Register@RZ)):
                "Unpredictable Behavior Warning: Rc must be RZ for AST in non Geometry Shaders"


            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOGICAL_ATTR_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ASTmio_pipe =  0b1110111111110;
        AST =  0b1110111111110;

    ENCODING
      Opcode13= Opcode;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegBAST = Rb;
      Imm10 = uImm;
      ALSize = AInteger;

      !AIO;
      !NencALD;
      !msbImm11;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_AST_PATCH"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /AInteger("32"):size
             A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register:Rb
             ',' Register(RZ):Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS):
                "Can't use with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS):
                "Can't use with shader type CS)"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((p==`POnly@P) -> (%SHADER_TYPE == $ST_TI)):
                ".P modifier can only be used with shader type TI"


        UNPREDICTABLE_BEHAVIOR_WARNING
                ((%SHADER_TYPE != $ST_GS)->(Rc==`Register@RZ)):
                "Unpredictable Behavior Warning: Rc must be RZ for AST in non Geometry Shaders"


            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PATCH_OFFSET_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ASTmio_pipe =  0b1110111111110;
        AST =  0b1110111111110;

    ENCODING
      Opcode13= Opcode;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegBAST = Rb;
      Imm10 = uImm;
      ALSize = AInteger;

      !AIO;
      !NencALD;
      !msbImm11;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "AST"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /AInteger("32"):size
             A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register:Rb
             ',' Register(RZ):Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS):
                "Can't use with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS):
                "Can't use with shader type CS)"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((p==`POnly@P) -> (%SHADER_TYPE == $ST_TI)):
                ".P modifier can only be used with shader type TI"


        UNPREDICTABLE_BEHAVIOR_WARNING
                ((%SHADER_TYPE != $ST_GS)->(Rc==`Register@RZ)):
                "Unpredictable Behavior Warning: Rc must be RZ for AST in non Geometry Shaders"


            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PATCH_OFFSET_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ASTmio_pipe =  0b1110111111110;
        AST =  0b1110111111110;

    ENCODING
      Opcode13 = Opcode;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegBAST = Rb;
      Imm11 = sImm;
      ALSize = AInteger;

      !NencALD;
      !AIO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "AST_PHYS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Phys:phys /AInteger("32"):size
             A:srcAttr[NonZeroRegister:Ra]
             ',' Register:Rb
             ',' Register(RZ):Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS):
                "Can't use with shader type PS"
                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_CS):
                "Can't use with shader type CS)"


        UNPREDICTABLE_BEHAVIOR_WARNING
                ((%SHADER_TYPE != $ST_GS)->(Rc==`Register@RZ)):
                "Unpredictable Behavior Warning: Rc must be RZ for AST in non Geometry Shaders"


            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % ARegAlignment(AInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
                "Register B is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PHYSICAL_ATTR_MISMATCH_ERROR)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PHYSICAL_ATTR_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==`AInteger@"32")*32) + ((size==`AInteger@"64")*64) + ((size==`AInteger@"96")*96) + ((size==`AInteger@"128")*128));
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ASTmio_pipe =  0b1110111111110;
        AST =  0b1110111111110;

    ENCODING
      Opcode13 = Opcode;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegBAST = Rb;
      Imm11 = 0;
      ALSize = AInteger;

      !NencALD;
      !AIO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "OUT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out
            Register:Rd
            ',' Register:Ra
            ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_GS):
                "must be used with GS shader"

            ILLEGAL_INSTR_ENCODING_ERROR
                (out == `OutType@CUT) -> (Rb ==`Register@RZ) :
                ".CUT modifier must be used with Rb as Rz"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (out != `OutType@INVALIDOUTSTYPE0):
                "Invalid OutType (out) field value INVALIDOUTSTYPE0"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = (1<<ISHADER_GS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        OUTmio_pipe =  0b1111101111100;
        OUT =  0b1111101111100;

    ENCODING
            Opcode13 = Opcode;
            RegA = Ra;
            RegB = Rb;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            OutType = OutType;
            !NencOUT;
            !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Imm_OUT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out
            Register:Rd
            ',' Register:Ra
            ',' SImm(20):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_GS):
                "must be used with GS shader"

            ILLEGAL_INSTR_ENCODING_ERROR
                out != `OutType@CUT :
                "with .CUT modifier can't be used with immediate"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (out != `OutType@INVALIDOUTSTYPE0):
                "Invalid OutType (out) field value INVALIDOUTSTYPE0"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = (1<<ISHADER_GS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        OUTmio_pipe =  0b1111011_11100;
        OUT =  0b1111011_11100;

    ENCODING
            Opcode7b5 = Opcode;
            RegA = Ra;
            Bconst=uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            OutType = OutType;
            !NencOUT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "Const_OUT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out
            Register:Rd
            ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_GS):
                "must be used with GS shader"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((out != `OutType@CUT)&&(out != `OutType@EMIT_THEN_CUT)) :
                "OUT.CUT/.EMIT_THEM_CUT cannot be used when Sb is constant with immediate address.  See Errate 24 in the ISA page of OUT"

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                0:
                "OUT with constat with immediate address for Sb is deprecated (Errata 24)"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (out != `OutType@INVALIDOUTSTYPE0):
                "Invalid OutType (out) field value INVALIDOUTSTYPE0"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = (1<<ISHADER_GS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_GEOMETRY_SM_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GS_STATE);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        OUTmio_pipe =  0b1110101111100;
        OUT =  0b1110101111100;

    ENCODING
            Opcode13 = Opcode;
            RegA = Ra;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            OutType = OutType;
            !NencOUT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "PIXLD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode
            Register:Rd
            ',' Predicate(PT):Pd
            ',' [NonZeroRegister:Ra + SImm(8/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "must be used with PS shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (pixmode != `PixMode@INVALIDPIXMODE6):
                "Invalid PixMode (pixmode) field value INVALIDPIXMODE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (pixmode != `PixMode@INVALIDPIXMODE7):
                "Invalid PixMode (pixmode) field value INVALIDPIXMODE7"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PIXLD_INDEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        PIXLDmio_pipe =  0b1110111111101;
        PIXLD =  0b1110111111101;

    ENCODING
            Opcode13 = Opcode;
            DstPred = Pd;
            PixMode = PixMode;
            Imm8 = sImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA =* Ra;
            !NencPIXLD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_PIXLD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode
            Register:Rd
            ',' Predicate(PT):Pd
            ',' [ZeroRegister(RZ):Ra + UImm(8/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "must be used with PS shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (pixmode != `PixMode@INVALIDPIXMODE6):
                "Invalid PixMode (pixmode) field value INVALIDPIXMODE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (pixmode != `PixMode@INVALIDPIXMODE7):
                "Invalid PixMode (pixmode) field value INVALIDPIXMODE7"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_PIXLD_INDEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 20;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        PIXLDmio_pipe =  0b1110111111101;
        PIXLD =  0b1110111111101;

    ENCODING
            Opcode13 = Opcode;
            DstPred = Pd;
            PixMode = PixMode;
            Imm8 = uImm;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            RegA =* Ra;
            !NencPIXLD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 ALTERNATE CLASS "PIXLD_simple"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode
            Register:Rd
            ',' Predicate(PT):Pd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "must be used with PS shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (pixmode != `PixMode@INVALIDPIXMODE6):
                "Invalid PixMode (pixmode) field value INVALIDPIXMODE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (pixmode != `PixMode@INVALIDPIXMODE7):
                "Invalid PixMode (pixmode) field value INVALIDPIXMODE7"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        PIXLDmio_pipe =  0b1110111111101;
        PIXLD =  0b1110111111101;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            DstPred = Pd;
            RegA = `Register@RZ;
            PixMode = PixMode;
            Imm8 = 0;
            !NencPIXLD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;

CLASS "LDC"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_n64_n128("32"):size /AdMode(IA):ad
            RegisterFAU:Rd
',' C:srcConst[UImm(5/0*):constBank]* [NonZeroRegisterFAU:Ra + SImm(17/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger_n64_n128@INVALIDSIZE6):
                "Invalid CInteger_n64_n128 (size) field value INVALIDSIZE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger_n64_n128@INVALIDSIZE7):
                "Invalid CInteger_n64_n128 (size) field value INVALIDSIZE7"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_CONSTANT_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        LDCmio_pipe =  0b1110111110010;
        LDC =  0b1110111110010;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 =* CInteger_n64_n128;
            AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !NencLDC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_LDC"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_n64_n128("32"):size /AdMode(IA):ad
            RegisterFAU:Rd
',' C:srcConst[UImm(5/0*):constBank]* [ZeroRegister(RZ):Ra + SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger_n64_n128@INVALIDSIZE6):
                "Invalid CInteger_n64_n128 (size) field value INVALIDSIZE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger_n64_n128@INVALIDSIZE7):
                "Invalid CInteger_n64_n128 (size) field value INVALIDSIZE7"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_CONSTANT_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(Ra)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        LDCmio_pipe =  0b1110111110010;
        LDC =  0b1110111110010;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 =* CInteger_n64_n128;
            AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !NencLDC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "LDC_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_64:size /AdMode(IA):ad
            RegisterFAU:Rd
',' C:srcConst[UImm(5/0*):constBank]* [NonZeroRegisterFAU:Ra + SImm(17/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_CONSTANT_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        LDCmio_pipe =  0b1110111110010;
        LDC =  0b1110111110010;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 = 5;
            AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !NencLDC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_LDC_64"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_64:size /AdMode(IA):ad
RegisterFAU:Rd ',' C:srcConst[UImm(5/0*):constBank]* [ZeroRegister(RZ):Ra + SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"


            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_CONSTANT_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(Ra)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        LDCmio_pipe =  0b1110111110010;
        LDC =  0b1110111110010;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 = 5;
            AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !NencLDC;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "LD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size
            Register:Rd
            ',' [NonZeroRegister:Ra + SImm(32/0)*:sImm]
            ',' Predicate(PT):Ps

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE != $ST_CS) -> (Ps == `Predicate@PT)):
                "with non-CS shader type Plg must be PT )"

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % LDRegAlignment(LDInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_GENERICS;


    OPCODES
        LDmio_pipe =  0b100;
        LD =  0b100;

    ENCODING
            Opcode3 = Opcode;
            PredSrcldst = Ps;
            COP = LoadCacheOp;
            LSSize =* LDInteger;
            E = E;
            Imm32 = sImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_LD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size
             Register:Rd
             ',' [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm]
             ',' Predicate(PT):Ps

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE != $ST_CS) -> (Ps == `Predicate@PT)):
                "with non-CS shader type Plg must be PT )"

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % LDRegAlignment(LDInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_GENERICS;


    OPCODES
        LDmio_pipe =  0b100;
        LD =  0b100;

    ENCODING
            Opcode3 = Opcode;
            PredSrcldst = Ps;
            COP = LoadCacheOp;
            LSSize =* LDInteger;
            E = E;
            Imm32 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "LDG"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size
                 Register:Rd ',' [NonZeroRegister:Ra + SImm(24/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
                ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % LDRegAlignment(LDInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


     OPCODES
        LDGmio_pipe =  0b111_01110_11010;
        LDG =  0b111_01110_11010;


     ENCODING
           Opcode13 = Opcode;
           Pred = Pg;
           PredNot = Pg@not;
           Dest = Rd;
           RegA =* Ra;
           LSSize2 = LDInteger;
           COP4 = LoadCacheOp;
           E2 = E;
           Imm24 = sImm;
           !NencLDG;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_LDG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size
            Register:Rd ',' [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % LDRegAlignment(LDInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


     OPCODES
        LDGmio_pipe =  0b111_01110_11010;
        LDG =  0b111_01110_11010;


     ENCODING
           Opcode13 = Opcode;
           Pred = Pg;
           PredNot = Pg@not;
           Dest = Rd;
           RegA =* Ra;
           LSSize2 = LDInteger;
           COP4 = LoadCacheOp;
           E2 = E;
           Imm24 = uImm;
           !NencLDG;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "LDG_SPARSE"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size
            Predicate:Pd ','
            Register:Rd ',' [NonZeroRegister:Ra + SImm(20/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
                ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % LDRegAlignment(LDInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


     OPCODES
        LDGmio_pipe =  0b111_01110_11001;
        LDG =  0b111_01110_11001;


     ENCODING
           Opcode13 = Opcode;
           Pred = Pg;
           PredNot = Pg@not;
           Dest = Rd;
           RegA =* Ra;
           LSSize2 = LDInteger;
           COP4 = LoadCacheOp;
           E2 = E;
           PredDest4 = DestPred(Pd);
           Imm20 = sImm;
           !NencLDG2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_LDG_SPARSE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size
            Predicate:Pd ','
            Register:Rd ',' [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % LDRegAlignment(LDInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
                "Register D is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


     OPCODES
        LDGmio_pipe =  0b111_01110_11001;
        LDG =  0b111_01110_11001;


     ENCODING
           Opcode13 = Opcode;
           Pred = Pg;
           PredNot = Pg@not;
           Dest = Rd;
           RegA =* Ra;
           LSSize2 = LDInteger;
           COP4 = LoadCacheOp;
           E2 = E;
           PredDest4 = DestPred(Pd);
           Imm20 = uImm;
           !NencLDG2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "LDL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size
            Register:Rd
            ',' [NonZeroRegister:Ra + SImm(24/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOCAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        LDLmio_pipe =  0b1110111101000;
        LDL =  0b1110111101000;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 = CInteger;
            COP2 = LLoadCacheOp;
            Imm24 = sImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !WriteCC;
            !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_LDL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size
            Register:Rd
            ',' [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register D is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOCAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        LDLmio_pipe =  0b1110111101000;
        LDL =  0b1110111101000;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 = CInteger;
            COP2 = LLoadCacheOp;
            Imm24 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !WriteCC;
            !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "LDS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDSInteger("32"):size
            Register:Rd ',' [NonZeroRegister:Ra + SImm(24/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "must be used with compute shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDSInteger@INVALIDSIZE7):
                "Invalid LDSInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDSInteger@U.INVALIDSIZE7):
                "Invalid LDSInteger (size) field value U.INVALIDSIZE7"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((size==0)*8) + ((size==1)*8) + ((size==2)*8) + ((size==3)*8) + ((size==4)*16) + ((size==5)*16) + ((size==6)*16) + ((size==7)*16) + ((size==8)*32) + ((size==9)*32) + ((size==10)*64) + ((size==11)*64) + ((size==12)*128) + ((size==13)*128) + ((size==14)*1) + ((size==15)*1));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        LDSmio_pipe =  0b1110111101001;
        LDS =  0b1110111101001;

    ENCODING
            Opcode13 = Opcode;
            LDSSize =* size;
            Imm24 = sImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !NencLDS;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_LDS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDSInteger("32"):size
            Register:Rd ',' [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "must be used with compute shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDSInteger@INVALIDSIZE7):
                "Invalid LDSInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDSInteger@U.INVALIDSIZE7):
                "Invalid LDSInteger (size) field value U.INVALIDSIZE7"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((size==0)*8) + ((size==1)*8) + ((size==2)*8) + ((size==3)*8) + ((size==4)*16) + ((size==5)*16) + ((size==6)*16) + ((size==7)*16) + ((size==8)*32) + ((size==9)*32) + ((size==10)*64) + ((size==11)*64) + ((size==12)*128) + ((size==13)*128) + ((size==14)*1) + ((size==15)*1));
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        LDSmio_pipe =  0b1110111101001;
        LDS =  0b1110111101001;

    ENCODING
            Opcode13 = Opcode;
            LDSSize =* size;
            Imm24 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rd;
            !NencLDS;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "LEA_LO_REG"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOOnly(LO)@:hilo /X(noX):xmode
        Predicate(PT):Pd
       ',' $( Register:Rd /optCC(noCC):writeCC )$
       ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
       ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
       ',' UImm(5/0):uImm5

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
       ;

     CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
        SECONDARY;
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


     OPCODES
        LEAfxu_pipe =  0b0101101111010;
        LEA =  0b0101101111010;

     ENCODING
       Opcode13 = Opcode;
       PredDest = Pd;
       WriteCC = writeCC;
       Xm4 = xmode;
       nA4 = Ra@negate;
       ImmU5 = uImm5;
       RegB = Rb;
       PredNot = Pg@not;
       Pred = Pg;
       RegA = Ra;
       Dest = Rd;
       !NencLEA_LO;
       !BFiller;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "LEA_LO_IMM"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOOnly(LO)@:hilo /X(noX):xmode
        Predicate(PT):Pd
       ',' $( Register:Rd /optCC(noCC):writeCC )$
       ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
       ',' SImm(20):uImm20
       ',' UImm(5/0):uImm5

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
       ;

     CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
        SECONDARY;
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm20));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


     OPCODES
        LEAfxu_pipe =  0b0011011_11010;
        LEA =  0b0011011_11010;

     ENCODING
       Opcode7b5 = Opcode;
       PredDest = Pd;
       WriteCC = writeCC;
       Xm4 = xmode;
       nA4 = Ra@negate;
       ImmU5 = uImm5;
       Bconst = uImm20;
       PredNot = Pg@not;
       Pred = Pg;
       RegA = Ra;
       Dest = Rd;
       !NencLEA_LO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "LEA_LO_CONST"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOOnly(LO)@:hilo /X(noX):xmode
        Predicate(PT):Pd
       ',' $( Register:Rd /optCC(noCC):writeCC )$
       ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
       ',' UImm(5/0):uImm5

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
       ;

     CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
        SECONDARY;
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = (xmode==`X@X);


     OPCODES
        LEAfxu_pipe =  0b0100101111010;
        LEA =  0b0100101111010;

     ENCODING
       Opcode13 = Opcode;
       PredDest = Pd;
       WriteCC = writeCC;
       Xm4 = xmode;
       nA4 = Ra@negate;
       ImmU5 = uImm5;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
       PredNot = Pg@not;
       Pred = Pg;
       RegA = Ra;
       Dest = Rd;
       !NencLEA_LO;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "LEA_HI_REG"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /HIOnly:hi /X(noX):xmode
        Predicate(PT):Pd
       ',' $( Register:Rd /optCC(noCC):writeCC )$
       ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
       ',' $( Register:Rb {/REUSE(noreuse):reuse_src_b} )$
       ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$
       ',' UImm(5/0):uImm5

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
       ;

     CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
        SECONDARY;
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 1;


     OPCODES
        LEAfxu_pipe =  0b0101101111011;
        LEA =  0b0101101111011;

     ENCODING
       Opcode13 = Opcode;
       PredDest = Pd;
       WriteCC = writeCC;
              RegC = Rc;
       Xm5 = xmode;
       nA5 = Ra@negate;
       ImmU5_2 = uImm5;
       RegB = Rb;
       PredNot = Pg@not;
       Pred = Pg;
       RegA = Ra;
       Dest = Rd;
       !NencLEA_HI_REG;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 CLASS "LEA_HI_CONST"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /HIOnly:hi /X(noX):xmode
        Predicate(PT):Pd
       ',' $( Register:Rd /optCC(noCC):writeCC )$
       ',' $( [-] Register:Ra {/REUSE(noreuse):reuse_src_a} )$
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
       ',' $( Register:Rc {/REUSE(noreuse):reuse_src_c} )$
       ',' UImm(5/0):uImm5

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
       ;

     CONDITIONS

            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((writeCC) -> (Pd==`Predicate@PT)) :
                "CC and destination Predicates cannot both be updated"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



    PROPERTIES
        SECONDARY;
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         CC_BYPASS_ALLOWED;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 1;


     OPCODES
        LEAfxu_pipe =  0b000110;
        LEA =  0b000110;

     ENCODING
       Opcode6 = Opcode;
       Xm6 = xmode;
       nA6 = Ra@negate;
       ImmU5_3 = uImm5;
       PredDest = Pd;
       WriteCC = writeCC;
              RegC = Rc;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
       PredNot = Pg@not;
       Pred = Pg;
       RegA = Ra;
       Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;

CLASS "ST"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size
            [NonZeroRegister:Ra + SImm(32/0)*:sImm]
            ',' Register:Rb
            ',' Predicate(PT):Plg

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE != $ST_CS) -> (Plg == `Predicate@PT)):
                "with non-CS shader type Plg must be PT )"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_GENERICS;


    OPCODES
        STmio_pipe =  0b101;
        ST =  0b101;

    ENCODING
            Opcode3 = Opcode;
            PredSrcldst = Plg;
            COP = StoreCacheOp;
            LSSize = CInteger;
            E = E;
            Imm32 = sImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_ST"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size
            [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm]
            ',' Register:Rb
            ',' Predicate(PT):Plg

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

             ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE != $ST_CS) -> (Plg == `Predicate@PT)):
                "with non-CS shader type Plg must be PT )"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_GENERICS;


    OPCODES
        STmio_pipe =  0b101;
        ST =  0b101;

    ENCODING
            Opcode3 = Opcode;
            PredSrcldst = Plg;
            COP = StoreCacheOp;
            LSSize = CInteger;
            E = E;
            Imm32 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rb;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "STG"

     FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size
                [NonZeroRegister:Ra + SImm(24/0)*:sImm] ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
                ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


     OPCODES
        STGmio_pipe =  0b111_01110_11011;
        STG =  0b111_01110_11011;


     ENCODING
           Opcode13 = Opcode;
           Pred = Pg;
           PredNot = Pg@not;
           Dest = Rb;
           RegA =* Ra;
           LSSize2 = CInteger;
           COP4 = StoreCacheOp;
           E2 = E;
           Imm24 = sImm;
           !NencLDG;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_STG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size
            [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


     OPCODES
        STGmio_pipe =  0b111_01110_11011;
        STG =  0b111_01110_11011;


     ENCODING
           Opcode13 = Opcode;
           Pred = Pg;
           PredNot = Pg@not;
           Dest = Rb;
           RegA =* Ra;
           LSSize2 = CInteger;
           COP4 = StoreCacheOp;
           E2 = E;
           Imm24 = uImm;
           !NencLDG;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "STL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size
            [NonZeroRegister:Ra + SImm(24/0)*:sImm]
            ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS


            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOCAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        STLmio_pipe =  0b1110111101010;
        STL =  0b1110111101010;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 = CInteger;
            COP2 = StoreCacheOp;
            Imm24 = sImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rb;
            !WriteCC;
            !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_STL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size
            [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
            ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS


            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOCAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        STLmio_pipe =  0b1110111101010;
        STL =  0b1110111101010;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 = CInteger;
            COP2 = StoreCacheOp;
            Imm24 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rb;
            !WriteCC;
            !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "STS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size
            [NonZeroRegister:Ra + SImm(24/0)*:sImm]
            ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "must be used with compute shader"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        STSmio_pipe =  0b1110111101011;
        STS =  0b1110111101011;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 =* CInteger;
            Imm24 = sImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rb;
            !COP2;
            !WriteCC;
            !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_STS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size
            [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
            ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "must be used with compute shader"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CRegAlignment(CInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
                "Register B is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `CInteger@INVALIDSIZE7):
                "Invalid CInteger (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        STSmio_pipe =  0b1110111101011;
        STS =  0b1110111101011;

    ENCODING
            Opcode13 = Opcode;
            LSSize2 =* CInteger;
            Imm24 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Dest = Rb;
            !COP2;
            !WriteCC;
            !aA2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;

 CLASS "ATOM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb ',' Register(RZ)@:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@S32) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP9):
                "Invalid AtomOp (atom) field value INVALIDATOMOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP11):
                "Invalid AtomOp (atom) field value INVALIDATOMOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP12):
                "Invalid AtomOp (atom) field value INVALIDATOMOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP13):
                "Invalid AtomOp (atom) field value INVALIDATOMOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP14):
                "Invalid AtomOp (atom) field value INVALIDATOMOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP15):
                "Invalid AtomOp (atom) field value INVALIDATOMOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE6):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE7):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@ADD) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@F32.FTZ.RN)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.ADD only supports sizes U32, S32, U64, F16x2.FTZ.RN, and F32.FTZ.RN"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@MIN) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.MIN only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@MAX) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.MAX only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@INC) -> ((size == `SQInteger@U32))):
                "ATOM.INC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@DEC) -> ((size == `SQInteger@U32))):
                "ATOM.DEC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@AND) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.AND only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@OR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.OR only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@XOR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.XOR only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@EXCH) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.EXCH only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@SAFEADD) -> ((size == `SQInteger@U64))):
                "ATOM.SAFEADD only supports size U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD)):
                "Only ATOM.ADD can use F32.FTZ.RN"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_C_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b11101101;
        ATOM =  0b11101101;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest =* Rd;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb ',' Register(RZ)@:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@S32) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP9):
                "Invalid AtomOp (atom) field value INVALIDATOMOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP11):
                "Invalid AtomOp (atom) field value INVALIDATOMOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP12):
                "Invalid AtomOp (atom) field value INVALIDATOMOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP13):
                "Invalid AtomOp (atom) field value INVALIDATOMOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP14):
                "Invalid AtomOp (atom) field value INVALIDATOMOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP15):
                "Invalid AtomOp (atom) field value INVALIDATOMOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE6):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE7):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@ADD) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@F32.FTZ.RN)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.ADD only supports sizes U32, S32, U64, F16x2.FTZ.RN, and F32.FTZ.RN"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@MIN) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.MIN only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@MAX) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.MAX only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@INC) -> ((size == `SQInteger@U32))):
                "ATOM.INC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@DEC) -> ((size == `SQInteger@U32))):
                "ATOM.DEC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@AND) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.AND only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@OR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.OR only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@XOR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.XOR only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@EXCH) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.EXCH only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@SAFEADD) -> ((size == `SQInteger@U64))):
                "ATOM.SAFEADD only supports size U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD)):
                "Only ATOM.ADD can use F32.FTZ.RN"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_C_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b11101101;
        ATOM =  0b11101101;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest =* Rd;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOM_CAS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==`Register@RZ))):
                "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)+((Rb)==`Register@RZ))%4 == 0):
                "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

            MISALIGNED_REG_ERROR
                (((Rc)+((Rc)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)+((Rc)==`Register@RZ))%2 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)+((Rc)==`Register@RZ))%4 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011101111;
        ATOM =  0b111011101111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Size1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      Dest = Rd;
      RegA =* Ra;
      Imm20a = sImm;
      bcRZ = 0;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOM_CAS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==`Register@RZ))):
                "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)+((Rb)==`Register@RZ))%4 == 0):
                "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

            MISALIGNED_REG_ERROR
                (((Rc)+((Rc)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)+((Rc)==`Register@RZ))%2 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)+((Rc)==`Register@RZ))%4 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011101111;
        ATOM =  0b111011101111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Size1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      Dest = Rd;
      RegA =* Ra;
      Imm20a = uImm;
      bcRZ = 0;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOM_CAS_Rb_and_RZ"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb ',' ZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==`Register@RZ))):
                "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)+((Rb)==`Register@RZ))%4 == 0):
                "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011101111;
        ATOM =  0b111011101111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize1 = CASInteger;
      bcRZ = 1;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOM_CAS_Rb_and_RZ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb ',' ZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==`Register@RZ))):
                "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)+((Rb)==`Register@RZ))%4 == 0):
                "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011101111;
        ATOM =  0b111011101111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize1 = CASInteger;
      bcRZ = 1;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOM_CAS_RZ_and_Rc"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            MISALIGNED_REG_ERROR
                (((Rc)+((Rc)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)+((Rc)==`Register@RZ))%2 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)+((Rc)==`Register@RZ))%4 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011101111;
        ATOM =  0b111011101111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rc;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize1 = CASInteger;
      bcRZ = 2;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOM_CAS_RZ_and_Rc"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            MISALIGNED_REG_ERROR
                (((Rc)+((Rc)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)+((Rc)==`Register@RZ))%2 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)+((Rc)==`Register@RZ))%4 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011101111;
        ATOM =  0b111011101111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rc;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize1 = CASInteger;
      bcRZ = 2;
      AtomE = E;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOM_SPARSE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size
             Predicate:Pd ','
             Register:Rd ','
             [NonZeroRegister:Ra]
             ',' Register:Rb ',' Register(RZ)@:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@S32) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP9):
                "Invalid AtomOp (atom) field value INVALIDATOMOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP11):
                "Invalid AtomOp (atom) field value INVALIDATOMOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP12):
                "Invalid AtomOp (atom) field value INVALIDATOMOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP13):
                "Invalid AtomOp (atom) field value INVALIDATOMOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP14):
                "Invalid AtomOp (atom) field value INVALIDATOMOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomOp@INVALIDATOMOP15):
                "Invalid AtomOp (atom) field value INVALIDATOMOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE6):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE7):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@ADD) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@F32.FTZ.RN)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.ADD only supports sizes U32, S32, U64, F16x2.FTZ.RN, and F32.FTZ.RN"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@MIN) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.MIN only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@MAX) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "ATOM.MAX only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@INC) -> ((size == `SQInteger@U32))):
                "ATOM.INC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@DEC) -> ((size == `SQInteger@U32))):
                "ATOM.DEC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@AND) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.AND only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@OR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.OR only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@XOR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.XOR only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@EXCH) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.EXCH only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomOp@SAFEADD) -> ((size == `SQInteger@U64))):
                "ATOM.SAFEADD only supports size U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD)):
                "Only ATOM.ADD can use F32.FTZ.RN"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_C_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011100110;
        ATOM =  0b111011100110;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PredDest4 = DestPred(Pd);
      RegB = Rb;
      Dest =* Rd;
      RegA =* Ra;
      AtomSize = SQInteger;
      AtomOp2 = AtomOp;
      AtomE = E;
      !NencATOM;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOM_CAS_SPARSE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Predicate:Pd ','
             Register:Rd ','
             [NonZeroRegister:Ra]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==`Register@RZ))):
                "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)+((Rb)==`Register@RZ))%4 == 0):
                "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

            MISALIGNED_REG_ERROR
                (((Rc)+((Rc)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)+((Rc)==`Register@RZ))%2 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)+((Rc)==`Register@RZ))%4 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011100111;
        ATOM =  0b111011100111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PredDest4 = DestPred(Pd);
      Size1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      Dest = Rd;
      RegA =* Ra;
      bcRZ = 0;
      AtomE = E;
      !NencATOM2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOM_CAS_RZ_and_Rc_SPARSE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Predicate:Pd ','
             Register:Rd ','
             [NonZeroRegister:Ra]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            MISALIGNED_REG_ERROR
                (((Rc)+((Rc)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> (((Rc)+((Rc)==`Register@RZ))%2 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rc)+((Rc)==`Register@RZ))%4 == CASRegAlignment(CASInteger)):
                "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011100111;
        ATOM =  0b111011100111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PredDest4 = DestPred(Pd);
      RegB = Rc;
      Dest = Rd;
      RegA =* Ra;
      AtomSize1 = CASInteger;
      bcRZ = 2;
      AtomE = E;
      !NencATOM2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOM_CAS_Rb_and_RZ_SPARSE"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size
             Predicate:Pd ','
             Register:Rd ','
             [NonZeroRegister:Ra]
             ',' Register:Rb ',' ZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            MISALIGNED_REG_ERROR
                (((Rd)+((Rd)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % CASRegAlignment(CASInteger)) == 0 :
                "Output register improperly aligned for specified operation size"

            OOR_REG_ERROR
                (size == `CASInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            OOR_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==`Register@RZ))):
                "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

            MISALIGNED_REG_ERROR
                (size == `CASInteger@"64") -> (((Rb)+((Rb)==`Register@RZ))%4 == 0):
                "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "ATOM.CAS only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOM.CAS"
            MISALIGNED_REG_ERROR
                ((Rc==`Register@RZ)||(((Rb%(2*CASRegAlignment(CASInteger))==0)&&(Rc==Rb+CASRegAlignment(CASInteger))))):
                "ATOM.CAS requires that (Rb,Rc) to be aligned and be vector-consecutive"

                MISALIGNED_REG_ERROR
                ((Rb%(2*CASRegAlignment(CASInteger)))==0):
                "ATOM.CAS requires Rb to be aligned"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        ATOMmio_pipe =  0b111011100111;
        ATOM =  0b111011100111;

    ENCODING
      Opcode12 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PredDest4 = DestPred(Pd);
      RegB = Rb;
      Dest = Rd;
      RegA =* Ra;
      AtomSize1 = CASInteger;
      bcRZ = 1;
      AtomE = E;
      !NencATOM2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "ATOMS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AtomsOp:atom /AtomsSz("U32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm]
             ',' Register:Rb ',' Register(RZ)@:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP9):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP10):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP11):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP12):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP13):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP14):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP15):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP15"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@ADD)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.ADD only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@MIN)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.MIN only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@MAX)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.MAX only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@INC)->((size == `AtomsSz@U32))):
                "ATOMS.INC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@DEC)->((size == `AtomsSz@U32))):
                "ATOMS.DEC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@AND)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.AND only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@OR)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.OR only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@XOR)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.XOR only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@EXCH)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32)||(size == `AtomsSz@U64))):
                "ATOMS.EXCH only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (size != `AtomsSz@S64):
                "S64 is not supported for any ops of ATOMS"
            MISALIGNED_REG_ERROR
                (((size == `AtomsSz@U64)||(size == `AtomsSz@S64)) -> ((Rb==`Register@RZ)||(Rb%2==0))):
                "Misaligned Rb register in ATOMS"

                MISALIGNED_REG_ERROR
                (((size == `AtomsSz@U64)||(size == `AtomsSz@S64)) -> ((Rd==`Register@RZ)||(Rd%2==0))):
                "Misaligned Rd register in ATOMS"


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = ((((size==0)||(size==1))*32)+(((size==2)||(size==3))*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = ((((size==0)||(size==1))*32)+(((size==2)||(size==3))*64));
         ISRC_C_SIZE = ((((size==0)||(size==1))*32)+(((size==2)||(size==3))*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101100;
        ATOMS =  0b11101100;

    ENCODING
      Opcode8 = Opcode;
      AtomOp = atom;
      Imm22atoms = sImm SCALE 4;
      AtomsSize = size;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest =* Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOMS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AtomsOp:atom /AtomsSz("U32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
             ',' Register:Rb ',' Register(RZ)@:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP9):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP10):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP11):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP12):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP13):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP14):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (atom != `AtomsOp@INVALIDATOMSOP15):
                "Invalid AtomsOp (atom) field value INVALIDATOMSOP15"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@ADD)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.ADD only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@MIN)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.MIN only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@MAX)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.MAX only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@INC)->((size == `AtomsSz@U32))):
                "ATOMS.INC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@DEC)->((size == `AtomsSz@U32))):
                "ATOMS.DEC only supports size U32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@AND)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.AND only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@OR)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.OR only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@XOR)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32))):
                "ATOMS.XOR only supports sizes U32 and S32"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((atom == `AtomsOp@EXCH)->((size == `AtomsSz@U32)||(size == `AtomsSz@S32)||(size == `AtomsSz@U64))):
                "ATOMS.EXCH only supports sizes U32, S32 and U64"

                ILLEGAL_INSTR_ENCODING_ERROR
                (size != `AtomsSz@S64):
                "S64 is not supported for any ops of ATOMS"
            MISALIGNED_REG_ERROR
                (((size == `AtomsSz@U64)||(size == `AtomsSz@S64)) -> ((Rb==`Register@RZ)||(Rb%2==0))):
                "Misaligned Rb register in ATOMS"

                MISALIGNED_REG_ERROR
                (((size == `AtomsSz@U64)||(size == `AtomsSz@S64)) -> ((Rd==`Register@RZ)||(Rd%2==0))):
                "Misaligned Rd register in ATOMS"


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = ((((size==0)||(size==1))*32)+(((size==2)||(size==3))*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = ((((size==0)||(size==1))*32)+(((size==2)||(size==3))*64));
         ISRC_C_SIZE = ((((size==0)||(size==1))*32)+(((size==2)||(size==3))*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101100;
        ATOMS =  0b11101100;

    ENCODING
      Opcode8 = Opcode;
      AtomOp = atom;
      Imm22atoms = uImm SCALE 4;
      AtomsSize = size;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest =* Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOMS_CAS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101110010;
        ATOMS =  0b11101110010;

    ENCODING
      Opcode11 = Opcode;
      atomsbcRZ = 0;
      Imm22atoms = sImm SCALE 4;
      asSize1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "I_ATOMS_CAS"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101110010;
        ATOMS =  0b11101110010;

    ENCODING
      Opcode11 = Opcode;
      atomsbcRZ = 0;
      Imm22atoms = uImm SCALE 4;
      asSize1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "ATOMS_CAS_Rb_and_RZ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm]
             ',' Register:Rb ',' ZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101110010;
        ATOMS =  0b11101110010;

    ENCODING
      Opcode11 = Opcode;
      atomsbcRZ = 1;
      Imm22atoms = sImm SCALE 4;
      AtomsSize1 = CASInteger;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "I_ATOMS_CAS_Rb_and_RZ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
             ',' Register:Rb ',' ZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101110010;
        ATOMS =  0b11101110010;

    ENCODING
      Opcode11 = Opcode;
      atomsbcRZ = 1;
      Imm22atoms = uImm SCALE 4;
      AtomsSize1 = CASInteger;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "ATOMS_CAS_RZ_and_Rc"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101110010;
        ATOMS =  0b11101110010;

    ENCODING
      Opcode11 = Opcode;
      atomsbcRZ = 2;
      Imm22atoms = sImm SCALE 4;
      AtomsSize1 = CASInteger;
      RegB = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;





 CLASS "I_ATOMS_CAS_RZ_and_Rc"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAS:cas /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b11101110010;
        ATOMS =  0b11101110010;

    ENCODING
      Opcode11 = Opcode;
      atomsbcRZ = 2;
      Imm22atoms = uImm SCALE 4;
      AtomsSize1 = CASInteger;
      RegB = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




 CLASS "ATOMS_CAST"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAST:cast /AtomsSPIN(noSPIN):spin /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES TERTIARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b1110111000;
        ATOMS =  0b1110111000;

    ENCODING
      Opcode10 = Opcode;
      atomsbcRZ = 0;
      Imm22atoms = sImm SCALE 4;
      asSize1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      atomscSPIN = spin;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOMS_CAST"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAST:cast /AtomsSPIN(noSPIN):spin /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES TERTIARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b1110111000;
        ATOMS =  0b1110111000;

    ENCODING
      Opcode10 = Opcode;
      atomsbcRZ = 0;
      Imm22atoms = uImm SCALE 4;
      asSize1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      atomscSPIN = spin;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOMS_CAST_Rb_and_RZ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAST:cast /AtomsSPIN(noSPIN):spin /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm]
             ',' Register:Rb ',' ZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES TERTIARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b1110111000;
        ATOMS =  0b1110111000;

    ENCODING
      Opcode10 = Opcode;
      atomsbcRZ = 1;
      Imm22atoms = sImm SCALE 4;
      AtomsSize1 = CASInteger;
      atomscSPIN = spin;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOMS_CAST_Rb_and_RZ"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAST:cast /AtomsSPIN(noSPIN):spin/CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
             ',' Register:Rb ',' ZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES TERTIARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b1110111000;
        ATOMS =  0b1110111000;

    ENCODING
      Opcode10 = Opcode;
      atomsbcRZ = 1;
      Imm22atoms = uImm SCALE 4;
      AtomsSize1 = CASInteger;
      atomscSPIN = spin;
      RegB = Rb;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "ATOMS_CAST_RZ_and_Rc"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAST:cast /AtomsSPIN(noSPIN):spin /CASInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES TERTIARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b1110111000;
        ATOMS =  0b1110111000;

    ENCODING
      Opcode10 = Opcode;
      atomsbcRZ = 2;
      Imm22atoms = sImm SCALE 4;
      AtomsSize1 = CASInteger;
      atomscSPIN = spin;
      RegB = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "I_ATOMS_CAST_RZ_and_Rc"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CAST:cast /AtomsSPIN(noSPIN):spin /CASInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"


            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "ATOMS.CAS/ATOMS.CAST must be used with compute shader"

                ILLEGAL_INSTR_ENCODING_ERROR
                (Rb != `Register@RZ):
                "Register Rb cannot be RZ for ATOMS.CAS/ATOMS.CAST"
            MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb==`Register@RZ)||(Rb%4 == 0))):
                "Misaligned Rb register in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"32") -> ((Rb%2==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+1)||(Rc == `Register@RZ)))):
                "Rb should be 2n and Rc should be Rb+1 when size is 32 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rb%4==0)&&(Rb!=`Register@RZ)&&((Rc == Rb+2)||(Rc == `Register@RZ)))):
                "Rb should be 4n and Rc should be Rb+2 when size is 64 bits in ATOMS.CAS/.CAST"

                MISALIGNED_REG_ERROR
                ((size == `CASInteger@"64") -> ((Rd==`Register@RZ)||(Rd%2 == 0))):
                "Misaligned Rd register in ATOMS.CAS/.CAST"



    PROPERTIES TERTIARY;

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SHARED_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = (((size==0)*32)+((size==1)*64));
         ISRC_C_SIZE = (((size==0)*32)+((size==1)*64));
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ATOMSmio_pipe =  0b1110111000;
        ATOMS =  0b1110111000;

    ENCODING
      Opcode10 = Opcode;
      atomsbcRZ = 2;
      Imm22atoms = uImm SCALE 4;
      AtomsSize1 = CASInteger;
      atomscSPIN = spin;
      RegB = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "RED"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@S32) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP8):
                "Invalid RedOp (redop) field value INVALIDREDOP8"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP9):
                "Invalid RedOp (redop) field value INVALIDREDOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP10):
                "Invalid RedOp (redop) field value INVALIDREDOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP11):
                "Invalid RedOp (redop) field value INVALIDREDOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP12):
                "Invalid RedOp (redop) field value INVALIDREDOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP13):
                "Invalid RedOp (redop) field value INVALIDREDOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP14):
                "Invalid RedOp (redop) field value INVALIDREDOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP15):
                "Invalid RedOp (redop) field value INVALIDREDOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE6):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE7):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "
            ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@ADD) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@F32.FTZ.RN)||(size == `SQInteger@F16x2.FTZ.RN))):
                "RED.ADD only supports sizes U32, S32, U64, F16x2.FTZ.RN, and F32.FTZ.RN"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MIN) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "RED.MIN only supports sizes U32, S32, U64, F16x2.FTZ.RN, and S64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MAX) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "RED.MAX only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@INC) -> ((size == `SQInteger@U32))):
                "RED.INC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@DEC) -> ((size == `SQInteger@U32))):
                "RED.DEC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@AND) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "RED.AND only supports sizes U32, S32, and U64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@OR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "RED.OR only supports sizes U32, S32, and U64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@XOR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "RED.XOR only supports sizes U32, S32, and U64"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
         INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
             MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        REDmio_pipe =  0b1110101111111;
        RED =  0b1110101111111;

    ENCODING
      Opcode13 = Opcode;
      AtomE = E;
      Imm20a = sImm;
      RedOp = RedOp;
      RedSize = SQInteger;
      Pred = Pg;
      PredNot = Pg@not;
      RegBAST = Rb;
      RegA =* Ra;
      !NencRed;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "I RED"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@S32) -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"S64") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-2)) :
                "Register is out of range"

            OOR_REG_ERROR
                (size == `SQInteger@"F16x2.FTZ.RN") -> (((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-1)):
                "Register is out of range"

            MISALIGNED_REG_ERROR
                (((Rb)+((Rb)==`Register@RZ)) % SQRegAlignment(SQInteger)) == 0 :
                "Input register improperly aligned for specified operation size"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP8):
                "Invalid RedOp (redop) field value INVALIDREDOP8"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP9):
                "Invalid RedOp (redop) field value INVALIDREDOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP10):
                "Invalid RedOp (redop) field value INVALIDREDOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP11):
                "Invalid RedOp (redop) field value INVALIDREDOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP12):
                "Invalid RedOp (redop) field value INVALIDREDOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP13):
                "Invalid RedOp (redop) field value INVALIDREDOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP14):
                "Invalid RedOp (redop) field value INVALIDREDOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP15):
                "Invalid RedOp (redop) field value INVALIDREDOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE6):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `SQInteger@INVALIDATOMICSIZE7):
                "Invalid SQInteger (size) field value INVALIDATOMICSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "
            ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@ADD) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@F32.FTZ.RN)||(size == `SQInteger@F16x2.FTZ.RN))):
                "RED.ADD only supports sizes U32, S32, U64, F16x2.FTZ.RN, and F32.FTZ.RN"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MIN) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "RED.MIN only supports sizes U32, S32, U64, F16x2.FTZ.RN, and S64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MAX) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64)||(size == `SQInteger@S64)||(size == `SQInteger@F16x2.FTZ.RN))):
                "RED.MAX only supports sizes U32, S32, U64, F16x2.FTZ.RN and S64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@INC) -> ((size == `SQInteger@U32))):
                "RED.INC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@DEC) -> ((size == `SQInteger@U32))):
                "RED.DEC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@AND) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "RED.AND only supports sizes U32, S32, and U64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@OR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "RED.OR only supports sizes U32, S32, and U64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@XOR) -> ((size == `SQInteger@U32)||(size == `SQInteger@S32)||(size == `SQInteger@U64))):
                "RED.XOR only supports sizes U32, S32, and U64"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
         INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
             MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_INVALID_ADDR_SPACE)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GLOBAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = (((size==`SQInteger@"32")*32) + ((size==`SQInteger@S32)*32) + ((size==`SQInteger@"64")*64) + ((size==`SQInteger@F32)*32) + ((size==`SQInteger@"F16x2.FTZ.RN")*32) + ((size==`SQInteger@S64)*64) + ((size==`SQInteger@INVALIDATOMICSIZE6)*1) + ((size==`SQInteger@INVALIDATOMICSIZE7)*1));
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        REDmio_pipe =  0b1110101111111;
        RED =  0b1110101111111;

    ENCODING
      Opcode13 = Opcode;
      AtomE = E;
      Imm20a = uImm;
      RedOp = RedOp;
      RedSize = SQInteger;
      Pred = Pg;
      PredNot = Pg@not;
      RegBAST = Rb;
      RegA = `Register@RZ;
      !NencRed;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;

CLASS "CCTL"

        FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /CCTLOp:cctlop
            [NonZeroRegister:Ra + SImm(32/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
            (cctlop != `CCTLOp@RSLB) :
            "RSLB is disallowed for CCTL"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((Cache3 != `Cache3@D) && (Cache3 != `Cache3@U)) -> ((cctlop != `CCTLOp@RS) &&
                                      (cctlop != `CCTLOp@PF1) &&
                                      (cctlop != `CCTLOp@WB) &&
                                      (cctlop != `CCTLOp@PF2)):
            "Illegal instruction: unsupported combination"

        ILLEGAL_INSTR_ENCODING_ERROR
            (cctlop != `CCTLOp@PF1.5):
            "PF1.5 CCTLOP is invalid"

         ILLEGAL_INSTR_ENCODING_ERROR
             (cctlop == `CCTLOp@IV) -> ((Cache3 != `Cache3@C) &&
                                        (Cache3 != `Cache3@I)):
             "Illegal instruction: unsupported combination"

        ILLEGAL_INSTR_ENCODING_ERROR
            (Cache3 != `Cache3@CRS) :
            "CRS is disallowed for CCTL"


        UNPREDICTABLE_BEHAVIOR_WARNING
                ((cctlop == `CCTLOp@WB) -> (cache == `Cache3@D)) :
                "Unpredictable Behavior Error: CCTL.WB must only be used with Data Cache"


            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP10):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP11):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP12):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP13):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP14):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP15):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP5):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP6):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP7):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLmio_pipe =  0b11101111011;
        CCTL =  0b11101111011;

    ENCODING
            Opcode11 = Opcode;
            Imm30a = sImm SCALE 4;
            E = E;
            Pred = Pg;
            PredNot = Pg@not;
            RegA =* Ra;
            Cache3 = Cache3;
            CCTLOp =* CCTLOp;
            !NencCCTL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_CCTL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /CCTLOp:cctlop
            [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS


         ILLEGAL_INSTR_ENCODING_ERROR
             (cctlop != `CCTLOp@RSLB) :
             "RSLB is disallowed for CCTL"

        ILLEGAL_INSTR_ENCODING_ERROR
            ((Cache3 != `Cache3@D) && (Cache3 != `Cache3@U)) -> ((cctlop != `CCTLOp@RS) &&
                                      (cctlop != `CCTLOp@PF1) &&
                                      (cctlop != `CCTLOp@WB) &&
                                      (cctlop != `CCTLOp@PF2)):
            "Illegal instruction: unsupported combination"

        ILLEGAL_INSTR_ENCODING_ERROR
            (cctlop != `CCTLOp@PF1.5):
            "PF1.5 CCTLOP is invalid"

         ILLEGAL_INSTR_ENCODING_ERROR
             (cctlop == `CCTLOp@IV) -> ((Cache3 != `Cache3@C) &&
                                        (Cache3 != `Cache3@I)):
             "Illegal instruction: unsupported combination"

        ILLEGAL_INSTR_ENCODING_ERROR
            (Cache3 != `Cache3@CRS) :
            "CRS is disallowed for CCTL"


        UNPREDICTABLE_BEHAVIOR_WARNING
                ((cctlop == `CCTLOp@WB) -> (cache == `Cache3@D)) :
                "Unpredictable Behavior Error: CCTL.WB must only be used with Data Cache"


            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP10):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP11):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP12):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP13):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP14):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctlop != `CCTLOp@INVALIDCCTLOP15):
                "Invalid CCTLOp (cctlop) field value INVALIDCCTLOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP5):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP6):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP7):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLmio_pipe =  0b11101111011;
        CCTL =  0b11101111011;

    ENCODING
            Opcode11 = Opcode;
            Imm30a = uImm SCALE 4;
            E = E;
            Pred = Pg;
            PredNot = Pg@not;
            RegA =* Ra;
            Cache3 = Cache3;
            CCTLOp =* CCTLOp;
            !NencCCTL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CCTL_IVALL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3NoCI(D):cache /OnlyIvall:ivall

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3NoCI@INVALIDCCTLCACHEOP5):
                "Invalid Cache3NoCI (cache) field value INVALIDCCTLCACHEOP5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3NoCI@INVALIDCCTLCACHEOP6):
                "Invalid Cache3NoCI (cache) field value INVALIDCCTLCACHEOP6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3NoCI@INVALIDCCTLCACHEOP7):
                "Invalid Cache3NoCI (cache) field value INVALIDCCTLCACHEOP7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


         ILLEGAL_INSTR_ENCODING_ERROR
             (e != `E@E) :
             "E is disallowed for CCTL.IVALL"

        ILLEGAL_INSTR_ENCODING_ERROR
            (Cache3NoCI != `Cache3NoCI@CRS) :
            "CRS is disallowed for CCTL"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLmio_pipe =  0b11101111011;
        CCTL =  0b11101111011;

    ENCODING
            Opcode11 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = `Register@RZ;
            Imm30a = 0;
            E = E;
            Cache3 =* Cache3NoCI;
            CCTLOp =* OnlyIvall;
            !NencCCTL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "CCTL_CI_IVALL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3CI:cache /OnlyIvall:ivall

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS


         ILLEGAL_INSTR_ENCODING_ERROR
             (e != `E@E) :
             "E is disallowed for CCTL.IVALL"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLmio_pipe =  0b11101111011;
        CCTL =  0b11101111011;

    ENCODING
            Opcode11 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = `Register@RZ;
            Imm30a = 0;
            E = E;
            Cache3 =* Cache3CI;
            CCTLOp =* OnlyIvall;
            !NencCCTL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CCTL_QRY"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /OnlyQry:op
            Register(RZ)@:Rd ',' [NonZeroRegister:Ra + SImm(32/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
            0:
            "can't use .QRY1 modifier"

        ILLEGAL_INSTR_ENCODING_ERROR
            (Cache3 != `Cache3@CRS) :
            "CRS is disallowed for CCTL"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP5):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP6):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP7):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = e ? 64 : 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLmio_pipe =  0b11101111011;
        CCTL =  0b11101111011;

    ENCODING
            Opcode11 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            RegA =* Ra;
            Imm30a = sImm SCALE 4;
            E = E;
            Cache3 = Cache3;
            CCTLOp =* OnlyQry;
            !NencCCTL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_CCTL_QRY"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /OnlyQry:op
            Register(RZ)@:Rd ',' [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
            0 :
            "can't use .QRY1 modifier"

        ILLEGAL_INSTR_ENCODING_ERROR
            (Cache3 != `Cache3@CRS) :
            "CRS is disallowed for CCTL"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            MISALIGNED_REG_ERROR
                E -> IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required when '.E' is specified"

            OOR_REG_ERROR
                E -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-2)):
                "Register A is out of range"

            OOR_REG_ERROR
                (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-1)):
                "Register A is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP5):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP5"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP6):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `Cache3@INVALIDCCTLCACHEOP7):
                "Invalid Cache3 (cache) field value INVALIDCCTLCACHEOP7"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES

         CCTL = 0b11101111011;

    ENCODING
            Opcode11 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            RegA =* Ra;
            Imm30a = uImm SCALE 4;
            E = E;
            Cache3 = Cache3;
            CCTLOp =* OnlyQry;
            !NencCCTL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "CCTLL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLOp:cctllop
            [NonZeroRegister:Ra + SImm(24/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@PF1.5):
                "PF1.5 CCTLOP is invalid"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP10):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP11):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP12):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP13):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP14):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP15):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `LCache@INVALIDLCACHETYPE2):
                "Invalid LCache (cache) field value INVALIDLCACHETYPE2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `LCache@INVALIDLCACHETYPE3):
                "Invalid LCache (cache) field value INVALIDLCACHETYPE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOCAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLLmio_pipe =  0b1110111110000;
        CCTLL =  0b1110111110000;

    ENCODING
            Opcode13 = Opcode;
            Imm22a = sImm SCALE 4;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Cache = cache;
            CCTLOp =* cctllop;
            !NencCCTLL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "I_CCTLL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLOp:cctllop
            [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@PF1.5):
                "PF1.5 CCTLOP is invalid"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP10):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP11):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP12):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP13):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP14):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP15):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `LCache@INVALIDLCACHETYPE2):
                "Invalid LCache (cache) field value INVALIDLCACHETYPE2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cache != `LCache@INVALIDLCACHETYPE3):
                "Invalid LCache (cache) field value INVALIDLCACHETYPE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_LOCAL_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLLmio_pipe =  0b1110111110000;
        CCTLL =  0b1110111110000;

    ENCODING
            Opcode13 = Opcode;
            Imm22a = uImm SCALE 4;
            PredNot = Pg@not;
            Pred = Pg;
            RegA =* Ra;
            Cache = cache;
            CCTLOp =* cctllop;
            !NencCCTLL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CCTLL_IVALL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CCTLLOp2:cctllop

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP10):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP11):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP12):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP13):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP14):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP15):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLLmio_pipe =  0b1110111110000;
        CCTLL =  0b1110111110000;

    ENCODING
            Opcode13 = Opcode;
            Imm22a = 0;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = `Register@RZ;
            Cache = 0;
            CCTLOp =* cctllop;
            !NencCCTLL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CCTLL_CRS_WBALL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CRSOnly:cache /CCTLLOp3:cctllop

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS





            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP10):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP11):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP12):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP13):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP14):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctllop != `CCTLOp@INVALIDCCTLOP15):
                "Invalid CCTLOp (cctllop) field value INVALIDCCTLOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        CCTLLmio_pipe =  0b1110111110000;
        CCTLL =  0b1110111110000;

    ENCODING
            Opcode13 = Opcode;
            Imm22a = 0;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = `Register@RZ;
            Cache = cache;
            CCTLOp =* cctllop;
            !NencCCTLL;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "CCTLT_REG"

        FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CCTLTOp:cctltop
     Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctltop != `CCTLTOp@INVALIDCCTLTOP2):
                "Invalid CCTLTOp (cctltop) field value INVALIDCCTLTOP2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctltop != `CCTLTOp@INVALIDCCTLTOP3):
                "Invalid CCTLTOp (cctltop) field value INVALIDCCTLTOP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "

 ILLEGAL_INSTR_ENCODING_ERROR
     (cctltop == `CCTLTOp@IVTH) :
            "Only IVTH encoding is allowed for with a register"



    PROPERTIES SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLTmio_pipe =  0b1110101111101;
        CCTLT =  0b1110101111101;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            RegC =* Rb;
            CCTLTOp =* CCTLTOp;
            !NencCCTLTReg;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CCTLT_IDX"

        FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CCTLTOp:cctltop
     UImm(13):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctltop != `CCTLTOp@INVALIDCCTLTOP2):
                "Invalid CCTLTOp (cctltop) field value INVALIDCCTLTOP2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctltop != `CCTLTOp@INVALIDCCTLTOP3):
                "Invalid CCTLTOp (cctltop) field value INVALIDCCTLTOP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "

 ILLEGAL_INSTR_ENCODING_ERROR
     (cctltop == `CCTLTOp@IVTH) :
            "Only IVTH encoding is allowed for with an index"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 13;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLTmio_pipe =  0b1110101111110;
        CCTLT =  0b1110101111110;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            TsIdx13 =* uImm;
            CCTLTOp =* CCTLTOp;
            !NencCCTLTIDx;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CCTLT_IVALL"

        FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CCTLTOpIVALL:cctltop

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctltop != `CCTLTOp@INVALIDCCTLTOP2):
                "Invalid CCTLTOp (cctltop) field value INVALIDCCTLTOP2"

            ILLEGAL_INSTR_ENCODING_ERROR
                (cctltop != `CCTLTOp@INVALIDCCTLTOP3):
                "Invalid CCTLTOp (cctltop) field value INVALIDCCTLTOP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        CCTLTmio_pipe =  0b1110101111110;
        CCTLT =  0b1110101111110;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCTLTOp =* CCTLTOpIVALL;
            TsIdx13 = 0;
            !NencCCTLTIDx;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "MEMBAR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MemBarLevel:lvl /MemBarIvall(NOIVALL):ivall

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS
            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "





    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        MEMBARmio_pipe =  0b1110111110011;
        MEMBAR =  0b1110111110011;

    ENCODING
            Opcode13 = Opcode;
            MembarL = MemBarLevel;
            Pred = Pg;
            PredNot = Pg@not;
     Ivall = MemBarIvall;
            !NencMEMBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;

CLASS "SULD_D_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /LoadCacheOp(CA):cop /LDInteger_nU128("32"):size /Clamp1(NEAR):clamp
            Predicate(PT):Pd
            ',' Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))) == 0) :
                "Rd is misaligned in SULD.D"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 )))))) :
                "Register Rd is out of range in SULD.D"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDInteger_nU128@INVALIDSIZE7):
                "Invalid LDInteger_nU128 (size) field value INVALIDSIZE7"




    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SULDmio_pipe =  0b1110101100010;
        SULD =  0b1110101100010;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            PredDest2 = DestPred(Pd);
            COP5 = cop;
            BA = ba;
            SUSize = size;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSULD3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SULD_D_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /LoadCacheOp(CA):cop /LDInteger_nU128("32"):size /Clamp1(NEAR):clamp
            Predicate(PT):Pd
            ',' Register:Rd
            ',' [ Register:Ra ]
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))) == 0) :
                "Rd is misaligned in SULD.D"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 )))))) :
                "Register Rd is out of range in SULD.D"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDInteger_nU128@INVALIDSIZE7):
                "Invalid LDInteger_nU128 (size) field value INVALIDSIZE7"



    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SULDmio_pipe =  0b1110101100011;
        SULD =  0b1110101100011;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            PredDest2 = DestPred(Pd);
            COP5 = cop;
            BA = ba;
            SUSize = size;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSULD4;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SULD_P_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /LoadCacheOp(CA):cop /RGBA(RGBA):rgba /Clamp1(NEAR):clamp
            Predicate(PT):Pd
            ',' Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((rgba==`RGBA@R)||(rgba==`RGBA@RG)||(rgba==`RGBA@RGBA)):
                "rgba field can only be .R or .RG or .RGBA for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))) == 0) :
                "Rd is misaligned in SULD.P"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4)))))) :
                "Register Rd is out of range SULD.P"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"



    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))*32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SULDmio_pipe =  0b1110101100000;
        SULD =  0b1110101100000;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            PredDest2 = DestPred(Pd);
            COP5 = cop;
            SURGBA = rgba;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSULD3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SULD_P_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /LoadCacheOp(CA):cop /RGBA(RGBA):rgba /Clamp1(NEAR):clamp
            Predicate(PT):Pd
            ',' Register:Rd
            ',' [ Register:Ra ]
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS


            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((rgba==`RGBA@R)||(rgba==`RGBA@RG)||(rgba==`RGBA@RGBA)):
                "rgba field can only be .R or .RG or .RGBA for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))) == 0) :
                "Rd is misaligned in SULD.P"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4)))))) :
                "Register Rd is out of range SULD.P"
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"



    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))*32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SULDmio_pipe =  0b1110101100001;
        SULD =  0b1110101100001;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            PredDest2 = DestPred(Pd);
            COP5 = cop;
            SURGBA = rgba;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSULD4;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "SUST_D_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /StoreCacheOp(WB):cop /LDInteger_nU128("32"):size /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))) == 0) :
                "Rb is misaligned in SUST.D"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 )))))) :
                "Register Rb is out of range in SUST.D"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDInteger_nU128@INVALIDSIZE7):
                "Invalid LDInteger_nU128 (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUSTmio_pipe =  0b1110101100110;
        SUST =  0b1110101100110;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            COP5 = cop;
            BA = ba;
            SUSize = size;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSULD1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUST_D_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /StoreCacheOp(WB):cop /LDInteger_nU128("32"):size /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))) == 0) :
                "Rb is misaligned in SUST.D"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 )))))) :
                "Register Rb is out of range in SUST.D"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (size != `LDInteger_nU128@INVALIDSIZE7):
                "Invalid LDInteger_nU128 (size) field value INVALIDSIZE7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( size <= 4 ) ? 1 : ( ( size == 5 ) ? 2 : 4 ))*32;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUSTmio_pipe =  0b1110101100111;
        SUST =  0b1110101100111;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            COP5 = cop;
            BA = ba;
            SUSize = size;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSULD2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUST_P_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /StoreCacheOp(WB):cop /RGBA(RGBA):rgba /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((rgba==`RGBA@R)||(rgba==`RGBA@RG)||(rgba==`RGBA@RGBA)):
                "rgba field can only be .R or .RG or .RGBA for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))) == 0) :
                "Rb is misaligned in SUST.P"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4)))))) :
                "Register Rb is out of range in SUST.P"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))*32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUSTmio_pipe =  0b1110101100100;
        SUST =  0b1110101100100;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            COP5 = cop;
            SURGBA = rgba;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSULD1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUST_P_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /StoreCacheOp(WB):cop /RGBA(RGBA):rgba /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((rgba==`RGBA@R)||(rgba==`RGBA@RG)||(rgba==`RGBA@RGBA)):
                "rgba field can only be .R or .RG or .RGBA for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))) == 0) :
                "Rb is misaligned in SUST.P"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4)))))) :
                "Register Rb is out of range in SUST.P"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
        SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_STORE;




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = ((((rgba==`RGBA@R)||(rgba==`RGBA@G)||(rgba==`RGBA@B)||(rgba==`RGBA@A))*1+ ((rgba==`RGBA@RG)||(rgba==`RGBA@RB)||(rgba==`RGBA@GB)||(rgba==`RGBA@RA)||(rgba==`RGBA@GA)||(rgba==`RGBA@BA))*2+ ((rgba==`RGBA@RGB)||(rgba==`RGBA@RGA)||(rgba==`RGBA@RBA)||(rgba==`RGBA@GBA))*3+ ((rgba==`RGBA@RGBA))*4))*32;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUSTmio_pipe =  0b1110101100101;
        SUST =  0b1110101100101;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            COP5 = cop;
            SURGBA = rgba;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSULD2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "SURED_D_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /RedOp:redop /AtomicInteger("U32"):size /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@ADD) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@F32.FTZ.RN)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SURED.ADD only supports sizes U32, S32, U64, F32.FTZ.RN, F16x2.FTZ.RN and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MIN) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SURED.MIN only supports sizes U32, S32, U64, S64, SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MAX) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SURED.MAX only supports sizes U32, S32, U64, S64, SD32.F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@INC) -> ((size == `AtomicInteger@U32))):
                "SURED.INC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@DEC) -> ((size == `AtomicInteger@U32))):
                "SURED.DEC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@AND) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SURED.AND only supports sizes U32, S32, U64, and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@OR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SURED.OR only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@XOR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SURED.XOR only supports sizes U32, S32, U64 and SD32"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rb is misaligned in SURED.D/SUATOM.D"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SURED.D/SUATOM.D"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP8):
                "Invalid RedOp (redop) field value INVALIDREDOP8"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP9):
                "Invalid RedOp (redop) field value INVALIDREDOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP10):
                "Invalid RedOp (redop) field value INVALIDREDOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP11):
                "Invalid RedOp (redop) field value INVALIDREDOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP12):
                "Invalid RedOp (redop) field value INVALIDREDOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP13):
                "Invalid RedOp (redop) field value INVALIDREDOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP14):
                "Invalid RedOp (redop) field value INVALIDREDOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP15):
                "Invalid RedOp (redop) field value INVALIDREDOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
         INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
             MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUREDmio_pipe =  0b1110101101010;
        SURED =  0b1110101101010;


    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            SURedOp = redop;
            BA = ba;
            SUSize = size;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSURED1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SURED_D_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /RedOp:redop /AtomicInteger("U32"):size /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@ADD) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@F32.FTZ.RN)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SURED.ADD only supports sizes U32, S32, U64, F32.FTZ.RN, F16x2.FTZ.RN and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MIN) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SURED.MIN only supports sizes U32, S32, U64, S64, SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@MAX) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SURED.MAX only supports sizes U32, S32, U64, S64, SD32.F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@INC) -> ((size == `AtomicInteger@U32))):
                "SURED.INC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@DEC) -> ((size == `AtomicInteger@U32))):
                "SURED.DEC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@AND) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SURED.AND only supports sizes U32, S32, U64, and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@OR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SURED.OR only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((redop == `RedOP@XOR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SURED.XOR only supports sizes U32, S32, U64 and SD32"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rb is misaligned in SURED.D/SUATOM.D"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SURED.D/SUATOM.D"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP8):
                "Invalid RedOp (redop) field value INVALIDREDOP8"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP9):
                "Invalid RedOp (redop) field value INVALIDREDOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP10):
                "Invalid RedOp (redop) field value INVALIDREDOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP11):
                "Invalid RedOp (redop) field value INVALIDREDOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP12):
                "Invalid RedOp (redop) field value INVALIDREDOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP13):
                "Invalid RedOp (redop) field value INVALIDREDOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP14):
                "Invalid RedOp (redop) field value INVALIDREDOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP15):
                "Invalid RedOp (redop) field value INVALIDREDOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
         INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
             MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUREDmio_pipe =  0b1110101101011;
        SURED =  0b1110101101011;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            SURedOp = redop;
            BA = ba;
            SUSize = size;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSURED2;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SURED_P_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /RedOp:redop /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP8):
                "Invalid RedOp (redop) field value INVALIDREDOP8"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP9):
                "Invalid RedOp (redop) field value INVALIDREDOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP10):
                "Invalid RedOp (redop) field value INVALIDREDOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP11):
                "Invalid RedOp (redop) field value INVALIDREDOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP12):
                "Invalid RedOp (redop) field value INVALIDREDOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP13):
                "Invalid RedOp (redop) field value INVALIDREDOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP14):
                "Invalid RedOp (redop) field value INVALIDREDOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP15):
                "Invalid RedOp (redop) field value INVALIDREDOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "
            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                0 :
                "SURED.P is deprecated!"


    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
         INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
             MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUREDmio_pipe =  0b1110101101000;
        SURED =  0b1110101101000;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            SURedOp = redop;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSURED3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SURED_P_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /RedOp:redop /Clamp1(NEAR):clamp
            [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP8):
                "Invalid RedOp (redop) field value INVALIDREDOP8"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP9):
                "Invalid RedOp (redop) field value INVALIDREDOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP10):
                "Invalid RedOp (redop) field value INVALIDREDOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP11):
                "Invalid RedOp (redop) field value INVALIDREDOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP12):
                "Invalid RedOp (redop) field value INVALIDREDOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP13):
                "Invalid RedOp (redop) field value INVALIDREDOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP14):
                "Invalid RedOp (redop) field value INVALIDREDOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redop != `RedOp@INVALIDREDOP15):
                "Invalid RedOp (redop) field value INVALIDREDOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "
            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                0 :
                "SURED.P is deprecated!"


    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
         INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
             MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUREDmio_pipe =  0b1110101101001;
        SURED =  0b1110101101001;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            SURedOp= redop;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rb;
            !NencSURED4;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "SUATOM_D_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /AtomsOp:suatomop /AtomicInteger("U32"):size /Clamp1(NEAR):clamp
            Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP9):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP10):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP11):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP12):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP13):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP14):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP15):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@ADD) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@F32.FTZ.RN)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.ADD only supports sizes U32, S32, U64, F32.FTZ.RN, F16x2.FTZ.RN and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@MIN) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.MIN only supports sizes U32, S32, U64, S64, SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@MAX) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.MAX only supports sizes U32, S32, U64, S64 SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@INC) -> ((size == `AtomicInteger@U32))):
                "SUATOM.INC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@DEC) -> ((size == `AtomicInteger@U32))):
                "SUATOM.DEC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@AND) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.AND only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@OR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.OR only supports sizes U32, S32, U64 and SD32 "
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@XOR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.XOR only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@EXCH) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64))):
                "SUATOM.EXCH only supports sizes U32, S32 and U64"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rb is misaligned in SURED.D/SUATOM.D"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SURED.D/SUATOM.D"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rd is misaligned in SUATOM.D"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SUATOM.D"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101001110;
        SUATOM =  0b1110101001110;


    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            satmSize2 = size;
            SUDim = dim;
            satmOp = suatomop;
            satmBA = ba;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_D_REG_SPARSE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /AtomsOp:suatomop /AtomicInteger("U32"):size /Clamp1(NEAR):clamp
            Predicate:Pd
            ',' Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP9):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP10):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP11):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP12):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP13):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP14):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP15):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@ADD) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@F32.FTZ.RN)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.ADD only supports sizes U32, S32, U64, F32.FTZ.RN, F16x2.FTZ.RN and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@MIN) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.MIN only supports sizes U32, S32, U64, S64, SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@MAX) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.MAX only supports sizes U32, S32, U64, S64 SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@INC) -> ((size == `AtomicInteger@U32))):
                "SUATOM.INC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@DEC) -> ((size == `AtomicInteger@U32))):
                "SUATOM.DEC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@AND) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.AND only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@OR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.OR only supports sizes U32, S32, U64 and SD32 "
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@XOR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.XOR only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@EXCH) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64))):
                "SUATOM.EXCH only supports sizes U32, S32 and U64"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rb is misaligned in SURED.D/SUATOM.D"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SURED.D/SUATOM.D"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rd is misaligned in SUATOM.D"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SUATOM.D"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101110;
        SUATOM =  0b1110101110;


    ENCODING
            Opcode10 = Opcode;
            PredDest3 = DestPred(Pd);
            Clamp4 = clamp;
            RegC = Rc;
            satmSize2 = size;
            SUDim = dim;
            satmOp = suatomop;
            satmBA = ba;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_D_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /AtomsOp:suatomop /AtomicInteger("U32"):size /Clamp1(NEAR):clamp
            Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP9):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP10):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP11):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP12):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP13):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP14):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP15):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@ADD) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@F32.FTZ.RN)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.ADD only supports sizes U32, S32, U64, F32.FTZ.RN, F16x2.FTZ.RN and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@MIN) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.MIN only supports sizes U32, S32, U64, S64, SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@MAX) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@S64)||(size == `AtomicInteger@SD32)||(size == `AtomicInteger@SD64)||(size == `AtomicInteger@F16x2.FTZ.RN))):
                "SUATOM.MAX only supports sizes U32, S32, U64, S64 SD32, F16x2.FTZ.RN and SD64"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@INC) -> ((size == `AtomicInteger@U32))):
                "SUATOM.INC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@DEC) -> ((size == `AtomicInteger@U32))):
                "SUATOM.DEC only supports sizes U32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@AND) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.AND only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@OR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.OR only supports sizes U32, S32, U64 and SD32 "
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@XOR) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)||(size == `AtomicInteger@SD32))):
                "SUATOM.XOR only supports sizes U32, S32, U64 and SD32"
                ILLEGAL_INSTR_ENCODING_ERROR
                ((suatomop == `AtomsOp@EXCH) -> ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64))):
                "SUATOM.EXCH only supports sizes U32, S32 and U64"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rb is misaligned in SURED.D/SUATOM.D"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SURED.D/SUATOM.D"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rd is misaligned in SUATOM.D"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SUATOM.D"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101000;
        SUATOM =  0b1110101000;

    ENCODING
            Opcode10 = Opcode;
            satmSize1 = size;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            satmOp = suatomop;
            satmBA = ba;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_P_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /AtomsOp:suatomop /Clamp1(NEAR):clamp
            Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP9):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP10):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP11):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP12):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP13):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP14):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP15):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                0 :
                "SUATOM.P is deprecated!"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101001100;
        SUATOM =  0b1110101001100;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            satmOp = suatomop;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_P_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /AtomsOp:suatomop /Clamp1(NEAR):clamp
            Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP9):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP9"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP10):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP10"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP11):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP11"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP12):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP12"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP13):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP13"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP14):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP14"

            ILLEGAL_INSTR_ENCODING_ERROR
                (suatomop != `AtomsOp@INVALIDATOMSOP15):
                "Invalid AtomsOp (suatomop) field value INVALIDATOMSOP15"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                0 :
                "SUATOM.P is deprecated!"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101001101;
        SUATOM =  0b1110101001101;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            satmOp = suatomop;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_D_CAS_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /CAS:suatomop /AtomicInteger("U32"):size /Clamp1(NEAR):clamp
            Predicate(PT):Pd
            ',' Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)):
                "SUATOM.CAS only supports sizes U32, S32 and U64"
            ILLEGAL_INSTR_ENCODING_ERROR
                (Rc != `Register@RZ):
                "In bindless mode, Rc cannot be RZ for surface instructions"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((((Rc)==`Register@RZ)||((Rc)<=%MAX_REG_COUNT-1)))) :
                "Register Rc is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % ((( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*2))) == 0) :
                "Rb is misaligned in SUATOM.D.CAS"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*2)))))) :
                "Register Rb is out of range in SUATOM.D.CAS"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rd is misaligned in SUATOM.D"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SUATOM.D"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*2*32);
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101011010;
        SUATOM =  0b1110101011010;


    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            satmSize2 = size;
            SUDim = dim;
            PredDest2 = DestPred(Pd);
            satmBA = ba;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM4;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_D_CAS_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /DOnly:d /BA(noBA):ba /Dim1:dim /CAS:suatomop /AtomicInteger("U32"):size /Clamp1(NEAR):clamp
            Predicate(PT):Pd
            ',' Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_ERROR
                ((size == `AtomicInteger@U32)||(size == `AtomicInteger@S32)||(size == `AtomicInteger@U64)):
                "SUATOM.CAS only supports sizes U32, S32 and U64"
            MISALIGNED_REG_ERROR
                ((Ra % (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) + (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ) == 3))) == 0 ) :
                "Ra is misaligned in surface instruction"

                OOR_REG_ERROR
                ((((Ra)==`Register@RZ)||((Ra)<=%MAX_REG_COUNT-(( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") ))))) :
                "Register Ra is out of range in surface instruction"
            MISALIGNED_REG_ERROR
                (Rb == `Register@RZ)||((Rb % ((( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*2))) == 0) :
                "Rb is misaligned in SUATOM.D.CAS"

                OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((((Rb)==`Register@RZ)||((Rb)<=%MAX_REG_COUNT-((( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*2)))))) :
                "Register Rb is out of range in SUATOM.D.CAS"
            MISALIGNED_REG_ERROR
                (Rd == `Register@RZ)||((Rd % (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) ))) == 0) :
                "Rd is misaligned in SUATOM.D"

                OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((((Rd)==`Register@RZ)||((Rd)<=%MAX_REG_COUNT-(( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )))))) :
                "Register Rb is out of range in SUATOM.D"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*32);
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = (( ((size == `AtomicInteger@U32)) + ((size == `AtomicInteger@S32)) + ((size == `AtomicInteger@SD32)) + ((size == `AtomicInteger@U64)*2) + ((size == `AtomicInteger@S64)*2) + ((size == `AtomicInteger@SD64)*2) + ((size == `AtomicInteger@F32.FTZ.RN) + ((size == `AtomicInteger@F16x2.FTZ.RN)*1)) )*2*32);
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101010;
        SUATOM =  0b1110101010;

    ENCODING
            Opcode10 = Opcode;
            satmSize1 = size;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            PredDest2 = DestPred(Pd);
            satmBA = ba;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM5;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_P_CAS_REG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /CAS:suatomop /Clamp1(NEAR):clamp
            Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' Register:Rc

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                0 :
                "SUATOM.P.CAS is deprecated!"

    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101011000;
        SUATOM =  0b1110101011000;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            RegC = Rc;
            SUDim = dim;
            satmOp = suatomop;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SUATOM_P_CAS_IMM"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /Dim1:dim /CAS:suatomop /Clamp1(NEAR):clamp
            Register:Rd
            ',' [ Register:Ra ]
            ',' Register:Rb
            ',' UImm(13):suid

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (clamp != `Clamp1@INVALIDSURFACECLAMP3):
                "Invalid Clamp1 (clamp) field value INVALIDSURFACECLAMP3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM6):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM6"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dim != `Dim1@INVALIDSURFACEDIM7):
                "Invalid Dim1 (dim) field value INVALIDSURFACEDIM7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (Ra != `Register@RZ):
                "Ra cannot be RZ for surface instructions"
            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                0 :
                "SUATOM.P.CAS is deprecated!"


    PROPERTIES
        SECONDARY;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_SURFACE_COORDINATES);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_TEX);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(suid));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = (( (Dim1 == `Dim1@"1D") + (Dim1 == `Dim1@"1D_BUFFER") + (Dim1 == `Dim1@"1D_ARRAY") * 2 + (Dim1 == `Dim1@"2D") * 2 + (Dim1 == `Dim1@"2D_ARRAY") * 3 + (Dim1 == `Dim1@"3D") * 3 + (Dim1 == `Dim1@"INVALIDSURFACEDIM6") + (Dim1 == `Dim1@"INVALIDSURFACEDIM7") )) * 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 13;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_TEX;


    OPCODES
        SUATOMmio_pipe =  0b1110101011001;
        SUATOM =  0b1110101011001;

    ENCODING
            Opcode13 = Opcode;
            Clamp4 = clamp;
            TidB = suid;
            SUDim = dim;
            satmOp = suatomop;
            RegB = Rb;
            PredNot = Pg@not;
            Pred = Pg;
            RegA = Ra;
            Dest = Rd;
            !NencSUATOM3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;






CLASS "BRA"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
             ',' RSImm(24)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(sImm);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        BRAbru_pipe =  0b111000100100;
        BRA =  0b111000100100;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            CA = 0;
            Imm24 = sImm;
            U = U;
            LMT = LMT;
            !NencBRA;
            !RegA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BRA_c"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        BRAbru_pipe =  0b111000100100;
        BRA =  0b111000100100;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            U = U;
            LMT = LMT;
            !ScaleLow;
            !NencBRA;
            !RegA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "BRX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
            ',' Register:Ra SImm(24/0):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(Ra);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        BRXbru_pipe =  0b111000100101;
        BRX =  0b111000100101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            CA = 0;
            Imm24 = sImm;
            RegA = Ra;
            LMT = LMT;
            !U;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BRX_c"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
',' C:srcConst[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(sImm);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        BRXbru_pipe =  0b111000100101;
        BRX =  0b111000100101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
            RegA = Ra;
            LMT = LMT;
            !U;
            !ScaleLow;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "JMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
             ',' UImm(32)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(sImm);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        JMPbru_pipe =  0b111000100001;
        JMP =  0b111000100001;

    ENCODING
            Opcode12 = Opcode;
            Imm32 = sImm;
            Pred = Pg;
            PredNot = Pg@not;
            U = U;
            LMT = LMT;
            CA = 0;
            CCC_1 = Test;
            !RegA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "JMP_c"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS
            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        JMPbru_pipe =  0b111000100001;
        JMP =  0b111000100001;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            U = U;
            LMT = LMT;
            !RegA;
            !NencJMP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "JMX"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
            ',' Register:Ra SImm(32/0):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(Ra);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        JMXbru_pipe =  0b111000100000;
        JMX =  0b111000100000;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            CA = 0;
            Imm32 = sImm;
            RegA = Ra;
            LMT = LMT;
            !U;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "JMX_c"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
          { CC(CC):TestCC/Test(T):CCTest }
',' C:srcConst[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:sImm]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(sImm);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(Ra)) + (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        JMXbru_pipe =  0b111000100000;
        JMX =  0b111000100000;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
            RegA = Ra;
            LMT = LMT;
            !U;
            !NencJMP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "CAL"

    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS



    PROPERTIES
            BRANCH_TYPE = BRT_CALL;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(sImm);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        CALbru_pipe =  0b111000100110;
        CAL =  0b111000100110;

    ENCODING
            Opcode12 = Opcode;
            CA = 0;
            Imm24 = sImm;
            INC = INC;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !CCC_1;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CAL_c"

FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
            BRANCH_TYPE = BRT_CALL;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        CALbru_pipe =  0b111000100110;
        CAL =  0b111000100110;

    ENCODING
            Opcode12 = Opcode;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            INC = INC;
            !ScaleLow;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !CCC_1;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "PRET"

    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
           BRANCH_TARGET_INDEX = INDEX(sImm);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PRETbru_pipe =  0b111000100111;
        PRET =  0b111000100111;

    ENCODING
            Opcode12 = Opcode;
            CA = 0;
            Imm24 = sImm;
            INC = INC;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !CCC_1;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "PRET_c"

FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
           BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PRETbru_pipe =  0b111000100111;
        PRET =  0b111000100111;

    ENCODING
            Opcode12 = Opcode;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            INC = INC;
            !ScaleLow;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !CCC_1;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "JCAL"

    FORMAT Opcode /INC(INC):inc UImm(32)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES
            BRANCH_TYPE = BRT_CALL;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(sImm);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        JCALbru_pipe =  0b111000100010;
        JCAL =  0b111000100010;

    ENCODING
            Opcode12 = Opcode;
            CA = 0;
            Imm32 = sImm;
            INC = INC;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !CCC_1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "JCAL_c"

FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
            BRANCH_TYPE = BRT_CALL;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
           BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        JCALbru_pipe =  0b111000100010;
        JCAL =  0b111000100010;

    ENCODING
            Opcode12 = Opcode;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            INC = INC;
            !NencJMP;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !CCC_1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "SSY"

    FORMAT Opcode RSImm(24)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        SSYbru_pipe =  0b111000101001;
        SSY =  0b111000101001;

    ENCODING
            Opcode12 = Opcode;
            Imm24 = sImm;
            CA = 0;
            !CCC_1;
            !LMT;
            !U;
            !RegA;
            !Pred;
            !PredNot;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "SSY_c"

FORMAT Opcode C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        SSYbru_pipe =  0b111000101001;
        SSY =  0b111000101001;

    ENCODING
            Opcode12 = Opcode;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            !NencBRA;
            !ScaleLow;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !LMT;
            !CCC_1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "PLONGJMP"

    FORMAT Opcode RSImm(24)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PLONGJMPbru_pipe =  0b111000101000;
        PLONGJMP =  0b111000101000;

    ENCODING
            Opcode12 = Opcode;
            Imm24 = sImm;
            CA = 0;
            !CCC_1;
            !LMT;
            !U;
            !RegA;
            !Pred;
            !PredNot;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "PLONGJMP_c"

FORMAT Opcode C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PLONGJMPbru_pipe =  0b111000101000;
        PLONGJMP =  0b111000101000;

    ENCODING
            Opcode12 = Opcode;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            !NencBRA;
            !ScaleLow;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !LMT;
            !CCC_1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "PBK"

    FORMAT Opcode RSImm(24)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PBKbru_pipe =  0b111000101010;
        PBK =  0b111000101010;

    ENCODING
            Opcode12 = Opcode;
            Imm24 = sImm;
            CA = 0;
            !CCC_1;
            !LMT;
            !U;
            !RegA;
            !Pred;
            !PredNot;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "PBK_c"

FORMAT Opcode C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PBKbru_pipe =  0b111000101010;
        PBK =  0b111000101010;

    ENCODING
            Opcode12 = Opcode;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            !NencBRA;
            !ScaleLow;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !LMT;
            !CCC_1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "PCNT"

    FORMAT Opcode RSImm(24)*:sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 24;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PCNTbru_pipe =  0b111000101011;
        PCNT =  0b111000101011;

    ENCODING
            Opcode12 = Opcode;
            Imm24 = sImm;
            CA = 0;
            !CCC_1;
            !LMT;
            !U;
            !RegA;
            !Pred;
            !PredNot;
            !NencBRA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "PCNT_c"

FORMAT Opcode C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PCNTbru_pipe =  0b111000101011;
        PCNT =  0b111000101011;

    ENCODING
            Opcode12 = Opcode;
            CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
            !NencBRA;
            !ScaleLow;
            !Pred;
            !PredNot;
            !RegA;
            !U;
            !LMT;
            !CCC_1;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "RET"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS



    PROPERTIES
            BRANCH_TYPE = BRT_RETURN;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        RETbru_pipe =  0b111000110010;
        RET =  0b111000110010;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            !Imm32;
            !RegA;
            !U;
            !CA;
            !LMT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "LONGJMP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITION



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        LONGJMPbru_pipe =  0b111000110001;
        LONGJMP =  0b111000110001;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            !Imm32;
            !RegA;
            !U;
            !CA;
            !LMT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "KIL"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;
    CONDITIONS

    ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_PS):
                "Can only be used with pixel shader"


    PROPERTIES
            BRANCH_TYPE = BRT_BRANCHOUT;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_PS);
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_SPH_INSTR_COMBINATION)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        KILbru_pipe =  0b111000110011;
        KIL =  0b111000110011;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            !Imm32;
            !RegA;
            !U;
            !CA;
            !LMT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "BRK"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        BRKbru_pipe =  0b111000110100;
        BRK =  0b111000110100;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            !Imm32;
            !RegA;
            !U;
            !CA;
            !LMT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "CONT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS



    PROPERTIES
            BRANCH_TYPE = BRT_BRANCH;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        CONTbru_pipe =  0b111000110101;
        CONT =  0b111000110101;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            !Imm32;
            !RegA;
            !U;
            !CA;
            !LMT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "EXIT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
            /KeepRefCount(noKEEPREFCOUNT):krc CC(CC):TestCC/Test(T):CCTest

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE != $ST_CS) -> (krc == `KeepRefCount@noKEEPREFCOUNT)) :
                    "EXIT.KEEPREFCOUNT can only be used in compute shaders."

    PROPERTIES
            BRANCH_TYPE = BRT_BRANCHOUT;
            CC_INDEX = INDEX(CCTest);

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        EXITbru_pipe =  0b111000110000;
        EXIT =  0b111000110000;

    ENCODING
            Opcode12 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            KeepRefCnt = krc;

            !NencEXIT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "PEXIT"

    FORMAT Opcode RSImm(24)*:sImm


     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        PC_MISALIGNED_ERROR
            ((sImm & 0x7) == 0 ):
                "Misaligned PEXIT address"

        ILLEGAL_INSTR_ENCODING_ERROR
            (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE != $ST_PS):
                "Cant' used with shader type PS"


    PROPERTIES
    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PC_OVERFLOW)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   + (1<<IERROR_PC_MISALIGNED)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC_ADDRESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        PEXITbru_pipe =  0b111000100011;
        PEXIT =  0b111000100011;

    ENCODING
            Opcode12 = Opcode;
            Imm24 = sImm;

            !NencPEXIT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;






 CLASS "SAM"

    FORMAT Opcode

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 2;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_PHYSICAL_STACK_OVERFLOW)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        SAMbru_pipe =  0b111000110111;
        SAM =  0b111000110111;

    ENCODING
            Opcode12 = Opcode;
            !NencRTT;
            !RTTOp;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "RAM"

    FORMAT Opcode

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_API_STACK_ERROR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        RAMbru_pipe =  0b111000111000;
        RAM =  0b111000111000;

    ENCODING
            Opcode12 = Opcode;
            !NencRTT;
            !RTTOp;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "BPT"

    FORMAT Opcode /BPTMode:bpt UImm(20/0):sImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS


            ILLEGAL_INSTR_ENCODING_ERROR
                !(bpt == `BPTMode@TRAP && (sImm < 1 || sImm > 7)) :
                "BPT.TRAP immediate must be between 1 and 7"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bpt != `BPTMode@CAL):
                ".CAL option is illegal for Maxwell BPT instruction"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(sImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        BPTbru_pipe =  0b111000111010;
        BPT =  0b111000111010;

    ENCODING
            Opcode12 = Opcode;
            Imm20 = sImm;
            Bpt = BPTMode;
            !NencBPT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "RTT"

    FORMAT Opcode /RTTOp(POPCRS):rttop

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;
    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR (rttop!=`RTTOp@PREEMPTED) :
                "Illegal instruction encoding: Preempted not supported in sm5 but reserved for the future "


    PROPERTIES
            BRANCH_TYPE = BRT_RETURN;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        RTTbru_pipe =  0b111000110110;
        RTT =  0b111000110110;

    ENCODING
            Opcode12 = Opcode;
            RTTOp = RTTOp;
            !NencRTT;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "IDE_EN"

    FORMAT Opcode /IDEActionENOnly:en UImm(16/0xc10):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;
    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (uImm == 0xC10 ) :
                "only immediate value 0xC10 is allowed"


            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        IDEfxu_pipe =  0b111000111001;
        IDE =  0b111000111001;


    ENCODING
            Opcode12 = Opcode;
            Imm16 = uImm;
            DI = 0;
            !NencIDE;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "IDE_DI"

    FORMAT Opcode /IDEActionDIOnly(DI):di UImm(16/0xc10):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;
    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (uImm == 0xC10 ) :
                "only immediate value 0xC10 is allowed"


            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        IDEfxu_pipe =  0b111000111001;
        IDE =  0b111000111001;


    ENCODING
            Opcode12 = Opcode;
            Imm16 = uImm;
            DI = 1;
            !NencIDE;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
 CLASS "SYNC"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS


    PROPERTIES
        BRANCH_TYPE = BRT_BRANCH;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_BRU_DEPBAR_RD_SCBD;
               MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((CCTest!=`Test@T) && (CCTest!=`Test@F) && (CCTest!=`Test@CSM_TA) && (CCTest!=`Test@CSM_TR) && (CCTest!=`Test@CSM_MX) && (CCTest!=`Test@FCSM_TA) && (CCTest!=`Test@FCSM_TR) && (CCTest!=`Test@FCSM_MX));
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        SYNCbru_pipe =  0b1111000011111;
        SYNC =  0b1111000011111;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            CCC_1 = Test;
            !NencSync;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OETexPhase;
       !OEReserved;
   !OEReserved1;





CLASS "NOP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { CC(CC):TestCC/Test(T):fcomp } ',' UImm(16/0):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        NOPcoupled_fe_pipe =  0b0101000010110;
        NOP =  0b0101000010110;



    ENCODING
            Opcode13 = Opcode;
            Imm16 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            Trig = 0;
            CCC_2 = Test;
            !NencNOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "NOP_trig"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Trig:trig { CC(CC):TestCC/Test(T):fcomp } ',' UImm(16/0):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS



    PROPERTIES

         SINGLETON;



         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = ((fcomp!=`Test@T) && (fcomp!=`Test@F) && (fcomp!=`Test@CSM_TA) && (fcomp!=`Test@CSM_TR) && (fcomp!=`Test@CSM_MX) && (fcomp!=`Test@FCSM_TA) && (fcomp!=`Test@FCSM_TR) && (fcomp!=`Test@FCSM_MX));


    OPCODES
        NOPcoupled_fe_pipe =  0b0101000010110;
        NOP =  0b0101000010110;

    ENCODING
            Opcode13 = Opcode;
            Imm16 = uImm;
            PredNot = Pg@not;
            Pred = Pg;
            Trig = 1;
            CCC_2 = Test;
            !NencNOP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "S2R"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             RegisterFAU:Rd
             ',' SpecialRegister:SR

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(SR));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        S2Rmio_pipe =  0b1111000011001;
        S2R =  0b1111000011001;

    ENCODING
      Opcode13= Opcode;
      SReg = SR;
      PredNot = Pg@not;
      Pred = Pg;
      Dest = Rd;
      !NencS2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "CS2R"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             RegisterFAU:Rd
             ',' SpecialRegister:SR

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"


            ILLEGAL_INSTR_ENCODING_WARNING
                ((SR >= 4)&&(SR <= 11)||(SR >= 72)&&(SR <= 83)):
                "Warning: Only SR4..SR11 and SR72..SR83 are valid for CS2R"


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(SR));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        CS2Rfxu_pipe =  0b0101000011001;
        CS2R =  0b0101000011001;

    ENCODING
      Opcode13= Opcode;
      SReg = SR;
      PredNot = Pg@not;
      Pred = Pg;
      Dest = Rd;
      !NencS2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
  CLASS "B2R_BAR"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdBAR(BAR):barmd
             Register:Rd ','
             UImm(4):barNum

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "Can only be used with compute shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (barmd != `BarmdBAR@INVALID):
                "Invalid BarmdBAR (barmd) field value INVALID"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        B2Rmio_pipe =  0b1111000010111;
        B2R =  0b1111000010111;


    ENCODING
            Opcode13 = Opcode;
            DstPred =* `Predicate@PT;
            Barmd =* BarmdBAR;
            Dest = Rd;
            RegA = barNum;
            Pred = Pg;
            PredNot = Pg@not;

            !NencB2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;





  CLASS "B2R_RESULT"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdRESULT:barmd
             Register:Rd
             ',' Predicate(PT):Pd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "Can only be used with compute shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        B2Rmio_pipe =  0b1111000010111;
        B2R =  0b1111000010111;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Barmd =* BarmdRESULT;
            DstPred = Pd;
            Dest = Rd;
            RegA = `Register@RZ;
            !NencB2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



  CLASS "B2R_WARP"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdWARP:barmd
             Register:Rd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS) :
                "Can only be used with compute shader"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        B2Rmio_pipe =  0b1111000010111;
        B2R =  0b1111000010111;

    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Barmd =* BarmdWARP;
            DstPred =* `Predicate@PT;
            Dest = Rd;
            RegA = `Register@RZ;
            !NencB2R;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "R2B"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Barmd(BAR):barmd
             UImm(4):uImm ','
             Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (barmd != `Barmd@RESULT):
                "R2B.RESULT is invalid"

                ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "must be used with compute shader"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (barmd != `Barmd@INVALID):
                "Invalid Barmd (barmd) field value INVALID"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "



    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 8;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        R2Bmio_pipe =  0b1111000011000;
        R2B =  0b1111000011000;


    ENCODING
            Opcode13 = Opcode;
            Barmd = barmd;
            BarName = uImm;
            Pred = Pg;
            PredNot = Pg@not;
            RegB = Rb;
            !RegA;
            !Dest;
            !NencR2B;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "LEPC"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode Register:Rd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITION

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        LEPCfxu_pipe =  0b0101000011010;
        LEPC =  0b0101000011010;


    ENCODING
            Opcode13 = Opcode;
            Pred = Pg;
            PredNot = Pg@not;
            Dest = Rd;
            !Imm28;
            !LSSize2;
            !RegA;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
CLASS "BAR_Sync"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            Register:Ra ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR ((Ra+(Ra==`Register@RZ)) == (Rb+(Rb==`Register@RZ))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;


    ENCODING
            Opcode13 = Opcode;
            SrcNot = 0;
            SrcPred = `Predicate@PT;
            BarOp =* BarSync;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            RegB = Rb;
            !Dest;

            AFix_BAR=0;
            BFix_BAR=0;
            !BarFiller;
            !BarRedOp;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Sync_b"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            Register:Ra ',' UImm(12/0):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;


    ENCODING
            Opcode13 = Opcode;
            SrcNot = 0;
            SrcPred = `Predicate@PT;
            BarOp =* BarSync;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            Imm12 = uImm;
            !Dest;

            AFix_BAR=0;
            BFix_BAR=1;
            !BarRedOp;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Sync_a_b"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            UImm(4):barNum ',' UImm(12/0):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;


    ENCODING
            Opcode13 = Opcode;
            SrcNot = 0;
            SrcPred = `Predicate@PT;
            BarOp =* BarSync;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            Imm12 = uImm;
            !Dest;

            AFix_BAR=1;
            BFix_BAR=1;
            !BarRedOp;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Sync_a"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            UImm(4):barNum ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;


    ENCODING
            Opcode13 = Opcode;
            SrcNot = 0;
            SrcPred = `Predicate@PT;
            BarOp =* BarSync;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            RegB = Rb;
            !Dest;

            !BarFiller;
            AFix_BAR=1;
            BFix_BAR=0;
            !BarRedOp;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Arv"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            Register:Ra ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;



    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR ((Ra+(Ra==`Register@RZ)) == (Rb+(Rb==`Register@RZ))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarArv;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            RegB = Rb;
            !Dest;

            SrcPred = `Predicate@PT;
            SrcNot = 0;
            !BarFiller;
            AFix_BAR=0;
            BFix_BAR=0;
            !BarRedOp;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Arv_a"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            UImm(4):barNum ',' Register:Rb

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;



    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarArv;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            RegB = Rb;
            !Dest;

            SrcPred = `Predicate@PT;
            SrcNot = 0;
            !BarFiller;
            AFix_BAR=1;
            BFix_BAR=0;
            !BarRedOp;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Arv_imm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            Register:Ra ',' UImm(12):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarArv;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            Imm12 = uImm;

            !Dest;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            !BarRedOp;
            AFix_BAR=0;
            BFix_BAR=1;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Arv_imm_a"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            UImm(4):barNum ',' UImm(12):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarArv;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            Imm12 = uImm;

            !Dest;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            !BarRedOp;
            AFix_BAR=1;
            BFix_BAR=1;
            !NencBAR;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Red"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            Register:Ra ',' Register:Rb ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR ((Ra+(Ra==`Register@RZ)) == (Rb+(Rb==`Register@RZ))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redmode != `Red@INVALIDBARMODE3):
                "Invalid Red (redmode) field value INVALIDBARMODE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarRED;
            BarRedOp = Red;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            RegB = Rb;
            SrcPred = Pa;
            SrcNot = Pa@not;
            !Dest;
            !BarFiller;
            AFix_BAR=0;
            BFix_BAR=0;
            !NencBAR;




      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Red_b"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            Register:Ra ',' UImm(12/0):uImm ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redmode != `Red@INVALIDBARMODE3):
                "Invalid Red (redmode) field value INVALIDBARMODE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarRED;
            BarRedOp = Red;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            Imm12 = uImm;
            SrcPred = Pa;
            SrcNot = Pa@not;
            !Dest;
            AFix_BAR=0;
            BFix_BAR=1;
            !NencBAR;




      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Red_a_b"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            UImm(4):barNum ',' UImm(12/0):uImm ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redmode != `Red@INVALIDBARMODE3):
                "Invalid Red (redmode) field value INVALIDBARMODE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarRED;
            BarRedOp = Red;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            Imm12 = uImm;
            SrcPred = Pa;
            SrcNot = Pa@not;
            !Dest;
            AFix_BAR=1;
            BFix_BAR=1;
            !NencBAR;




      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_Red_a"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            UImm(4):barNum ',' Register:Rb ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;


    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (redmode != `Red@INVALIDBARMODE3):
                "Invalid Red (redmode) field value INVALIDBARMODE3"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarRED;
            BarRedOp = Red;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            RegB = Rb;
            SrcPred = Pa;
            SrcNot = Pa@not;
            !Dest;
            !BarFiller;
            AFix_BAR=1;
            BFix_BAR=0;
            !NencBAR;




      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "BAR_syncall"

    FORMAT Opcode /BarSYNCALL:barmode

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;
    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarSYNCALL;
            Pred =*`Predicate@PT;
            PredNot =* 0;
            !RegA;
            RegB = `Register@RZ;
            !Dest;
            SrcPred = `Predicate@PT;
            SrcNot = 0;
            !BarFiller;
            !BarRedOp;
            !NencBAR2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "BAR_Scan"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            Register:Ra ',' Register:Rb ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR ((Ra+(Ra==`Register@RZ)) == (Rb+(Rb==`Register@RZ))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarSCAN;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            RegB = Rb;
            !Dest;
            SrcPred = Pa;
            SrcNot = Pa@not;
            !BarFiller;
            AFix_BAR=0;
            BFix_BAR=0;
            !BarRedOp;
            !NencBAR;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



 CLASS "BAR_Scan_a"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            UImm(4):barNum ',' Register:Rb ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarSCAN;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            RegB = Rb;
            !Dest;
             SrcPred = Pa;
             SrcNot = Pa@not;
            !BarFiller;
            AFix_BAR=1;
            BFix_BAR=0;
            !BarRedOp;
            !NencBAR;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "BAR_scan_imm"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            Register:Ra ',' UImm(12):uImm ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarSCAN;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = Ra;
            Imm12 = uImm;
            !Dest;
             SrcPred = Pa;
             SrcNot = Pa@not;
            !BarRedOp;
            AFix_BAR=0;
            BFix_BAR=1;
            !NencBAR;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "BAR_scan_imm_a"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            UImm(4):barNum ',' UImm(12):uImm ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS

            ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || (%SHADER_TYPE == $ST_CS):
                "Shader type must be CS"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = (1<<ISHADER_CS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM)
                   + (1<<IERROR_ILLEGAL_INSTR_PARAM2)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_INTEGER);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(barNum));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 4;
         ISRC_B_SIZE = 12;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        BARmio_pipe =  0b1111000010101;
        BAR =  0b1111000010101;

    ENCODING
            Opcode13 = Opcode;
            BarOp =* BarSCAN;
            Pred = Pg;
            PredNot = Pg@not;
            RegA = barNum;
            Imm12 = uImm;
            !Dest;
             SrcPred = Pa;
             SrcNot = Pa@not;
            !BarRedOp;
            AFix_BAR=1;
            BFix_BAR=1;
            !NencBAR;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "VOTE.VTG"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VTG:vtg /VTGMode:vtgmode UImm(28):uImm

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;
    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_VSA) || (%SHADER_TYPE == $ST_VSB) || (%SHADER_TYPE == $ST_TI) || (%SHADER_TYPE == $ST_TS) || (%SHADER_TYPE == $ST_GS)) :
                " VOTE.VTG can only be used with VSa, VSb, TI, TS, or GS"
            ILLEGAL_INSTR_ENCODING_ERROR
                (vtgmode != `VTGMode@INVALIDVTGMODE3):
                "Invalid VTGMode (vtgmode) field value INVALIDVTGMODE3"



    PROPERTIES
        SIDL_NAME = `SIDL_NAMES@VOTE_VTG;

    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_VOTE_INDEX);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(uImm));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 28;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VOTEfxu_pipe =  0b010_10000_11100;
        VOTE =  0b010_10000_11100;

    ENCODING
      Opcode13 = Opcode;
      VMode = VTGMode;
      Pred = Pg;
      PredNot = Pg@not;
      Imm28 = uImm;

      !NencVOTEVTG;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "VOTE"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VoteOp:voteop
          { Register(RZ):Rd }
            ',' Predicate:Pd
            ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
     $( { '?' USCHED_INFO:usched_info } )$
            ;

    CONDITIONS
            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (voteop != `VoteOp@INVALIDVMODE3):
                "Invalid VoteOp (voteop) field value INVALIDVMODE3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_MATH;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;


    OPCODES
        VOTEfxu_pipe =  0b010_10000_11011;
        VOTE =  0b010_10000_11011;

    ENCODING
      Opcode13 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      VMode = VoteOp;
      Dest = Rd;
      VPDest = Pd;
      SrcPred = Pa;
      SrcNot = Pa@not;

      !NencVOTE;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = 7;
           OEVarLatSrc = 7;
           !OEReuseA;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "SETCRSPTR"

    FORMAT Opcode Register:Ra

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "


    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 5;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        SETCRSPTRmio_pipe =  0b111000_10_1110;
        SETCRSPTR =  0b111000_10_1110;

    ENCODING
      Opcode12 = Opcode;
      RegA = Ra;
      !Dest;
      !NencCRSLMEM;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;



CLASS "GETCRSPTR"

    FORMAT Opcode Register:Rd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_UNORDERED;


    OPCODES
        GETCRSPTRmio_pipe =  0b111000_10_1100;
        GETCRSPTR =  0b111000_10_1100;

    ENCODING
      Opcode12 = Opcode;
      Dest = Rd;
      !RegA ;
      !NencCRSLMEM;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "SETLMEMBASE"

    FORMAT Opcode Register:Ra

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (dst_wr_sb == 7):
                "Illegal instruction encoding: Instruction type INST_TYPE_MIO_RD_SCBD can not have a wr scoreboard value other than 7 (no scbd) "
            MISALIGNED_REG_ERROR
                IsEven(((Ra)+((Ra)==`Register@RZ))) :
                "An even address register is required"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 64;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_ADU;


    OPCODES
        SETLMEMBASEmio_pipe =  0b111000_10_1111;
        SETLMEMBASE =  0b111000_10_1111;

    ENCODING
      Opcode12 = Opcode;
      RegA = Ra;
      !Dest;
      !NencCRSLMEM;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;




CLASS "GETLMEMBASE"

    FORMAT Opcode Register:Rd

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            MISALIGNED_REG_ERROR
                IsEven(((Rd)+((Rd)==`Register@RZ))) :
                "Register numbers must be even for double float operations"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))) :
                "Register Rd is out of range"




    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_MISALIGNED_REG)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 64;
         ISRC_A_SIZE = 0;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_ADU;


    OPCODES
        GETLMEMBASEmio_pipe =  0b111000_10_1101;
        GETLMEMBASE =  0b111000_10_1101;

    ENCODING
      Opcode12 = Opcode;
      Dest = Rd;
      !RegA;
      !NencCRSLMEM;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;
CLASS "ISBERD"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ISBERDIO(I):io /BASE(MAP):base /SKEW(noSKEW):skew /ISBERDInteger(U8):size
             Register:Rd
             ',' [Register:Ra]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_bit_set } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

        ILLEGAL_INSTR_ENCODING_ERROR
                (%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_TI) || (%SHADER_TYPE == $ST_TS) || (%SHADER_TYPE == $ST_GS) || (%SHADER_TYPE == $ST_VSA) || (%SHADER_TYPE == $ST_VSB)) :
                " ISBERD can only be used with VSa, VSb, TI, TS, or GS"

                ILLEGAL_INSTR_ENCODING_ERROR
                ((io == `ISBERDIO@O) -> ((%SHADER_TYPE == $ST_UNKNOWN) || ((%SHADER_TYPE == $ST_TI) || (%SHADER_TYPE == $ST_TS) || (%SHADER_TYPE == $ST_VSA) || (%SHADER_TYPE == $ST_VSB)))) :
                " ISBERD.O can only be used with VSa, VSb, TI, or TS"

                ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
                ((((%SHADER_TYPE == $ST_VSA) || (%SHADER_TYPE == $ST_VSB))&&(io==`ISBERDIO@I)) -> ((base!=`BASE@MAP) && (base!=`BASE@PATCH))) :
                " ISBERD.I.MAP and ISBERD.I.PATCH canot be used with VSa, VSb"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;




         VALID_IN_SHADERS = (1<<ISHADER_VS) + (1<<ISHADER_GS) + (1<<ISHADER_TI) + (1<<ISHADER_TS);
              INSTRUCTION_TYPE = INST_TYPE_DECOUPLED_RD_WR_SCBD;
              MIN_WAIT_NEEDED = 1;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_GENERIC);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_RAW_ISBE_ACCESS);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = (((size==`ISBERDInteger@U8)*8) + ((size==`ISBERDInteger@U16)*16) + ((size==`ISBERDInteger@"32")*32));
         ISRC_A_SIZE = 10;
         ISRC_B_SIZE = 0;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_SHM;


    OPCODES
        ISBERDmio_pipe =  0b1110111111010;
        ISBERD =  0b1110111111010;

    ENCODING
      Opcode13 = Opcode;
      ALSize = ISBERDInteger;
      IBase = base;
      AIO = ISBERDIO;
      P = SKEW;
      Pred = Pg;
      PredNot = Pg@not;
      RegA =* Ra;
      Dest = Rd;

      !NencISBERD;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_bit_set;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           !OETexPhase;
       !OEReserved;
   !OEReserved1;


CLASS "hfma2__v2"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hfma2__v2_ofmt("F16_V2"):ofmt /hfma2__v2_fmz("nofmz"):fmz /hfma2__v2_sat("nosat"):sat hfma2__v2_Rd:Rd
',' $( [-] hfma2__v2_Ra:Ra /hfma2__v2_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' $( [-] hfma2__v2_Rb:Rb /hfma2__v2_Sb_iswz_Rb_mod("H1_H0"):iswz_Rb_mod {/REUSE(noreuse):reuse_src_b} )$
',' $( [-] hfma2__v2_Rc:Rc /hfma2__v2_Rc_iswz_Rc_reg_mod("H1_H0"):iswz_Rc_reg_mod {/REUSE(noreuse):reuse_src_c} )$
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HFMA2_REG ;
 ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 32;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HFMA2fp16g0_pipe = 2976;
        HFMA2fp16g1_pipe = 2976;
        HFMA2 = 2976;
ENCODING
!hfma2__v2_unused;
hfma2__v2_Pg = Pg;
hfma2__v2_PgNot = Pg@not;
hfma2__v2_opcode=Opcode;
hfma2__v2_ofmt=ofmt;
hfma2__v2_fmz=fmz;
hfma2__v2_sat=sat;
hfma2__v2_Rd=Rd;
hfma2__v2_Ra=Ra;
hfma2__v2_Ra_iswz_Ra_mod=iswz_Ra_mod;
hfma2__v2_Sb=Rb;
hfma2__v2_Sb_iswz_Rb_mod=iswz_Rb_mod;
hfma2__v2_Rc=Rc;
hfma2__v2_Rc_negate=Rc@negate;
hfma2__v2_Rc_iswz_Rc_reg_mod=iswz_Rc_reg_mod;
hfma2__v2_req_sb_bitset=req_sb_bitset;
hfma2__v2_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hfma2__v2_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
OEReuseB = reuse_src_b;
OEReuseC = reuse_src_c;
hfma2__v2_usched_info=usched_info;
hfma2__v2_nAB=hfma2__v2_nAB(Ra@negate,Rb@negate);


CLASS "hfma2__v1"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hfma2__v1_ofmt("F16_V2"):ofmt /hfma2__v1_fmz("nofmz"):fmz /hfma2__v1_sat("nosat"):sat hfma2__v1_Rd:Rd
',' $( hfma2__v1_Ra:Ra /hfma2__v1_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
','F16Imm(64):Sb ','F16Imm(64):Sb2
',' $( [-] hfma2__v1_Rc:Rc /hfma2__v1_Rc_iswz_Rc_mod("H1_H0"):iswz_Rc_mod {/REUSE(noreuse):reuse_src_c} )$
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"




PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HFMA2_IMM ;
 ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Sb))+(1<<INDEX(Sb)+1);
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 32;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 20;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HFMA2fp16g0_pipe = 28;
        HFMA2fp16g1_pipe = 28;
        HFMA2 = 28;
ENCODING
!hfma2__v1_unused;
hfma2__v1_Pg = Pg;
hfma2__v1_PgNot = Pg@not;
hfma2__v1_opcode=Opcode;
hfma2__v1_ofmt=ofmt;
hfma2__v1_fmz=fmz;
hfma2__v1_sat=sat;
hfma2__v1_Rd=Rd;
hfma2__v1_Ra=Ra;
hfma2__v1_Ra_iswz_Ra_mod=iswz_Ra_mod;
hfma2__v1_Sb=Sb;
hfma2__v1_Sb2=Sb2;
hfma2__v1_Rc=Rc;
hfma2__v1_Rc_negate=Rc@negate;
hfma2__v1_Rc_iswz_Rc_mod=iswz_Rc_mod;
hfma2__v1_req_sb_bitset=req_sb_bitset;
hfma2__v1_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hfma2__v1_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
OEReuseC = reuse_src_c;
hfma2__v1_usched_info=usched_info;


CLASS "hfma2__v0"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hfma2__v0_ofmt("F16_V2"):ofmt /hfma2__v0_fmz("nofmz"):fmz /hfma2__v0_sat("nosat"):sat hfma2__v0_Rd:Rd
',' $( [-] hfma2__v0_Ra:Ra /hfma2__v0_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' [-] C:Sb[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
',' $( [-] hfma2__v0_Rc:Rc /hfma2__v0_Rc_iswz_Rc_mod("H1_H0"):iswz_Rc_mod {/REUSE(noreuse):reuse_src_c} )$
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_MISALIGNED_ADDR)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+(1<<IERROR_INVALID_CONST_ADDR)+(1<<IERROR_OOR_REG)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HFMA2_BCST ;
 ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(constBank))+(1<<INDEX(immConstOffset));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 32;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HFMA2fp16g0_pipe = 29;
        HFMA2fp16g1_pipe = 29;
        HFMA2 = 29;
ENCODING
!hfma2__v0_unused;
hfma2__v0_Pg = Pg;
hfma2__v0_PgNot = Pg@not;
hfma2__v0_opcode=Opcode;
hfma2__v0_ofmt=ofmt;
hfma2__v0_fmz=fmz;
hfma2__v0_sat=sat;
hfma2__v0_Rd=Rd;
hfma2__v0_Ra=Ra;
hfma2__v0_Ra_iswz_Ra_mod=iswz_Ra_mod;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
hfma2__v0_Rc=Rc;
hfma2__v0_Rc_negate=Rc@negate;
hfma2__v0_Rc_iswz_Rc_mod=iswz_Rc_mod;
hfma2__v0_req_sb_bitset=req_sb_bitset;
hfma2__v0_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hfma2__v0_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
OEReuseC = reuse_src_c;
hfma2__v0_usched_info=usched_info;
hfma2__v0_nAB=hfma2__v0_nAB(Ra@negate,Sb@negate);


CLASS "hset2__v2"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hset2__v2_bval("BM"):bval /hset2__v2_cmp:cmp /hset2__v2_ftz("noftz"):ftz /hset2__v2_bop:bop hset2__v2_Rd:Rd
',' $( [-][||] hset2__v2_Ra:Ra /hset2__v2_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' $( [-][||] hset2__v2_Rb:Rb /hset2__v2_Sb_iswz_Rb_mod("H1_H0"):iswz_Rb_mod {/REUSE(noreuse):reuse_src_b} )$
',' [!]Predicate:Ps
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HSET2_REG ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HSET2fp16g0_pipe = 2979;
        HSET2fp16g1_pipe = 2979;
        HSET2 = 2979;
ENCODING
!hset2__v2_unused;
hset2__v2_Pg = Pg;
hset2__v2_PgNot = Pg@not;
hset2__v2_opcode=Opcode;
hset2__v2_bval=bval;
hset2__v2_cmp=cmp;
hset2__v2_ftz=ftz;
hset2__v2_bop=bop;
hset2__v2_Rd=Rd;
hset2__v2_Ra=Ra;
hset2__v2_Ra_absolute=Ra@absolute;
hset2__v2_Ra_negate=Ra@negate;
hset2__v2_Ra_iswz_Ra_mod=iswz_Ra_mod;
hset2__v2_Sb=Rb;
hset2__v2_Sb_absolute=Rb@absolute;
hset2__v2_Sb_negate=Rb@negate;
hset2__v2_Sb_iswz_Rb_mod=iswz_Rb_mod;
hset2__v2_Ps = Ps;
hset2__v2_PsNot = Ps@not;
hset2__v2_req_sb_bitset=req_sb_bitset;
hset2__v2_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hset2__v2_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
OEReuseB = reuse_src_b;
!OEReuseC;
hset2__v2_usched_info=usched_info;


CLASS "hset2__v1"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hset2__v1_bval("BM"):bval /hset2__v1_cmp:cmp /hset2__v1_ftz("noftz"):ftz /hset2__v1_bop:bop hset2__v1_Rd:Rd
',' $( [-][||] hset2__v1_Ra:Ra /hset2__v1_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
','F16Imm(64):Sb ','F16Imm(64):Sb2
',' [!]Predicate:Ps
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;
    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HSET2_IMM ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Sb))+(1<<INDEX(Sb)+1);
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 20;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HSET2fp16g0_pipe = 124;
        HSET2fp16g1_pipe = 124;
        HSET2 = 124;
ENCODING
!hset2__v1_unused;
hset2__v1_Pg = Pg;
hset2__v1_PgNot = Pg@not;
hset2__v1_opcode=Opcode;
hset2__v1_bval=bval;
hset2__v1_cmp=cmp;
hset2__v1_ftz=ftz;
hset2__v1_bop=bop;
hset2__v1_Rd=Rd;
hset2__v1_Ra=Ra;
hset2__v1_Ra_absolute=Ra@absolute;
hset2__v1_Ra_negate=Ra@negate;
hset2__v1_Ra_iswz_Ra_mod=iswz_Ra_mod;
hset2__v1_Sb=Sb;
hset2__v1_Sb2=Sb2;
hset2__v1_Ps = Ps;
hset2__v1_PsNot = Ps@not;
hset2__v1_req_sb_bitset=req_sb_bitset;
hset2__v1_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hset2__v1_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hset2__v1_usched_info=usched_info;


CLASS "hset2__v0"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hset2__v0_bval("BM"):bval /hset2__v0_cmp:cmp /hset2__v0_ftz("noftz"):ftz /hset2__v0_bop:bop hset2__v0_Rd:Rd
',' $( [-][||] hset2__v0_Ra:Ra /hset2__v0_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' [-] C:Sb[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
',' [!]Predicate:Ps
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;
    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+(1<<IERROR_INVALID_CONST_ADDR)+(1<<IERROR_MISALIGNED_ADDR)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HSET2_BCST ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(constBank))+(1<<INDEX(immConstOffset));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HSET2fp16g0_pipe = 125;
        HSET2fp16g1_pipe = 125;
        HSET2 = 125;
ENCODING
!hset2__v0_unused;
hset2__v0_Pg = Pg;
hset2__v0_PgNot = Pg@not;
hset2__v0_opcode=Opcode;
hset2__v0_bval=bval;
hset2__v0_cmp=cmp;
hset2__v0_ftz=ftz;
hset2__v0_bop=bop;
hset2__v0_Rd=Rd;
hset2__v0_Ra=Ra;
hset2__v0_Ra_absolute=Ra@absolute;
hset2__v0_Ra_negate=Ra@negate;
hset2__v0_Ra_iswz_Ra_mod=iswz_Ra_mod;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
hset2__v0_Sb_negate=Sb@negate;
hset2__v0_Ps = Ps;
hset2__v0_PsNot = Ps@not;
hset2__v0_req_sb_bitset=req_sb_bitset;
hset2__v0_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hset2__v0_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hset2__v0_usched_info=usched_info;


ALTERNATE CLASS "hset2_bop__v1"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hset2_bop__v1_bval("BM"):bval /hset2_bop__v1_cmp:cmp /hset2_bop__v1_ftz("noftz"):ftz hset2_bop__v1_Rd:Rd
',' $( [-][||] hset2_bop__v1_Ra:Ra /hset2_bop__v1_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
','F16Imm(64):Sb ','F16Imm(64):Sb2
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 MIN_WAIT_NEEDED = 0 ;
 VALID_IN_SHADERS = ISHADER_ALL ;
 SIDL_NAME = `SIDL_NAMES@HSET2_IMM ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Sb))+(1<<INDEX(Sb)+1);
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 20;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HSET2fp16g0_pipe = 124;
        HSET2fp16g1_pipe = 124;
        HSET2 = 124;
ENCODING
!hset2_bop__v1_unused;
hset2_bop__v1_Pg = Pg;
hset2_bop__v1_PgNot = Pg@not;
hset2_bop__v1_opcode=Opcode;
hset2_bop__v1_bval=bval;
hset2_bop__v1_cmp=cmp;
hset2_bop__v1_ftz=ftz;
hset2_bop__v1_bop=*0;
hset2_bop__v1_Rd=Rd;
hset2_bop__v1_Ra=Ra;
hset2_bop__v1_Ra_absolute=Ra@absolute;
hset2_bop__v1_Ra_negate=Ra@negate;
hset2_bop__v1_Ra_iswz_Ra_mod=iswz_Ra_mod;
hset2_bop__v1_Sb=Sb;
hset2_bop__v1_Sb2=Sb2;
hset2_bop__v1_Ps =* 7;
hset2_bop__v1_PsNot =* 0;
hset2_bop__v1_req_sb_bitset=req_sb_bitset;
hset2_bop__v1_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hset2_bop__v1_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hset2_bop__v1_usched_info=usched_info;


ALTERNATE CLASS "hset2_bop__v0"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hset2_bop__v0_bval("BM"):bval /hset2_bop__v0_cmp:cmp /hset2_bop__v0_ftz("noftz"):ftz hset2_bop__v0_Rd:Rd
',' $( [-][||] hset2_bop__v0_Ra:Ra /hset2_bop__v0_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' [-] C:Sb[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+(1<<IERROR_INVALID_CONST_ADDR)+(1<<IERROR_MISALIGNED_ADDR)+0;
 MIN_WAIT_NEEDED = 0 ;
 VALID_IN_SHADERS = ISHADER_ALL ;
 SIDL_NAME = `SIDL_NAMES@HSET2_BCST ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(constBank))+(1<<INDEX(immConstOffset));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HSET2fp16g0_pipe = 125;
        HSET2fp16g1_pipe = 125;
        HSET2 = 125;
ENCODING
!hset2_bop__v0_unused;
hset2_bop__v0_Pg = Pg;
hset2_bop__v0_PgNot = Pg@not;
hset2_bop__v0_opcode=Opcode;
hset2_bop__v0_bval=bval;
hset2_bop__v0_cmp=cmp;
hset2_bop__v0_ftz=ftz;
hset2_bop__v0_bop=*0;
hset2_bop__v0_Rd=Rd;
hset2_bop__v0_Ra=Ra;
hset2_bop__v0_Ra_absolute=Ra@absolute;
hset2_bop__v0_Ra_negate=Ra@negate;
hset2_bop__v0_Ra_iswz_Ra_mod=iswz_Ra_mod;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
hset2_bop__v0_Sb_negate=Sb@negate;
hset2_bop__v0_Ps =* 7;
hset2_bop__v0_PsNot =* 0;
hset2_bop__v0_req_sb_bitset=req_sb_bitset;
hset2_bop__v0_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hset2_bop__v0_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hset2_bop__v0_usched_info=usched_info;


CLASS "hmul2_32i_"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hmul2_32i__fmz("nofmz"):fmz /hmul2_32i__sat("nosat"):sat hmul2_32i__Rd:Rd
',' $( hmul2_32i__Ra:Ra /hmul2_32i__Ra_iswz_Ra_32i_mod("H1_H0"):iswz_Ra_32i_mod {/REUSE(noreuse):reuse_src_a} )$
','F16Imm(64):imm ','F16Imm(64):imm2
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(imm))+(1<<INDEX(imm)+1);
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HMUL2_32Ifp16g0_pipe = 21;
        HMUL2_32Ifp16g1_pipe = 21;
        HMUL2_32I = 21;
ENCODING
!hmul2_32i__unused;
hmul2_32i__Pg = Pg;
hmul2_32i__PgNot = Pg@not;
hmul2_32i__opcode=Opcode;
hmul2_32i__fmz=fmz;
hmul2_32i__sat=sat;
hmul2_32i__Rd=Rd;
hmul2_32i__Ra=Ra;
hmul2_32i__Ra_iswz_Ra_32i_mod=iswz_Ra_32i_mod;
hmul2_32i__imm=imm;
hmul2_32i__imm2=imm2;
hmul2_32i__req_sb_bitset=req_sb_bitset;
hmul2_32i__src_rel_sb=VarLatOperandEnc(src_rel_sb);
hmul2_32i__dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hmul2_32i__usched_info=usched_info;


ALTERNATE CLASS "hset2_bop__v2"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hset2_bop__v2_bval("BM"):bval /hset2_bop__v2_cmp:cmp /hset2_bop__v2_ftz("noftz"):ftz hset2_bop__v2_Rd:Rd
',' $( [-][||] hset2_bop__v2_Ra:Ra /hset2_bop__v2_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' $( [-][||] hset2_bop__v2_Rb:Rb /hset2_bop__v2_Sb_iswz_Rb_mod("H1_H0"):iswz_Rb_mod {/REUSE(noreuse):reuse_src_b} )$
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;
    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 MIN_WAIT_NEEDED = 0 ;
 VALID_IN_SHADERS = ISHADER_ALL ;
 SIDL_NAME = `SIDL_NAMES@HSET2_REG ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HSET2fp16g0_pipe = 2979;
        HSET2fp16g1_pipe = 2979;
        HSET2 = 2979;
ENCODING
!hset2_bop__v2_unused;
hset2_bop__v2_Pg = Pg;
hset2_bop__v2_PgNot = Pg@not;
hset2_bop__v2_opcode=Opcode;
hset2_bop__v2_bval=bval;
hset2_bop__v2_cmp=cmp;
hset2_bop__v2_ftz=ftz;
hset2_bop__v2_bop=*0;
hset2_bop__v2_Rd=Rd;
hset2_bop__v2_Ra=Ra;
hset2_bop__v2_Ra_absolute=Ra@absolute;
hset2_bop__v2_Ra_negate=Ra@negate;
hset2_bop__v2_Ra_iswz_Ra_mod=iswz_Ra_mod;
hset2_bop__v2_Sb=Rb;
hset2_bop__v2_Sb_absolute=Rb@absolute;
hset2_bop__v2_Sb_negate=Rb@negate;
hset2_bop__v2_Sb_iswz_Rb_mod=iswz_Rb_mod;
hset2_bop__v2_Ps =* 7;
hset2_bop__v2_PsNot =* 0;
hset2_bop__v2_req_sb_bitset=req_sb_bitset;
hset2_bop__v2_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hset2_bop__v2_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
OEReuseB = reuse_src_b;
!OEReuseC;
hset2_bop__v2_usched_info=usched_info;


CLASS "hadd2__v0"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hadd2__v0_ofmt("F16_V2"):ofmt /hadd2__v0_ftz("noftz"):ftz /hadd2__v0_sat("nosat"):sat hadd2__v0_Rd:Rd
',' $( [-][||] hadd2__v0_Ra:Ra /hadd2__v0_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' [-][||] C:Sb[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+(1<<IERROR_INVALID_CONST_ADDR)+(1<<IERROR_MISALIGNED_ADDR)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HADD2_BCST ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(constBank))+(1<<INDEX(immConstOffset));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HADD2fp16g0_pipe = 123;
        HADD2fp16g1_pipe = 123;
        HADD2 = 123;
ENCODING
!hadd2__v0_unused;
hadd2__v0_Pg = Pg;
hadd2__v0_PgNot = Pg@not;
hadd2__v0_opcode=Opcode;
hadd2__v0_ofmt=ofmt;
hadd2__v0_ftz=ftz;
hadd2__v0_sat=sat;
hadd2__v0_Rd=Rd;
hadd2__v0_Ra=Ra;
hadd2__v0_Ra_absolute=Ra@absolute;
hadd2__v0_Ra_negate=Ra@negate;
hadd2__v0_Ra_iswz_Ra_mod=iswz_Ra_mod;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
hadd2__v0_Sb_absolute=Sb@absolute;
hadd2__v0_Sb_negate=Sb@negate;
hadd2__v0_req_sb_bitset=req_sb_bitset;
hadd2__v0_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hadd2__v0_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hadd2__v0_usched_info=usched_info;


CLASS "hadd2__v1"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hadd2__v1_ofmt("F16_V2"):ofmt /hadd2__v1_ftz("noftz"):ftz /hadd2__v1_sat("nosat"):sat hadd2__v1_Rd:Rd
',' $( [-][||] hadd2__v1_Ra:Ra /hadd2__v1_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
','F16Imm(64):Sb ','F16Imm(64):Sb2
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HADD2_IMM ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Sb))+(1<<INDEX(Sb)+1);
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 20;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HADD2fp16g0_pipe = 122;
        HADD2fp16g1_pipe = 122;
        HADD2 = 122;
ENCODING
!hadd2__v1_unused;
hadd2__v1_Pg = Pg;
hadd2__v1_PgNot = Pg@not;
hadd2__v1_opcode=Opcode;
hadd2__v1_ofmt=ofmt;
hadd2__v1_ftz=ftz;
hadd2__v1_sat=sat;
hadd2__v1_Rd=Rd;
hadd2__v1_Ra=Ra;
hadd2__v1_Ra_absolute=Ra@absolute;
hadd2__v1_Ra_negate=Ra@negate;
hadd2__v1_Ra_iswz_Ra_mod=iswz_Ra_mod;
hadd2__v1_Sb=Sb;
hadd2__v1_Sb2=Sb2;
hadd2__v1_req_sb_bitset=req_sb_bitset;
hadd2__v1_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hadd2__v1_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hadd2__v1_usched_info=usched_info;


CLASS "hadd2__v2"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hadd2__v2_ofmt("F16_V2"):ofmt /hadd2__v2_ftz("noftz"):ftz /hadd2__v2_sat("nosat"):sat hadd2__v2_Rd:Rd
',' $( [-][||] hadd2__v2_Ra:Ra /hadd2__v2_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' $( [-][||] hadd2__v2_Rb:Rb /hadd2__v2_Sb_iswz_Rb_mod("H1_H0"):iswz_Rb_mod {/REUSE(noreuse):reuse_src_b} )$
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HADD2_REG ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HADD2fp16g0_pipe = 2978;
        HADD2fp16g1_pipe = 2978;
        HADD2 = 2978;
ENCODING
!hadd2__v2_unused;
hadd2__v2_Pg = Pg;
hadd2__v2_PgNot = Pg@not;
hadd2__v2_opcode=Opcode;
hadd2__v2_ofmt=ofmt;
hadd2__v2_ftz=ftz;
hadd2__v2_sat=sat;
hadd2__v2_Rd=Rd;
hadd2__v2_Ra=Ra;
hadd2__v2_Ra_absolute=Ra@absolute;
hadd2__v2_Ra_negate=Ra@negate;
hadd2__v2_Ra_iswz_Ra_mod=iswz_Ra_mod;
hadd2__v2_Sb=Rb;
hadd2__v2_Sb_absolute=Rb@absolute;
hadd2__v2_Sb_negate=Rb@negate;
hadd2__v2_Sb_iswz_Rb_mod=iswz_Rb_mod;
hadd2__v2_req_sb_bitset=req_sb_bitset;
hadd2__v2_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hadd2__v2_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
OEReuseC = reuse_src_b;
hadd2__v2_usched_info=usched_info;


CLASS "hmul2__v2"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hmul2__v2_ofmt("F16_V2"):ofmt /hmul2__v2_fmz("nofmz"):fmz /hmul2__v2_sat("nosat"):sat hmul2__v2_Rd:Rd
',' $( [-][||] hmul2__v2_Ra:Ra /hmul2__v2_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' $( [-][||] hmul2__v2_Rb:Rb /hmul2__v2_Sb_iswz_Rb_mod("H1_H0"):iswz_Rb_mod {/REUSE(noreuse):reuse_src_b} )$
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"


PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HMUL2_REG ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HMUL2fp16g0_pipe = 2977;
        HMUL2fp16g1_pipe = 2977;
        HMUL2 = 2977;
ENCODING
!hmul2__v2_unused;
hmul2__v2_Pg = Pg;
hmul2__v2_PgNot = Pg@not;
hmul2__v2_opcode=Opcode;
hmul2__v2_ofmt=ofmt;
hmul2__v2_fmz=fmz;
hmul2__v2_sat=sat;
hmul2__v2_Rd=Rd;
hmul2__v2_Ra=Ra;
hmul2__v2_Ra_absolute=Ra@absolute;
hmul2__v2_Ra_iswz_Ra_mod=iswz_Ra_mod;
hmul2__v2_Sb=Rb;
hmul2__v2_Sb_absolute=Rb@absolute;
hmul2__v2_Sb_iswz_Rb_mod=iswz_Rb_mod;
hmul2__v2_req_sb_bitset=req_sb_bitset;
hmul2__v2_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hmul2__v2_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
OEReuseB = reuse_src_b;
!OEReuseC;
hmul2__v2_usched_info=usched_info;
hmul2__v2_nAB=hmul2__v2_nAB(Ra@negate,Rb@negate);


CLASS "hadd2_32i_"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hadd2_32i__ftz("noftz"):ftz /hadd2_32i__sat("nosat"):sat hadd2_32i__Rd:Rd
',' $( [-] hadd2_32i__Ra:Ra /hadd2_32i__Ra_iswz_Ra_32i_mod("H1_H0"):iswz_Ra_32i_mod {/REUSE(noreuse):reuse_src_a} )$
','F16Imm(64):imm ','F16Imm(64):imm2
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(imm))+(1<<INDEX(imm)+1);
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HADD2_32Ifp16g0_pipe = 22;
        HADD2_32Ifp16g1_pipe = 22;
        HADD2_32I = 22;
ENCODING
!hadd2_32i__unused;
hadd2_32i__Pg = Pg;
hadd2_32i__PgNot = Pg@not;
hadd2_32i__opcode=Opcode;
hadd2_32i__ftz=ftz;
hadd2_32i__sat=sat;
hadd2_32i__Rd=Rd;
hadd2_32i__Ra=Ra;
hadd2_32i__Ra_negate=Ra@negate;
hadd2_32i__Ra_iswz_Ra_32i_mod=iswz_Ra_32i_mod;
hadd2_32i__imm=imm;
hadd2_32i__imm2=imm2;
hadd2_32i__req_sb_bitset=req_sb_bitset;
hadd2_32i__src_rel_sb=VarLatOperandEnc(src_rel_sb);
hadd2_32i__dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hadd2_32i__usched_info=usched_info;


CLASS "hmul2__v1"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hmul2__v1_ofmt("F16_V2"):ofmt /hmul2__v1_fmz("nofmz"):fmz /hmul2__v1_sat("nosat"):sat hmul2__v1_Rd:Rd
',' $( [-][||] hmul2__v1_Ra:Ra /hmul2__v1_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
','F16Imm(64):Sb ','F16Imm(64):Sb2
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"




PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HMUL2_IMM ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(Sb))+(1<<INDEX(Sb)+1);
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 20;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HMUL2fp16g0_pipe = 120;
        HMUL2fp16g1_pipe = 120;
        HMUL2 = 120;
ENCODING
!hmul2__v1_unused;
hmul2__v1_Pg = Pg;
hmul2__v1_PgNot = Pg@not;
hmul2__v1_opcode=Opcode;
hmul2__v1_ofmt=ofmt;
hmul2__v1_fmz=fmz;
hmul2__v1_sat=sat;
hmul2__v1_Rd=Rd;
hmul2__v1_Ra=Ra;
hmul2__v1_Ra_absolute=Ra@absolute;
hmul2__v1_Ra_negate=Ra@negate;
hmul2__v1_Ra_iswz_Ra_mod=iswz_Ra_mod;
hmul2__v1_Sb=Sb;
hmul2__v1_Sb2=Sb2;
hmul2__v1_req_sb_bitset=req_sb_bitset;
hmul2__v1_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hmul2__v1_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hmul2__v1_usched_info=usched_info;


CLASS "hmul2__v0"
FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /hmul2__v0_ofmt("F16_V2"):ofmt /hmul2__v0_fmz("nofmz"):fmz /hmul2__v0_sat("nosat"):sat hmul2__v0_Rd:Rd
',' $( [-][||] hmul2__v0_Ra:Ra /hmul2__v0_Ra_iswz_Ra_mod("H1_H0"):iswz_Ra_mod {/REUSE(noreuse):reuse_src_a} )$
',' [-][||] C:Sb[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
$( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
$( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
$( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
$( { '?' USCHED_INFO:usched_info } )$ ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"




PROPERTIES
 INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
 IERRORS = (1<<IERROR_PC_WRAP)+(1<<IERROR_OOR_REG)+(1<<IERROR_ILLEGAL_INSTR_DECODING)+(1<<IERROR_INVALID_CONST_ADDR)+(1<<IERROR_MISALIGNED_ADDR)+0;
 VALID_IN_SHADERS = ISHADER_ALL ;
 MIN_WAIT_NEEDED = 0 ;
 SIDL_NAME = `SIDL_NAMES@HMUL2_BCST ;
 ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
 ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 ISRC_B_OPERAND_MAP = (1<<INDEX(constBank))+(1<<INDEX(immConstOffset));
 ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
 IDEST2_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
 IDEST2_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
 IDEST_OPERAND_MAP = (1<<INDEX(Rd));
 IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
PREDICATES
 DOES_READ_CC=0;
 ISRC_C_SIZE = 0;
 ISRC_A_SIZE = 32;
 ISRC_B_SIZE = 32;
 IDEST2_SIZE = 0;
 IDEST_SIZE = 32;
 VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16 ;
OPCODES
        HMUL2fp16g0_pipe = 121;
        HMUL2fp16g1_pipe = 121;
        HMUL2 = 121;
ENCODING
!hmul2__v0_unused;
hmul2__v0_Pg = Pg;
hmul2__v0_PgNot = Pg@not;
hmul2__v0_opcode=Opcode;
hmul2__v0_ofmt=ofmt;
hmul2__v0_fmz=fmz;
hmul2__v0_sat=sat;
hmul2__v0_Rd=Rd;
hmul2__v0_Ra=Ra;
hmul2__v0_Ra_absolute=Ra@absolute;
hmul2__v0_Ra_iswz_Ra_mod=iswz_Ra_mod;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
hmul2__v0_Sb_absolute=Sb@absolute;
hmul2__v0_req_sb_bitset=req_sb_bitset;
hmul2__v0_src_rel_sb=VarLatOperandEnc(src_rel_sb);
hmul2__v0_dst_wr_sb=VarLatOperandEnc(dst_wr_sb);
OEReuseA = reuse_src_a;
!OEReuseB;
!OEReuseC;
hmul2__v0_usched_info=usched_info;
hmul2__v0_nAB=hmul2__v0_nAB(Ra@negate,Sb@negate);

CLASS "HSETP2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /H_AND(noH_AND):h_and /FTZ(noFTZ):ftz /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb/ISWZ(H1_H0):iswz_Rb {/REUSE(noreuse):reuse_src_b} )$
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


    OPCODES
        HSETP2fp16g0_pipe =  0b0101110100100;
        HSETP2fp16g1_pipe =  0b0101110100100;
        HSETP2 =  0b0101110100100;

    ENCODING
      Opcode13 = Opcode;
      H_and = h_and;
      vAmux = iswz_Ra;
      Bop = bopopt;
      aAH = Ra@absolute;
      nA2 = Ra@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;
      FComp2 = Test;
      nBH = Rb@negate;
      aBH = Rb@absolute;
      vBmux = iswz_Rb;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      FTZH = FTZ;
      PDest = Pd;
      PNDest = nPd;
      !NencHSETP2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_HSETP2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /H_AND(noH_AND):h_and /FTZ(noFTZ):ftz
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-][||] RegisterFAU:Rb/ISWZ(H1_H0):iswz_Rb {/REUSE(noreuse):reuse_src_b} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS


            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_REG;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


    OPCODES
        HSETP2fp16g0_pipe =  0b0101110100100;
        HSETP2fp16g1_pipe =  0b0101110100100;
        HSETP2 =  0b0101110100100;

    ENCODING
      Opcode13 = Opcode;
      H_and = h_and;
      vAmux = iswz_Ra;
      Bop = `Bop@AND;
      aAH = Ra@absolute;
      nA2 = Ra@negate;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      FComp2 = Test;
      nBH = Rb@negate;
      aBH = Rb@absolute;
      vBmux = iswz_Rb;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      FTZH = FTZ;
      PDest = Pd;
      PNDest = nPd;
      !NencHSETP2;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Imm_HSETP2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /H_AND(noH_AND):h_and /FTZ(noFTZ):ftz /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F16Imm(64):uImm
             ',' F16Imm(64):uImmH0
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm))+(1<<INDEX(uImm)+1);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


    OPCODES
        HSETP2fp16g0_pipe =  0b0111111_0;
        HSETP2fp16g1_pipe =  0b0111111_0;
        HSETP2 =  0b0111111_0;

    ENCODING
      Opcode7b1 = Opcode;
      H_and2 = h_and;
      FComp3 = Test;
      vAmux = iswz_Ra;
      Bop = bopopt;
      aAH = Ra@absolute;
      nA2 = Ra@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BimmH1=uImm;
      BimmH0=uImmH0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      FTZH = FTZ;
      PDest = Pd;
      PNDest = nPd;
      !NencHSETP;



      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Imm_HSETP2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /H_AND(noH_AND):h_and /FTZ(noFTZ):ftz
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F16Imm(64):uImm
             ',' F16Imm(64):uImmH0

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;


    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"



    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(uImm))+(1<<INDEX(uImm)+1);
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


    OPCODES
        HSETP2fp16g0_pipe =  0b0111111_0;
        HSETP2fp16g1_pipe =  0b0111111_0;
        HSETP2 =  0b0111111_0;

    ENCODING
      Opcode7b1 = Opcode;
      H_and2 = h_and;
      FComp3 = Test;
      vAmux = iswz_Ra;
      Bop = `Bop@AND;
      aAH = Ra@absolute;
      nA2 = Ra@negate;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BimmH1=uImm;
      BimmH0=uImmH0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      FTZH = FTZ;
      PDest = Pd;
      PNDest = nPd;
      !NencHSETP;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



CLASS "Const_HSETP2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /H_AND(noH_AND):h_and /FTZ(noFTZ):ftz /Bop:bopopt
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
             ',' [!]Predicate:Pa

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (bopopt != `Bop@INVALIDBOP03):
                "Invalid Bop (bopopt) field value INVALIDBOP03"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


    OPCODES
        HSETP2fp16g0_pipe =  0b0111111_1;
        HSETP2fp16g1_pipe =  0b0111111_1;
        HSETP2 =  0b0111111_1;

    ENCODING
      Opcode7b1 = Opcode;
      nBH2 = srcConst@negate;
      aBH2 = srcConst@absolute;
      H_and2 = h_and;
      FComp3 = Test;
      vAmux = iswz_Ra;
      Bop = bopopt;
      aAH = Ra@absolute;
      nA2 = Ra@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      FTZH = FTZ;
      PDest = Pd;
      PNDest = nPd;
      !NencHSETP3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



ALTERNATE CLASS "NoBop_Const_HSETP2"


    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /H_AND(noH_AND):h_and /FTZ(noFTZ):ftz
             Predicate:Pd ',' Predicate:nPd
             ',' $( [-][||] RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"



    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_NON_EXISTENT_OPERAND);

         IDEST_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));
         ISRC_C_OPERAND_MAP = (1<<IOPERAND_MAP_NON_EXISTENT_OPERAND);

    PREDICATES
         IDEST_SIZE = 0;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 20;
         ISRC_C_SIZE = 0;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


    OPCODES
        HSETP2fp16g0_pipe =  0b0111111_1;
        HSETP2fp16g1_pipe =  0b0111111_1;
        HSETP2 =  0b0111111_1;

    ENCODING
      Opcode7b1 = Opcode;
      nBH2 = srcConst@negate;
      aBH2 = srcConst@absolute;
      H_and2 = h_and;
      FComp3 = Test;
      vAmux = iswz_Ra;
      Bop = `Bop@AND;
      aAH = Ra@absolute;
      nA2 = Ra@negate;
      SrcPred = `Predicate@PT;
      SrcNot = 0;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      FTZH = FTZ;
      PDest = Pd;
      PNDest = nPd;
      !NencHSETP3;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
 CLASS "HFMA2_32I"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz
             $( RegisterFAU:Rd )$
             ',' $( RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F16Imm(64):fImm
             ',' F16Imm(64):fImm1
             ',' $( [-] RegisterFAU:Rc {/REUSE(noreuse):reuse_src_c} )$

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

         ILLEGAL_INSTR_ENCODING_SASS_ONLY_ERROR
           Rd == Rc :
             "Output register must be the same as last input register"

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) :
                "Register Rc is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(fImm))+(1<<INDEX(fImm)+1);
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rc));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


   OPCODES
        HFMA2_32Ifp16g0_pipe =  0b0010100;
        HFMA2_32Ifp16g1_pipe =  0b0010100;
        HFMA2_32I =  0b0010100;

   ENCODING
      Opcode7 = Opcode;
      FMZ_H = FMZ;
      nC_H = Rc@negate;
      vAmux_H = iswz_Ra;
      FimmH1 = fImm;
      FimmH0 = fImm1;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = IDENTICAL(Rd,Rc);


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           OEReuseC = reuse_src_c;
       OECoupled = 0;
   !OEReserved1;



 ALTERNATE CLASS "HFMA2_32I_2"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz
             $( RegisterFAU:Rd )$
             ',' $( RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' F16Imm(64):fImm
             ',' F16Imm(64):fImm1

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;



    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(fImm))+(1<<INDEX(fImm)+1);
         ISRC_C_OPERAND_MAP = (1<<INDEX(Rd));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


    OPCODES
        HFMA2_32Ifp16g0_pipe =  0b0010100;
        HFMA2_32Ifp16g1_pipe =  0b0010100;
        HFMA2_32I =  0b0010100;

    ENCODING
      Opcode7 = Opcode;
      FMZ_H = FMZ;
      nC_H = 0;
      vAmux_H = iswz_Ra;
      FimmH1 = fImm;
      FimmH0 = fImm1;
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           !OEReuseB;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;



 CLASS "HFMA2_CCST"

    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Ofmt_FP16(F16_V2):ofmt /FMZ(noFTZ):fmz /SAT(noSAT):sat
             $( RegisterFAU:Rd )$
             ',' $( [-] RegisterFAU:Ra/ISWZ(H1_H0):iswz_Ra {/REUSE(noreuse):reuse_src_a} )$
             ',' $( [-] RegisterFAU:Rb/ISWZ(H1_H0):iswz_Rb {/REUSE(noreuse):reuse_src_b} )$
',' [-] C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]

     $( { '&' REQ:req '=' BITSET(6/0x0000):req_sb_bitset } )$
         $( { '&' RD:rd '=' UImm(3/0x7):src_rel_sb } )$
         $( { '&' WR:wr '=' UImm(3/0x7):dst_wr_sb } )$
     $( { '?' USCHED_INFO:usched_info } )$
             ;

    CONDITIONS

            OOR_REG_ERROR
                (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))) :
                "Register Rd is out of range"

            OOR_REG_ERROR
                (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) :
                "Register Ra is out of range"

            OOR_REG_ERROR
                (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) :
                "Register Rb is out of range"

            INVALID_CONST_ADDR_SASS_ONLY_ERROR
                (constBank <= %MAX_CONST_BANK) :
                "Invalid constant bank error"

            MISALIGNED_ADDR_ERROR
                (immConstOffset & 0x3) == 0 :
                "Constant offsets must be aligned on a 4B boundary"

            ILLEGAL_INSTR_ENCODING_ERROR
                (fmz != `FMZ@INVALIDFMZ3):
                "Invalid FMZ (fmz) field value INVALIDFMZ3"



    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;




         VALID_IN_SHADERS = ISHADER_ALL;
           INSTRUCTION_TYPE = INST_TYPE_COUPLED_EMULATABLE;
           MIN_WAIT_NEEDED = 0;
         IERRORS = (1<<IERROR_PC_WRAP)
                   + (1<<IERROR_ILLEGAL_INSTR_DECODING)
                   + (1<<IERROR_OOR_REG)
                   + (1<<IERROR_INVALID_CONST_ADDR)
                   + (1<<IERROR_MISALIGNED_ADDR)
                   ;

         IDEST_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_A_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_B_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);
         ISRC_C_OPERAND_TYPE = (1<<IOPERAND_TYPE_FP16SIMD);

         IDEST_OPERAND_MAP = (1<<INDEX(Rd));
         ISRC_A_OPERAND_MAP = (1<<INDEX(Ra));
         ISRC_B_OPERAND_MAP = (1<<INDEX(Rb));
         ISRC_C_OPERAND_MAP = (1<<INDEX(constBank)) + (1<<INDEX(immConstOffset));

    PREDICATES
         IDEST_SIZE = 32;
         ISRC_A_SIZE = 32;
         ISRC_B_SIZE = 32;
         ISRC_C_SIZE = 32;
         DOES_READ_CC = 0;
         VIRTUAL_QUEUE = $VQ_REDIRECTABLE_FP16;


   OPCODES
        HFMA2fp16g0_pipe =  0b011001;
        HFMA2fp16g1_pipe =  0b011001;
        HFMA2 =  0b011001;

   ENCODING
      Opcode5b1 = Opcode;
      FMZ_H2 = FMZ;
      nAB_H = PSignFFMA(Ra@negate,Rb@negate);
      vBmux_H = iswz_Rb;
      sat_H = sat;
      nC_H2 = srcConst@negate;
      Ofmt = ofmt;
      vAmux_H2 = iswz_Ra;
      RegC = Rb;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA = Ra;
      Dest = Rd;


      OEUSchedInfo = usched_info;

       OEWaitOnSb = req_sb_bitset;
           OEVarLatDest = VarLatOperandEnc( dst_wr_sb );
           OEVarLatSrc = VarLatOperandEnc( src_rel_sb );
           OEReuseA = reuse_src_a;
           OEReuseB = reuse_src_b;
           !OEReuseC;
       OECoupled = 0;
   !OEReserved1;
