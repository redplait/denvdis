ARCHITECTURE "Kepler"

   PROCESSOR_ID Kepler;
    ISSUE_SLOTS 2;
   WORD_SIZE 64;
   BRANCH_DELAY 0;
   ELF_ID 190;
   ELF_ABI 0x33;
   ELF_ABI_VERSION 7;


   ELF_VERSION 101;

   RELOCATORS
  { "R_CUDA_NONE", 0, False, False, 0,0, { { 0, 0} } }
  { "R_CUDA_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_G32", "R_CUDA_G32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_G64", "R_CUDA_G64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS32_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_TEX_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_SAMP_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 20, 12} } }
  { "R_CUDA_SURF_HW_DESC", 4, 0, 32 }
  { "R_CUDA_SURF_HW_SW_DESC", 5, 0, 32 }
  { "R_CUDA_ABS32_LO_26", 0x00000000ffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_HI_26", 0xffffffff00000000, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS24_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 24} } }
  { "R_CUDA_ABS24_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS16_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 16} } }
  { "R_CUDA_ABS16_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 16} } }
  { "R_CUDA_TEX_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 32, 8} } }
  { "R_CUDA_SAMP_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 40, 5} } }
  { "R_CUDA_SURF_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 26, 6} } }
  { "R_CUDA_TEX_BINDLESSOFF13_32", 0xffffffffffffffff, False, False, 0,2, { { 32, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_47", 0xffffffffffffffff, False, False, 0,2, { { 47, 13} } }
  { "R_CUDA_CONST_FIELD19_28", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 28, 18},
  { 26, 1} } }
  { "R_CUDA_CONST_FIELD19_23", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 23, 19} } }
  { "R_CUDA_TEX_SLOT9_49", 0xffffffffffffffff, False, False, 0,0, { { 49, 9} } }
  { "R_CUDA_6_31", 0xffffffffffffffff, False, False, 0,0, { { 31, 6} } }
  { "R_CUDA_2_47", 0xffffffffffffffff, False, False, 0,0, { { 47, 2} } }
  { "R_CUDA_TEX_BINDLESSOFF13_41", 0xffffffffffffffff, False, False, 0,2, { { 41, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_45", 0xffffffffffffffff, False, False, 0,2, { { 45, 13} } }
  { "R_CUDA_FUNC_DESC32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC_32", "R_CUDA_FUNC_DESC_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_FUNC_DESC_64", "R_CUDA_FUNC_DESC_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_CONST_FIELD21_26", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 26, 21} } }
  { "R_CUDA_QUERY_DESC21_37", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 37, 21} } }
  { "R_CUDA_CONST_FIELD19_26", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 26, 19} } }
  { "R_CUDA_CONST_FIELD21_23", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 23, 21} } }
  { "R_CUDA_PCREL_IMM24_26", 0xffffffffffffffff, True, False, 0,0, { { 26, 24} } }
  { "R_CUDA_PCREL_IMM24_23", 0xffffffffffffffff, True, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS24_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 24} } }
  { "R_CUDA_ABS16_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 16} } }
  { "R_CUDA_FUNC_DESC32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_CONST_FIELD19_20", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 20, 19} } }
  { "R_CUDA_BINDLESSOFF13_36", 0xffffffffffffffff, False, False, 0,2, { { 36, 13} } }
  { "R_CUDA_SURF_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_INSTRUCTION64", 17, 0, 64 }
  { "R_CUDA_CONST_FIELD21_20", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 20, 21} } }
  { "R_CUDA_ABS32_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS32_LO_32", 0x00000000ffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS32_HI_32", 0xffffffff00000000, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS47_34", 0xffffffffffffffff, False, False, 0,2, { { 34, 47} } }
  { "R_CUDA_ABS16_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 16} } }
  { "R_CUDA_ABS24_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 24} } }
  { "R_CUDA_FUNC_DESC32_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_32", 0x00000000ffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_32", 0xffffffff00000000, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_CONST_FIELD19_40", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 40, 19} } }
  { "R_CUDA_BINDLESSOFF14_40", 0xffffffffffffffff, False, False, 0,2, { { 40, 14} } }
  { "R_CUDA_CONST_FIELD21_38", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 38, 21} } }
  { "R_CUDA_INSTRUCTION128", 17, 0, 128 }
  { "R_CUDA_YIELD_OPCODE9_0", 18, 0, 9 }
  { "R_CUDA_YIELD_CLEAR_PRED4_87", 19, 87, 4 }
  { "R_CUDA_32_LO", 0x00000000ffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_32_HI", 0xffffffff00000000, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_UNUSED_CLEAR32", "R_CUDA_UNUSED_CLEAR32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_UNUSED_CLEAR64", "R_CUDA_UNUSED_CLEAR64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS24_40", 0xffffffffffffffff, False, False, 0,0, { { 40, 24} } }
      ;


   OPTIONS NOCHECK_OPCLASS_AMBIGUITY,
                           CASE_INSENSITIVE_SYNTAX,
                           VLIW_BRACE_NOTATION;

   EMPTY_INSTRUCTION = "NOP;";

PARAMETERS
    MAX_REG_COUNT = 255
    SHADER_TYPE = 0

CONSTANTS
    ITYPE_OTHER = 0
    ITYPE_ABC_REG = 1
    ITYPE_ABC_BCST = 2
    ITYPE_ABC_CCST = 3
    ITYPE_ABC_B20I = 4

    BRT_CALL = 1
    BRT_RETURN = 2
    BRT_BRANCH = 3
    BRT_BRANCHOUT = 4

    MEMORY_LOAD = 1

    ST_UNKNOWN = 0
    ST_PS = 1
    ST_TI = 2
    ST_TS = 3
    ST_GS = 4
    ST_CS = 5
    ST_VSA = 6
    ST_VSB = 7


REGISTERS



    UnaryInv noINV, INV;
    UnaryNeg noNEG, NEG;
    UnaryAbs noABS, ABS;

    SIDL_NAMES
        NO_CUSTOM_NAME,
        VOTE_VTG,
 TEXS16,
 TLDS16,
 TLD4S16,
  HFMA2_REG,
  HFMA2_IMM,
  HFMA2_BCST,
  HSET2_REG,
  HSET2_IMM,
  HSET2_BCST,
  HADD2_BCST,
  HADD2_IMM,
  HADD2_REG,
  HMUL2_REG,
  HMUL2_IMM,
  HMUL2_BCST,
  HFMA2_REG,
  HFMA2_IMM,
  HFMA2_BCST,
  HSET2_REG,
  HSET2_IMM,
  HSET2_BCST,
  HADD2_BCST,
  HADD2_IMM,
  HADD2_REG,
  HMUL2_REG,
  HMUL2_IMM,
  HMUL2_BCST,
 DUMMY ;





    NonZeroRegister R0(0..9), R(0..254)=(0..254);





    NonZeroRegisterFAU = NonZeroRegister;





    ZeroRegister RZ=255;

    RegisterFAU = NonZeroRegisterFAU + ZeroRegister;
    Register = NonZeroRegister + ZeroRegister;




    Predicate P(0..7), PT=7;

    SpecialRegister SR(0..255)=(0..255),
                      SR_LANEID = 0,
                      SR_CLOCK,
                      SR_VIRTCFG,
                      SR_VIRTID,
                      SR_PM(0..7),

                      SR_PRIM_TYPE=16,
                      SR_INVOCATION_ID,
                      SR_Y_DIRECTION,
                      SR_THREAD_KILL,
                      SM_SHADER_TYPE,

                      SR_MACHINE_ID_(0..3)=(24..27),
                      SR_AFFINITY,

                      SR_TID=32, "SR_TID.X", "SR_TID.Y", "SR_TID.Z",
                      SR_CTAPARAM, SR_CTA_PARAM=36,
                      "SR_CTAID.X", "SR_CTAID.Y", "SR_CTAID.Z",
                      SR_NTID, "SR_CirQueueIncrMinusOne", "SR_NLATC",

                      SR_SWINLO=48, SR_SWINSZ,
                      SR_SMEMSZ, SR_SMEMBANKS,
                      SR_LWINLO, SR_LWINSZ,
                      SR_LMEMLOSZ, SR_LMEMHIOFF,
                      SR_EQMASK, SR_LTMASK, SR_LEMASK, SR_GTMASK, SR_GEMASK,
                      SR_REGALLOC, SR_CTXADDR,

                      SR_GLOBALERRORSTATUS=64,

                      SR_WARPERRORSTATUS=66, SR_WARPERRORSTATUSCLEAR,

                      SR_CLOCKLO=80, SR_CLOCKHI,
                      SR_GLOBALTIMERLO, SR_GLOBALTIMERHI,

                      SR_HWTASKID=96, SR_CIRCULARQUEUEENTRYINDEX,
                      SR_CIRCULARQUEUEENTRYADDRESSLOW,
                      SR_CIRCULARQUEUEENTRYADDRESSHIGH;







    Round1 RN, RM, RP, RZ;
    F2FRound1 PASS=1, PASS, PASS, RN, RM, RP, RZ, PASS=0, ROUND=4, FLOOR, CEIL, TRUNC;
    F2FRound2 PASS, ROUND=0, FLOOR, CEIL, TRUNC, RN=0, RM, RP, RZ;
    Round3 ROUND, FLOOR, CEIL, TRUNC;
    VOP MRG_16H, MRG_16L, MRG_8B0, MRG_8B2, ACC, MIN, MAX, PASS;
    IPAOp PASS, MUL, CONSTANT, SC;
    VRed SIMD_MRG, SIMD_MIN, SIMD_MAX, REDOP3, INVALIDRED3=3, ACC, MIN, MAX, REDOP7, INVALIDRED7=7;
    VRed2 SIMD_MRG, ACC, INVALIDRED2, INVALIDRED3;
    AtomOp INVALIDATOMOP(0..15), ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR,EXCH,SAFEADD=10;
    RedOp INVALIDREDOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR;
    SUOp INVALIDSUREDOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR;
    VMadScale PASS,SHR_7,SHR_15,INVALIDVMADSCALE3;
    INC NOINC,INC;
    IPAOpN MUL, SC;
    Bop AND, OR, XOR, INVALIDBOP03,INVALIDBOP13=3,INVALIDBOP3=3;
    LOP AND, OR, XOR, PASS_B;
    Red POPC,AND,OR,INVALIDBARMODE3;

    CC CC=1;
    optCC noCC, CC;

    Float INVALIDFPDEST0, INVALIDFPSRC0=0, F16, F32, F64;
    Float16 F16=1;
    Float32 INVALIDFPDEST0, INVALIDFPSRC0=0, F32=2;
    Float64 F64=3;
    F32 F32;
    F2Ffmts1 "INVALIDFPDEST0.INVALIDFPSRC0"=0, "F32.F32"=10;
    F2Ffmts1_16 "F16.F16"=5;
    F2Ffmts1_64 "F64.F64"=15;
    F2Ffmts2 "F16.INVALIDFPSRC0"=1, "F32.INVALIDFPSRC0"=2, "F64.INVALIDFPSRC0"=3,
                      "INVALIDFPDEST0.F32"=8, "F16.F32"=9, "F64.F32"=11;
    F2Ffmts2_16 "INVALIDFPDEST0.F16"=4, "F32.F16"=6, "F64.F16"=7;
    F2Ffmts2_64 "INVALIDFPDEST0.F64"=12, "F16.F64"=13, "F32.F64"=14;

    Integer8 U8 = 0, S8 = 1;
    Integer16 U16 = 2, S16 = 3;
    Integer32 U32 = 4, S32 = 5;
    Integer64 U64 = 6, S64 = 7;
    Integer128 U128= 8, S128= 9;

    U8 U8 = 0;
    U16 U16 = 2;
    U32 U32 = 4, INVALIDASEL7=6, INVALIDBSEL7=6, INVALIDSEL7=6;
    IntegerSPA U32, S32, U24, S24, U16H0, S16H0, U16H1, S16H1;
    IntegerSPB U16H0, S16H0, U24, S24;
    IntegerSPC U32, S32, U24, S24, U16H0, S16H0;
    IMADSP_SD SD=3;

    VInteger32 U32 = 4, S32 = 5, INVALIDASEL7=7, INVALIDASEL7=6,
                      INVALIDBSEL7=7, INVALIDBSEL7=6, INVALIDSEL7=7, INVALIDSEL7=6;

    Integer = Integer8 + Integer16 + Integer32 + Integer64;
    UInteger = U8 + U16 + U32;
    LInteger = Integer8 + Integer16 + Integer32 + Integer64 + Integer128;
    Integer1632 = Integer16 + Integer32;
    IntegerNo16 = Integer8 + Integer32 + Integer64;




    LDInteger "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", "U.128";
    CInteger SD=0, "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", INVALIDSIZE7;
    CInteger_n64 SD=0, "8"=0, "16"=2, U8=0, S8=1, U16=2, S16=3, "32"=4, "128"=6, INVALIDSIZE7;
    CInteger_64 "64"=5;
    Ofmt U32=0, S32=1, U8=2, S8=3;

    AInteger "32", "64", "96", "128";
    QInteger "32", "64";
    BQInteger "64", "128";
    SQInteger U8=7, S8=7, U16=7, S16=7, S128=7, F16=7, F64=7,
                      INVALIDATOMICSIZE13=7, INVALIDATOMICSIZE14=7, INVALIDATOMICSIZE15=7,
                      "32"=0, "64"=2, F32, "128", U32=0, S32, U64, "F32.FTZ.RN", U128, S64, INVALIDATOMICSIZE(6..7);
    CASInteger U32, U64, S32=0, S64, "32"=0, "64";
    maxShift "32"=0, INVALIDMAXSHIFT3, U64, S64;
    DFormat UD,SD;

    Pipe HW, FMA64, FMA32, XLU, ALU, AGU, SU, FU, FMUL,
              INVALIDPIPE49, INVALID0PIPE4A, INVALID0PIPE4B, INVALID0PIPE4C, INVALID0PIPE4D, INVALID0PIPE4E,
              INVALID0PIPE4F, INVALID9=9, INVALID0A, INVALID0B, INVALID0C, INVALID0D, INVALID0E, INVALID0F;
    Pipe2 HW, XLU, ALU, INVALIDPIPEA3, INVALID=3;
    Pipe2FMALite HW, FMA, MUL, INVALIDPIPE3, FMA2=2, INVALID;

    Test FALSE=0, ZFF=5, ZF0=5, LEG=7, U=8, ZFT=10, ZF1=10, TRUE=15, NOT_OVERFLOW=16, "0FF"=16,
              CFF=17, CARRY=17, ABOVE=18, SF0=18, SIGN=19, SF1=21, CFT=22, CF1=22, OF1=23, OVERFLOW=23,
              NOT_SIGN=28, BELOW_OR_EQUAL=29, NOT_CARRY=30, "1E"=30, "1F"=31,
              F=0, LT, EQ, LE, GT, NE, GE, NUM, NAN, LTU, EQU, LEU, GTU,
              NEU, GEU, T, OFF, LO, SFF, LS, HI, SFT, HS, OFT, CSM_TA,
              CSM_TR, CSM_MX, FCSM_TA, FCSM_TR, FCSM_MX, RLE, RGT;

    Scale NONE, D2, D4, D8, M8, M4, M2, INVALIDSCALE37;

    ICmpAll F, LT, EQ, LE, GT, NE, GE, T;
    ICmpU LO=1, LS=3, HI=4, HS=6;

    IDEAction EN,DI;

    TPhase noPhase,T,P,INVALIDPHASE3;
    ITypeI I;
    ITypeF F;
    BVal BM, BF;

    PR PR;
    H1H0 H0,H1;
    B1B0 H0, H1=2, B(0..3)=(0..3);
    I2XH B(0..3), H0=1, H0=0, H1=3, H1=2;
    HILO LO,HI;
    RelOpt REL;

    X noX, X;
    XMode noX, XLO, XMED, XHI;
    SHFXMode NONE, HI, X, XHI;
    XXHI noX, INVALIDSHRXMODE1, X, XHI;
    SHF_L L;
    SHF_R R;


    LDGcop1 CT;
    LDGcop2 CG, CS;

    C C, c=0;
    V V, v=0;
    A A, a=0;
    CWMode C,W;
    B noB, B;
    P noP, P;
    Phys PHYS;
    CAS CAS;
    VTG VTG;
    E noE, E;
    LDG_E noE, E=2;
    U noU, U;
    S noS, S;
    DC noDC, DC;
    MS noMS, MS;
    CL noCL, CL;
    PO noPO, ILLEGAL1, ILLEGAL2, PO;
    SH noSH, SH;
    NDV noNDV, NDV;
    LMT noLMT, LMT;
    FTZ noFTZ, FTZ;
    SAT noSAT, SAT;
    AVRG noAVRG, AVRG;
    TOFF1 noTOFF, AOFFI;
    TOFF2 noTOFF, AOFFI, INVALIDBTOFF02, PTP=2, INVALIDBTOFF03;
    BREV noBREV, BREV;
    NODEP noNODEP, NODEP;

    BOnly B=1;
    POnly P;

    SD U8, U32, S32, F32, SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    SD3 "8", S8, "16", U16=2, S16, "32", "64", "128", INVALIDSIZE7,
              U8=0, U32, S32, F32, SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    SD3B SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    FMZ noFTZ, FTZ, FMZ, INVALIDFMZ3;
    LOD noLOD, LZ, LB, LL, INVALIDBLOD(4..5), LBA, LLA;
    LOD1 LZ,LL;
    LODOnly LOD;

    PMode IDX, F4E, B4E, RC8, ECL, ECR, RC16, INVALIDPMODE7;
    VoteOp ALL,ANY,EQ,INVALIDVMODE3;
    VTGMode R, A, RA, INVALIDVTGMODE3;

    BPTMode DRAIN_ILLEGAL,CAL,PAUSE,TRAP,INT,DRAIN;
    BPTModeN DRAIN,CAL,PAUSE;
    BPTModeN2 TRAP=3;

    KeepRefCount noKEEPREFCOUNT, KEEPREFCOUNT;

    ChkMode DIVIDE, INVALIDCHKMODE(1..63);

    CMode SP, DP0Z, DP1XY, INVALIDFCCO3, DP1Z=3;
    AdMode IA, IL, IS, ISL;
    MN MN,MX;

    Shflmd IDX=0, UP, DOWN, BFLY;

    Barmd BAR, RESULT, WARP, INVALID;
    BarmdBAR BAR = 0, INVALID=3;
    BarmdRESULT RESULT = 1;
    BarmdWARP WARP = 2;

    OutType INVALIDOUTSTYPE0, EMIT, CUT, EMIT_THEN_CUT;

    PixMode MSCOUNT,COVMASK,COVERED,OFFSET,CENTROID_OFFSET,MY_INDEX,INVALIDPIXMODE(6..7),INVALID(0..1)=(6..7);
    MSI C=0,INVALIDMSI3=3,CENTER=0,CENTROID,OFFSET,INVALID;


    MufuOp COS, SIN, EX2, LG2, RCP, RSQ, RCP64H, RSQ64H,
                   INVALIDMUFUOPCODE(8..9), INVALIDMUFUOPCODEA, INVALIDMUFUOPCODEB, INVALIDMUFUOPCODEC,
                   INVALIDMUFUOPCODED, INVALIDMUFUOPCODEE, INVALIDMUFUOPCODEF;
    BarSyncArv SYNC, ARV;
    BarSync SYNC = 0;
    BarArv ARV = 1;
    BarRED RED = 2;
    BarSCAN SCAN = 3;
    BarSYNCALL SYNCALL = 4;


    Arv SYNC,ARV;
    RTTOp POPCRS, TERMINATE, FALLTHROUGH, PREEMPTED;
    RROOp SINCOS, EX2;
    AIO I, O;
    Trig TRIG = 1;
    STPMode noWAIT, WAIT;

    OnlyNoDep NODEP;
    OnlyT T;

    LoadCacheOp0 CA, CG;
    LoadCacheOp LU=2, CA=0, CG, CS, CV;
    LLoadCacheOp CS=2, CA=0, CG, LU, CV;
    StoreCacheOp WB, CG, CS, WT;
    OnlyQry QRY1;
    CCTLOp PF1=1, PF1.5, PF2, WB, IV, IVALL, RS, WBALL, RSLB, INVALIDCCTLOP(10..15);
    CCTLOpRSLB RSLB=9;
    OnlyIvall IVALL=6;
    CCTLLOp2 IVALL=6, WBALL=8;
    SuqOp RANK,PIXFMT,SMPLSZ,DIM,RGBA,BLKSZ,INVALIDSUQOP(6..31);
    RGBA_NONE INVALIDRGBAMASK0, noRGBA=0;
    RGBA INVALIDRGBAMASK(1..15)=(1..15),
                   R=1, G, RG, B, RB, GB, RGB, A, RA, GA, RGA, BA, RBA, GBA, RGBA;
    Dim "1D", "2D", INVALIDSURFACEDIM2, "3D"=2, "E2D";

    BDim "1D", "MD";
    ThreeD "2D", "3D";
    Smode "SD.R1" = 0,
                   "SD.R2" = 1,
                   "SD.R4" = 2,
                   "SD.R8" = 3,
                   "SD.R16" = 4,
                   "PL.R1" = 5,
                   "PL.R2" = 6,
                   "PL.R4" = 7,
                   "PL.R8" = 8,
                   "PL.R16" = 9,
                   "BL.R1" = 10,
                   "BL.R2" = 11,
                   "BL.R4" = 12,
                   "BL.R8" = 13,
                   "BL.R16" = 14,
                   "INVALIDSMODE15" = 15;

    Clamp0 Z,NEAR,TRAP,INVALIDSURFACECLAMP3;
    Clamp1 IGN,NEAR,TRAP,INVALIDSURFACECLAMP3;


    Clamp2 Z,TRAP,INVALIDSURFACECLAMP3, SDCL;
    Clamp3 IGN,TRAP,INVALIDSURFACECLAMP3, SDCL;


    TexComp R,G,B,A;

    TXQMode TEX_HEADER_DIMENSION, TEX_HEADER_TEXTURE_TYPE, TEX_HEADER_SAMPLER_POS, "3", "4", "5", "6", "7",
                   TEX_SAMPLER_FILTER, TEX_SAMPLER_LOD, TEX_SAMPLER_WRAP, TEX_SAMPLER_BORDER_COLOR, "12", "13",
                   "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
                   "30", "31";

    ParamA "_1D" = 0b00_0,
                   "1D" = 0b00_0,
                   RECT = 0b01_0,
                   "_2D" = 0b01_0,
                   "2D" = 0b01_0,
                   "_3D" = 0b10_0,
                   "3D" = 0b10_0,
                   CUBE = 0b11_0,
                   ARRAY_1D = 0b00_1,
                   ARRAY_RECT = 0b01_1,
                   ARRAY_2D = 0b01_1,
                   ARRAY_3D = 0b10_1,
                   CUBEARRAY = 0b11_1,
                   ARRAY_CUBE = 0b11_1;

    MemBarLevel CTA,GL,SYS,INVALIDMEMBAR3;

    Cache D,U,C,I;
    Cache3 D,U,C,I,CRS,INVALIDCCTLCACHEOP5=5,INVALIDCCTLCACHEOP6=6,INVALIDCCTLCACHEOP7=7,INVALIDCACHETYPE5=5,INVALIDCACHETYPE6=6,INVALIDCACHETYPE7=7;
    LCache D,CRS,INVALIDLCACHETYPE2,INVALIDLCACHETYPE3;




    LaneMask2
        X = 0b01,
        Y = 0b10,
        XY = 0b11;

    LaneMask4
        X = 0b0100,
        Y = 0b1000,
        Z = 0b0001,
        W = 0b0010,
        XW = 0b0110,
        YW = 0b1010,
        ZW = 0b0011,
        XZ = 0b0101,
        YZ = 0b1001,
        XY = 0b1100,
        YZW = 0b1011,
        XZW = 0b0111,
        XYW = 0b1110,
        XYZ = 0b1101,
        XYZW = 0b1111
        ;

   SWZMode
        "0000","1111","2222","3333","1032","2301",INVALIDSWIZZLEMODE(6..7);

   ASel4
        "0000","1111","2222","3333","3210","4321","5432","6543","3201","3012","0213","3120","1230","2310",
        ASEL4E, ASEL4F, INVALIDASEL4E=14, INVALIDASEL4F;

   BSel4
        "4444","5555","6666","7777","7654","6543","5432","4321","4567","6745","5476",BSEL4B,BSEL4C,BSEL4D,
        BSEL4E, INVALIDBSEL4B=11, INVALIDBSEL4C, INVALIDBSEL4D, INVALIDBSEL4E;

   Sel2
        "00","01","02","03",
        "10","11","12","13",
        "20","21","22","23",
        "30","31","32","33";


   Sel2hi
        "00","01",
        "10","11";


    PNWord
        PPPPPPPP,PPPPPPNP,PPPPPPPN,PPPPPPZP,PPPPNPPP,PPPPNPNP,PPPPNPPN,PPPPNPZP,
        PPPPPNPP,PPPPPNNP,PPPPPNPN,PPPPPNZP,PPPPZPPP,PPPPZPNP,PPPPZPPN,PPPPZPZP,
        PPNPPPPP,PPNPPPNP,PPNPPPPN,PPNPPPZP,PPNPNPPP,PPNPNPNP,PPNPNPPN,PPNPNPZP,
        PPNPPNPP,PPNPPNNP,PPNPPNPN,PPNPPNZP,PPNPZPPP,PPNPZPNP,PPNPZPPN,PPNPZPZP,
        PPPNPPPP,PPPNPPNP,PPPNPPPN,PPPNPPZP,PPPNNPPP,PPPNNPNP,PPPNNPPN,PPPNNPZP,
        PPPNPNPP,PPPNPNNP,PPPNPNPN,PPPNPNZP,PPPNZPPP,PPPNZPNP,PPPNZPPN,PPPNZPZP,
        PPZPPPPP,PPZPPPNP,PPZPPPPN,PPZPPPZP,PPZPNPPP,PPZPNPNP,PPZPNPPN,PPZPNPZP,
        PPZPPNPP,PPZPPNNP,PPZPPNPN,PPZPPNZP,PPZPZPPP,PPZPZPNP,PPZPZPPN,PPZPZPZP,
        NPPPPPPP,NPPPPPNP,NPPPPPPN,NPPPPPZP,NPPPNPPP,NPPPNPNP,NPPPNPPN,NPPPNPZP,
        NPPPPNPP,NPPPPNNP,NPPPPNPN,NPPPPNZP,NPPPZPPP,NPPPZPNP,NPPPZPPN,NPPPZPZP,
        NPNPPPPP,NPNPPPNP,NPNPPPPN,NPNPPPZP,NPNPNPPP,NPNPNPNP,NPNPNPPN,NPNPNPZP,
        NPNPPNPP,NPNPPNNP,NPNPPNPN,NPNPPNZP,NPNPZPPP,NPNPZPNP,NPNPZPPN,NPNPZPZP,
        NPPNPPPP,NPPNPPNP,NPPNPPPN,NPPNPPZP,NPPNNPPP,NPPNNPNP,NPPNNPPN,NPPNNPZP,
        NPPNPNPP,NPPNPNNP,NPPNPNPN,NPPNPNZP,NPPNZPPP,NPPNZPNP,NPPNZPPN,NPPNZPZP,
        NPZPPPPP,NPZPPPNP,NPZPPPPN,NPZPPPZP,NPZPNPPP,NPZPNPNP,NPZPNPPN,NPZPNPZP,
        NPZPPNPP,NPZPPNNP,NPZPPNPN,NPZPPNZP,NPZPZPPP,NPZPZPNP,NPZPZPPN,NPZPZPZP,
        PNPPPPPP,PNPPPPNP,PNPPPPPN,PNPPPPZP,PNPPNPPP,PNPPNPNP,PNPPNPPN,PNPPNPZP,
        PNPPPNPP,PNPPPNNP,PNPPPNPN,PNPPPNZP,PNPPZPPP,PNPPZPNP,PNPPZPPN,PNPPZPZP,
        PNNPPPPP,PNNPPPNP,PNNPPPPN,PNNPPPZP,PNNPNPPP,PNNPNPNP,PNNPNPPN,PNNPNPZP,
        PNNPPNPP,PNNPPNNP,PNNPPNPN,PNNPPNZP,PNNPZPPP,PNNPZPNP,PNNPZPPN,PNNPZPZP,
        PNPNPPPP,PNPNPPNP,PNPNPPPN,PNPNPPZP,PNPNNPPP,PNPNNPNP,PNPNNPPN,PNPNNPZP,
        PNPNPNPP,PNPNPNNP,PNPNPNPN,PNPNPNZP,PNPNZPPP,PNPNZPNP,PNPNZPPN,PNPNZPZP,
        PNZPPPPP,PNZPPPNP,PNZPPPPN,PNZPPPZP,PNZPNPPP,PNZPNPNP,PNZPNPPN,PNZPNPZP,
        PNZPPNPP,PNZPPNNP,PNZPPNPN,PNZPPNZP,PNZPZPPP,PNZPZPNP,PNZPZPPN,PNZPZPZP,
        ZPPPPPPP,ZPPPPPNP,ZPPPPPPN,ZPPPPPZP,ZPPPNPPP,ZPPPNPNP,ZPPPNPPN,ZPPPNPZP,
        ZPPPPNPP,ZPPPPNNP,ZPPPPNPN,ZPPPPNZP,ZPPPZPPP,ZPPPZPNP,ZPPPZPPN,ZPPPZPZP,
        ZPNPPPPP,ZPNPPPNP,ZPNPPPPN,ZPNPPPZP,ZPNPNPPP,ZPNPNPNP,ZPNPNPPN,ZPNPNPZP,
        ZPNPPNPP,ZPNPPNNP,ZPNPPNPN,ZPNPPNZP,ZPNPZPPP,ZPNPZPNP,ZPNPZPPN,ZPNPZPZP,
        ZPPNPPPP,ZPPNPPNP,ZPPNPPPN,ZPPNPPZP,ZPPNNPPP,ZPPNNPNP,ZPPNNPPN,ZPPNNPZP,
        ZPPNPNPP,ZPPNPNNP,ZPPNPNPN,ZPPNPNZP,ZPPNZPPP,ZPPNZPNP,ZPPNZPPN,ZPPNZPZP,
        ZPZPPPPP,ZPZPPPNP,ZPZPPPPN,ZPZPPPZP,ZPZPNPPP,ZPZPNPNP,ZPZPNPPN,ZPZPNPZP,
        ZPZPPNPP,ZPZPPNNP,ZPZPPNPN,ZPZPPNZP,ZPZPZPPP,ZPZPZPNP,ZPZPZPPN,ZPZPZPZP;
TABLES

   IntSize
          Integer@U8 -> 0b0_00
          Integer@S8 -> 0b1_00
          Integer@U16 -> 0b0_01
          Integer@S16 -> 0b1_01
          Integer@U32 -> 0b0_10
          Integer@S32 -> 0b1_10
          Integer@U64 -> 0b0_11
          Integer@S64 -> 0b1_11
          ;

   IsSigned
          Integer32@U32 -> 0
          Integer32@S32 -> 1
          ;

   IsSPASigned
          IntegerSPA@U32 -> 0
          IntegerSPA@U24 -> 0
          IntegerSPA@U16H0 -> 0
          IntegerSPA@U16H1 -> 0
          IntegerSPA@S32 -> 1
          IntegerSPA@S24 -> 1
          IntegerSPA@S16H0 -> 1
          IntegerSPA@S16H1 -> 1
          ;

   IsSPBSigned
          IntegerSPB@U24 -> 0
          IntegerSPB@U16H0 -> 0
          IntegerSPB@S24 -> 1
          IntegerSPB@S16H0 -> 1
          ;

   IsSPCSigned
          IntegerSPC@U32 -> 0
          IntegerSPC@U24 -> 0
          IntegerSPC@U16H0 -> 0
          IntegerSPC@S32 -> 1
          IntegerSPC@S24 -> 1
          IntegerSPC@S16H0 -> 1
          ;

   GetSPExtract
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_00_000
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_00_000
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_00_010
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_00_010
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_00_100
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_00_100
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_00_110
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_00_110

          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_01_000
          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_01_000
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_01_010
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_01_010
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_01_100
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_01_100
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_01_110
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_01_110

          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_10_000
          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_10_000
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_10_010
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_10_010
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_10_110
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_10_110

          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_00_000
          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_00_000
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_00_010
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_00_010
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_00_100
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_00_100
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_00_110
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_00_110

          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_00_001
          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_00_001
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_00_011
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_00_011
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_00_101
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_00_101
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_00_111
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_00_111

          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_00_001
          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_00_001
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_00_011
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_00_011
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_00_101
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_00_101
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_00_111
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_00_111

          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_01_000
          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_01_000
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_01_010
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_01_010
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_01_100
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_01_100
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_01_110
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_01_110

          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_01_001
          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_01_001
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_01_011
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_01_011
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_01_101
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_01_101
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_01_111
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_01_111

          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_01_001
          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_01_001
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_01_011
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_01_011
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_01_101
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_01_101
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_01_111
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_01_111

          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_10_000
          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_10_000
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_10_010
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_10_010
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_10_110
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_10_110

          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_10_001
          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_10_001
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_10_011
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_10_011
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_10_111
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_10_111

          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_10_001
          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_10_001
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_10_011
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_10_011
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_10_101
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_10_111
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_10_111


          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_00_000
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_00_000
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_00_010
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_00_010
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_00_100
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_00_100
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_00_110
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_00_110

          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_00_001
          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_00_001
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_00_011
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_00_011
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_00_101
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_00_101
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_00_111
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_00_111

          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_00_001
          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_00_001
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_00_011
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_00_011
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_00_101
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_00_101
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_00_111
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_00_111

          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_01_000
          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_01_000
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_01_010
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_01_010
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_01_100
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_01_100
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_01_110
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_01_110

          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_01_001
          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_01_001
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_01_011
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_01_011
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_01_101
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_01_101
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_01_111
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_01_111

          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_01_001
          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_01_001
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_01_011
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_01_011
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_01_101
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_01_101
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_01_111
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_01_111

          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_10_000
          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b11_10_000
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_10_010
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b11_10_010
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b11_10_100
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_10_110
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b11_10_110

          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_10_001
          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_10_001
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_10_011
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_10_011
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_10_111
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_10_111

          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_10_001
          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b11_10_001
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_10_011
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b11_10_011
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b11_10_101
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_10_111
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b11_10_111

          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_00_000
          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_00_000
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_00_010
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_00_010
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_00_100
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_00_100
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_00_110
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_00_110

          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_01_000
          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_01_000
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_01_010
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_01_010
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_01_100
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_01_100
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_01_110
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_01_110

          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_10_000
          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_10_000
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_10_010
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_10_010
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_10_100
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_10_110
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_10_110
        ;

   IsSameSigned
          Integer32@U32 Integer32@U32 -> 0
          Integer32@S32 Integer32@S32 -> 1
          Integer32@S32 Integer32@U32 -> 0
          Integer32@U32 Integer32@S32 -> 0
          ;

   I2I_N_Sizes
          Integer1632@U16 Integer1632@U16 -> 0b0000
          Integer1632@S16 Integer1632@U16 -> 0b0010
          Integer1632@U32 Integer1632@U16 -> 0b0100
          Integer1632@S32 Integer1632@U16 -> 0b0110

          Integer1632@U16 Integer1632@S16 -> 0b0001
          Integer1632@S16 Integer1632@S16 -> 0b0011
          Integer1632@U32 Integer1632@S16 -> 0b0101
          Integer1632@S32 Integer1632@S16 -> 0b0111

          Integer1632@U16 Integer1632@U32 -> 0b1000
          Integer1632@S16 Integer1632@U32 -> 0b1010
          Integer1632@U32 Integer1632@U32 -> 0b1100
          Integer1632@S32 Integer1632@U32 -> 0b1110

          Integer1632@U16 Integer1632@S32 -> 0b1001
          Integer1632@S16 Integer1632@S32 -> 0b1011
          Integer1632@U32 Integer1632@S32 -> 0b1101
          Integer1632@S32 Integer1632@S32 -> 0b1111
          ;

Integer8Signed
          Integer8@U8 -> 0
          Integer8@S8 -> 1
          ;

Integer16Signed
          Integer16@U16 -> 0
          Integer16@S16 -> 1
          ;

IntegerSigned
          Integer@U16 -> 0
          Integer@S16 -> 1
          Integer@U8 -> 0
          Integer@S8 -> 1
          Integer@U32 -> 0
          Integer@S32 -> 1
          Integer@U64 -> 0
          Integer@S64 -> 1
          ;

Integer8x8Signed
          Integer8@U8 Integer8@U8 -> 0
          Integer8@S8 Integer8@S8 -> 1
          Integer8@S8 Integer8@U8 -> 0
          Integer8@U8 Integer8@S8 -> 0
          ;

Integer16x16Signed
          Integer16@U16 Integer16@U16 -> 0
          Integer16@S16 Integer16@S16 -> 1
          Integer16@S16 Integer16@U16 -> 0
          Integer16@U16 Integer16@S16 -> 0
          ;

    PSign
       PO@noPO 0 0 -> 0b00
       PO@noPO 0 1 -> 0b01
       PO@noPO 1 0 -> 0b10
       PO@noPO 1 1 -> 0b00
         PO@PO 0 0 -> 0b11
         PO@PO 0 1 -> 0b11
         PO@PO 1 0 -> 0b11
         PO@PO 1 1 -> 0b11
   PO@ILLEGAL1 0 0 -> 0b01
   PO@ILLEGAL1 0 1 -> 0b01
   PO@ILLEGAL1 1 0 -> 0b01
   PO@ILLEGAL1 1 1 -> 0b01
   PO@ILLEGAL2 0 0 -> 0b10
   PO@ILLEGAL2 0 1 -> 0b10
   PO@ILLEGAL2 1 0 -> 0b10
   PO@ILLEGAL2 1 1 -> 0b10
          ;

    VMode
        AVRG@noAVRG 0 0 -> 0
        AVRG@noAVRG 0 1 -> 1
        AVRG@noAVRG 1 0 -> 2
        AVRG@noAVRG 1 1 -> 0
          AVRG@AVRG 0 0 -> 3
          AVRG@AVRG 0 1 -> 3
          AVRG@AVRG 1 0 -> 3
          AVRG@AVRG 1 1 -> 3
          ;

    PSign32
        PO@noPO 0 -> 0b00
        PO@noPO 1 -> 0b10
          PO@PO 0 -> 0b11
          PO@PO 1 -> 0b00
    PO@ILLEGAL1 0 -> 0b01
    PO@ILLEGAL1 1 -> 0b01
    PO@ILLEGAL2 0 -> 0b10
    PO@ILLEGAL2 1 -> 0b10
          ;

    PSignFFMA
          0 0 -> 0
          1 0 -> 1
          0 1 -> 1
          1 1 -> 0
          ;

    PSignMAD
       PO@noPO 0 0 0 -> 0b00
       PO@noPO 1 1 0 -> 0b00
       PO@noPO 0 0 1 -> 0b01
       PO@noPO 1 0 0 -> 0b10
       PO@noPO 0 1 0 -> 0b10
       PO@noPO 1 1 1 -> 0b01
       PO@noPO 0 1 1 -> 0b00
       PO@noPO 1 0 1 -> 0b00
         PO@PO 0 0 0 -> 0b11
         PO@PO 0 0 1 -> 0b11
         PO@PO 0 1 0 -> 0b11
         PO@PO 0 1 1 -> 0b11
         PO@PO 1 0 0 -> 0b11
         PO@PO 1 0 1 -> 0b11
         PO@PO 1 1 0 -> 0b11
         PO@PO 1 1 1 -> 0b11
   PO@ILLEGAL1 0 0 0 -> 0b01
   PO@ILLEGAL1 0 0 1 -> 0b01
   PO@ILLEGAL1 0 1 0 -> 0b01
   PO@ILLEGAL1 0 1 1 -> 0b01
   PO@ILLEGAL1 1 0 0 -> 0b01
   PO@ILLEGAL1 1 0 1 -> 0b01
   PO@ILLEGAL1 1 1 0 -> 0b01
   PO@ILLEGAL1 1 1 1 -> 0b01
   PO@ILLEGAL2 0 0 0 -> 0b10
   PO@ILLEGAL2 0 0 1 -> 0b10
   PO@ILLEGAL2 0 1 0 -> 0b10
   PO@ILLEGAL2 0 1 1 -> 0b10
   PO@ILLEGAL2 1 0 0 -> 0b10
   PO@ILLEGAL2 1 0 1 -> 0b10
   PO@ILLEGAL2 1 1 0 -> 0b10
   PO@ILLEGAL2 1 1 1 -> 0b10
          ;

    CombineBP
          1 0 -> 0
          0 1 -> 1
          0 0 -> 0
          1 1 -> 0
          ;

    RCIConstBank
          0 -> 0b010
          1 -> 0b100
         16 -> 0b110
          2 -> 0b010
          3 -> 0b010
          4 -> 0b010
          5 -> 0b010
          6 -> 0b010
          7 -> 0b010
          8 -> 0b010
          9 -> 0b010
         10 -> 0b010
         11 -> 0b010
         12 -> 0b010
         13 -> 0b010
         14 -> 0b010
         15 -> 0b010
         17 -> 0b010
         18 -> 0b010
         19 -> 0b010
         20 -> 0b010
         21 -> 0b010
         22 -> 0b010
         23 -> 0b010
         24 -> 0b010
         25 -> 0b010
         26 -> 0b010
         27 -> 0b010
         28 -> 0b010
         29 -> 0b010
         30 -> 0b010
         31 -> 0b010
          ;

    CNSConstBank
          0 -> 0b01
          1 -> 0b10
         16 -> 0b11
          2 -> 0b01
          3 -> 0b01
          4 -> 0b01
          5 -> 0b01
          6 -> 0b01
          7 -> 0b01
          8 -> 0b01
          9 -> 0b01
         10 -> 0b01
         11 -> 0b01
         12 -> 0b01
         13 -> 0b01
         14 -> 0b01
         15 -> 0b01
         17 -> 0b01
         18 -> 0b01
         19 -> 0b01
         20 -> 0b01
         21 -> 0b01
         22 -> 0b01
         23 -> 0b01
         24 -> 0b01
         25 -> 0b01
         26 -> 0b01
         27 -> 0b01
         28 -> 0b01
         29 -> 0b01
         30 -> 0b01
         31 -> 0b01
          ;

    LDCNConstBank
          0 -> 0b000
          1 -> 0b001
          2 -> 0b010
          3 -> 0b011
          4 -> 0b100
          5 -> 0b101
          6 -> 0b110
         16 -> 0b111
          7 -> 0b000
          8 -> 0b000
          9 -> 0b000
         10 -> 0b000
         11 -> 0b000
         12 -> 0b000
         13 -> 0b000
         14 -> 0b000
         15 -> 0b000
         17 -> 0b000
         18 -> 0b000
         19 -> 0b000
         20 -> 0b000
         21 -> 0b000
         22 -> 0b000
         23 -> 0b000
         24 -> 0b000
         25 -> 0b000
         26 -> 0b000
         27 -> 0b000
         28 -> 0b000
         29 -> 0b000
         30 -> 0b000
         31 -> 0b000
          ;

    CRegAlignment
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 1
          CInteger@S16 -> 1
          CInteger@"32" -> 1
          CInteger@"64" -> 2
          CInteger@"128" -> 4
          CInteger@INVALIDSIZE7 -> 1
          ;

    LDGSizeTidBMask
          CInteger@U8 -> 0b000
          CInteger@S8 -> 0b001
          CInteger@U16 -> 0b010
          CInteger@S16 -> 0b011
          CInteger@"32" -> 0b100
          CInteger@"64" -> 0b101
          CInteger@"128" -> 0b110
          CInteger@INVALIDSIZE7 -> 0b111
          ;

    LDGSizeWmskMask
          CInteger@U8 -> 0b0001
          CInteger@S8 -> 0b0001
          CInteger@U16 -> 0b0001
          CInteger@S16 -> 0b0001
          CInteger@"32" -> 0b0001
          CInteger@"64" -> 0b0011
          CInteger@"128" -> 0b1111
          CInteger@INVALIDSIZE7 -> 0b0001
          ;


    LDGSizeMask
          CInteger@U8 -> 0b0000000000_000_0001
          CInteger@S8 -> 0b0000000000_001_0001
          CInteger@U16 -> 0b0000000000_010_0001
          CInteger@S16 -> 0b0000000000_011_0001
          CInteger@"32" -> 0b0000000000_100_0001
          CInteger@"64" -> 0b0000000000_101_0011
          CInteger@"128" -> 0b0000000000_110_1111
          CInteger@INVALIDSIZE7 -> 0b0000000000_111_0001
          ;

    LDRegAlignment
          LDInteger@U8 -> 1
          LDInteger@S8 -> 1
          LDInteger@U16 -> 1
          LDInteger@S16 -> 1
          LDInteger@"32" -> 1
          LDInteger@"64" -> 2
          LDInteger@"128" -> 4
          LDInteger@"U.128" -> 4
          ;

    BQRegAlignment
          BQInteger@"64" -> 2
          BQInteger@"128" -> 4
          ;

    ARegAlignment
          AInteger@"32" -> 1
          AInteger@"64" -> 2
          AInteger@"96" -> 4
          AInteger@"128" -> 4
          ;

    QRegAlignment
          QInteger@"32" -> 1
          QInteger@"64" -> 2
          ;

    SQRegAlignment
          SQInteger@U32 -> 1
          SQInteger@S32 -> 1
          SQInteger@"F32.FTZ.RN" -> 1
          SQInteger@INVALIDATOMICSIZE6 -> 1
          SQInteger@INVALIDATOMICSIZE7 -> 1
          SQInteger@U64 -> 2
          SQInteger@S64 -> 2
          SQInteger@U128 -> 4
          ;

    CASRegAlignment
          CASInteger@"32" -> 1
          CASInteger@"64" -> 2
          ;

    CIntSize
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 2
          CInteger@S16 -> 2
          CInteger@"32" -> 4
          CInteger@"64" -> 8
          CInteger@"128" -> 16
          ;

    Video4ImmSel
          ASel4@"0000" -> 1
          ASel4@"1111" -> 1
          ASel4@"2222" -> 1
          ASel4@"3333" -> 1
          ASel4@"3210" -> 1
          ASel4@"4321" -> 1
          ASel4@"5432" -> 1
          ASel4@"6543" -> 1
          ASel4@"3201" -> 1
          ASel4@"3012" -> 1
          ASel4@"0213" -> 1
          ASel4@"3120" -> 1
          ASel4@"1230" -> 1
          ASel4@"2310" -> 1
          ASel4@INVALIDASEL4E -> 1
          ASel4@INVALIDASEL4F -> 1
          ;

    TXQModeDim
          TXQMode@TEX_HEADER_DIMENSION -> 0b00000_1
          TXQMode@TEX_HEADER_TEXTURE_TYPE -> 0b00001_0
          TXQMode@TEX_HEADER_SAMPLER_POS -> 0b00010_1
          TXQMode@"3" -> 0b00011_0
          TXQMode@"4" -> 0b00100_0
          TXQMode@"5" -> 0b00101_0
          TXQMode@"6" -> 0b00110_0
          TXQMode@"7" -> 0b00111_0
          TXQMode@TEX_SAMPLER_FILTER -> 0b01000_0
          TXQMode@TEX_SAMPLER_LOD -> 0b01001_0
          TXQMode@TEX_SAMPLER_WRAP -> 0b01010_0
          TXQMode@TEX_SAMPLER_BORDER_COLOR -> 0b01011_0
          TXQMode@"12" -> 0b01100_0
          TXQMode@"13" -> 0b01101_0
          TXQMode@"14" -> 0b01110_0
          TXQMode@"15" -> 0b01111_0
          TXQMode@"16" -> 0b10000_0
          TXQMode@"17" -> 0b10001_0
          TXQMode@"18" -> 0b10010_0
          TXQMode@"19" -> 0b10011_0
          TXQMode@"20" -> 0b10100_0
          TXQMode@"21" -> 0b10101_0
          TXQMode@"22" -> 0b10110_0
          TXQMode@"23" -> 0b10111_0
          TXQMode@"24" -> 0b11000_0
          TXQMode@"25" -> 0b11001_0
          TXQMode@"26" -> 0b11010_0
          TXQMode@"27" -> 0b11011_0
          TXQMode@"28" -> 0b11100_0
          TXQMode@"29" -> 0b11101_0
          TXQMode@"30" -> 0b11110_0
          TXQMode@"31" -> 0b11111_0
          ;

    ldbvCopMerge
          BQInteger@"64" LoadCacheOp0@CA -> 0
          BQInteger@"64" LoadCacheOp0@CG -> 1
          BQInteger@"128" LoadCacheOp0@CA -> 2
          BQInteger@"128" LoadCacheOp0@CG -> 3
          ;

    abSize
          CInteger@U8 CInteger@U8 -> 0
          CInteger@U8 CInteger@S8 -> 1
          CInteger@U8 CInteger@U16 -> 2
          CInteger@U8 CInteger@S16 -> 3
          CInteger@U8 CInteger@"32" -> 4

          CInteger@S8 CInteger@U8 -> 5
          CInteger@S8 CInteger@S8 -> 6
          CInteger@S8 CInteger@U16 -> 7
          CInteger@S8 CInteger@S16 -> 8
          CInteger@S8 CInteger@"32" -> 9

          CInteger@U16 CInteger@U8 -> 10
          CInteger@U16 CInteger@S8 -> 11
          CInteger@U16 CInteger@U16 -> 12
          CInteger@U16 CInteger@S16 -> 13
          CInteger@U16 CInteger@"32" -> 14

          CInteger@S16 CInteger@U8 -> 15
          CInteger@S16 CInteger@S8 -> 16
          CInteger@S16 CInteger@U16 -> 17
          CInteger@S16 CInteger@S16 -> 18
          CInteger@S16 CInteger@"32" -> 19

          CInteger@"32" CInteger@U8 -> 20
          CInteger@"32" CInteger@S8 -> 21
          CInteger@"32" CInteger@U16 -> 22
          CInteger@"32" CInteger@S16 -> 23
          CInteger@"32" CInteger@"32" -> 24
          CInteger@"32" CInteger@"64" -> 25
          CInteger@"32" CInteger@"128" -> 26

          CInteger@"64" CInteger@"32" -> 27
          CInteger@"64" CInteger@"64" -> 28
          CInteger@"64" CInteger@"128" -> 29

          CInteger@"128" CInteger@"32" -> 30
          CInteger@"128" CInteger@"64" -> 31

          CInteger@U8 CInteger@"64" -> 0
          CInteger@U8 CInteger@"128" -> 0
          CInteger@S8 CInteger@"64" -> 0
          CInteger@S8 CInteger@"128" -> 0
          CInteger@U16 CInteger@"64" -> 0
          CInteger@U16 CInteger@"128" -> 0
          CInteger@S16 CInteger@"64" -> 0
          CInteger@S16 CInteger@"128" -> 0
          CInteger@"64" CInteger@U8 -> 0
          CInteger@"64" CInteger@S8 -> 0
          CInteger@"64" CInteger@U16 -> 0
          CInteger@"64" CInteger@S16 -> 0
          CInteger@"128" CInteger@U8 -> 0
          CInteger@"128" CInteger@S8 -> 0
          CInteger@"128" CInteger@U16 -> 0
          CInteger@"128" CInteger@S16 -> 0
          CInteger@"128" CInteger@"128" -> 0
          ;

    VFormat8
          Integer@U8 B1B0@B0 -> 0b0_000
          Integer@U8 B1B0@B1 -> 0b0_001
          Integer@U8 B1B0@B2 -> 0b0_010
          Integer@U8 B1B0@B3 -> 0b0_011
          Integer@S8 B1B0@B0 -> 0b1_000
          Integer@S8 B1B0@B1 -> 0b1_001
          Integer@S8 B1B0@B2 -> 0b1_010
          Integer@S8 B1B0@B3 -> 0b1_011
          ;

    VFormat16
          Integer@U16 H1H0@H0 -> 0b0_100
          Integer@U16 H1H0@H1 -> 0b0_101
          Integer@S16 H1H0@H0 -> 0b1_100
          Integer@S16 H1H0@H1 -> 0b1_101
          ;

    VFormat32
          VInteger32@U32 -> 0b0_110
          VInteger32@S32 -> 0b1_110
          6 -> 0b0_111
          7 -> 0b1_111
          ;

    VFormatU8
          U8@U8 B1B0@B0 -> 0b000
          U8@U8 B1B0@B1 -> 0b001
          U8@U8 B1B0@B2 -> 0b010
          U8@U8 B1B0@B3 -> 0b011
          ;

    VFormatU16
          U16@U16 H1H0@H0 -> 0b100
          U16@U16 H1H0@H1 -> 0b101
          ;

    VFormatU32
          U32@U32 -> 0b110
          U32@INVALIDSEL7 -> 0b111
          ;






    VFormat8_N
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b0_0_00000
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b0_0_00001
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b0_0_00010
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b0_0_00011
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b0_0_00100
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b0_0_00101
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b0_0_00110
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b0_0_00111
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b0_0_01000
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b0_0_01001
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b0_0_01010
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b0_0_01011
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b0_0_01100
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b0_0_01101
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b0_0_01110
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b0_0_01111
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b0_1_00000
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b0_1_00001
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b0_1_00010
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b0_1_00011
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b0_1_00100
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b0_1_00101
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b0_1_00110
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b0_1_00111
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b0_1_01000
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b0_1_01001
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b0_1_01010
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b0_1_01011
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b0_1_01100
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b0_1_01101
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b0_1_01110
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b0_1_01111
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b1_0_00000
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b1_0_00001
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b1_0_00010
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b1_0_00011
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b1_0_00100
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b1_0_00101
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b1_0_00110
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b1_0_00111
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b1_0_01000
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b1_0_01001
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b1_0_01010
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b1_0_01011
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b1_0_01100
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b1_0_01101
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b1_0_01110
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b1_0_01111
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b1_1_00000
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b1_1_00001
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b1_1_00010
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b1_1_00011
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b1_1_00100
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b1_1_00101
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b1_1_00110
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b1_1_00111
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b1_1_01000
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b1_1_01001
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b1_1_01010
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b1_1_01011
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b1_1_01100
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b1_1_01101
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b1_1_01110
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b1_1_01111
          ;

    VFormat32_8_N
          Integer@U32 Integer@U8 B1B0@B0 -> 0b0_0_10000
          Integer@U32 Integer@U8 B1B0@B1 -> 0b0_0_10001
          Integer@U32 Integer@U8 B1B0@B2 -> 0b0_0_10010
          Integer@U32 Integer@U8 B1B0@B3 -> 0b0_0_10011
          Integer@U32 Integer@S8 B1B0@B0 -> 0b0_1_10000
          Integer@U32 Integer@S8 B1B0@B1 -> 0b0_1_10001
          Integer@U32 Integer@S8 B1B0@B2 -> 0b0_1_10010
          Integer@U32 Integer@S8 B1B0@B3 -> 0b0_1_10011
          Integer@S32 Integer@U8 B1B0@B0 -> 0b1_0_10000
          Integer@S32 Integer@U8 B1B0@B1 -> 0b1_0_10001
          Integer@S32 Integer@U8 B1B0@B2 -> 0b1_0_10010
          Integer@S32 Integer@U8 B1B0@B3 -> 0b1_0_10011
          Integer@S32 Integer@S8 B1B0@B0 -> 0b1_1_10000
          Integer@S32 Integer@S8 B1B0@B1 -> 0b1_1_10001
          Integer@S32 Integer@S8 B1B0@B2 -> 0b1_1_10010
          Integer@S32 Integer@S8 B1B0@B3 -> 0b1_1_10011
          ;

    VFormat8_32_N
          Integer@U8 B1B0@B0 Integer@U32 -> 0b0_0_10100
          Integer@U8 B1B0@B1 Integer@U32 -> 0b0_0_10101
          Integer@U8 B1B0@B2 Integer@U32 -> 0b0_0_10110
          Integer@U8 B1B0@B3 Integer@U32 -> 0b0_0_10111
          Integer@U8 B1B0@B0 Integer@S32 -> 0b0_1_10100
          Integer@U8 B1B0@B1 Integer@S32 -> 0b0_1_10101
          Integer@U8 B1B0@B2 Integer@S32 -> 0b0_1_10110
          Integer@U8 B1B0@B3 Integer@S32 -> 0b0_1_10111
          Integer@S8 B1B0@B0 Integer@U32 -> 0b1_0_10100
          Integer@S8 B1B0@B1 Integer@U32 -> 0b1_0_10101
          Integer@S8 B1B0@B2 Integer@U32 -> 0b1_0_10110
          Integer@S8 B1B0@B3 Integer@U32 -> 0b1_0_10111
          Integer@S8 B1B0@B0 Integer@S32 -> 0b1_1_10100
          Integer@S8 B1B0@B1 Integer@S32 -> 0b1_1_10101
          Integer@S8 B1B0@B2 Integer@S32 -> 0b1_1_10110
          Integer@S8 B1B0@B3 Integer@S32 -> 0b1_1_10111
          ;

    VFormat16_N
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b0_0_11000
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b0_0_11001
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b0_0_11010
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b0_0_11011
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b0_1_11000
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b0_1_11001
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b0_1_11010
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b0_1_11011
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b1_0_11000
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b1_0_11001
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b1_0_11010
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b1_0_11011
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b1_1_11000
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b1_1_11001
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b1_1_11010
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b1_1_11011
          ;

    VFormat32_16_N
          Integer@U32 Integer@U16 H1H0@H0 -> 0b0_0_11100
          Integer@U32 Integer@U16 H1H0@H1 -> 0b0_0_11101
          Integer@U32 Integer@S16 H1H0@H0 -> 0b0_1_11100
          Integer@U32 Integer@S16 H1H0@H1 -> 0b0_1_11101
          Integer@S32 Integer@U16 H1H0@H0 -> 0b1_0_11100
          Integer@S32 Integer@U16 H1H0@H1 -> 0b1_0_11101
          Integer@S32 Integer@S16 H1H0@H0 -> 0b1_1_11100
          Integer@S32 Integer@S16 H1H0@H1 -> 0b1_1_11101
          ;

    VFormat16_32_N
          Integer@U16 H1H0@H0 Integer@U32 -> 0b0_0_11110
          Integer@U16 H1H0@H1 Integer@U32 -> 0b0_0_11111
          Integer@U16 H1H0@H0 Integer@S32 -> 0b0_1_11110
          Integer@U16 H1H0@H1 Integer@S32 -> 0b0_1_11111
          Integer@S16 H1H0@H0 Integer@U32 -> 0b1_0_11110
          Integer@S16 H1H0@H1 Integer@U32 -> 0b1_0_11111
          Integer@S16 H1H0@H0 Integer@S32 -> 0b1_1_11110
          Integer@S16 H1H0@H1 Integer@S32 -> 0b1_1_11111
          ;

    ConsecutiveReg8
          Register@R0 Register@R1 CASInteger@"32" -> 0b0_00000000
          Register@R1 Register@R2 CASInteger@"32" -> 0b0_00000001
          Register@R2 Register@R3 CASInteger@"32" -> 0b0_00000010
          Register@R3 Register@R4 CASInteger@"32" -> 0b0_00000011
          Register@R4 Register@R5 CASInteger@"32" -> 0b0_00000100
          Register@R5 Register@R6 CASInteger@"32" -> 0b0_00000101
          Register@R6 Register@R7 CASInteger@"32" -> 0b0_00000110
          Register@R7 Register@R8 CASInteger@"32" -> 0b0_00000111
          Register@R8 Register@R9 CASInteger@"32" -> 0b0_00001000
          Register@R9 Register@R10 CASInteger@"32" -> 0b0_00001001
          Register@R10 Register@R11 CASInteger@"32" -> 0b0_00001010
          Register@R11 Register@R12 CASInteger@"32" -> 0b0_00001011
          Register@R12 Register@R13 CASInteger@"32" -> 0b0_00001100
          Register@R13 Register@R14 CASInteger@"32" -> 0b0_00001101
          Register@R14 Register@R15 CASInteger@"32" -> 0b0_00001110
          Register@R15 Register@R16 CASInteger@"32" -> 0b0_00001111
          Register@R16 Register@R17 CASInteger@"32" -> 0b0_00010000
          Register@R17 Register@R18 CASInteger@"32" -> 0b0_00010001
          Register@R18 Register@R19 CASInteger@"32" -> 0b0_00010010
          Register@R19 Register@R20 CASInteger@"32" -> 0b0_00010011
          Register@R20 Register@R21 CASInteger@"32" -> 0b0_00010100
          Register@R21 Register@R22 CASInteger@"32" -> 0b0_00010101
          Register@R22 Register@R23 CASInteger@"32" -> 0b0_00010110
          Register@R23 Register@R24 CASInteger@"32" -> 0b0_00010111
          Register@R24 Register@R25 CASInteger@"32" -> 0b0_00011000
          Register@R25 Register@R26 CASInteger@"32" -> 0b0_00011001
          Register@R26 Register@R27 CASInteger@"32" -> 0b0_00011010
          Register@R27 Register@R28 CASInteger@"32" -> 0b0_00011011
          Register@R28 Register@R29 CASInteger@"32" -> 0b0_00011100
          Register@R29 Register@R30 CASInteger@"32" -> 0b0_00011101
          Register@R30 Register@R31 CASInteger@"32" -> 0b0_00011110
          Register@R31 Register@R32 CASInteger@"32" -> 0b0_00011111
          Register@R32 Register@R33 CASInteger@"32" -> 0b0_00100000
          Register@R33 Register@R34 CASInteger@"32" -> 0b0_00100001
          Register@R34 Register@R35 CASInteger@"32" -> 0b0_00100010
          Register@R35 Register@R36 CASInteger@"32" -> 0b0_00100011
          Register@R36 Register@R37 CASInteger@"32" -> 0b0_00100100
          Register@R37 Register@R38 CASInteger@"32" -> 0b0_00100101
          Register@R38 Register@R39 CASInteger@"32" -> 0b0_00100110
          Register@R39 Register@R40 CASInteger@"32" -> 0b0_00100111
          Register@R40 Register@R41 CASInteger@"32" -> 0b0_00101000
          Register@R41 Register@R42 CASInteger@"32" -> 0b0_00101001
          Register@R42 Register@R43 CASInteger@"32" -> 0b0_00101010
          Register@R43 Register@R44 CASInteger@"32" -> 0b0_00101011
          Register@R44 Register@R45 CASInteger@"32" -> 0b0_00101100
          Register@R45 Register@R46 CASInteger@"32" -> 0b0_00101101
          Register@R46 Register@R47 CASInteger@"32" -> 0b0_00101110
          Register@R47 Register@R48 CASInteger@"32" -> 0b0_00101111
          Register@R48 Register@R49 CASInteger@"32" -> 0b0_00110000
          Register@R49 Register@R50 CASInteger@"32" -> 0b0_00110001
          Register@R50 Register@R51 CASInteger@"32" -> 0b0_00110010
          Register@R51 Register@R52 CASInteger@"32" -> 0b0_00110011
          Register@R52 Register@R53 CASInteger@"32" -> 0b0_00110100
          Register@R53 Register@R54 CASInteger@"32" -> 0b0_00110101
          Register@R54 Register@R55 CASInteger@"32" -> 0b0_00110110
          Register@R55 Register@R56 CASInteger@"32" -> 0b0_00110111
          Register@R56 Register@R57 CASInteger@"32" -> 0b0_00111000
          Register@R57 Register@R58 CASInteger@"32" -> 0b0_00111001
          Register@R58 Register@R59 CASInteger@"32" -> 0b0_00111010
          Register@R59 Register@R60 CASInteger@"32" -> 0b0_00111011
          Register@R60 Register@R61 CASInteger@"32" -> 0b0_00111100
          Register@R61 Register@R62 CASInteger@"32" -> 0b0_00111101
          Register@R62 Register@R63 CASInteger@"32" -> 0b0_00111110
          Register@R63 Register@R64 CASInteger@"32" -> 0b0_00111111
          Register@R64 Register@R65 CASInteger@"32" -> 0b0_01000000
          Register@R65 Register@R66 CASInteger@"32" -> 0b0_01000001
          Register@R66 Register@R67 CASInteger@"32" -> 0b0_01000010
          Register@R67 Register@R68 CASInteger@"32" -> 0b0_01000011
          Register@R68 Register@R69 CASInteger@"32" -> 0b0_01000100
          Register@R69 Register@R70 CASInteger@"32" -> 0b0_01000101
          Register@R70 Register@R71 CASInteger@"32" -> 0b0_01000110
          Register@R71 Register@R72 CASInteger@"32" -> 0b0_01000111
          Register@R72 Register@R73 CASInteger@"32" -> 0b0_01001000
          Register@R73 Register@R74 CASInteger@"32" -> 0b0_01001001
          Register@R74 Register@R75 CASInteger@"32" -> 0b0_01001010
          Register@R75 Register@R76 CASInteger@"32" -> 0b0_01001011
          Register@R76 Register@R77 CASInteger@"32" -> 0b0_01001100
          Register@R77 Register@R78 CASInteger@"32" -> 0b0_01001101
          Register@R78 Register@R79 CASInteger@"32" -> 0b0_01001110
          Register@R79 Register@R80 CASInteger@"32" -> 0b0_01001111
          Register@R80 Register@R81 CASInteger@"32" -> 0b0_01010000
          Register@R81 Register@R82 CASInteger@"32" -> 0b0_01010001
          Register@R82 Register@R83 CASInteger@"32" -> 0b0_01010010
          Register@R83 Register@R84 CASInteger@"32" -> 0b0_01010011
          Register@R84 Register@R85 CASInteger@"32" -> 0b0_01010100
          Register@R85 Register@R86 CASInteger@"32" -> 0b0_01010101
          Register@R86 Register@R87 CASInteger@"32" -> 0b0_01010110
          Register@R87 Register@R88 CASInteger@"32" -> 0b0_01010111
          Register@R88 Register@R89 CASInteger@"32" -> 0b0_01011000
          Register@R89 Register@R90 CASInteger@"32" -> 0b0_01011001
          Register@R90 Register@R91 CASInteger@"32" -> 0b0_01011010
          Register@R91 Register@R92 CASInteger@"32" -> 0b0_01011011
          Register@R92 Register@R93 CASInteger@"32" -> 0b0_01011100
          Register@R93 Register@R94 CASInteger@"32" -> 0b0_01011101
          Register@R94 Register@R95 CASInteger@"32" -> 0b0_01011110
          Register@R95 Register@R96 CASInteger@"32" -> 0b0_01011111
          Register@R96 Register@R97 CASInteger@"32" -> 0b0_01100000
          Register@R97 Register@R98 CASInteger@"32" -> 0b0_01100001
          Register@R98 Register@R99 CASInteger@"32" -> 0b0_01100010
          Register@R99 Register@R100 CASInteger@"32" -> 0b0_01100011
          Register@R100 Register@R101 CASInteger@"32" -> 0b0_01100100
          Register@R101 Register@R102 CASInteger@"32" -> 0b0_01100101
          Register@R102 Register@R103 CASInteger@"32" -> 0b0_01100110
          Register@R103 Register@R104 CASInteger@"32" -> 0b0_01100111
          Register@R104 Register@R105 CASInteger@"32" -> 0b0_01101000
          Register@R105 Register@R106 CASInteger@"32" -> 0b0_01101001
          Register@R106 Register@R107 CASInteger@"32" -> 0b0_01101010
          Register@R107 Register@R108 CASInteger@"32" -> 0b0_01101011
          Register@R108 Register@R109 CASInteger@"32" -> 0b0_01101100
          Register@R109 Register@R110 CASInteger@"32" -> 0b0_01101101
          Register@R110 Register@R111 CASInteger@"32" -> 0b0_01101110
          Register@R111 Register@R112 CASInteger@"32" -> 0b0_01101111
          Register@R112 Register@R113 CASInteger@"32" -> 0b0_01110000
          Register@R113 Register@R114 CASInteger@"32" -> 0b0_01110001
          Register@R114 Register@R115 CASInteger@"32" -> 0b0_01110010
          Register@R115 Register@R116 CASInteger@"32" -> 0b0_01110011
          Register@R116 Register@R117 CASInteger@"32" -> 0b0_01110100
          Register@R117 Register@R118 CASInteger@"32" -> 0b0_01110101
          Register@R118 Register@R119 CASInteger@"32" -> 0b0_01110110
          Register@R119 Register@R120 CASInteger@"32" -> 0b0_01110111
          Register@R120 Register@R121 CASInteger@"32" -> 0b0_01111000
          Register@R121 Register@R122 CASInteger@"32" -> 0b0_01111001
          Register@R122 Register@R123 CASInteger@"32" -> 0b0_01111010
          Register@R123 Register@R124 CASInteger@"32" -> 0b0_01111011
          Register@R124 Register@R125 CASInteger@"32" -> 0b0_01111100
          Register@R125 Register@R126 CASInteger@"32" -> 0b0_01111101
          Register@R126 Register@R127 CASInteger@"32" -> 0b0_01111110
          Register@R127 Register@R128 CASInteger@"32" -> 0b0_01111111
          Register@R128 Register@R129 CASInteger@"32" -> 0b0_10000000
          Register@R129 Register@R130 CASInteger@"32" -> 0b0_10000001
          Register@R130 Register@R131 CASInteger@"32" -> 0b0_10000010
          Register@R131 Register@R132 CASInteger@"32" -> 0b0_10000011
          Register@R132 Register@R133 CASInteger@"32" -> 0b0_10000100
          Register@R133 Register@R134 CASInteger@"32" -> 0b0_10000101
          Register@R134 Register@R135 CASInteger@"32" -> 0b0_10000110
          Register@R135 Register@R136 CASInteger@"32" -> 0b0_10000111
          Register@R136 Register@R137 CASInteger@"32" -> 0b0_10001000
          Register@R137 Register@R138 CASInteger@"32" -> 0b0_10001001
          Register@R138 Register@R139 CASInteger@"32" -> 0b0_10001010
          Register@R139 Register@R140 CASInteger@"32" -> 0b0_10001011
          Register@R140 Register@R141 CASInteger@"32" -> 0b0_10001100
          Register@R141 Register@R142 CASInteger@"32" -> 0b0_10001101
          Register@R142 Register@R143 CASInteger@"32" -> 0b0_10001110
          Register@R143 Register@R144 CASInteger@"32" -> 0b0_10001111
          Register@R144 Register@R145 CASInteger@"32" -> 0b0_10010000
          Register@R145 Register@R146 CASInteger@"32" -> 0b0_10010001
          Register@R146 Register@R147 CASInteger@"32" -> 0b0_10010010
          Register@R147 Register@R148 CASInteger@"32" -> 0b0_10010011
          Register@R148 Register@R149 CASInteger@"32" -> 0b0_10010100
          Register@R149 Register@R150 CASInteger@"32" -> 0b0_10010101
          Register@R150 Register@R151 CASInteger@"32" -> 0b0_10010110
          Register@R151 Register@R152 CASInteger@"32" -> 0b0_10010111
          Register@R152 Register@R153 CASInteger@"32" -> 0b0_10011000
          Register@R153 Register@R154 CASInteger@"32" -> 0b0_10011001
          Register@R154 Register@R155 CASInteger@"32" -> 0b0_10011010
          Register@R155 Register@R156 CASInteger@"32" -> 0b0_10011011
          Register@R156 Register@R157 CASInteger@"32" -> 0b0_10011100
          Register@R157 Register@R158 CASInteger@"32" -> 0b0_10011101
          Register@R158 Register@R159 CASInteger@"32" -> 0b0_10011110
          Register@R159 Register@R160 CASInteger@"32" -> 0b0_10011111
          Register@R160 Register@R161 CASInteger@"32" -> 0b0_10100000
          Register@R161 Register@R162 CASInteger@"32" -> 0b0_10100001
          Register@R162 Register@R163 CASInteger@"32" -> 0b0_10100010
          Register@R163 Register@R164 CASInteger@"32" -> 0b0_10100011
          Register@R164 Register@R165 CASInteger@"32" -> 0b0_10100100
          Register@R165 Register@R166 CASInteger@"32" -> 0b0_10100101
          Register@R166 Register@R167 CASInteger@"32" -> 0b0_10100110
          Register@R167 Register@R168 CASInteger@"32" -> 0b0_10100111
          Register@R168 Register@R169 CASInteger@"32" -> 0b0_10101000
          Register@R169 Register@R170 CASInteger@"32" -> 0b0_10101001
          Register@R170 Register@R171 CASInteger@"32" -> 0b0_10101010
          Register@R171 Register@R172 CASInteger@"32" -> 0b0_10101011
          Register@R172 Register@R173 CASInteger@"32" -> 0b0_10101100
          Register@R173 Register@R174 CASInteger@"32" -> 0b0_10101101
          Register@R174 Register@R175 CASInteger@"32" -> 0b0_10101110
          Register@R175 Register@R176 CASInteger@"32" -> 0b0_10101111
          Register@R176 Register@R177 CASInteger@"32" -> 0b0_10110000
          Register@R177 Register@R178 CASInteger@"32" -> 0b0_10110001
          Register@R178 Register@R179 CASInteger@"32" -> 0b0_10110010
          Register@R179 Register@R180 CASInteger@"32" -> 0b0_10110011
          Register@R180 Register@R181 CASInteger@"32" -> 0b0_10110100
          Register@R181 Register@R182 CASInteger@"32" -> 0b0_10110101
          Register@R182 Register@R183 CASInteger@"32" -> 0b0_10110110
          Register@R183 Register@R184 CASInteger@"32" -> 0b0_10110111
          Register@R184 Register@R185 CASInteger@"32" -> 0b0_10111000
          Register@R185 Register@R186 CASInteger@"32" -> 0b0_10111001
          Register@R186 Register@R187 CASInteger@"32" -> 0b0_10111010
          Register@R187 Register@R188 CASInteger@"32" -> 0b0_10111011
          Register@R188 Register@R189 CASInteger@"32" -> 0b0_10111100
          Register@R189 Register@R190 CASInteger@"32" -> 0b0_10111101
          Register@R190 Register@R191 CASInteger@"32" -> 0b0_10111110
          Register@R191 Register@R192 CASInteger@"32" -> 0b0_10111111
          Register@R192 Register@R193 CASInteger@"32" -> 0b0_11000000
          Register@R193 Register@R194 CASInteger@"32" -> 0b0_11000001
          Register@R194 Register@R195 CASInteger@"32" -> 0b0_11000010
          Register@R195 Register@R196 CASInteger@"32" -> 0b0_11000011
          Register@R196 Register@R197 CASInteger@"32" -> 0b0_11000100
          Register@R197 Register@R198 CASInteger@"32" -> 0b0_11000101
          Register@R198 Register@R199 CASInteger@"32" -> 0b0_11000110
          Register@R199 Register@R200 CASInteger@"32" -> 0b0_11000111
          Register@R200 Register@R201 CASInteger@"32" -> 0b0_11001000
          Register@R201 Register@R202 CASInteger@"32" -> 0b0_11001001
          Register@R202 Register@R203 CASInteger@"32" -> 0b0_11001010
          Register@R203 Register@R204 CASInteger@"32" -> 0b0_11001011
          Register@R204 Register@R205 CASInteger@"32" -> 0b0_11001100
          Register@R205 Register@R206 CASInteger@"32" -> 0b0_11001101
          Register@R206 Register@R207 CASInteger@"32" -> 0b0_11001110
          Register@R207 Register@R208 CASInteger@"32" -> 0b0_11001111
          Register@R208 Register@R209 CASInteger@"32" -> 0b0_11010000
          Register@R209 Register@R210 CASInteger@"32" -> 0b0_11010001
          Register@R210 Register@R211 CASInteger@"32" -> 0b0_11010010
          Register@R211 Register@R212 CASInteger@"32" -> 0b0_11010011
          Register@R212 Register@R213 CASInteger@"32" -> 0b0_11010100
          Register@R213 Register@R214 CASInteger@"32" -> 0b0_11010101
          Register@R214 Register@R215 CASInteger@"32" -> 0b0_11010110
          Register@R215 Register@R216 CASInteger@"32" -> 0b0_11010111
          Register@R216 Register@R217 CASInteger@"32" -> 0b0_11011000
          Register@R217 Register@R218 CASInteger@"32" -> 0b0_11011001
          Register@R218 Register@R219 CASInteger@"32" -> 0b0_11011010
          Register@R219 Register@R220 CASInteger@"32" -> 0b0_11011011
          Register@R220 Register@R221 CASInteger@"32" -> 0b0_11011100
          Register@R221 Register@R222 CASInteger@"32" -> 0b0_11011101
          Register@R222 Register@R223 CASInteger@"32" -> 0b0_11011110
          Register@R223 Register@R224 CASInteger@"32" -> 0b0_11011111
          Register@R224 Register@R225 CASInteger@"32" -> 0b0_11100000
          Register@R225 Register@R226 CASInteger@"32" -> 0b0_11100001
          Register@R226 Register@R227 CASInteger@"32" -> 0b0_11100010
          Register@R227 Register@R228 CASInteger@"32" -> 0b0_11100011
          Register@R228 Register@R229 CASInteger@"32" -> 0b0_11100100
          Register@R229 Register@R230 CASInteger@"32" -> 0b0_11100101
          Register@R230 Register@R231 CASInteger@"32" -> 0b0_11100110
          Register@R231 Register@R232 CASInteger@"32" -> 0b0_11100111
          Register@R232 Register@R233 CASInteger@"32" -> 0b0_11101000
          Register@R233 Register@R234 CASInteger@"32" -> 0b0_11101001
          Register@R234 Register@R235 CASInteger@"32" -> 0b0_11101010
          Register@R235 Register@R236 CASInteger@"32" -> 0b0_11101011
          Register@R236 Register@R237 CASInteger@"32" -> 0b0_11101100
          Register@R237 Register@R238 CASInteger@"32" -> 0b0_11101101
          Register@R238 Register@R239 CASInteger@"32" -> 0b0_11101110
          Register@R239 Register@R240 CASInteger@"32" -> 0b0_11101111
          Register@R240 Register@R241 CASInteger@"32" -> 0b0_11110000
          Register@R241 Register@R242 CASInteger@"32" -> 0b0_11110001
          Register@R242 Register@R243 CASInteger@"32" -> 0b0_11110010
          Register@R243 Register@R244 CASInteger@"32" -> 0b0_11110011
          Register@R244 Register@R245 CASInteger@"32" -> 0b0_11110100
          Register@R245 Register@R246 CASInteger@"32" -> 0b0_11110101
          Register@R246 Register@R247 CASInteger@"32" -> 0b0_11110110
          Register@R247 248 CASInteger@"32" -> 0b0_11110111
          248 249 CASInteger@"32" -> 0b0_11111000
          249 250 CASInteger@"32" -> 0b0_11111001
          250 251 CASInteger@"32" -> 0b0_11111010
          251 252 CASInteger@"32" -> 0b0_11111011
          252 253 CASInteger@"32" -> 0b0_11111100
          253 254 CASInteger@"32" -> 0b0_11111101
          254 Register@RZ CASInteger@"32" -> 0b0_11111110
          Register@RZ Register@RZ CASInteger@"32" -> 0b0_11111111
          Register@R0 Register@R2 CASInteger@"64" -> 0b1_00000000
          Register@R1 Register@R3 CASInteger@"64" -> 0b1_00000001
          Register@R2 Register@R4 CASInteger@"64" -> 0b1_00000010
          Register@R3 Register@R5 CASInteger@"64" -> 0b1_00000011
          Register@R4 Register@R6 CASInteger@"64" -> 0b1_00000100
          Register@R5 Register@R7 CASInteger@"64" -> 0b1_00000101
          Register@R6 Register@R8 CASInteger@"64" -> 0b1_00000110
          Register@R7 Register@R9 CASInteger@"64" -> 0b1_00000111
          Register@R8 Register@R10 CASInteger@"64" -> 0b1_00001000
          Register@R9 Register@R11 CASInteger@"64" -> 0b1_00001001
          Register@R10 Register@R12 CASInteger@"64" -> 0b1_00001010
          Register@R11 Register@R13 CASInteger@"64" -> 0b1_00001011
          Register@R12 Register@R14 CASInteger@"64" -> 0b1_00001100
          Register@R13 Register@R15 CASInteger@"64" -> 0b1_00001101
          Register@R14 Register@R16 CASInteger@"64" -> 0b1_00001110
          Register@R15 Register@R17 CASInteger@"64" -> 0b1_00001111
          Register@R16 Register@R18 CASInteger@"64" -> 0b1_00010000
          Register@R17 Register@R19 CASInteger@"64" -> 0b1_00010001
          Register@R18 Register@R20 CASInteger@"64" -> 0b1_00010010
          Register@R19 Register@R21 CASInteger@"64" -> 0b1_00010011
          Register@R20 Register@R22 CASInteger@"64" -> 0b1_00010100
          Register@R21 Register@R23 CASInteger@"64" -> 0b1_00010101
          Register@R22 Register@R24 CASInteger@"64" -> 0b1_00010110
          Register@R23 Register@R25 CASInteger@"64" -> 0b1_00010111
          Register@R24 Register@R26 CASInteger@"64" -> 0b1_00011000
          Register@R25 Register@R27 CASInteger@"64" -> 0b1_00011001
          Register@R26 Register@R28 CASInteger@"64" -> 0b1_00011010
          Register@R27 Register@R29 CASInteger@"64" -> 0b1_00011011
          Register@R28 Register@R30 CASInteger@"64" -> 0b1_00011100
          Register@R29 Register@R31 CASInteger@"64" -> 0b1_00011101
          Register@R30 Register@R32 CASInteger@"64" -> 0b1_00011110
          Register@R31 Register@R33 CASInteger@"64" -> 0b1_00011111
          Register@R32 Register@R34 CASInteger@"64" -> 0b1_00100000
          Register@R33 Register@R35 CASInteger@"64" -> 0b1_00100001
          Register@R34 Register@R36 CASInteger@"64" -> 0b1_00100010
          Register@R35 Register@R37 CASInteger@"64" -> 0b1_00100011
          Register@R36 Register@R38 CASInteger@"64" -> 0b1_00100100
          Register@R37 Register@R39 CASInteger@"64" -> 0b1_00100101
          Register@R38 Register@R40 CASInteger@"64" -> 0b1_00100110
          Register@R39 Register@R41 CASInteger@"64" -> 0b1_00100111
          Register@R40 Register@R42 CASInteger@"64" -> 0b1_00101000
          Register@R41 Register@R43 CASInteger@"64" -> 0b1_00101001
          Register@R42 Register@R44 CASInteger@"64" -> 0b1_00101010
          Register@R43 Register@R45 CASInteger@"64" -> 0b1_00101011
          Register@R44 Register@R46 CASInteger@"64" -> 0b1_00101100
          Register@R45 Register@R47 CASInteger@"64" -> 0b1_00101101
          Register@R46 Register@R48 CASInteger@"64" -> 0b1_00101110
          Register@R47 Register@R49 CASInteger@"64" -> 0b1_00101111
          Register@R48 Register@R50 CASInteger@"64" -> 0b1_00110000
          Register@R49 Register@R51 CASInteger@"64" -> 0b1_00110001
          Register@R50 Register@R52 CASInteger@"64" -> 0b1_00110010
          Register@R51 Register@R53 CASInteger@"64" -> 0b1_00110011
          Register@R52 Register@R54 CASInteger@"64" -> 0b1_00110100
          Register@R53 Register@R55 CASInteger@"64" -> 0b1_00110101
          Register@R54 Register@R56 CASInteger@"64" -> 0b1_00110110
          Register@R55 Register@R57 CASInteger@"64" -> 0b1_00110111
          Register@R56 Register@R58 CASInteger@"64" -> 0b1_00111000
          Register@R57 Register@R59 CASInteger@"64" -> 0b1_00111001
          Register@R58 Register@R60 CASInteger@"64" -> 0b1_00111010
          Register@R59 Register@R61 CASInteger@"64" -> 0b1_00111011
          Register@R60 Register@R62 CASInteger@"64" -> 0b1_00111100
          Register@R61 Register@R63 CASInteger@"64" -> 0b1_00111101
          Register@R62 Register@R64 CASInteger@"64" -> 0b1_00111110
          Register@R63 Register@R65 CASInteger@"64" -> 0b1_00111111
          Register@R64 Register@R66 CASInteger@"64" -> 0b1_01000000
          Register@R65 Register@R67 CASInteger@"64" -> 0b1_01000001
          Register@R66 Register@R68 CASInteger@"64" -> 0b1_01000010
          Register@R67 Register@R69 CASInteger@"64" -> 0b1_01000011
          Register@R68 Register@R70 CASInteger@"64" -> 0b1_01000100
          Register@R69 Register@R71 CASInteger@"64" -> 0b1_01000101
          Register@R70 Register@R72 CASInteger@"64" -> 0b1_01000110
          Register@R71 Register@R73 CASInteger@"64" -> 0b1_01000111
          Register@R72 Register@R74 CASInteger@"64" -> 0b1_01001000
          Register@R73 Register@R75 CASInteger@"64" -> 0b1_01001001
          Register@R74 Register@R76 CASInteger@"64" -> 0b1_01001010
          Register@R75 Register@R77 CASInteger@"64" -> 0b1_01001011
          Register@R76 Register@R78 CASInteger@"64" -> 0b1_01001100
          Register@R77 Register@R79 CASInteger@"64" -> 0b1_01001101
          Register@R78 Register@R80 CASInteger@"64" -> 0b1_01001110
          Register@R79 Register@R81 CASInteger@"64" -> 0b1_01001111
          Register@R80 Register@R82 CASInteger@"64" -> 0b1_01010000
          Register@R81 Register@R83 CASInteger@"64" -> 0b1_01010001
          Register@R82 Register@R84 CASInteger@"64" -> 0b1_01010010
          Register@R83 Register@R85 CASInteger@"64" -> 0b1_01010011
          Register@R84 Register@R86 CASInteger@"64" -> 0b1_01010100
          Register@R85 Register@R87 CASInteger@"64" -> 0b1_01010101
          Register@R86 Register@R88 CASInteger@"64" -> 0b1_01010110
          Register@R87 Register@R89 CASInteger@"64" -> 0b1_01010111
          Register@R88 Register@R90 CASInteger@"64" -> 0b1_01011000
          Register@R89 Register@R91 CASInteger@"64" -> 0b1_01011001
          Register@R90 Register@R92 CASInteger@"64" -> 0b1_01011010
          Register@R91 Register@R93 CASInteger@"64" -> 0b1_01011011
          Register@R92 Register@R94 CASInteger@"64" -> 0b1_01011100
          Register@R93 Register@R95 CASInteger@"64" -> 0b1_01011101
          Register@R94 Register@R96 CASInteger@"64" -> 0b1_01011110
          Register@R95 Register@R97 CASInteger@"64" -> 0b1_01011111
          Register@R96 Register@R98 CASInteger@"64" -> 0b1_01100000
          Register@R97 Register@R99 CASInteger@"64" -> 0b1_01100001
          Register@R98 Register@R100 CASInteger@"64" -> 0b1_01100010
          Register@R99 Register@R101 CASInteger@"64" -> 0b1_01100011
          Register@R100 Register@R102 CASInteger@"64" -> 0b1_01100100
          Register@R101 Register@R103 CASInteger@"64" -> 0b1_01100101
          Register@R102 Register@R104 CASInteger@"64" -> 0b1_01100110
          Register@R103 Register@R105 CASInteger@"64" -> 0b1_01100111
          Register@R104 Register@R106 CASInteger@"64" -> 0b1_01101000
          Register@R105 Register@R107 CASInteger@"64" -> 0b1_01101001
          Register@R106 Register@R108 CASInteger@"64" -> 0b1_01101010
          Register@R107 Register@R109 CASInteger@"64" -> 0b1_01101011
          Register@R108 Register@R110 CASInteger@"64" -> 0b1_01101100
          Register@R109 Register@R111 CASInteger@"64" -> 0b1_01101101
          Register@R110 Register@R112 CASInteger@"64" -> 0b1_01101110
          Register@R111 Register@R113 CASInteger@"64" -> 0b1_01101111
          Register@R112 Register@R114 CASInteger@"64" -> 0b1_01110000
          Register@R113 Register@R115 CASInteger@"64" -> 0b1_01110001
          Register@R114 Register@R116 CASInteger@"64" -> 0b1_01110010
          Register@R115 Register@R117 CASInteger@"64" -> 0b1_01110011
          Register@R116 Register@R118 CASInteger@"64" -> 0b1_01110100
          Register@R117 Register@R119 CASInteger@"64" -> 0b1_01110101
          Register@R118 Register@R120 CASInteger@"64" -> 0b1_01110110
          Register@R119 Register@R121 CASInteger@"64" -> 0b1_01110111
          Register@R120 Register@R122 CASInteger@"64" -> 0b1_01111000
          Register@R121 Register@R123 CASInteger@"64" -> 0b1_01111001
          Register@R122 Register@R124 CASInteger@"64" -> 0b1_01111010
          Register@R123 Register@R125 CASInteger@"64" -> 0b1_01111011
          Register@R124 Register@R126 CASInteger@"64" -> 0b1_01111100
          Register@R125 Register@R127 CASInteger@"64" -> 0b1_01111101
          Register@R126 Register@R128 CASInteger@"64" -> 0b1_01111110
          Register@R127 Register@R129 CASInteger@"64" -> 0b1_01111111
          Register@R128 Register@R130 CASInteger@"64" -> 0b1_10000000
          Register@R129 Register@R131 CASInteger@"64" -> 0b1_10000001
          Register@R130 Register@R132 CASInteger@"64" -> 0b1_10000010
          Register@R131 Register@R133 CASInteger@"64" -> 0b1_10000011
          Register@R132 Register@R134 CASInteger@"64" -> 0b1_10000100
          Register@R133 Register@R135 CASInteger@"64" -> 0b1_10000101
          Register@R134 Register@R136 CASInteger@"64" -> 0b1_10000110
          Register@R135 Register@R137 CASInteger@"64" -> 0b1_10000111
          Register@R136 Register@R138 CASInteger@"64" -> 0b1_10001000
          Register@R137 Register@R139 CASInteger@"64" -> 0b1_10001001
          Register@R138 Register@R140 CASInteger@"64" -> 0b1_10001010
          Register@R139 Register@R141 CASInteger@"64" -> 0b1_10001011
          Register@R140 Register@R142 CASInteger@"64" -> 0b1_10001100
          Register@R141 Register@R143 CASInteger@"64" -> 0b1_10001101
          Register@R142 Register@R144 CASInteger@"64" -> 0b1_10001110
          Register@R143 Register@R145 CASInteger@"64" -> 0b1_10001111
          Register@R144 Register@R146 CASInteger@"64" -> 0b1_10010000
          Register@R145 Register@R147 CASInteger@"64" -> 0b1_10010001
          Register@R146 Register@R148 CASInteger@"64" -> 0b1_10010010
          Register@R147 Register@R149 CASInteger@"64" -> 0b1_10010011
          Register@R148 Register@R150 CASInteger@"64" -> 0b1_10010100
          Register@R149 Register@R151 CASInteger@"64" -> 0b1_10010101
          Register@R150 Register@R152 CASInteger@"64" -> 0b1_10010110
          Register@R151 Register@R153 CASInteger@"64" -> 0b1_10010111
          Register@R152 Register@R154 CASInteger@"64" -> 0b1_10011000
          Register@R153 Register@R155 CASInteger@"64" -> 0b1_10011001
          Register@R154 Register@R156 CASInteger@"64" -> 0b1_10011010
          Register@R155 Register@R157 CASInteger@"64" -> 0b1_10011011
          Register@R156 Register@R158 CASInteger@"64" -> 0b1_10011100
          Register@R157 Register@R159 CASInteger@"64" -> 0b1_10011101
          Register@R158 Register@R160 CASInteger@"64" -> 0b1_10011110
          Register@R159 Register@R161 CASInteger@"64" -> 0b1_10011111
          Register@R160 Register@R162 CASInteger@"64" -> 0b1_10100000
          Register@R161 Register@R163 CASInteger@"64" -> 0b1_10100001
          Register@R162 Register@R164 CASInteger@"64" -> 0b1_10100010
          Register@R163 Register@R165 CASInteger@"64" -> 0b1_10100011
          Register@R164 Register@R166 CASInteger@"64" -> 0b1_10100100
          Register@R165 Register@R167 CASInteger@"64" -> 0b1_10100101
          Register@R166 Register@R168 CASInteger@"64" -> 0b1_10100110
          Register@R167 Register@R169 CASInteger@"64" -> 0b1_10100111
          Register@R168 Register@R170 CASInteger@"64" -> 0b1_10101000
          Register@R169 Register@R171 CASInteger@"64" -> 0b1_10101001
          Register@R170 Register@R172 CASInteger@"64" -> 0b1_10101010
          Register@R171 Register@R173 CASInteger@"64" -> 0b1_10101011
          Register@R172 Register@R174 CASInteger@"64" -> 0b1_10101100
          Register@R173 Register@R175 CASInteger@"64" -> 0b1_10101101
          Register@R174 Register@R176 CASInteger@"64" -> 0b1_10101110
          Register@R175 Register@R177 CASInteger@"64" -> 0b1_10101111
          Register@R176 Register@R178 CASInteger@"64" -> 0b1_10110000
          Register@R177 Register@R179 CASInteger@"64" -> 0b1_10110001
          Register@R178 Register@R180 CASInteger@"64" -> 0b1_10110010
          Register@R179 Register@R181 CASInteger@"64" -> 0b1_10110011
          Register@R180 Register@R182 CASInteger@"64" -> 0b1_10110100
          Register@R181 Register@R183 CASInteger@"64" -> 0b1_10110101
          Register@R182 Register@R184 CASInteger@"64" -> 0b1_10110110
          Register@R183 Register@R185 CASInteger@"64" -> 0b1_10110111
          Register@R184 Register@R186 CASInteger@"64" -> 0b1_10111000
          Register@R185 Register@R187 CASInteger@"64" -> 0b1_10111001
          Register@R186 Register@R188 CASInteger@"64" -> 0b1_10111010
          Register@R187 Register@R189 CASInteger@"64" -> 0b1_10111011
          Register@R188 Register@R190 CASInteger@"64" -> 0b1_10111100
          Register@R189 Register@R191 CASInteger@"64" -> 0b1_10111101
          Register@R190 Register@R192 CASInteger@"64" -> 0b1_10111110
          Register@R191 Register@R193 CASInteger@"64" -> 0b1_10111111
          Register@R192 Register@R194 CASInteger@"64" -> 0b1_11000000
          Register@R193 Register@R195 CASInteger@"64" -> 0b1_11000001
          Register@R194 Register@R196 CASInteger@"64" -> 0b1_11000010
          Register@R195 Register@R197 CASInteger@"64" -> 0b1_11000011
          Register@R196 Register@R198 CASInteger@"64" -> 0b1_11000100
          Register@R197 Register@R199 CASInteger@"64" -> 0b1_11000101
          Register@R198 Register@R200 CASInteger@"64" -> 0b1_11000110
          Register@R199 Register@R201 CASInteger@"64" -> 0b1_11000111
          Register@R200 Register@R202 CASInteger@"64" -> 0b1_11001000
          Register@R201 Register@R203 CASInteger@"64" -> 0b1_11001001
          Register@R202 Register@R204 CASInteger@"64" -> 0b1_11001010
          Register@R203 Register@R205 CASInteger@"64" -> 0b1_11001011
          Register@R204 Register@R206 CASInteger@"64" -> 0b1_11001100
          Register@R205 Register@R207 CASInteger@"64" -> 0b1_11001101
          Register@R206 Register@R208 CASInteger@"64" -> 0b1_11001110
          Register@R207 Register@R209 CASInteger@"64" -> 0b1_11001111
          Register@R208 Register@R210 CASInteger@"64" -> 0b1_11010000
          Register@R209 Register@R211 CASInteger@"64" -> 0b1_11010001
          Register@R210 Register@R212 CASInteger@"64" -> 0b1_11010010
          Register@R211 Register@R213 CASInteger@"64" -> 0b1_11010011
          Register@R212 Register@R214 CASInteger@"64" -> 0b1_11010100
          Register@R213 Register@R215 CASInteger@"64" -> 0b1_11010101
          Register@R214 Register@R216 CASInteger@"64" -> 0b1_11010110
          Register@R215 Register@R217 CASInteger@"64" -> 0b1_11010111
          Register@R216 Register@R218 CASInteger@"64" -> 0b1_11011000
          Register@R217 Register@R219 CASInteger@"64" -> 0b1_11011001
          Register@R218 Register@R220 CASInteger@"64" -> 0b1_11011010
          Register@R219 Register@R221 CASInteger@"64" -> 0b1_11011011
          Register@R220 Register@R222 CASInteger@"64" -> 0b1_11011100
          Register@R221 Register@R223 CASInteger@"64" -> 0b1_11011101
          Register@R222 Register@R224 CASInteger@"64" -> 0b1_11011110
          Register@R223 Register@R225 CASInteger@"64" -> 0b1_11011111
          Register@R224 Register@R226 CASInteger@"64" -> 0b1_11100000
          Register@R225 Register@R227 CASInteger@"64" -> 0b1_11100001
          Register@R226 Register@R228 CASInteger@"64" -> 0b1_11100010
          Register@R227 Register@R229 CASInteger@"64" -> 0b1_11100011
          Register@R228 Register@R230 CASInteger@"64" -> 0b1_11100100
          Register@R229 Register@R231 CASInteger@"64" -> 0b1_11100101
          Register@R230 Register@R232 CASInteger@"64" -> 0b1_11100110
          Register@R231 Register@R233 CASInteger@"64" -> 0b1_11100111
          Register@R232 Register@R234 CASInteger@"64" -> 0b1_11101000
          Register@R233 Register@R235 CASInteger@"64" -> 0b1_11101001
          Register@R234 Register@R236 CASInteger@"64" -> 0b1_11101010
          Register@R235 Register@R237 CASInteger@"64" -> 0b1_11101011
          Register@R236 Register@R238 CASInteger@"64" -> 0b1_11101100
          Register@R237 Register@R239 CASInteger@"64" -> 0b1_11101101
          Register@R238 Register@R240 CASInteger@"64" -> 0b1_11101110
          Register@R239 Register@R241 CASInteger@"64" -> 0b1_11101111
          Register@R240 Register@R242 CASInteger@"64" -> 0b1_11110000
          Register@R241 Register@R243 CASInteger@"64" -> 0b1_11110001
          Register@R242 Register@R244 CASInteger@"64" -> 0b1_11110010
          Register@R243 Register@R245 CASInteger@"64" -> 0b1_11110011
          Register@R244 Register@R246 CASInteger@"64" -> 0b1_11110100
          Register@R245 Register@R247 CASInteger@"64" -> 0b1_11110101
          Register@R246 248 CASInteger@"64" -> 0b1_11110110
          Register@R247 249 CASInteger@"64" -> 0b1_11110111
          248 250 CASInteger@"64" -> 0b1_11111000
          249 251 CASInteger@"64" -> 0b1_11111001
          250 252 CASInteger@"64" -> 0b1_11111010
          251 253 CASInteger@"64" -> 0b1_11111011
          252 254 CASInteger@"64" -> 0b1_11111100
          253 Register@RZ CASInteger@"64" -> 0b1_11111101
          254 Register@RZ CASInteger@"64" -> 0b1_11111110
          Register@RZ Register@RZ CASInteger@"64" -> 0b1_11111111
          ;



    SM4vshlCW
          CWMode@C UInteger@U16 -> 0b0
          CWMode@C UInteger@U8 -> 0b0
          CWMode@C UInteger@U32 -> 0b0
          CWMode@W UInteger@U16 -> 0b1
          CWMode@W UInteger@U8 -> 0b1
          CWMode@W UInteger@U32 -> 0b1
          ;

OPERATION PROPERTIES
    IWIDTH
    ITYPE
    SPA
    SECONDARY
    TERTIARY
    BRANCH_TARGET_INDEX
    OPERATION_TYPE
    IMM_INDEX
    BRANCH_TYPE
    CC_INDEX
    SIDL_NAME
    ;

OPERATION PREDICATES
    ;

FUNIT uC
    ISSUE_SLOTS 0 1;
   ENCODING WIDTH 64;




  KeepRefCnt '........................................................X.......'
  CCC_1 '.........................................................XXXXX..'
  Imm32 '.........XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.......................'
  Sync '.........................................X......................'
  PredNot '..........................................X.....................'
  Pred '...........................................XXX..................'
  QuadMask '..................XXXX..........................................'
  QuadMask2 '..............................................XXXX..............'
  Dest '......................................................XXXXXXXX..'
  RegA '..............................................XXXXXXXX..........'
  RegB '.................................XXXXXXXX.......................'
  RegC '..............XXXXXXXX..........................................'

  RegBALD '..............XXXXXXXX..........................................'
  RegBAST '......................................................XXXXXXXX..'

  NODEP '................................X...............................'
  Phase '..............................XX................................'
  Wmsk '..........................XXXX..................................'
  ParamA '.......................XXX......................................'
  TOFF1 '......................X.........................................'
  TOFF1b '.........X......................................................'
  CL '.....................X..........................................'
  MS '....................X...........................................'
  LOD1 '...................X............................................'
  TidB '....XXXXXXXXXXXXX...............................................'
  TidBWmsk '....XXXXXXXXXXXXX.........XXXX..................................'
  TidBTEX '.........XXXXXXXX...............................................'
  TidBSAMP '....XXXXX.......................................................'
  TidB2 '......XXXXXXXXXXXXX.............................................'
  TidBWmsk2 '......XXXXXXXXXXXXX.......XXXX..................................'
  TidB3 '..........XXXXXXXXXXXXX.........................................'
  TidBTEX3 '...............XXXXXXXX.........................................'
  TidBSAMP3 '..........XXXXX.................................................'
  LOD '.................XXX............................................'
  AOFFI '....................X...........................................'
  DC '.....................X..........................................'
  NDV '......................X.........................................'
  NDVa '.................................X..............................'
  TexQuery '.................................XXXXXX.........................'
  STPMode '.............................X..................................'

  TexComp '.................XX.............................................'
  TOFF2 '...................XX...........................................'

  Sat '..........X.....................................................'
  PSign '...........XX...................................................'
  WriteCC '.............X..................................................'
  Xm '.................X..............................................'

  ALSize '............XX..................................................'
  AIO '............................X...................................'
  P '.............................X..................................'
  Imm10 '...............................XXXXXXXXXX.......................'
  Imm11 '..............................XXXXXXXXXXX.......................'
  msbImm11 '..............................X.................................'

  FMZ '......XX........................................................'
  Rnd '........XX......................................................'
  nC '...........X....................................................'
  nAB '............X...................................................'

  FMZLow '...............XX...............................................'
  ScaleLow '.................XXX............................................'
  RndLow '....................XX..........................................'

  SatLow '.............X..................................................'
  IPAOp '.........XX.....................................................'
  MSI '...........XX...................................................'
  IPAImm10 '.......................XXXXXXXXXX...............................'
  IPAImm11 '......................XXXXXXXXXXX...............................'




  nC2 '...X............................................................'
  nAB2 '....X...........................................................'
  SatHigh '.....X..........................................................'
  FMZHigh '......XX........................................................'
  WriteCCI '........X.......................................................'

  PSign2 '....XX..........................................................'
  Sat2 '......X.........................................................'
  Xm2 '.......X........................................................'

  MufuOp '.....................................XXXX.......................'

  BSigned '...................X............................................'
  ASigned '....................X...........................................'
  HILO '.....................X..........................................'

  BSigned2 '.....X..........................................................'
  ASigned2 '......X.........................................................'
  HILO2 '.......X........................................................'

  BSigned4 '...X............................................................'

  Imm24sh '......XXXXXXXXXXXXXXXXXXXXXXXX..................................'
  Imm32sh '..............................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..'
  Imm4n '......XXXX......................................................'
  Imm4m '..........XXXX..................................................'
  Imm4l '..............XXXX..............................................'
  Imm4k '..................XXXX..........................................'
  Imm4j '......................XXXX......................................'
  Imm4i '..........................XXXX..................................'
  Imm4h '..............................XXXX..............................'
  Imm4g '..................................XXXX..........................'
  Imm4f '......................................XXXX......................'
  Imm4e '..........................................XXXX..................'
  Imm4d '..............................................XXXX..............'
  Imm4c '..................................................XXXX..........'
  Imm4b '......................................................XXXX......'
  Imm4a '..........................................................XXXX..'

  nA1 '............X...................................................'
  aA2 '..............X.................................................'
  nB2 '...............X................................................'
  FComp '.........XXXX...................................................'
  nA2 '.................X..............................................'
  aB2 '................X...............................................'
  aA3 '......X.........................................................'
  nB3 '.......X........................................................'
  aA4 '......................................................X.........'
  nB4 '.......................................................X........'
  FTZ '................X...............................................'
  FTZ2 '.............X..................................................'
  FTZ3 '.....X..........................................................'
  SrcNot '..................X.............................................'
  SrcPred '...................XXX..........................................'
  Src1Not '............................X...................................'
  Src1Pred '.............................XXX................................'
  Src2Not '..............................................X.................'
  Src2Pred '...............................................XXX..............'
  PDest '........................................................XXX.....'
  PNDest '...........................................................XXX..'

  nA3 '.................X..............................................'
  BVal '................X...............................................'
  BVal1 '........X.......................................................'

  SReg '.................................XXXXXXXX.......................'

  COP '...XX...........................................................'
  COP1 '........XX......................................................'
  LSSize '.....XXX........................................................'
  Rf '......XX........................................................'
  E '........X.......................................................'

  AdMode '...............XX...............................................'
  LSSize2 '..........XXX...................................................'
  COP2 '...............XX...............................................'

  SABCExt '......XXXXXXX...................................................'
  SBExt '......XX........................................................'
  SCExt '........XX......................................................'
  SAExt '..........XXX...................................................'
  AtomOp '.....XXXX.......................................................'
  AtomSize '.........XXX....................................................'
  bcRZ '.........XX.....................................................'
  AtomSize1 '...........X....................................................'
  Size1RegBC '...........X.....................XXXXXXXX.......................'
  AtomE '............X...................................................'
  Imm20a '.............XXXXXXXXXXXXXXXXXXXX...............................'

  Imm20 '.....................XXXXXXXXXXXXXXXXXXXX.......................'
  Bpt '.....................................................XXX........'

  Imm5I '.................XXXXX..........................................'
  Imm5Ib '...XXXXX........................................................'

  CA '........................................................X.......'
  LMT '.......................................................X........'
  INC '.......................................................X........'
  U '......................................................X.........'
  Imm24 '.................XXXXXXXXXXXXXXXXXXXXXXXX.......................'
  CBank '....................XXXXX.......................................'
  Imm16 '.........................XXXXXXXXXXXXXXXX.......................'
  Imm16b '..............................................XXXXXXXXXXXXXXXX..'

  IComp '.........XXX....................................................'
  Signed '............X...................................................'
  Bop '..............XX................................................'
  Bop0 '...................................XX...........................'

  PixMode '...........................XXX..................................'
  Imm8 '.................................XXXXXXXX.......................'




  LOP '..................XX............................................'
  nB_L '....................X...........................................'
  nA_L '.....................X..........................................'

  M_H '..........X.....................................................'
  XmdSHF '...........XX...................................................'
  MaxShift '......................XX........................................'
  Imm06_shf '...................................XXXXXX.......................'

  M '.....................X..........................................'
  XMode '................XX..............................................'
  Brev '....................X...........................................'

  Xm_I '...X............................................................'
  nB_L2 '....X...........................................................'
  nA_L2 '.....X..........................................................'
  LOP_I '......XX........................................................'

  Imm06Tex '...................................XXXXXX.......................'

  HILO3 '......X.........................................................'
  BSigned3 '.......X........................................................'
  PSign3 '........XX......................................................'
  Xm3 '...........X....................................................'
  ASigned3 '............X...................................................'

  aB '...........X....................................................'
  nB '...............X................................................'
  By '..................XX............................................'
  ISrcFmt '................................................X.XX............'
  DstFmt '....................................................XX..........'

  H1H0a '.....................X..........................................'

  OutType '....................XX..........................................'

  VMode '...........XX...................................................'
  Imm28 '.............XXXXXXXXXXXXXXXXXXXXXXXXXXXX.......................'
  VPDest '.............XXX................................................'

  MembarL '....................................................XX..........'

  AFix_BAR '................X...............................................'
  BFix_BAR '.................X..............................................'
  BarRedOp '........................XX......................................'
  BarOp '..........................XXX...................................'
  BarFiller '.............................XXXX...............................'
  Imm12 '.............................XXXXXXXXXXXX.......................'

  Trig '................................................X...............'
  Trig2 '........................................X.......................'
  CCC_2 '.................................................XXXXX..........'

  SrcDstFmt '..................................................XXXX..........'
  IR '..................X.............................................'
  IRRnd '..................X.XX..........................................'
  Rnd_1 '....................XX..........................................'
  SH '...................X............................................'

  IDstFmt '.................................................X..XX..........'
  SrcFmt '..................................................XX............'
  SrcFmt2 '................................................X.XX............'

  PMode '.........XXXX...................................................'
  RROOp '.....................X..........................................'

  Barmd '...........................XX...................................'
  DstPred '.............XXX................................................'
  BarName '.............................XXXX...............................'

  Imm13 '..............XXXXXXXXXXXXX.....................................'
  PredDest '..........XXX...................................................'
  SHFLFiller '......................XXXXX.....................................'
  Shflmd '.............................XX.................................'
  CFix_SHFL '...............................X................................'
  BFix_SHFL '................................X...............................'
  shfl_imm5 '....................................XXXXX.......................'
  bit6_RegB '.................................XXX............................'

  RTTOp '............................................................XX..'




  Imm22a '.................XXXXXXXXXXXXXXXXXXXXXX.........................'
  Cache '........................................................XX......'
  CCTLOp '..........................................................XXXX..'
  Imm30a '.........XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.........................'
  Cache3 '.......................................................XXX......'

  SWZMode '.................XXX............................................'
  PNWord '.........................XXXXXXXX...............................'

  SUPDest '..........XXX...................................................'
  BDim '.............X..................................................'

  BDim2 '.......X........................................................'
  SMode '........XXXX....................................................'
  Imm06 '................XXXXXX..........................................'

  Rnd3 '.........XX.....................................................'
  CMode '......................................................XX........'
  ChkModeF '................XXXXXX..........................................'

  DI '........................................................X.......'





  Ofmt '..........XX....................................................'
  RGBAb '............XXXX................................................'
  Clamp '................XX..............................................'
  LSSize3 '............................XXX.................................'
  Rf3 '.............................XX.................................'

  COP3 '...............................XX...............................'
  Ofmt2 '.................................XX.............................'
  RGBAa '...................................XXXX.........................'
  Clamp2 '.......................................XX.......................'

  SrcNotSU '..........X.....................................................'
  SrcPredSU '...........XXX..................................................'
  Ofmt3 '......................................................XX........'
  RGBAc '........................................................XXXX....'
  Clamp3 '............................................................XX..'

  DFormat '......................X.........................................'
  DFormat2 '......X.........................................................'
  safmt '............X...................................................'
  sbfmt '...........X....................................................'
  sbfmt2 '.....X..........................................................'
  sbfmt3 '.......X........................................................'
  VRed '......XX........................................................'
  VRed2 '...........XX...................................................'
  LaneMask4 '........XX.............XX.......................................'
  asel4 '.........................XXXX...................................'
  bsel4 '.............................XXXX...............................'
  AVGMode '....XX..........................................................'
  AVGMode2 '...XX...........................................................'
  AVGMode3 '......XX........................................................'
  MN '.....X..........................................................'
  MN2 '....X...........................................................'
  VComp '..........XXX...................................................'
  VComp2 '....XXX.........................................................'
  VComp3 '.............X..XX..............................................'
  VRed3 '..............XX................................................'
  LaneMask4b '................XX.....XX.......................................'
  BFiller2 '...............................XX...............................'
  LaneMask2 '........XX......................................................'
  LaneMask2b '................XX..............................................'
  asel2 '.......................XXXX.....................................'
  bsel2 '...........................XXXX.................................'
  asel2hi '.......................XX.......................................'
  BVideo '..........X.....................................................'
  aSelect '............X.........XXX.......................................'
  bSelect '...........X..................XXX...............................'
  bSelectU '..............................XXX...............................'
  BFiller3 '.........................XXXXX..................................'
  VOP '.......XXX......................................................'
  MV '...........X....................................................'
  VScale '........XX......................................................'
  Sat3 '.........X......................................................'

  Bconst '....X.................XXXXXXXXXXXXXXXXXXX.......................'
  Bcbank '......................XXXXX.....................................'
  Bcaddr '...........................XXXXXXXXXXXXXX.......................'
  BFiller '......................XXXXXXXXXXX...............................'
  Canvas32 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX................................'
  Opcode32 'XXX...........................................................XX'
  Opcode42 'XXXX..........................................................XX'
  Opcode52 'XXXXX.........................................................XX'
  Opcode362 'XXXXXXXXX.....................................................XX'
  Opcode542 'XXXXXXXXX.....................................................XX'
  Opcode532 'XXXXXXXX......................................................XX'
  Opcode512 'XXXXXX........................................................XX'
  Opcode552 'XXXXXXXXXX....................................................XX'

  Opcode352_N '................................XXXXXXXX......................XX'

  SubOpcodeX5X '.....XXXXX......................................................'
  SubOpcodeX4X '.....XXXX.......................................................'
  SubOpcodeX1X '.....X..........................................................'
  SubOpcodeX2X '.....XX.........................................................'
  Opcode2X2 'XX............................................................XX'
  ABCOpcodeX3X_1 '..XXX...........................................................'
  Opcode1X2 'X.............................................................XX'
  ABCOpcodeX3X_2 '.XXX............................................................'




  NencMOV32I '..................................................XXXX..........'
  NencMOV '..........XXXXXXXX............................XXXXXXXX..........'
  NencEXIT '.........XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXXXXXXXXX........'
  NencIADD '..............XXX.XXXX..........................................'
  NencISCADD '..........X...XXX...............................................'
  NencPOPC '..........XXXXXXXXXX............................................'
  NencTLDB '..........XXXXXXXXX.............................................'
  NencTEXB '..........XXXXXXX...............................................'
  NencALD '..........XX..........XXXXXX....................................'
  NencFMUL '...........X..X.................................................'
  NencMUFU '...........X.X.XXXXXXXXXXXXXXXXXXXXXX...........................'
  NencIMUL '..........XXX.XXXXX.............................................'
  NencSHINT '.....X..........................................................'
  NencS2R '..........XXXXXXXXXXXXXXXXXXXXXXX.............XXXXXXXX..........'
  NencBRA '.........XXXXXXXX...............................................'
  NencISETP '.............X..X.....................................XX........'
  NencPSETP '..........XXXX..XX....XXXXXX....XXX..XXXX.........XXXXXX........'
  NencPSET '..........XXX....X....XXXXXX....XXX..XXXX.........XXXX..........'
  NencCSETP '..........XXXX..XX....XXXXXXXXXXXXXXXXXXX.....XXX.....XX........'
  NencCSET '..........XXX....X....XXXXXXXXXXXXXXXXXXX.....XXX...............'
  NencVSETP '......................................................XX........'
  NencLOP '..........XXX.XXX...............................................'
  NencSHL '..........XXX.XXX.XXX...........................................'
  NencSHR '..........XX..XX..XX............................................'
  NencP2R '..........XXXXXXXXXXX...........................................'
  NencTEXDEPBAR '..........XXXXXXXXXXXXXXXXXXXXXXXXX...........XXXXXXXXXXXXXXXX..'
  NencSEL '..........XXXXXXXX..............................................'
  NencOUT '..........XXXXXXXXXX............................................'
  NencI2F '..........X.X.X.XX............................XX.X..............'
  NencMEMBAR '..........XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.....XXXXXX..XXXXXXXX..'
  NencBAR2 '..........XXXXXXXX....XX........................................'
  NencBAR '..........XXXXXX......XX........................................'
  NencCCTLL '..........XXXXXXX......................XX.............XX........'
  NencCCTL '.......................................XX.............X.........'
  NencNOP '..........XXXXXXXXXXXXXXX.....................XX......XXXXXXXX..'
  NencF2F '............X.X..X............................XXXX..............'
  NencF2I '..........X.X.X..XX...........................XXX...............'
  NencJMP '.........XXXXXXXXXXX............................................'
  NencFSWZ '..........XXX.XX.......XX.......................................'
  NencVOTEVTG '..........X...................................XXXXXXXXXXXXXXXX..'
  NencVOTE '..........X.....XX....XXXXXXXXXXXXXXXXXXX.....XXXXXXXX..........'
  NencSULDGA '......................XXXXXX....................................'
  NencBPT '.........XXXXXXXXXXXX....................XXXXXXXXXXXX...XXXXXX..'
  NencFLO '..........XX..XXXXX..X..........................................'
  NencI2I '............X.X.XX..XX........................XX................'
  NencB2R '..........XXX...XXXXXXXXXXX..XXXXXXXXXXXX.......................'
  NencRTT '.........XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....'
  NencSHFL '.............X.............XX...................................'
  NencPIXLD '..........XXX...XXXXXXXXXXX...XXX...............................'
  NencTXQ '.......................XXX.............XX.......................'
  NencTXA '.......................XXX........XXXXXXX.......................'
  NencTMML '..................................XXXXXXX.......................'
  NencTMMLB '..........XXXXXXXXXXXX..........................................'
  NencSTP '..........XXXXXXXXXXXXXXXXXXX...X.............XXXXXXXXXXXXXXXX..'
  NencCRSLMEM '.........XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..................'
  NencLDC '.............XX..XXX............................................'
  NencBFE '..........XX..XXXXXX.X..........................................'
  NencBFI '..........XXX...................................................'
  NencR2B '..........XXXXXXXXXXXXXXXXX.....................................'
  NencVILD '..........XXXXXXXXXXXXXXXXXXXXXXX...............................'
  NencIDE '.........XXXXXXXXXXXXXXXX................XXXXXXXXXXXXXXX.XXXXX..'
  NencSHF '....X...................XXXXXXXXXXX.............................'
  NencSHF2 '........................XXXXXXXXX...............................'




ALL 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'

NOP_ENCODING
  ALL = 0x85800000001c3c02;
CLASS "SHINT"
    FORMAT Opcode UImm(24):uImmMsb ',' UImm(32):uImmLsb;

    OPCODES
        SHINTfe_pipe =  0b00001_00;
        SHINT =  0b00001_00;

    ENCODING
      Opcode52 = Opcode;
      Imm24sh = uImmMsb;
      Imm32sh = uImmLsb;

      !NencSHINT;



ALTERNATE CLASS "SHINT nibbles"
    FORMAT Opcode UImm(4):uImmA ',' UImm(4):uImmB ',' UImm(4):uImmC ',' UImm(4):uImmD ','
                  UImm(4):uImmE ',' UImm(4):uImmF ',' UImm(4):uImmG ',' UImm(4):uImmH ','
                  UImm(4):uImmI ',' UImm(4):uImmJ ',' UImm(4):uImmK ',' UImm(4):uImmL ','
                  UImm(4):uImmM ',' UImm(4):uImmN;

    OPCODES
        SHINTfe_pipe =  0b00001_00;
        SHINT =  0b00001_00;

    ENCODING
      Opcode52 = Opcode;
      Imm4a = uImmA;
      Imm4b = uImmB;
      Imm4c = uImmC;
      Imm4d = uImmD;
      Imm4e = uImmE;
      Imm4f = uImmF;
      Imm4g = uImmG;
      Imm4h = uImmH;
      Imm4i = uImmI;
      Imm4j = uImmJ;
      Imm4k = uImmK;
      Imm4l = uImmL;
      Imm4m = uImmM;
      Imm4n = uImmN;

      !NencSHINT;



CLASS "NOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe(HW)@:pipe /S(noS):sync
                               { CC(CC):TestCC/Test(T):fcomp ',' } UImm(16/0):uImm;

    OPCODES
        NOPbru_pipe =  0b10000_10;
        NOP =  0b10000_10;

    ENCODING
      Opcode52 = Opcode;
      SubOpcodeX5X = 0b10110;
      Imm16 = uImm;
      PredNot = Pg@not;
      Pred = Pg;
      Trig = 0;
      CCC_2 = Test;

      !NencNOP;
      Sync=S;


CLASS "NOP trig"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Trig:trig /Pipe(HW)@:pipe /S(noS):sync
                               { CC(CC):TestCC/Test(T):fcomp ',' } UImm(16/0):uImm;

    CONDITIONS

        ERROR
            (sync == `S@noS):
                "NOP.TRIG.S is illegal"

    OPCODES
        NOPbru_pipe =  0b10000_10;
        NOP =  0b10000_10;

    ENCODING
      Opcode52 = Opcode;
      SubOpcodeX5X = 0b10110;
      Imm16 = uImm;
      PredNot = Pg@not;
      Pred = Pg;
      Trig = 1;
      CCC_2 = Test;

      !NencNOP;
      Sync=S;



 CLASS "LEPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync Register:Rd;

    OPCODES
        LEPCxlu_pipe =  0b10000_11010_10;
        LEPC =  0b10000_11010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      !Imm28;
      !LSSize2;
      !RegA;
      Sync=S;



 CLASS "POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' [~]Register:Ra ',' [~]Register:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        POPCfmaX_pipe =  0b100;
        POPC =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00001;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      nA_L = Ra@invert;
      nB_L = Rb@invert;
      Sync = S;

      !BFiller;
      !NencPOPC;
      Opcode2X2 = 0b11_10;



 CLASS "Imm POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' [~]Register:Ra ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        POPCfmaX_pipe =  0b100;
        POPC =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00001;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      nA_L = Ra@invert;
      nB_L = UnaryInv;
      Sync = S;


      !NencPOPC;
      Opcode1X2 = 0b1_01;



 CLASS "Const POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
Register:Rd ',' [~]Register:Ra ',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        POPCfmaX_pipe =  0b100;
        POPC =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00001;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA_L = Ra@invert;
      nB_L = srcConst@invert;
      Sync = S;


      !NencPOPC;
      Opcode2X2 = 0b01_10;



 CLASS "VOTE.VTG"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VTG:vtg /VTGMode:vtgmode /S(noS):sync UImm(28):uImm;

    PROPERTIES
        SECONDARY;
        SIDL_NAME = `SIDL_NAMES@VOTE_VTG;

    OPCODES
        VOTEbar_pipe =  0b10000_11100_10;
        VOTE =  0b10000_11100_10;

    ENCODING
      Opcode552 = Opcode;
      VMode = VTGMode;
      Pred = Pg;
      PredNot = Pg@not;
      Imm28 = Imm;
      Sync = S;

      !NencVOTEVTG;



 CLASS "VOTE"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VoteOp(ALL):voteop /S(noS):sync
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VoteOp:voteop /S(noS):sync
##ENDIF
        { Register(RZ):Rd ',' }
        Predicate:Pd ',' [!]Predicate:Pa;

    CONDITIONS

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        VOTEbar_pipe =  0b10000_11011_10;
        VOTE =  0b10000_11011_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      VMode = VoteOp;
      Dest = Rd;
      VPDest = Pd;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Sync = S;

      !NencVOTE;





CLASS "CSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' CC:inputCC ',' [!]Predicate:Pa;

    OPCODES
        CSETPxlu_pipe =  0b10000_10100_10;
        CSETP =  0b10000_10100_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      CCC_2 = CCTest;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Sync = S;


      !NencCSETP;



ALTERNATE CLASS "NoBop CSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest /S(noS):sync
                               Predicate:Pd
                                    ',' CC:inputCC ;

    OPCODES
        CSETPxlu_pipe =  0b10000_10100_10;
        CSETP =  0b10000_10100_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      CCC_2 = CCTest;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Sync = S;


      !NencCSETP;



CLASS "CSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' CC:dummyCC
                                    ',' [!]Predicate:Pa;

    OPCODES
        CSETxlu_pipe =  0b10000_10011_10;
        CSET =  0b10000_10011_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      CCC_2 = CCTest;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      Sync = S;


      !NencCSET;



ALTERNATE CLASS "NoBop CSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' CC:dummyCC
                                    ;

    OPCODES
        CSETxlu_pipe =  0b10000_10011_10;
        CSET =  0b10000_10011_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      CCC_2 = CCTest;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Sync = S;


      !NencCSET;



CLASS "ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' RegisterFAU:Ra
                                    ',' RegisterFAU:Rb
                                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      Xm = X;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;



ALTERNATE CLASS "NoBop ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' RegisterFAU:Ra
                                    ',' RegisterFAU:Rb
                                    ;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Xm = X;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;



CLASS "Imm ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' RegisterFAU:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      Xm = X;
      Sync = S;



      Opcode1X2 = 0b1_01;



ALTERNATE CLASS "NoBop Imm ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' RegisterFAU:Ra
                                    ',' SImm(20):uImm
                                    ;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Xm = X;
      Sync = S;



      Opcode1X2 = 0b1_01;



CLASS "Const ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' RegisterFAU:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      Xm = X;
      Sync = S;



      Opcode2X2 = 0b01_10;



ALTERNATE CLASS "NoBop Const ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' RegisterFAU:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Xm = X;
      Sync = S;



      Opcode2X2 = 0b01_10;



ALTERNATE CLASS "ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      Xm = X;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;



ALTERNATE CLASS "NoBop ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Xm = X;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;



ALTERNATE CLASS "Imm ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      Xm = X;
      Sync = S;



      Opcode1X2 = 0b1_01;



ALTERNATE CLASS "NoBop Imm ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Xm = X;
      Sync = S;



      Opcode1X2 = 0b1_01;



ALTERNATE CLASS "Const ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      Xm = X;
      Sync = S;



      Opcode2X2 = 0b01_10;



ALTERNATE CLASS "NoBop Const ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETfau_pipe =  0b011;
        ISETxlu_pipe =  0b011;
        ISET =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      Xm = X;
      Sync = S;



      Opcode2X2 = 0b01_10;



CLASS "ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' RegisterFAU:Ra
                                    ',' RegisterFAU:Rb
                                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      Bop = bopopt;
      Xm = X;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;

      !NencISETP;

      !BFiller;
      Sync=S;
      Opcode2X2 = 0b11_10;




ALTERNATE CLASS "NoBop ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' RegisterFAU:Ra
                                    ',' RegisterFAU:Rb
                                    ;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      Bop = `Bop@AND;
      Xm = X;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;

      !NencISETP;

      !BFiller;
      Sync=S;
      Opcode2X2 = 0b11_10;




CLASS "Imm ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' RegisterFAU:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0110;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      Bop = bopopt;
      Xm = X;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;

      !NencISETP;


      Sync=S;
      Opcode1X2 = 0b1_01;




ALTERNATE CLASS "NoBop Imm ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' RegisterFAU:Ra
                                    ',' SImm(20):uImm
                                    ;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0110;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      Bop = `Bop@AND;
      Xm = X;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;

      !NencISETP;


      Sync=S;
      Opcode1X2 = 0b1_01;




CLASS "Const ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' RegisterFAU:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      Bop = bopopt;
      Xm = X;
      SrcPred = Pa;
      SrcNot = Pa@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;

      !NencISETP;


      Sync=S;
      Opcode2X2 = 0b01_10;




ALTERNATE CLASS "NoBop Const ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' RegisterFAU:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      Bop = `Bop@AND;
      Xm = X;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;

      !NencISETP;


      Sync=S;
      Opcode2X2 = 0b01_10;




ALTERNATE CLASS "ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !NencISETP;
      Sync=S;
      Opcode2X2 = 0b11_10;



ALTERNATE CLASS "NoBop ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !NencISETP;
      Sync=S;
      Opcode2X2 = 0b11_10;



ALTERNATE CLASS "Imm ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0110;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !NencISETP;
      Sync=S;
      Opcode1X2 = 0b1_01;



ALTERNATE CLASS "NoBop Imm ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0110;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !NencISETP;
      Sync=S;
      Opcode1X2 = 0b1_01;



ALTERNATE CLASS "Const ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !NencISETP;
      Sync=S;
      Opcode2X2 = 0b01_10;



ALTERNATE CLASS "NoBop Const ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISETPfau_pipe =  0b011;
        ISETPxlu_pipe =  0b011;
        ISETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0110;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Signed = IsSigned(Integer32);
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !NencISETP;
      Sync=S;
      Opcode2X2 = 0b01_10;



CLASS "ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Dest = Rd;

      !BFiller;
      !WriteCC;
      Sync=S;
      Opcode2X2 = 0b11_10;




CLASS "Imm ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst=uImm;
      Dest = Rd;


      !WriteCC;
      Sync=S;
      Opcode1X2 = 0b1_01;




CLASS "Const ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Dest = Rd;


      !WriteCC;
      Sync=S;
      Opcode2X2 = 0b01_10;




CLASS "Const1 ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpAll;
      Signed = IsSigned(Integer32);
      RegC = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Dest = Rd;


      !WriteCC;
      Sync=S;
      Opcode2X2 = 0b10_10;




ALTERNATE CLASS "ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' Register:Rc;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpU;
      Signed = IsSigned(Integer32);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Dest = Rd;

      !BFiller;
      !WriteCC;
      Sync=S;
      Opcode2X2 = 0b11_10;





ALTERNATE CLASS "Imm ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' Register:Rc;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpU;
      Signed = IsSigned(Integer32);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst=uImm;
      Dest = Rd;


      !WriteCC;
      Sync=S;
      Opcode1X2 = 0b1_01;





ALTERNATE CLASS "Const ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpU;
      Signed = IsSigned(Integer32);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Dest = Rd;


      !WriteCC;
      Sync=S;
      Opcode2X2 = 0b01_10;





ALTERNATE CLASS "Const1 ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        ICMPfau_pipe =  0b011;
        ICMPxlu_pipe =  0b011;
        ICMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0100;
      IComp = ICmpU;
      Signed = IsSigned(Integer32);
      RegC = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Dest = Rd;


      !WriteCC;
      Sync=S;
      Opcode2X2 = 0b10_10;





 CLASS "BRA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } RSImm(24)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRAbru_pipe =  0b000_100100_00;
        BRA =  0b000_100100_00;

    ENCODING
      Opcode362 = Opcode;

      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm24 = sImm;
      U = U;
      LMT = LMT;

      !NencBRA;
      !Sync;
      !RegA;





 CLASS "BRA c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRAbru_pipe =  0b000_100100_00;
        BRA =  0b000_100100_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      U = U;
      LMT = LMT;

      !ScaleLow;
      !NencBRA;
      !Sync;
      !RegA;



 CLASS "BRX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } Register:Ra SImm(24/0):sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRXadu_pipe =  0b000_100101_00;
        BRXbru_pipe =  0b000_100101_00;
        BRX =  0b000_100101_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm24 = sImm;
      RegA = Ra;
      LMT = LMT;

      !U;
      !NencBRA;
      !Sync;




 CLASS "BRX c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:sImm];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRXadu_pipe =  0b000_100101_00;
        BRXbru_pipe =  0b000_100101_00;
        BRX =  0b000_100101_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
      RegA = Ra;
      LMT = LMT;

      !U;
      !ScaleLow;
      !NencBRA;
      !Sync;



 CLASS "JMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } UImm(32)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMPbru_pipe =  0b000_100001_00;
        JMP =  0b000_100001_00;

    ENCODING
      Opcode362 = Opcode;
      Imm32 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      U = U;
      LMT = LMT;
      CA = 0;
      CCC_1 = Test;
      !RegA;
      !Sync;





 CLASS "JMP c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMPbru_pipe =  0b000_100001_00;
        JMP =  0b000_100001_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      U = U;
      LMT = LMT;

      !RegA;
      !Sync;
      !NencJMP;


 CLASS "JMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } Register:Ra SImm(32/0):sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMXadu_pipe =  0b000_100000_00;
        JMXbru_pipe =  0b000_100000_00;
        JMX =  0b000_100000_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm32 = sImm;
      RegA = Ra;
      LMT = LMT;

      !Sync;
      !U;





 CLASS "JMX c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:sImm];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMXadu_pipe =  0b000_100000_00;
        JMXbru_pipe =  0b000_100000_00;
        JMX =  0b000_100000_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
      RegA = Ra;
      LMT = LMT;

      !U;
      !Sync;
      !NencJMP;



 CLASS "CAL"
    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        CALbru_pipe =  0b000_100110_00;
        CAL =  0b000_100110_00;

    ENCODING
      Opcode362 = Opcode;
      CA = 0;
      Imm24 = sImm;
      INC = INC;
      !Pred;
      !PredNot;
      !RegA;
      !U;
      !CCC_1;
      !Sync;

      !NencBRA;



 CLASS "PRET"
    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm;

    OPCODES
        PRETbru_pipe =  0b000_100111_00;
        PRET =  0b000_100111_00;

    ENCODING
      Opcode362 = Opcode;
      CA = 0;
      Imm24 = sImm;
      INC = INC;
      !Pred;
      !PredNot;
      !RegA;
      !U;
      !CCC_1;
      !Sync;

      !NencBRA;



 CLASS "CAL c"
FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        CALbru_pipe =  0b000_100110_00;
        CAL =  0b000_100110_00;

    ENCODING
      Opcode362 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;
      !ScaleLow;
      !Pred;
      !PredNot;
      !RegA;
      !U;
      !CCC_1;
      !Sync;
      !NencBRA;



 CLASS "PRET c"
FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
        PRETbru_pipe =  0b000_100111_00;
        PRET =  0b000_100111_00;

    ENCODING
      Opcode362 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;
      !ScaleLow;
      !Pred;
      !PredNot;
      !RegA;
      !U;
      !CCC_1;
      !Sync;
      !NencBRA;



 CLASS "JCAL"
    FORMAT Opcode /INC(INC):inc UImm(32)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        JCALbru_pipe =  0b000_100010_00;
        JCAL =  0b000_100010_00;

    ENCODING
      Opcode362 = Opcode;
      CA = 0;
      Imm32 = sImm;
      INC = INC;
      !Sync;
      !Pred;
      !PredNot;
      !RegA;
      !U;
      !CCC_1;




 CLASS "JCAL c"
FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        JCALbru_pipe =  0b000_100010_00;
        JCAL =  0b000_100010_00;

    ENCODING
      Opcode362 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;

      !NencJMP;
      !Pred;
      !PredNot;
      !RegA;
      !U;
      !CCC_1;
      !Sync;



 CLASS "SSY"
    FORMAT Opcode RSImm(24)*:sImm;

    OPCODES
        PLONGJMPbru_pipe =  0b000_101000_00;
        PLONGJMP =  0b000_101000_00;
        SSYbru_pipe =  0b000_101001_00;
        SSY =  0b000_101001_00;
        PBKbru_pipe =  0b000_101010_00;
        PBK =  0b000_101010_00;
        PCNTbru_pipe =  0b000_101011_00;
        PCNT =  0b000_101011_00;

    ENCODING
      Opcode362 = Opcode;
      Imm24 = sImm;
      CA = 0;


      !CCC_1;
      !LMT;
      !U;
      !RegA;
      !Pred;
      !PredNot;
      !Sync;
      !NencBRA;



 CLASS "SSY c"
FORMAT Opcode C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
        PLONGJMPbru_pipe =  0b000_101000_00;
        PLONGJMP =  0b000_101000_00;
        SSYbru_pipe =  0b000_101001_00;
        SSY =  0b000_101001_00;
        PBKbru_pipe =  0b000_101010_00;
        PBK =  0b000_101010_00;
        PCNTbru_pipe =  0b000_101011_00;
        PCNT =  0b000_101011_00;

    ENCODING
      Opcode362 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);

      !NencBRA;
      !ScaleLow;
      !Sync;
      !Pred;
      !PredNot;
      !RegA;
      !U;
      !LMT;
      !CCC_1;



 CLASS "RET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest;

    PROPERTIES
         BRANCH_TYPE = BRT_RETURN;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        RETbru_pipe =  0b000_110010_00;
        RET =  0b000_110010_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      !Imm32;
      !Sync;
      !RegA;
      !U;
      !CA;
      !LMT;


 CLASS "BRK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest;

    PROPERTIES
         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        LONGJMPbru_pipe =  0b000_110001_00;
        LONGJMP =  0b000_110001_00;
        KILbru_pipe =  0b000_110011_00;
        KIL =  0b000_110011_00;
        BRKbru_pipe =  0b000_110100_00;
        BRK =  0b000_110100_00;
        CONTbru_pipe =  0b000_110101_00;
        CONT =  0b000_110101_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      !Imm32;
      !Sync;
      !RegA;
      !U;
      !CA;
      !LMT;



 CLASS "EXIT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                 /KeepRefCount(noKEEPREFCOUNT):krc CC(CC):TestCC/Test(T):CCTest;

    PROPERTIES
         BRANCH_TYPE = BRT_BRANCHOUT;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        EXITbru_pipe =  0b000_110000_00;
        EXIT =  0b000_110000_00;

    ENCODING
      Opcode362 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      KeepRefCnt = krc;

      !NencEXIT;



 CLASS "SAM"
    FORMAT Opcode;

    OPCODES
        SAMbru_pipe =  0b000_110111_00;
        SAM =  0b000_110111_00;
        RAMbru_pipe =  0b000_111000_00;
        RAM =  0b000_111000_00;

    ENCODING
      Opcode362 = Opcode;
      !NencRTT;
      !RTTOp;




 CLASS "BPT"
    FORMAT Opcode /BPTMode:bpt UImm(20/0):sImm;

    CONDITIONS
         ERROR
           !(bpt == `BPTMode@TRAP && (sImm < 1 || sImm > 3)) :
             "BPT.TRAP immediate must be between 1 and 3"

    OPCODES
        BPTbru_pipe =  0b000_000000_00;
        BPT =  0b000_000000_00;

    ENCODING
      Opcode362 = Opcode;
      Imm20 = sImm;
      Bpt = BPTMode;
      !NencBPT;



 CLASS "RTT"
    FORMAT Opcode /RTTOp(POPCRS):rttop;

    PROPERTIES
            BRANCH_TYPE = BRT_RETURN;

    OPCODES
        RTTbru_pipe =  0b000_110110_00;
        RTT =  0b000_110110_00;

    ENCODING
      Opcode362 = Opcode;
      RTTOp = RTTOp;
      !NencRTT;




CLASS "IDE"
    FORMAT Opcode /IDEAction(DI):action UImm(16/0):uImm;

    OPCODES
        IDEbru_pipe =  0b000_111001_00;
        IDE =  0b000_111001_00;

    ENCODING
      Opcode362 = Opcode;
      Imm16 = uImm;
      DI = action;

      !NencIDE;






 CLASS "DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
        && IsEven(((Rc)+((Rc)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DFMAfmaXliteW_pipe =  0b011;
        DFMAfmaX_pipe =  0b011;
        DFMA =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0111;
      Rnd3 = Round1;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      Sync=S;
      !BFiller;
      Opcode2X2 = 0b11_10;



 CLASS "Imm DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rc)+((Rc)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DFMAfmaXliteW_pipe =  0b011;
        DFMAfmaX_pipe =  0b011;
        DFMA =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b0111;
      Rnd3 = Round1;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      Sync=S;

      Opcode1X2 = 0b1_01;



 CLASS "Const DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' [-]Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rc)+((Rc)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DFMAfmaXliteW_pipe =  0b011;
        DFMAfmaX_pipe =  0b011;
        DFMA =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0111;
      Rnd3 = Round1;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      Sync=S;

      Opcode2X2 = 0b01_10;



 CLASS "Const1 DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        DFMAfmaXliteW_pipe =  0b011;
        DFMAfmaX_pipe =  0b011;
        DFMA =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b0111;
      Rnd3 = Round1;
      nC = srcConst@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      Sync=S;

      Opcode2X2 = 0b10_10;



 CLASS "DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DADDfmaXliteW_pipe =  0b100;
        DADDfmaX_pipe =  0b100;
        DADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01110;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !Sat;
      !XMode;
      !LOP;
      Opcode2X2 = 0b11_10;




 CLASS "Imm DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DADDfmaXliteW_pipe =  0b100;
        DADDfmaX_pipe =  0b100;
        DADD =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01110;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !Sat;
      !XMode;
      !LOP;
      Opcode1X2 = 0b1_01;




 CLASS "Const DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DADDfmaXliteW_pipe =  0b100;
        DADDfmaX_pipe =  0b100;
        DADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01110;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !Sat;
      !XMode;
      !LOP;
      Opcode2X2 = 0b01_10;




 CLASS "DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DMULfmaXliteW_pipe =  0b100;
        DMULfmaX_pipe =  0b100;
        DMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10000;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !Sat;
      !Bop;
      !aB;
      !XMode;
      !LOP;
      Opcode2X2 = 0b11_10;




 CLASS "Imm DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DMULfmaXliteW_pipe =  0b100;
        DMULfmaX_pipe =  0b100;
        DMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10000;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);
      WriteCC = writeCC;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !Sat;
      !Bop;
      !aB;
      !XMode;
      !LOP;
      Opcode1X2 = 0b1_01;




 CLASS "Const DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DMULfmaXliteW_pipe =  0b100;
        DMULfmaX_pipe =  0b100;
        DMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10000;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);
      WriteCC = writeCC;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !Sat;
      !Bop;
      !aB;
      !XMode;
      !LOP;
      Opcode2X2 = 0b01_10;




 CLASS "DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb
                    ',' [!]Predicate:Pa;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DMNMXfmaX_pipe =  0b100;
        DMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01010;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !Sat;
      !XMode;
      Opcode2X2 = 0b11_10;



 CLASS "Imm DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                    ',' [!]Predicate:Pa;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DMNMXfmaX_pipe =  0b100;
        DMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01010;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !Sat;
      !XMode;
      Opcode1X2 = 0b1_01;



 CLASS "Const DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                    ',' [!]Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==255)))
        && IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DMNMXfmaX_pipe =  0b100;
        DMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01010;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !Sat;
      !XMode;
      Opcode2X2 = 0b01_10;



CLASS "DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DSETfmaX_pipe =  0b001;
        DSET =  0b001;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0;
      Bop = bopopt;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = Rb@negate;
      BVal1 = bval;
      aB2 = Rb@absolute;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;




ALTERNATE CLASS "NoBop DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DSETfmaX_pipe =  0b001;
        DSET =  0b001;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0;
      Bop = `Bop@AND;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = Rb@negate;
      BVal1 = bval;
      aB2 = Rb@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;




CLASS "Imm DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DSETfmaX_pipe =  0b001;
        DSET =  0b001;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX1X = 0;
      Bop = bopopt;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = UnaryNeg;
      BVal1 = bval;
      aB2 = UnaryAbs;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Sync = S;



      Opcode1X2 = 0b1_01;




ALTERNATE CLASS "NoBop Imm DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DSETfmaX_pipe =  0b001;
        DSET =  0b001;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX1X = 0;
      Bop = `Bop@AND;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = UnaryNeg;
      BVal1 = bval;
      aB2 = UnaryAbs;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Sync = S;



      Opcode1X2 = 0b1_01;




CLASS "Const DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DSETfmaX_pipe =  0b001;
        DSET =  0b001;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0;
      Bop = bopopt;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = srcConst@negate;
      BVal1 = bval;
      aB2 = srcConst@absolute;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      Sync = S;



      Opcode2X2 = 0b01_10;




ALTERNATE CLASS "NoBop Const DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DSETfmaX_pipe =  0b001;
        DSET =  0b001;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0;
      Bop = `Bop@AND;
      nA3 = Ra@negate;
      FComp = fcomp;
      WriteCC = writeCC;
      aA3 = Ra@absolute;
      nB3 = srcConst@negate;
      BVal1 = bval;
      aB2 = srcConst@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      Sync = S;



      Opcode2X2 = 0b01_10;




CLASS "DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DSETPfmaX_pipe =  0b011;
        DSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1000;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      aB2 = Rb@absolute;
      SrcNot = Pa@not;
      SrcPred = Pa;
      RegB = Rb;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;
      Sync = S;


      !BFiller;
      !WriteCC;
      Opcode2X2 = 0b11_10;




ALTERNATE CLASS "NoBop DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DSETPfmaX_pipe =  0b011;
        DSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1000;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      aB2 = Rb@absolute;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      RegB = Rb;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Sync = S;


      !BFiller;
      !WriteCC;
      Opcode2X2 = 0b11_10;




CLASS "Imm DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DSETPfmaX_pipe =  0b011;
        DSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b1000;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      aB2 = UnaryAbs;
      SrcNot = Pa@not;
      SrcPred = Pa;
      Bconst=uImm;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;
      Sync = S;



      !WriteCC;
      Opcode1X2 = 0b1_01;




ALTERNATE CLASS "NoBop Imm DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DSETPfmaX_pipe =  0b011;
        DSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b1000;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      aB2 = UnaryAbs;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      Bconst=uImm;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Sync = S;



      !WriteCC;
      Opcode1X2 = 0b1_01;




CLASS "Const DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DSETPfmaX_pipe =  0b011;
        DSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1000;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      aB2 = srcConst@absolute;
      SrcNot = Pa@not;
      SrcPred = Pa;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;
      Sync = S;



      !WriteCC;
      Opcode2X2 = 0b01_10;




ALTERNATE CLASS "NoBop Const DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DSETPfmaX_pipe =  0b011;
        DSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1000;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      aB2 = srcConst@absolute;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Sync = S;



      !WriteCC;
      Opcode2X2 = 0b01_10;




CLASS "DCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
        && IsEven(((Rb)+((Rb)==255)))
         : "Register numbers must be even for double float operations"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        DCHKfmaX_pipe =  0b100;
        DCHK =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01111;
      aB = Rb@absolute;
      nAB = Ra@negate;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      ChkModeF = mode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB = Rb;

      !BFiller;
      !WriteCC;
      !Sat;
      !PNDest;
      !aA4;
      !nB4;
      Sync=S;
      Opcode2X2 = 0b11_10;






CLASS "Imm DCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        DCHKfmaX_pipe =  0b100;
        DCHK =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01111;
      aB = UnaryAbs;
      nAB = Ra@negate;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      ChkModeF = mode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      Bconst=uImm;


      !WriteCC;
      !Sat;
      !PNDest;
      !aA4;
      !nB4;
      Sync=S;
      Opcode1X2 = 0b1_01;






CLASS "Const DCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==255)))
         : "Register numbers must be even for double float operations"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        DCHKfmaX_pipe =  0b100;
        DCHK =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01111;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      ChkModeF = mode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);


      !WriteCC;
      !Sat;
      !PNDest;
      !aA4;
      !nB4;
      Sync=S;
      Opcode2X2 = 0b01_10;






 CLASS "FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' [-]RegisterFAU:Rb
                                       ',' [-]RegisterFAU:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FFMAfau_pipe =  0b001;
        FFMAfmaXliteW_pipe =  0b001;
        FFMAfmaX_pipe =  0b001;
        FFMA =  0b001;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

      Sync=S;
      !BFiller;
      Opcode2X2 = 0b11_10;



 CLASS "Imm FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg
                                       ',' [-]RegisterFAU:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FFMAfau_pipe =  0b001;
        FFMAfmaXliteW_pipe =  0b001;
        FFMAfmaX_pipe =  0b001;
        FFMA =  0b001;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX1X = 0b1;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

      Sync=S;

      Opcode1X2 = 0b1_01;



 CLASS "Const FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [-]RegisterFAU:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' [-]RegisterFAU:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FFMAfau_pipe =  0b001;
        FFMAfmaXliteW_pipe =  0b001;
        FFMAfmaX_pipe =  0b001;
        FFMA =  0b001;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = Rc@negate;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);
      WriteCC = writeCC;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

      Sync=S;

      Opcode2X2 = 0b01_10;



 CLASS "Const1 FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' [-]RegisterFAU:Rb
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        FFMAfau_pipe =  0b001;
        FFMAfmaXliteW_pipe =  0b001;
        FFMAfmaX_pipe =  0b001;
        FFMA =  0b001;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      FMZ = FMZ;
      Rnd = Round1;
      Sat = SAT;
      nC = srcConst@negate;
      nAB = PSignFFMA(Ra@negate,Rb@negate);
      WriteCC = writeCC;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

      Sync=S;

      Opcode2X2 = 0b10_10;



 CLASS "FFMA32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' F32Imm(64):fImm
                                       ',' [-]RegisterFAU:Rc;
    CONDITIONS
         ERROR
           Rd == Rc :
             "Output register must be the same as last input register"

    OPCODES
        FFMA32Ifau_pipe =  0b011_00;
        FFMA32IfmaXliteW_pipe =  0b011_00;
        FFMA32IfmaX_pipe =  0b011_00;
        FFMA32I =  0b011_00;

    ENCODING
      Opcode32 = Opcode;
      nC2 = Rc@negate;
      nAB2 = Ra@negate;
      SatHigh = SAT;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = IDENTICAL(Rd,Rc);
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZHigh = FMZ;

      Sync=S;




 ALTERNATE CLASS "FFMA32I 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):fImm;
    CONDITIONS

    OPCODES
        FFMA32Ifau_pipe =  0b011_00;
        FFMA32IfmaXliteW_pipe =  0b011_00;
        FFMA32IfmaX_pipe =  0b011_00;
        FFMA32I =  0b011_00;

   ENCODING
      Opcode32 = Opcode;
      nC2 = 0;
      nAB2 = Ra@negate;
      SatHigh = SAT;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZHigh = FMZ;

      Sync=S;




 CLASS "FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-][||]RegisterFAU:Ra ',' [-][||]RegisterFAU:Rb;

    CONDITIONS

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FADDfau_pipe =  0b100;
        FADDfmaXliteW_pipe =  0b100;
        FADDfmaX_pipe =  0b100;
        FADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01011;
      Sat = SAT;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      FTZ = FTZ;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !ScaleLow;
      Sync=S;
      !BFiller;

      Opcode2X2 = 0b11_10;



 CLASS "Imm FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-][||]RegisterFAU:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FADDfau_pipe =  0b100;
        FADDfmaXliteW_pipe =  0b100;
        FADDfmaX_pipe =  0b100;
        FADD =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01011;
      Sat = SAT;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      FTZ = FTZ;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      !ScaleLow;
      Sync=S;


      Opcode1X2 = 0b1_01;



 CLASS "Const FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [-][||]RegisterFAU:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FADDfau_pipe =  0b100;
        FADDfmaXliteW_pipe =  0b100;
        FADDfmaX_pipe =  0b100;
        FADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01011;
      Sat = SAT;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      FTZ = FTZ;
      RndLow = Round1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      !ScaleLow;
      Sync=S;


      Opcode2X2 = 0b01_10;



 CLASS "FADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-][||]RegisterFAU:Ra ',' F32Imm(64):fImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    OPCODES
        FADD32Ifau_pipe =  0b010_00;
        FADD32IfmaXliteW_pipe =  0b010_00;
        FADD32IfmaX_pipe =  0b010_00;
        FADD32I =  0b010_00;

    ENCODING
      Opcode32 = Opcode;
      nC2 = UnaryAbs;
      nAB2 = Ra@negate;
      FTZ3 = FTZ;
      aA3 = Ra@absolute;
      nB3 = UnaryNeg;
      WriteCCI = writeCC;
      Imm32 = fImm;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;




 CLASS "FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd
             ',' RegisterFAU:Ra ',' RegisterFAU:Rb
                                       ',' RegisterFAU:Rc;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FCMPfau_pipe =  0b011;
        FCMPxlu_pipe =  0b011;
        FCMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1010;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      Sync=S;
      !BFiller;
      Opcode2X2 = 0b11_10;


 CLASS "Imm FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd
             ',' RegisterFAU:Ra ',' F32Imm(64):uImm
                                       ',' RegisterFAU:Rc;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FCMPfau_pipe =  0b011;
        FCMPxlu_pipe =  0b011;
        FCMP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b1010;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      Sync=S;

      Opcode1X2 = 0b1_01;


 CLASS "Const FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd
',' RegisterFAU:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' RegisterFAU:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FCMPfau_pipe =  0b011;
        FCMPxlu_pipe =  0b011;
        FCMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1010;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      Sync=S;

      Opcode2X2 = 0b01_10;


 CLASS "Const1 FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd
             ',' RegisterFAU:Ra ',' RegisterFAU:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        FCMPfau_pipe =  0b011;
        FCMPxlu_pipe =  0b011;
        FCMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1010;
      FComp = Test;
      FTZ2 = FTZ;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      Sync=S;

      Opcode2X2 = 0b10_10;


 CLASS "FSWZ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SWZMode:swz /FTZ(noFTZ):ftz /Round1(RN):rnd /NDV(noNDV):ndv /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb
                    ',' PNWord:uImm;
    OPCODES
        FSWZfmaX_pipe =  0b01111_11111_10;
        FSWZ =  0b01111_11111_10;

    ENCODING
      Opcode552 = Opcode;
      WriteCC = writeCC;
      RndLow = Round1;
      SWZMode = SWZMode;
      NDV = NDV;
      FTZ = FTZ;
      PNWord = PNWord;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Dest = Rd;
      Sync = S;

      !NencFSWZ;




 CLASS "FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' [-]RegisterFAU:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FMULfau_pipe =  0b100;
        FMULfmaXliteW_pipe =  0b100;
        FMULfmaX_pipe =  0b100;
        FMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;

      FMZLow = FMZ;
      ScaleLow = Scale;
      RndLow = Round1;
      Sat = SAT;
      nAB = PSignFFMA(Ra@negate,Rb@negate);

      Sync=S;
      !BFiller;
      !NencFMUL;
      Opcode2X2 = 0b11_10;



 CLASS "Imm FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FMULfau_pipe =  0b100;
        FMULfmaXliteW_pipe =  0b100;
        FMULfmaX_pipe =  0b100;
        FMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;

      FMZLow = FMZ;
      ScaleLow = Scale;
      RndLow = Round1;
      Sat = SAT;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);

      Sync=S;

      !NencFMUL;
      Opcode1X2 = 0b1_01;



 CLASS "Const FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [-]RegisterFAU:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FMULfau_pipe =  0b100;
        FMULfmaXliteW_pipe =  0b100;
        FMULfmaX_pipe =  0b100;
        FMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01101;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;

      FMZLow = FMZ;
      ScaleLow = Scale;
      RndLow = Round1;
      Sat = SAT;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);

      Sync=S;

      !NencFMUL;
      Opcode2X2 = 0b01_10;



 CLASS "FMUL32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /Pipe2FMALite(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra ',' F32Imm(64):fImm;

    OPCODES
        FMUL32Ifau_pipe =  0b00100_10;
        FMUL32IfmaXliteW_pipe =  0b00100_10;
        FMUL32IfmaX_pipe =  0b00100_10;
        FMUL32I =  0b00100_10;

    ENCODING
      Opcode52 = Opcode;
      SatHigh = SAT;
      FMZHigh = FMZ;
      WriteCCI = writeCC;
      Imm32 = fImm;
      RegA = Ra;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;

      Sync=S;




 CLASS "FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-][||]RegisterFAU:Ra ',' [-][||]RegisterFAU:Rb
                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FMNMXfau_pipe =  0b100;
        FMNMXfmaX_pipe =  0b100;
        FMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01100;
      aB = Rb@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      FTZ = FTZ;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !Sat;
      !Xm;
      Opcode2X2 = 0b11_10;




 CLASS "Imm FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-][||]RegisterFAU:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FMNMXfau_pipe =  0b100;
        FMNMXfmaX_pipe =  0b100;
        FMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01100;
      aB = UnaryAbs;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      FTZ = FTZ;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !Sat;
      !Xm;
      Opcode1X2 = 0b1_01;




 CLASS "Const FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [-][||]RegisterFAU:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                    ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FMNMXfau_pipe =  0b100;
        FMNMXfmaX_pipe =  0b100;
        FMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01100;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      WriteCC = writeCC;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      FTZ = FTZ;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !Sat;
      !Xm;
      Opcode2X2 = 0b01_10;




 CLASS "FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
             ',' Register:Ra ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FCCOfmaX_pipe =  0b011;
        FCCO =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1001;
      PDest = Pd;
      PNDest = nPd;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      Opcode2X2 = 0b11_10;
      !FTZ2;
      !FComp;
      !BFiller;



 CLASS "Imm FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
             ',' Register:Ra ',' F32Imm(64):uImm ',' Register(RZ):Rc;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FCCOfmaX_pipe =  0b011;
        FCCO =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b1001;
      PDest = Pd;
      PNDest = nPd;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      Opcode1X2 = 0b1_01;
      !FTZ2;
      !FComp;




 CLASS "Const FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register(RZ):Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FCCOfmaX_pipe =  0b011;
        FCCO =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1001;
      PDest = Pd;
      PNDest = nPd;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      Opcode2X2 = 0b01_10;
      !FTZ2;
      !FComp;




 CLASS "Const1 FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        FCCOfmaX_pipe =  0b011;
        FCCO =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1001;
      PDest = Pd;
      PNDest = nPd;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      CMode = CMode;

      Sync=S;
      Opcode2X2 = 0b10_10;
      !FTZ2;
      !FComp;




CLASS "FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' [-][||]RegisterFAU:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FSETfau_pipe =  0b000;
        FSETfmaX_pipe =  0b000;
        FSET =  0b000;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA3 = Ra@negate;
      nB3 = Rb@negate;
      aA3 = Ra@absolute;
      aB2 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      FTZ3 = FTZ;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;



ALTERNATE CLASS "NoBop FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' [-][||]RegisterFAU:Rb
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FSETfau_pipe =  0b000;
        FSETfmaX_pipe =  0b000;
        FSET =  0b000;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA3 = Ra@negate;
      nB3 = Rb@negate;
      aA3 = Ra@absolute;
      aB2 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      FTZ3 = FTZ;
      Sync = S;


      !BFiller;
      Opcode2X2 = 0b11_10;



CLASS "Imm FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FSETfau_pipe =  0b000;
        FSETfmaX_pipe =  0b000;
        FSET =  0b000;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA3 = Ra@negate;
      nB3 = UnaryNeg;
      aA3 = Ra@absolute;
      aB2 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      FTZ3 = FTZ;
      Sync = S;



      Opcode1X2 = 0b1_01;



ALTERNATE CLASS "NoBop Imm FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FSETfau_pipe =  0b000;
        FSETfmaX_pipe =  0b000;
        FSET =  0b000;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA3 = Ra@negate;
      nB3 = UnaryNeg;
      aA3 = Ra@absolute;
      aB2 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      FTZ3 = FTZ;
      Sync = S;



      Opcode1X2 = 0b1_01;



CLASS "Const FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [-][||]RegisterFAU:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FSETfau_pipe =  0b000;
        FSETfmaX_pipe =  0b000;
        FSET =  0b000;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA3 = Ra@negate;
      nB3 = srcConst@negate;
      aA3 = Ra@absolute;
      aB2 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      FTZ3 = FTZ;
      Sync = S;



      Opcode2X2 = 0b01_10;



ALTERNATE CLASS "NoBop Const FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [-][||]RegisterFAU:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FSETfau_pipe =  0b000;
        FSETfmaX_pipe =  0b000;
        FSET =  0b000;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA3 = Ra@negate;
      nB3 = srcConst@negate;
      aA3 = Ra@absolute;
      aB2 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      FTZ3 = FTZ;
      Sync = S;



      Opcode2X2 = 0b01_10;



CLASS "FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' [-][||]RegisterFAU:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FSETPfau_pipe =  0b011;
        FSETPfmaX_pipe =  0b011;
        FSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1011;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      FTZ2 = FTZ;
      aB2 = Rb@absolute;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;


      !BFiller;
      Sync=S;
      Opcode2X2 = 0b11_10;




ALTERNATE CLASS "NoBop FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' [-][||]RegisterFAU:Rb
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FSETPfau_pipe =  0b011;
        FSETPfmaX_pipe =  0b011;
        FSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1011;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = Rb@negate;
      FTZ2 = FTZ;
      aB2 = Rb@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;


      !BFiller;
      Sync=S;
      Opcode2X2 = 0b11_10;




CLASS "Imm FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FSETPfau_pipe =  0b011;
        FSETPfmaX_pipe =  0b011;
        FSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b1011;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      FTZ2 = FTZ;
      aB2 = UnaryAbs;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst=uImm;
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;



      Sync=S;
      Opcode1X2 = 0b1_01;




ALTERNATE CLASS "NoBop Imm FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]RegisterFAU:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FSETPfau_pipe =  0b011;
        FSETPfmaX_pipe =  0b011;
        FSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b1011;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = UnaryNeg;
      FTZ2 = FTZ;
      aB2 = UnaryAbs;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst=uImm;
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;



      Sync=S;
      Opcode1X2 = 0b1_01;




CLASS "Const FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]RegisterFAU:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FSETPfau_pipe =  0b011;
        FSETPfmaX_pipe =  0b011;
        FSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1011;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      FTZ2 = FTZ;
      aB2 = srcConst@absolute;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Bop = bopopt;
      PDest = Pd;
      PNDest = nPd;



      Sync=S;
      Opcode2X2 = 0b01_10;




ALTERNATE CLASS "NoBop Const FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]RegisterFAU:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FSETPfau_pipe =  0b011;
        FSETPfmaX_pipe =  0b011;
        FSETP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b1011;
      FComp = Test;
      nA2 = Ra@negate;
      aA4 = Ra@absolute;
      nB4 = srcConst@negate;
      FTZ2 = FTZ;
      aB2 = srcConst@absolute;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Bop = `Bop@AND;
      PDest = Pd;
      PNDest = `Predicate@PT;



      Sync=S;
      Opcode2X2 = 0b01_10;




 CLASS "IPA 1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register:Rb ',' Register(RZ):Rc ;

    CONDITIONS
        ERROR
            ((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) -> (Rb == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (msi != `MSI@OFFSET) -> (Rc == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b01110_1001_10;
        IPA =  0b01110_1001_10;

    ENCODING
      Opcode542 = Opcode;
      IPAOp = IPAOp;
      MSI = MSI;
      SatLow = SAT;
      RegA =* Ra;
      RegB = Rb;
      RegC = Rc;
      IPAImm11 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Sync = S;



 CLASS "I IPA 1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register:Rb ',' Register(RZ):Rc ;

    CONDITIONS
        ERROR
            ((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) -> (Rb == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (msi != `MSI@OFFSET) -> (Rc == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b01110_1001_10;
        IPA =  0b01110_1001_10;

    ENCODING
      Opcode542 = Opcode;
      IPAOp = IPAOp;
      MSI = MSI;
      SatLow = SAT;
      RegA =* Ra;
      RegB = Rb;
      RegC = Rc;
      IPAImm10 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Sync = S;

      !TOFF1;




 ALTERNATE CLASS "IPA 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm] ;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b01110_1001_10;
        IPA =  0b01110_1001_10;

    ENCODING
      Opcode542 = Opcode;
      IPAOp = IPAOp;
      MSI = MSI;
      SatLow = SAT;
      RegA =* Ra;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      IPAImm11 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Sync = S;



 ALTERNATE CLASS "I IPA 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm] ;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b01110_1001_10;
        IPA =  0b01110_1001_10;

    ENCODING
      Opcode542 = Opcode;
      IPAOp = IPAOp;
      MSI = MSI;
      SatLow = SAT;
      RegA =* Ra;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      IPAImm10 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Sync = S;

      !TOFF1;



 CLASS "RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
             Register:Rd ',' [-][||]Register:Rb;

    CONDITIONS

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        RROfmaX_pipe =  0b100;
        RRO =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10010;
      aB = Rb@absolute;
      nB = Rb@negate;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      !RegA;
      !Sat;
      !nAB;
      !WriteCC;
      !aA2;
      !XMode;
      !LOP;
      !nB_L;

      Sync=S;
      !BFiller;
      Opcode2X2 = 0b11_10;



 CLASS "Imm RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
             Register:Rd ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        RROfmaX_pipe =  0b100;
        RRO =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10010;
      aB = UnaryAbs;
      nB = UnaryNeg;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      !RegA;
      !Sat;
      !nAB;
      !WriteCC;
      !aA2;
      !XMode;
      !LOP;
      !nB_L;

      Sync=S;

      Opcode1X2 = 0b1_01;



 CLASS "Const RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
Register:Rd ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        RROfmaX_pipe =  0b100;
        RRO =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10010;
      aB = srcConst@absolute;
      nB = srcConst@negate;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !RegA;
      !Sat;
      !nAB;
      !WriteCC;
      !aA2;
      !XMode;
      !LOP;
      !nB_L;

      Sync=S;

      Opcode2X2 = 0b01_10;



 CLASS "MUFU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MufuOp:mufu /SAT(noSAT):sat /S(noS):sync
             Register:Rd ',' [-][||]Register:Ra;

    OPCODES
        MUFUfu_pipe =  0b10000_10000_10;
        MUFU =  0b10000_10000_10;

    ENCODING
      Opcode552 = Opcode;
      Sat = SAT;
      aA2 = Ra@absolute;
      nA1 = Ra@negate;
      MufuOp = MufuOp;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;
      !NencMUFU;



CLASS "FCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb;
    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FCHKfmaX_pipe =  0b100;
        FCHK =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10001;
      aB = Rb@absolute;
      nAB = Ra@negate;
      aA2 = Ra@absolute;
      nB2 = Rb@negate;
      ChkModeF = mode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB = Rb;

      !BFiller;
      !WriteCC;
      !Sat;
      !PNDest;
      !aA4;
      !nB4;
      Sync=S;
      Opcode2X2 = 0b11_10;





CLASS "Imm FCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;
    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FCHKfmaX_pipe =  0b100;
        FCHK =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10001;
      aB = UnaryAbs;
      nAB = Ra@negate;
      aA2 = Ra@absolute;
      nB2 = UnaryNeg;
      ChkModeF = mode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      Bconst=uImm;


      !WriteCC;
      !Sat;
      !PNDest;
      !aA4;
      !nB4;
      Sync=S;
      Opcode1X2 = 0b1_01;





CLASS "Const FCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FCHKfmaX_pipe =  0b100;
        FCHK =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10001;
      aB = srcConst@absolute;
      nAB = Ra@negate;
      aA2 = Ra@absolute;
      nB2 = srcConst@negate;
      ChkModeF = mode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);


      !WriteCC;
      !Sat;
      !PNDest;
      !aA4;
      !nB4;
      Sync=S;
      Opcode2X2 = 0b01_10;





CLASS "F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2F;


CLASS "Imm F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode1X2 = 0b1_01;

      !NencF2F;


CLASS "Const F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode2X2 = 0b01_10;

      !NencF2F;


CLASS "F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==255))) :
             "F64 as destination format requires an even destination register"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"

         ERROR
           (ftz == `FTZ@FTZ) -> (fmts != `F2Ffmts2@"F64.F32"):
             ".FTZ cannot be used with F64 source"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))): "Register B is out of range"

         ERROR
            ((fmts != `F2Ffmts2@"F64.F32") && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
              "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2F;



CLASS "Imm F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==255))) :
             "F64 as destination format requires an even destination register"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"

         ERROR
           (ftz == `FTZ@FTZ) -> (fmts != `F2Ffmts2@"F64.F32"):
             ".FTZ cannot be used with F64 source"


         ERROR
            ((fmts != `F2Ffmts2@"F64.F32") && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
              "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode1X2 = 0b1_01;

      !NencF2F;



CLASS "Const F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==255))) :
             "F64 as destination format requires an even destination register"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"

         ERROR
           (ftz == `FTZ@FTZ) -> (fmts != `F2Ffmts2@"F64.F32"):
             ".FTZ cannot be used with F64 source"


         ERROR
            ((fmts != `F2Ffmts2@"F64.F32") && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
              "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode2X2 = 0b01_10;

      !NencF2F;



CLASS "F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (ftz != `FTZ@FTZ):
             ".FTZ cannot be used with F16.F16"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2F;



CLASS "Imm F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (ftz != `FTZ@FTZ):
             ".FTZ cannot be used with F16.F16"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode1X2 = 0b1_01;

      !NencF2F;



CLASS "Const F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (ftz != `FTZ@FTZ):
             ".FTZ cannot be used with F16.F16"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode2X2 = 0b01_10;

      !NencF2F;



CLASS "F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2F;



CLASS "Imm F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode1X2 = 0b1_01;

      !NencF2F;



CLASS "Const F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode2X2 = 0b01_10;

      !NencF2F;



CLASS "F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==255))) :
             "F64 as destination format requires an even destination register"

         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rb)+((Rb)==255))) :
             "F64 as source format requires an even source register"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2F;



CLASS "Imm F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==255))) :
             "F64 as destination format requires an even destination register"


         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode1X2 = 0b1_01;

      !NencF2F;



CLASS "Const F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==255))) :
             "F64 as destination format requires an even destination register"


         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      IRRnd = rnd;
      SH = halfsel;

      Sync=S;
      Opcode2X2 = 0b01_10;

      !NencF2F;



CLASS "F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

         ERROR
           ( fmts == `F2Ffmts2_64@"F32.F64" ) -> IsEven(((Rb)+((Rb)==255))) :
             "F64 as source format requires an even source register"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2F;



CLASS "Imm F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"


         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode1X2 = 0b1_01;

      !NencF2F;



CLASS "Const F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"


         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2FfmaX_pipe =  0b100;
        F2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10101;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SrcDstFmt =* fmts;
      Dest = Rd;
      Rnd_1 = rnd;
      SH = halfsel;

      Sync=S;
      !IR;
      Opcode2X2 = 0b01_10;

      !NencF2F;



CLASS "F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /Integer(S32):dstfmt /Float32(F32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))): "Register B is out of range"

         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2I;



CLASS "Imm F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /Integer(S32):dstfmt /Float32(F32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode1X2 = 0b1_01;

      !NencF2I;



CLASS "Const F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /Integer(S32):dstfmt /Float32(F32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode2X2 = 0b01_10;

      !NencF2I;



CLASS "F2I 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

         ERROR
           ftz == `FTZ@noFTZ:
             "F16 cannot be used with FTZ"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))): "Register B is out of range"

         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2I;



CLASS "Imm F2I 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

         ERROR
           ftz == `FTZ@noFTZ:
             "F16 cannot be used with FTZ"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode1X2 = 0b1_01;

      !NencF2I;



CLASS "Const F2I 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

         ERROR
           ftz == `FTZ@noFTZ:
             "F16 cannot be used with FTZ"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode2X2 = 0b01_10;

      !NencF2I;



CLASS "F2I 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
             "U64/S64 as destination format requires an even destination register"

         ERROR
           (srcfmt == `Float64@F64) -> IsEven(((Rb)+((Rb)==255))) :
             "F64 as source format requires an even source register"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))): "Register B is out of range"

         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

         ERROR
           ftz == `FTZ@noFTZ:
             "F64 cannot be used with FTZ"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      FTZ = FTZ;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencF2I;



CLASS "Imm F2I 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
             "U64/S64 as destination format requires an even destination register"



         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

         ERROR
           ftz == `FTZ@noFTZ:
             "F64 cannot be used with FTZ"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      FTZ = FTZ;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode1X2 = 0b1_01;

      !NencF2I;



CLASS "Const F2I 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==255))) :
             "U64/S64 as destination format requires an even destination register"



         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

         ERROR
           ftz == `FTZ@noFTZ:
             "F64 cannot be used with FTZ"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        F2IfmaX_pipe =  0b100;
        F2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10110;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      FTZ = FTZ;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      SH = halfsel;
      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;
      Rnd_1 = rnd;
      Dest = Rd;
      Sync=S;


      Opcode2X2 = 0b01_10;

      !NencF2I;



CLASS "MOV32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             RegisterFAU:Rd ','
             UImm(32)*:uImm ',' UImm(4/0xf):quadMask;

    CONDITIONS

        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        MOV32Ifau_pipe =  0b01110_1000_10;
        MOV32IfmaXliteW_pipe =  0b01110_1000_10;
        MOV32IfmaX_pipe =  0b01110_1000_10;
        MOV32Ifu_pipe =  0b01110_1000_10;
        MOV32Ixlu_pipe =  0b01110_1000_10;
        MOV32I =  0b01110_1000_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm32 = uImm;
      QuadMask2 = quadMask;

      Sync=S;
      !NencMOV32I;



CLASS "MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW)@:pipe /S(noS):sync
             RegisterFAU:Rd ','
             RegisterFAU:Rb ',' UImm(4/0xf):quadMask;

    CONDITIONS

        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        MOVfau_pipe =  0b100;
        MOVfmaXliteW_pipe =  0b100;
        MOVfmaX_pipe =  0b100;
        MOVfu_pipe =  0b100;
        MOVxlu_pipe =  0b100;
        MOV =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10011;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      QuadMask = quadMask;

      Sync=S;
      !BFiller;
      !NencMOV;
      Opcode2X2 = 0b11_10;




CLASS "Imm MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW)@:pipe /S(noS):sync
             RegisterFAU:Rd ','
             SImm(20):uImm ',' UImm(4/0xf):quadMask;

    CONDITIONS

        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
           :
                "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        MOVfau_pipe =  0b100;
        MOVfmaXliteW_pipe =  0b100;
        MOVfmaX_pipe =  0b100;
        MOVfu_pipe =  0b100;
        MOVxlu_pipe =  0b100;
        MOV =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10011;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      QuadMask = quadMask;

      Sync=S;

      !NencMOV;
      Opcode1X2 = 0b1_01;




CLASS "Const MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW)@:pipe /S(noS):sync
             RegisterFAU:Rd ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' UImm(4/0xf):quadMask;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
           :
                "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        MOVfau_pipe =  0b100;
        MOVfmaXliteW_pipe =  0b100;
        MOVfmaX_pipe =  0b100;
        MOVfu_pipe =  0b100;
        MOVxlu_pipe =  0b100;
        MOV =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10011;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      QuadMask = quadMask;

      Sync=S;

      !NencMOV;
      Opcode2X2 = 0b01_10;




CLASS "SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             RegisterFAU:Rd ','
             RegisterFAU:Ra ','
             RegisterFAU:Rb ','
             [!] Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SELfau_pipe =  0b100;
        SELxlu_pipe =  0b100;
        SEL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10100;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !NencSEL;
      Opcode2X2 = 0b11_10;
      !BFiller;




CLASS "Imm SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             RegisterFAU:Rd ','
             RegisterFAU:Ra ','
             SImm(20):uImm ','
             [!] Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SELfau_pipe =  0b100;
        SELxlu_pipe =  0b100;
        SEL =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10100;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !NencSEL;
      Opcode1X2 = 0b1_01;





CLASS "Const SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             RegisterFAU:Rd ','
             RegisterFAU:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             [!] Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SELfau_pipe =  0b100;
        SELxlu_pipe =  0b100;
        SEL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10100;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !NencSEL;
      Opcode2X2 = 0b01_10;





CLASS "S2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             RegisterFAU:Rd ','
             SpecialRegister:SR;

    CONDITIONS
        ERROR
            ((SR < 43) || (SR > 47)):
                "SR43 - SR47 are invalid on SM4"

    OPCODES
        S2Rfau_pipe =  0b10000_11001_10;
        S2Rxlu_pipe =  0b10000_11001_10;
        S2R =  0b10000_11001_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      SReg = SR;
      Sync=S;
      !NencS2R;



  CLASS "B2R BAR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdBAR(BAR):barmd /S(noS):sync
             Register:Rd ','
             UImm(4):barNum;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        B2Rfe_pipe =  0b10000_10111_10;
        B2R =  0b10000_10111_10;

    ENCODING
      Opcode552 = Opcode;
      !DstPred;
      Barmd =* BarmdBAR;
      Dest = Rd;
      RegA = barNum;
      Pred = Pg;
      PredNot = Pg@not;

      Sync=S;
      !NencB2R;





 CLASS "B2R RESULT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdRESULT:barmd /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        B2Rfe_pipe =  0b10000_10111_10;
        B2R =  0b10000_10111_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Barmd =* BarmdRESULT;
      DstPred = Pd;
      Dest = Rd;
      RegA = `Register@RZ;
      Sync=S;
      !NencB2R;




 CLASS "B2R WARP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdWARP:barmd /S(noS):sync
             Register:Rd;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        B2Rfe_pipe =  0b10000_10111_10;
        B2R =  0b10000_10111_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Barmd =* BarmdWARP;
      !DstPred;
      Dest = Rd;
      RegA = `Register@RZ;
      Sync=S;
      !NencB2R;




CLASS "R2B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW)@:pipe2 /Barmd(BAR):barmd /S(noS):sync
             UImm(4):uImm ','
             Register:Rb;

    CONDITIONS
        ERROR
            (barmd != `Barmd@RESULT):
                "R2B.RESULT is invalid"

        ERROR
            (sync != `S@S):
                "R2B.S is invalid"

        ERROR
            (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
                "Register B is out of range"

    OPCODES
        R2Bfe_pipe =  0b10000_11000_10;
        R2B =  0b10000_11000_10;

    ENCODING
      Opcode552 = Opcode;
      Barmd = barmd;
      BarName = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Sync=S;
      !RegA;
      !Dest;
      !NencR2B;





CLASS "P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr
             ',' Register:Ra ',' Register:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        P2Rxlu_pipe =  0b100;
        P2R =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11001;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      H1H0a = H1H0;

      Sync=S;
      !NencP2R;
      Opcode2X2 = 0b11_10;
      !BFiller;



CLASS "Imm P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr
             ',' Register:Ra ',' SImm(20):uImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        P2Rxlu_pipe =  0b100;
        P2R =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11001;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      H1H0a = H1H0;

      Sync=S;
      !NencP2R;
      Opcode1X2 = 0b1_01;




CLASS "Const P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        P2Rxlu_pipe =  0b100;
        P2R =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11001;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      H1H0a = H1H0;

      Sync=S;
      !NencP2R;
      Opcode2X2 = 0b01_10;




ALTERNATE CLASS "Simple P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        P2Rxlu_pipe =  0b100;
        P2R =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11001;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = `Register@RZ;
      Bconst = 0xFFFF;
      H1H0a = H1H0;
      Sync=S;
      !NencP2R;
      Opcode1X2 = 0b1_01;



 CLASS "R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             PR:Pr ',' Register:Ra ',' Register:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        R2Pxlu_pipe =  0b100;
        R2P =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11010;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      H1H0a = H1H0;

      Sync=S;
      !NencP2R;
      !Dest;
      !BFiller;
      Opcode2X2 = 0b11_10;



 CLASS "Imm R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             PR:Pr ',' Register:Ra ',' UImm(20/0xffff):uImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        R2Pxlu_pipe =  0b100;
        R2P =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11010;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      H1H0a = H1H0;

      Sync=S;
      !NencP2R;
      !Dest;
      Opcode1X2 = 0b1_01;



 CLASS "Const R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
PR:Pr ',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
        ERROR constBank <= 17 :
              "Only constant banks 0..17 are legal"
        ERROR (immConstOffset & 0x3) == 0 :
              "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        R2Pxlu_pipe =  0b100;
        R2P =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11010;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      H1H0a = H1H0;

      Sync=S;
      !NencP2R;
      !Dest;
      Opcode2X2 = 0b01_10;



 CLASS "PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             RegisterFAU:Rd ',' RegisterFAU:Ra ','
             RegisterFAU:Rb ',' RegisterFAU:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        PRMTfau_pipe =  0b011;
        PRMTxlu_pipe =  0b011;
        PRMT =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b01100;
      PMode = PMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;


      Sync=S;
      !BFiller;
      !WriteCC;
      Opcode2X2 = 0b11_10;





 CLASS "Imm PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             RegisterFAU:Rd ',' RegisterFAU:Ra ','
             SImm(20):uImm ',' RegisterFAU:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        PRMTfau_pipe =  0b011;
        PRMTxlu_pipe =  0b011;
        PRMT =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX4X = 0b01100;
      PMode = PMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;


      Sync=S;

      !WriteCC;
      Opcode1X2 = 0b1_01;





 CLASS "Const PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             RegisterFAU:Rd ',' RegisterFAU:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' RegisterFAU:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        PRMTfau_pipe =  0b011;
        PRMTxlu_pipe =  0b011;
        PRMT =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b01100;
      PMode = PMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;


      Sync=S;

      !WriteCC;
      Opcode2X2 = 0b01_10;





 CLASS "Const1 PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             RegisterFAU:Rd ',' RegisterFAU:Ra ','
RegisterFAU:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        PRMTfau_pipe =  0b011;
        PRMTxlu_pipe =  0b011;
        PRMT =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX4X = 0b01100;
      PMode = PMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;


      Sync=S;

      !WriteCC;
      Opcode2X2 = 0b10_10;





 CLASS "IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' [-]RegisterFAU:Rb;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
            ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "It is illegal to negate both sources at the same time."

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        IADDfau_pipe =  0b100;
        IADDxlu_pipe =  0b100;
        IADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00010;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,Rb@negate);
      Xm = xmode;
      Sync = S;

      !BFiller;
      !NencIADD;
      Opcode2X2 = 0b11_10;

 CLASS "Imm IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
            ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        IADDfau_pipe =  0b100;
        IADDxlu_pipe =  0b100;
        IADD =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00010;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,UnaryNeg);
      Xm = xmode;
      Sync = S;


      !NencIADD;
      Opcode1X2 = 0b1_01;

 CLASS "Const IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [-]RegisterFAU:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
            ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !srcConst@negate) :
             "It is illegal to negate both sources at the same time."

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        IADDfau_pipe =  0b100;
        IADDxlu_pipe =  0b100;
        IADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00010;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,srcConst@negate);
      Xm = xmode;
      Sync = S;


      !NencIADD;
      Opcode2X2 = 0b01_10;

##IF !DEFINED(ARCH_SEMANTICS)



 CLASS "ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra ',' RegisterFAU:Rb;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%RegisterFAU(Rd) .%%optCC(writeCC), %%RegisterFAU(Ra) , -%%RegisterFAU(Rb)";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Imm ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra ',' SImm(20):uImm;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%RegisterFAU(Rd) .%%optCC(writeCC), %%RegisterFAU(Ra) , uImm .NEG";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Imm ISUB1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm ',' RegisterFAU:Ra;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%RegisterFAU(Rd) .%%optCC(writeCC), -%%RegisterFAU(Ra) , uImm";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Const ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' RegisterFAU:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%RegisterFAU(Rd) .%%optCC(writeCC), %%RegisterFAU(Ra) , -C[constBank][immConstOffset]";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Const ISUB1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' RegisterFAU:Ra;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%RegisterFAU(Rd) .%%optCC(writeCC), -%%RegisterFAU(Ra) , C[constBank][immConstOffset]";
##ENDIF



 CLASS "IADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-]RegisterFAU:Ra ',' SImm(32):sImm;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> !Ra@negate) :
             ".PO cannot be used with '-' on either input"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    OPCODES
        IADD32Ifau_pipe =  0b0100_01;
        IADD32Ixlu_pipe =  0b0100_01;
        IADD32I =  0b0100_01;

    ENCODING
      Opcode42 = Opcode;
      PSign2 = PSign32(PO,Ra@negate);
      Sat2 = SAT;
      Xm2 = xmode;
      WriteCCI = writeCC;
      Imm32 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;



 CLASS "ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb ',' UImm(5):shift;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISCADDxlu_pipe =  0b100;
        ISCADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00011;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      !BFiller;
      !NencISCADD;
      Opcode2X2 = 0b11_10;



 CLASS "Imm ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg ',' UImm(5):shift;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISCADDxlu_pipe =  0b100;
        ISCADD =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00011;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign = PSign(PO,Ra@negate,UnaryNeg);
      Sync = S;


      !NencISCADD;
      Opcode1X2 = 0b1_01;



 CLASS "Const ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' UImm(5):shift;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISCADDxlu_pipe =  0b100;
        ISCADD =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00011;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Imm5I = shift;
      PSign = PSign(PO,Ra@negate,srcConst@negate);
      Sync = S;


      !NencISCADD;
      Opcode2X2 = 0b01_10;



 CLASS "ISCADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(32):sImm ',' UImm(5):shift;

    OPCODES
        ISCADD32Ixlu_pipe =  0b101_00;
        ISCADD32I =  0b101_00;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      Imm5Ib = shift;
      Sync = S;



 CLASS "ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        ISADxlu_pipe =  0b011;
        ISAD =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11101;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      Sync=S;
      !BFiller;
      !Sat;
      !aB;
      Opcode2X2 = 0b11_10;




 CLASS "Imm ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        ISADxlu_pipe =  0b011;
        ISAD =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11101;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      Sync=S;

      !Sat;
      !aB;
      Opcode1X2 = 0b1_01;




 CLASS "Const ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        ISADxlu_pipe =  0b011;
        ISAD =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11101;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      Sync=S;

      !Sat;
      !aB;
      Opcode2X2 = 0b01_10;




 CLASS "Const1 ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        ISADxlu_pipe =  0b011;
        ISAD =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11101;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      Sync=S;

      !Sat;
      !aB;
      Opcode2X2 = 0b10_10;




 CLASS "IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra ',' RegisterFAU:Rb ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        IMNMXfau_pipe =  0b100;
        IMNMXxlu_pipe =  0b100;
        IMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00100;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !BFiller;
      !Sat;
      !aB;
      !nB;
      !aA2;
      Opcode2X2 = 0b11_10;




 CLASS "Imm IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra ',' SImm(20):uImm ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        IMNMXfau_pipe =  0b100;
        IMNMXxlu_pipe =  0b100;
        IMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00100;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;

      !Sat;
      !aB;
      !nB;
      !aA2;
      Opcode1X2 = 0b1_01;




 CLASS "Const IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' RegisterFAU:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [!]Predicate:Pa;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        IMNMXfau_pipe =  0b100;
        IMNMXxlu_pipe =  0b100;
        IMNMX =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00100;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;

      !Sat;
      !aB;
      !nB;
      !aA2;
      Opcode2X2 = 0b01_10;




 CLASS "BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        BFExlu_pipe =  0b100;
        BFE =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00000;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      Sync = S;

      !BFiller;
      !NencBFE;
      Opcode2X2 = 0b11_10;



 CLASS "Imm BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        BFExlu_pipe =  0b100;
        BFE =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00000;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      Sync = S;


      !NencBFE;
      Opcode1X2 = 0b1_01;



 CLASS "Const BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        BFExlu_pipe =  0b100;
        BFE =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00000;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      Sync = S;


      !NencBFE;
      Opcode2X2 = 0b01_10;



 CLASS "BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        BFIxlu_pipe =  0b011;
        BFI =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11110;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;

      !BFiller;
      !NencBFI;
      Opcode2X2 = 0b11_10;



 CLASS "Imm BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        BFIxlu_pipe =  0b011;
        BFI =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11110;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;


      !NencBFI;
      Opcode1X2 = 0b1_01;



 CLASS "Const BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        BFIxlu_pipe =  0b011;
        BFI =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11110;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;


      !NencBFI;
      Opcode2X2 = 0b01_10;



 CLASS "Const1 BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        BFIxlu_pipe =  0b011;
        BFI =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11110;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Sync = S;


      !NencBFI;
      Opcode2X2 = 0b10_10;



 CLASS "SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SHRxlu_pipe =  0b100;
        SHR =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00101;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XXHI;
      Brev = BREV;
      M = CWMode;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !NencSHR;
      Opcode2X2 = 0b11_10;




 CLASS "Imm SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SHRxlu_pipe =  0b100;
        SHR =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00101;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XXHI;
      Brev = BREV;
      M = CWMode;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !NencSHR;
      Opcode1X2 = 0b1_01;




 CLASS "Const SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SHRxlu_pipe =  0b100;
        SHR =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00101;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      XMode = XXHI;
      Brev = BREV;
      M = CWMode;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !NencSHR;
      Opcode2X2 = 0b01_10;




 CLASS "SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;


    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SHLxlu_pipe =  0b100;
        SHL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01001;
      WriteCC = writeCC;
      Xm = X;
      M = CWMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !NencSHL;
      Opcode2X2 = 0b11_10;




 CLASS "Imm SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SHLxlu_pipe =  0b100;
        SHL =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01001;
      WriteCC = writeCC;
      Xm = X;
      M = CWMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !NencSHL;
      Opcode1X2 = 0b1_01;




 CLASS "Const SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SHLxlu_pipe =  0b100;
        SHL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01001;
      WriteCC = writeCC;
      Xm = X;
      M = CWMode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !NencSHL;
      Opcode2X2 = 0b01_10;




 CLASS "SHF_L imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_L:shfl /CWMode(C):wmode /maxShift("32"):maxshift /SHFXMode(NONE):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' UImm(32):uImm ',' Register:Rc;

    CONDITIONS
         ERROR
           (maxshift != `maxShift@S64):
             ".S64 can only be specified with .dir = .R "

         ERROR
            (xmode != `SHFXMode@HI) && (xmode != `SHFXMode@XHI):
            ".HI and .XHI are only allowed with .dir = .R "

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
            "Register is out of range"

    PROPERTIES SECONDARY;
    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SHFxlu_pipe =  0b011;
        SHFfmaX_pipe =  0b011;
        SHF =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      Opcode1X2 = 0b1_01;
      SubOpcodeX5X = 0b11111;
      M_H = CWMode;
      XmdSHF = xmode;
      WriteCC = writeCC;
      RegC = Rc;
      MaxShift = maxshift;
      Imm06_shf = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;
      !NencSHF;



 CLASS "SHF_R imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_R:shfr /CWMode(C):wmode /maxShift("32"):maxshift /SHFXMode(NONE):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' UImm(32):uImm ',' Register:Rc;

    CONDITIONS

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SHFxlu_pipe =  0b100;
        SHFfmaX_pipe =  0b100;
        SHF =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      Opcode1X2 = 0b1_01;
      SubOpcodeX5X = 0b11111;
      M_H = CWMode;
      XmdSHF = xmode;
      WriteCC = writeCC;
      RegC = Rc;
      MaxShift = maxshift;
      Imm06_shf = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;
      !NencSHF;



 CLASS "SHF_L reg"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_L:shfl /CWMode(C):wmode /maxShift("32"):maxshift /SHFXMode(NONE):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
           (maxshift != `maxShift@S64):
             ".S64 can only be specified with .dir = .R "

         ERROR
            (xmode != `SHFXMode@HI) && (xmode != `SHFXMode@XHI):
            ".HI and .XHI are only allowed with .dir = .R "

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
            "Register is out of range"

    PROPERTIES SECONDARY;
    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SHFxlu_pipe =  0b011;
        SHFfmaX_pipe =  0b011;
        SHF =  0b011;

    ENCODING
      Opcode2X2 = 0b11_10;
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11111;
      M_H = CWMode;
      XmdSHF = xmode;
      WriteCC = writeCC;
      RegC = Rc;
      MaxShift = maxshift;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;
      !NencSHF2;



 CLASS "SHF_R reg"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SHF_R:shfr /CWMode(C):wmode /maxShift("32"):maxshift /SHFXMode(NONE):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
            "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SHFxlu_pipe =  0b100;
        SHFfmaX_pipe =  0b100;
        SHF =  0b100;

    ENCODING
      Opcode2X2 = 0b11_10;
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11111;
      M_H = CWMode;
      XmdSHF = xmode;
      WriteCC = writeCC;
      RegC = Rc;
      MaxShift = maxshift;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;
      !NencSHF2;



 CLASS "LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [~]RegisterFAU:Ra ',' [~]RegisterFAU:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        LOPfau_pipe =  0b100;
        LOPxlu_pipe =  0b100;
        LOP =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01000;
      Xm = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = Rb@invert;
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !NencLOP;
      Opcode2X2 = 0b11_10;



 CLASS "Imm LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [~]RegisterFAU:Ra ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        LOPfau_pipe =  0b100;
        LOPxlu_pipe =  0b100;
        LOP =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b01000;
      Xm = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = UnaryInv;
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !NencLOP;
      Opcode1X2 = 0b1_01;



 CLASS "Const LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [~]RegisterFAU:Ra ',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        LOPfau_pipe =  0b100;
        LOPxlu_pipe =  0b100;
        LOP =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b01000;
      Xm = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = srcConst@invert;
      WriteCC = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !NencLOP;
      Opcode2X2 = 0b01_10;



 CLASS "LOP32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [~]RegisterFAU:Ra ',' UImm(32):uImm /UnaryInv(noINV):jinv ;

    OPCODES
        LOP32Ifau_pipe =  0b001_00;
        LOP32Ixlu_pipe =  0b001_00;
        LOP32I =  0b001_00;

    ENCODING
      Opcode32 = Opcode;
      Xm_I = X;
      nB_L2 = UnaryInv;
      nA_L2 = Ra@invert;
      LOP_I = LOP;
      WriteCCI = writeCC;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = uImm;

      Sync=S;




 CLASS "FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        FLOxlu_pipe =  0b100;
        FLO =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00110;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      SH = SH;
      nB_L = Rb@invert;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;


      Sync=S;
      !BFiller;
      !RegA;
      !NencFLO;
      Opcode2X2 = 0b11_10;




 CLASS "Imm FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        FLOxlu_pipe =  0b100;
        FLO =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00110;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      SH = SH;
      nB_L = UnaryInv;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;


      Sync=S;

      !RegA;
      !NencFLO;
      Opcode1X2 = 0b1_01;




 CLASS "Const FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        FLOxlu_pipe =  0b100;
        FLO =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00110;
      Signed = IsSigned(Integer32);
      WriteCC = writeCC;
      SH = SH;
      nB_L = srcConst@invert;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);


      Sync=S;

      !RegA;
      !NencFLO;
      Opcode2X2 = 0b01_10;




 CLASS "IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        IMULfmaX_pipe =  0b100;
        IMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00111;
      WriteCC = writeCC;
      BSigned = IsSigned(us32b);
      ASigned = IsSigned(us32);
      HILO = HILO;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !BFiller;
      !NencIMUL;
      Opcode2X2 = 0b11_10;



 CLASS "Imm IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        IMULfmaX_pipe =  0b100;
        IMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b00111;
      WriteCC = writeCC;
      BSigned = IsSigned(us32b);
      ASigned = IsSigned(us32);
      HILO = HILO;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      !NencIMUL;
      Opcode1X2 = 0b1_01;



 CLASS "Const IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        IMULfmaX_pipe =  0b100;
        IMUL =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b00111;
      WriteCC = writeCC;
      BSigned = IsSigned(us32b);
      ASigned = IsSigned(us32);
      HILO = HILO;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      !NencIMUL;
      Opcode2X2 = 0b01_10;



 CLASS "IMUL32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(32):sImm;

    OPCODES
        IMUL32IfmaX_pipe =  0b00101_10;
        IMUL32I =  0b00101_10;

    ENCODING
      Opcode52 = Opcode;
      BSigned2 = IsSigned(us32b);
      ASigned2 = IsSigned(us32);
      HILO2 = HILO;
      WriteCCI = writeCC;
      Imm32 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;

      Sync=S;



 CLASS "IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        IMADfmaX_pipe =  0b010;
        IMAD =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      Sync=S;
      !BFiller;
      Opcode2X2 = 0b11_10;



 CLASS "Imm IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        IMADfmaX_pipe =  0b010;
        IMAD =  0b010;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX1X = 0;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,UnaryNeg,Rc@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      Sync=S;

      Opcode1X2 = 0b1_01;



 CLASS "Const IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [-]Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        IMADfmaX_pipe =  0b010;
        IMAD =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,srcConst@negate,Rc@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      Sync=S;

      Opcode2X2 = 0b01_10;



 CLASS "Const1 IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]Register:Rb ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        IMADfmaX_pipe =  0b010;
        IMAD =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0;
      HILO3 = HILO;
      BSigned3 = IsSigned(us32b);
      PSign3 = PSignMAD(PO,Ra@negate,Rb@negate,srcConst@negate);
      Sat = SAT;
      Xm3 = X;
      ASigned3 = IsSigned(us32);
      WriteCC = writeCC;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      Sync=S;

      Opcode2X2 = 0b10_10;



 CLASS "IMAD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                            { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(32):sImm ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
            Rd == Rc :
             "Destination register must be the same as input register 3"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
             "Register is out of range"


    OPCODES
        IMAD32IfmaX_pipe =  0b100_00;
        IMAD32I =  0b100_00;

    ENCODING
      Opcode32 = Opcode;
      BSigned4 = IsSigned(us32b);
      PSign2 = PSign(PO,Ra@negate,Rc@negate);
      ASigned2 = IsSigned(us32);
      WriteCCI = writeCC;
      Imm32 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = IDENTICAL(Rd,Rc);
      RegA = Ra;

      HILO2 = HILO;


      Sync=S;




CLASS "IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;

      SABCExt =* GetSPExtract(scext, saext, sbext);

      !BFiller;
      Opcode2X2 = 0b11_10;



CLASS "Imm IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS
         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;

      SABCExt =* GetSPExtract(scext, saext, sbext);


      Opcode1X2 = 0b1_01;



CLASS "Const IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;

      SABCExt =* GetSPExtract(scext, saext, sbext);


      Opcode2X2 = 0b01_10;



CLASS "Const1 IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Sync = S;

      SABCExt =* GetSPExtract(scext, saext, sbext);


      Opcode2X2 = 0b10_10;



CLASS "IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;

      !SAExt;
      !SBExt;
      SCExt =* sd;

      !BFiller;
      Opcode2X2 = 0b11_10;
CLASS "Imm IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS
         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;

      !SAExt;
      !SBExt;
      SCExt =* sd;


      Opcode1X2 = 0b1_01;
CLASS "Const IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Sync = S;

      !SAExt;
      !SBExt;
      SCExt =* sd;


      Opcode2X2 = 0b01_10;
CLASS "Const1 IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        IMADSPfmaX_pipe =  0b010;
        IMADSP =  0b010;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX1X = 0b1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Sync = S;

      !SAExt;
      !SBExt;
      SCExt =* sd;


      Opcode2X2 = 0b10_10;
    CLASS "STP"
    FORMAT Opcode /STPMode(noWAIT):stpmode /TPhase(noPhase):phase /S(noS):sync UImm(8):uImm;

    OPCODES
        STPfe_pipe =  0b01110_10100_10;
        STP =  0b01110_10100_10;

    ENCODING
      Opcode552 = Opcode;
      STPMode = STPMode;
      Imm8 = Imm;
      Phase = TPhase;
      !Pred;
      !PredNot;
      Sync = S;

      !NencSTP;



 CLASS "TEX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD(noLOD):lod /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
##IF DEFINED(ARCH_SEMANTICS)
             UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) <= 4)) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) == 2)) || (((tid <= 0x7) && (LOD == `LOD@LZ)) && (ParamA == `ParamA@"2D"))) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 2)) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2)) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2)) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"
        ERROR
            (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

        ERROR
            (DC == `DC@DC) -> (ParamA != `ParamA@"_3D"):
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TEX (errata 36)"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )))):
                "Register A is out of range"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"





        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) - 4))):
                "Register B is out of range"

        ERROR
            (!((tid <= 0x7) && (LOD == `LOD@LZ))) -> (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TEXtex_pipe =  0b0110_01;
        TEX =  0b0110_01;

    ENCODING
      Opcode42 = Opcode;
      TidB = tid;
      LOD = LOD;
      AOFFI = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;


 ALTERNATE CLASS "TEX legacy style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD(noLOD):lod /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
##IF DEFINED(ARCH_SEMANTICS)
              UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
              UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) <= 4)) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) == 2)) || (((tid <= 0x7) && (LOD == `LOD@LZ)) && (ParamA == `ParamA@"2D"))) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 2)) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2)) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2)) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"
        ERROR
            (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

        ERROR
            (DC == `DC@DC) -> (ParamA != `ParamA@"_3D"):
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TEX (errata 36)"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )))):
                "Register A is out of range"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"





        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) - 4))):
                "Register B is out of range"

        ERROR
            (!((tid <= 0x7) && (LOD == `LOD@LZ))) -> (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TEXtex_pipe =  0b0110_01;
        TEX =  0b0110_01;

    ENCODING
      Opcode42 = Opcode;
      TidBTEX = tid;
      TidBSAMP = smp;
      LOD = LOD;
      AOFFI = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Sync = S;


##IF DEFINED(ARCH_SEMANTICS)
 CLASS "LDG CT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDG_E(noE):e /LDGcop1(CT):cop /CInteger("32"):size /TPhase(noPhase):phase /S(noS):sync
                               Register:Rd ',' [Register:Ra];
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDGtex_pipe =  0b0110_01;
        LDG =  0b0110_01;

    ENCODING
      Opcode42 = Opcode;
      TidBWmsk = LDGSizeMask(size);
      LOD = `LOD@LZ;
      Phase = TPhase;
      ParamA = LDG_E;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = `Register@RZ;
      Sync = S;
      !AOFFI;
      !DC;
      !NDV;
      !NODEP;
##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "LDG CT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDG_E(noE):e /LDGcop1(CT):cop /CInteger("32"):size /TPhase(noPhase):phase /S(noS):sync Register:Rd ',' [Register:Ra];

    OPCODES
        LDGtex_pipe =  0;
        LDG =  0;

    REMAP "@%%Predicate(Pg) TEX .LZ .%%TPhase(phase) .%%S(sync) %%Register(Rd), %%Register(Ra), RZ, size, %%ParamA(e), fun@LDGSizeWmskMask(size)";
##ENDIF



##IF DEFINED(ARCH_SEMANTICS)
ALTERNATE CLASS "CCTLT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyIvall:ivall /TPhase(noPhase):phase /S(noS):sync ;

    OPCODES
        CCTLTtex_pipe =  0b0110_01;
        CCTLT =  0b0110_01;

    ENCODING
      Opcode42 = Opcode;
      TidB = 7;
      LOD = `LOD@LZ;
      Phase = TPhase;
      ParamA = `ParamA@"1D";
      Pred = Pg;
      PredNot = Pg@not;
      RegA = `Register@RZ;
      RegB = `Register@RZ;
      Dest = `Register@RZ;
      Sync = S;
      !AOFFI;
      !DC;
      !NDV;
      !NODEP;
      !Wmsk;
##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
CLASS "CCTLT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyIvall:ivall /TPhase(noPhase):phase /S(noS):sync ;

    OPCODES
        CCTLTtex_pipe =  0;
        CCTLT =  0;

    REMAP "@%%Predicate(Pg) TEX .LZ .%%TPhase(phase) .%%S(sync) RZ, RZ, RZ, 7, _1D, 0";
##ENDIF



 CLASS "TEX B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /LOD(noLOD):lod /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
##IF DEFINED(ARCH_SEMANTICS)
             UImm(13)@:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             UImm(13)@:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"

        ERROR
            (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

        ERROR
            (DC == `DC@DC) -> (ParamA != `ParamA@"_3D"):
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TEX (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TEXtex_pipe =  0b01111_10110_10;
        TEX =  0b01111_10110_10;

    ENCODING
      Opcode552 = Opcode;
      LOD = LOD;
      AOFFI = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !NencTEXB;
      Sync=S;


 ALTERNATE CLASS "TEX B legacy style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /LOD(noLOD):lod /TOFF1(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
##IF DEFINED(ARCH_SEMANTICS)
             UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"

        ERROR
            (TOFF1 == `TOFF1@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

        ERROR
            (DC == `DC@DC) -> (ParamA != `ParamA@"_3D"):
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TEX (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TEXtex_pipe =  0b01111_10110_10;
        TEX =  0b01111_10110_10;

    ENCODING
      Opcode552 = Opcode;
      LOD = LOD;
      AOFFI = TOFF1;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      !NencTEXB;
      Sync=S;



 CLASS "TLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms
             /CL(noCL):clamp /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) <= 4)) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 4)) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) == 2)) || (((tid <= 0x7) && (LOD1 == `LOD1@LZ)) && (ParamA == `ParamA@"2D"))) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 2)) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2)) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2)) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"
        ERROR
            (ParamA != `ParamA@CUBE):
                "Illegal instruction encoding: CUBE is not supported"

        ERROR
            (ParamA != `ParamA@ARRAY_CUBE):
                "Illegal instruction encoding: ARRAY_CUBE is not supported"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (MS == `MS@noMS || CL == `CL@noCL):
                "Illegal instruction encoding: .MS cannot be combined with .CL"

        ERROR
            (MS == `MS@MS) -> (LOD1 == `LOD1@LZ):
                "Illegal instruction encoding: .MS can only be used with the .LZ LOD option"

        ERROR
            (MS == `MS@MS) -> (ParamA == `ParamA@"2D" || ParamA == `ParamA@ARRAY_2D):
                "Illegal instruction encoding: .MS can only be used with 2D/ARRAY_2D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD (errata 36)"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) )))):
                "Register A is out of range"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 4)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"





        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 4)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) - 4))):
                "Register B is out of range"

        ERROR
            (!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) -> (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TLDtex_pipe =  0b01110_0_10;
        TLD =  0b01110_0_10;

    ENCODING
      Opcode512 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB2 = tid;
      Wmsk = wmsk;
      LOD1 = LOD1;
      TOFF1 = TOFF1;
      MS = MS;
      CL = CL;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;



##IF DEFINED(ARCH_SEMANTICS)
 CLASS "LDG CG CS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDG_E(noE):e /LDGcop2:cop /CInteger("32"):size /TPhase(noPhase):phase /S(noS):sync
                               Register:Rd ',' [Register:Ra];
    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDGtex_pipe =  0b01110_0_10;
        LDG =  0b01110_0_10;

    ENCODING
      Opcode512 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = `Register@RZ;
      TidBWmsk2 = LDGSizeMask(size);
      LOD1 = `LOD1@LZ;
      CL = LDGcop2;
      ParamA = LDG_E;
      Phase = TPhase;
      Sync = S;
      !TOFF1;
      !NODEP;
      !MS;
##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "LDG CG CS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDG_E(noE):e /LDGcop2:cop /CInteger("32"):size /TPhase(noPhase):phase /S(noS):sync Register:Rd ',' [Register:Ra];

    OPCODES
        LDGtex_pipe =  0;
        LDG =  0;

    REMAP "@%%Predicate(Pg) TLD .LZ .%%CL(cop) .%%TPhase(phase) .%%S(sync) %%Register(Rd), %%Register(Ra), RZ, size, %%ParamA(e), fun@LDGSizeWmskMask(size) ";
##ENDIF



 CLASS "TLD B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms
             /CL(noCL):clamp /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
             ',' UImm(13)@:tid
##IF DEFINED(ARCH_SEMANTICS)
             ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz 64"

        ERROR
            (ParamA != `ParamA@CUBE):
                "Illegal instruction encoding: CUBE is not supported"

        ERROR
            (ParamA != `ParamA@ARRAY_CUBE):
                "Illegal instruction encoding: ARRAY_CUBE is not supported"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (MS == `MS@noMS || CL == `CL@noCL):
                "Illegal instruction encoding: .MS cannot be combined with .CL"

        ERROR
            (MS == `MS@MS) -> (LOD1 == `LOD1@LZ):
                "Illegal instruction encoding: .MS can only be used with the .LZ LOD option"

        ERROR
            (MS == `MS@MS) -> (ParamA == `ParamA@"2D" || ParamA == `ParamA@ARRAY_2D):
                "Illegal instruction encoding: .MS can only be used with 2D/ARRAY_2D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TLDtex_pipe =  0b01111_00000_10;
        TLD =  0b01111_00000_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Wmsk = wmsk;
      LOD1 = LOD1;
      TOFF1 = TOFF1;
      MS = MS;
      CL = CL;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;
      !NencTLDB;



  CLASS "TLD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: PTP is not supported with CubeMap textures"

        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            ((ParamA != `ParamA@"1D") && (ParamA != `ParamA@ARRAY_1D)):
                "Illegal instruction encoding: 1D is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD4 (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TLD4tex_pipe =  0b0111_01;
        TLD4 =  0b0111_01;

    ENCODING
      Opcode42 = Opcode;
      TidB = tid;
      TexComp = TexComp;
      TOFF2 = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;



  CLASS "TLD4 B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /BOnly:bindless /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)@:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)@:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: PTP is not supported with CubeMap textures"

        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            ((ParamA != `ParamA@"1D") && (ParamA != `ParamA@ARRAY_1D)):
                "Illegal instruction encoding: 1D is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD4 (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TLD4tex_pipe =  0b01111_10111_10;
        TLD4 =  0b01111_10111_10;

    ENCODING
      Opcode552 = Opcode;
      TexComp = TexComp;
      TOFF2 = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !NencTEXB;




  ALTERNATE CLASS "TLD4 Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: PTP is not supported with CubeMap textures"

        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            ((ParamA != `ParamA@"1D") && (ParamA != `ParamA@ARRAY_1D)):
                "Illegal instruction encoding: 1D is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD4 (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TLD4tex_pipe =  0b0111_01;
        TLD4 =  0b0111_01;

    ENCODING
      Opcode42 = Opcode;
      TidBTEX = tid;
      TidBSAMP = smp;
      TexComp = TexComp;
      TOFF2 = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;





  ALTERNATE CLASS "TLD4 B Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /BOnly:bindless /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: PTP is not supported with CubeMap textures"

        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            ((ParamA != `ParamA@"1D") && (ParamA != `ParamA@ARRAY_1D)):
                "Illegal instruction encoding: 1D is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD4 (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TLD4tex_pipe =  0b01111_10111_10;
        TLD4 =  0b01111_10111_10;

    ENCODING
      Opcode552 = Opcode;
      TexComp = TexComp;
      TOFF2 = TOFF2;
      DC = DC;
      NDV = NDV;
      ParamA = ParamA;
      Wmsk = wmsk;
      Phase = TPhase;
      NODEP = NODEP;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;
      !NencTEXB;



  CLASS "TMML"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ)@:Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TMML (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    OPCODES
        TMMLtex_pipe =  0b01110_11010_10;
        TMML =  0b01110_11010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidB3 = tid;
      Wmsk = wmsk;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;

      !NencTMML;



  ALTERNATE CLASS "TMML Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ)@:Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TMML (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    OPCODES
        TMMLtex_pipe =  0b01110_11010_10;
        TMML =  0b01110_11010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidBTEX3 = tid;
      TidBSAMP3 = smp;
      Wmsk = wmsk;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;

      !NencTMML;



  CLASS "TMML.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)@:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)@:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TMML (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    PROPERTIES SECONDARY;

    OPCODES
        TMMLtex_pipe =  0b01111_11010_10;
        TMML =  0b01111_11010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Wmsk = wmsk;
      NDV = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;

      !NencTMMLB;



  ALTERNATE CLASS "TMML.B Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /LODOnly:lod
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TMML (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    PROPERTIES SECONDARY;

    OPCODES
        TMMLtex_pipe =  0b01111_11010_10;
        TMML =  0b01111_11010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Wmsk = wmsk;
      NDV = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;

      !NencTMMLB;







  CLASS "TXA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
##IF DEFINED(ARCH_SEMANTICS)
             Register:Rd ',' Register:Ra ',' UImm(13)*:tid ',' UImm(4/15):wmsk ;
##ELSE
             Register:Rd ',' Register:Ra ',' UImm(13)*:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXA (errata 36)"

        ERROR
            ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-3))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"

    OPCODES
        TXAtex_pipe =  0b01110_11011_10;
        TXA =  0b01110_11011_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidB3 = tid;
      Wmsk = wmsk;
      NDVa = NDV;
      NODEP = NODEP;
      Phase = TPhase;
      Sync = S;

      !NencTXA;
  ALTERNATE CLASS "TXA Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ','
             UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXA (errata 36)"

        ERROR
            ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-3))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"

    OPCODES
        TXAtex_pipe =  0b01110_11011_10;
        TXA =  0b01110_11011_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidBTEX3 = tid;
      TidBSAMP3 = smp;
      Wmsk = wmsk;
      NDVa = NDV;
      NODEP = NODEP;
      Phase = TPhase;
      Sync = S;

      !NencTXA;



  CLASS "TXD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(13)*:tid ',' ParamA:paramA
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: Cube is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXD (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) <= 4) && (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TXDtex_pipe =  0b01110_1100_10;
        TXD =  0b01110_1100_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB3 = tid;
      Wmsk = wmsk;
      TOFF1b = TOFF1;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;



  ALTERNATE CLASS "TXD Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: Cube is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXD (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) <= 4) && (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TXDtex_pipe =  0b01110_1100_10;
        TXD =  0b01110_1100_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidBTEX3 = tid;
      TidBSAMP3 = smp;
      Wmsk = wmsk;
      TOFF1b = TOFF1;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;



  CLASS "TXD.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(13)@:tid ',' ParamA:paramA
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: Cube is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXD (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TXDtex_pipe =  0b01111_1100_10;
        TXD =  0b01111_1100_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Wmsk = wmsk;
      TOFF1b = TOFF1;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;

      !TidB3;



  ALTERNATE CLASS "TXD.B Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' ParamA:paramA
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 4) -> ((((Rb)+((Rb)==255)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) == 2) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 2) -> ((((Ra)+((Ra)==255)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: Cube is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXD (errata 36)"

        ERROR
            (((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) <= 4) && ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1)))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-(( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (TOFF1 == `TOFF1@AOFFI) ) + 1) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    PROPERTIES SECONDARY;

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        TXDtex_pipe =  0b01111_1100_10;
        TXD =  0b01111_1100_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Wmsk = wmsk;
      TOFF1b = TOFF1;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      Sync = S;

      !TidB3;
  CLASS "TXQ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' TXQMode:query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"

    OPCODES
        TXQtex_pipe =  0b01110_10101_10;
        TXQ =  0b01110_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidB3 = tid;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(TXQMode);
      Sync = S;

      !NencTXQ;







  ALTERNATE CLASS "TXQ Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' TXQMode:query
             ',' UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"

    OPCODES
        TXQtex_pipe =  0b01110_10101_10;
        TXQ =  0b01110_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidBTEX3 = tid;
      TidBSAMP3 = smp;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(TXQMode);
      Sync = S;

      !NencTXQ;
  ALTERNATE CLASS "TXQ Imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' UImm(5):query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"

    OPCODES
        TXQtex_pipe =  0b01110_10101_10;
        TXQ =  0b01110_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidB3 = tid;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(query);
      Sync = S;

      !NencTXQ;



  ALTERNATE CLASS "TXQ Imm Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' UImm(5):query
             ',' UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"

    OPCODES
        TXQtex_pipe =  0b01110_10101_10;
        TXQ =  0b01110_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidBTEX3 = tid;
      TidBSAMP3 = smp;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(query);
      Sync = S;

      !NencTXQ;
  CLASS "TXQ.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' TXQMode:query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)@:tid ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)@:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"


    PROPERTIES SECONDARY;

    OPCODES
        TXQtex_pipe =  0b01111_10101_10;
        TXQ =  0b01111_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(TXQMode);
      Sync = S;

      !TidB3;
      !NencTXQ;







  ALTERNATE CLASS "TXQ.B Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' TXQMode:query
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"


    PROPERTIES SECONDARY;

    OPCODES
        TXQtex_pipe =  0b01111_10101_10;
        TXQ =  0b01111_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(TXQMode);
      Sync = S;

      !TidB3;
      !NencTXQ;
  ALTERNATE CLASS "TXQ.B Imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' UImm(5):query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)@:tid ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)@:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"


    PROPERTIES SECONDARY;

    OPCODES
        TXQtex_pipe =  0b01111_10101_10;
        TXQ =  0b01111_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(query);
      Sync = S;

      !TidB3;
      !NencTXQ;



  ALTERNATE CLASS "TXQ.B Imm Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /BOnly:bindless /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' UImm(5):query
             ',' UImm(8)@:tid ',' UImm(5)@:smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                "Register A is not aligned"

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==255)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==255)) & 0x3) == 0):
                "Register D is not aligned"


    PROPERTIES SECONDARY;

    OPCODES
        TXQtex_pipe =  0b01111_10101_10;
        TXQ =  0b01111_10101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Wmsk = wmsk;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(query);
      Sync = S;

      !TidB3;
      !NencTXQ;



 CLASS "TEXDEPBAR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync UImm(6):uImm ;

    OPCODES
        TEXDEPBARbru_pipe =  0b01110_11100_10;
        TEXDEPBAR =  0b01110_11100_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Imm06Tex = uImm;
      !NencTEXDEPBAR;
      Sync=S;







CLASS "LDC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_n64("32"):size /AdMode(IA):ad /S(noS):sync
RegisterFAU:Rd ',' C:srcConst[UImm(5/0*):constBank]* [NonZeroRegisterFAU:Ra + SImm(17/0)*:sImm];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDCxlu_pipe =  0b10010;
        LDC =  0b10010;

    ENCODING
      Opcode52 = 0b01111_10;
      SubOpcodeX5X = Opcode;
      LSSize2 =* CInteger_n64;
      AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;

      !NencLDC;
      Sync=S;



CLASS "I LDC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_n64("32"):size /AdMode(IA):ad /S(noS):sync
RegisterFAU:Rd ',' C:srcConst[UImm(5/0*):constBank]* [ZeroRegister(RZ):Ra + SImm(17)*:immConstOffset];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDCxlu_pipe =  0b10010;
        LDC =  0b10010;

    ENCODING
      Opcode52 = 0b01111_10;
      SubOpcodeX5X = Opcode;
      LSSize2 =* CInteger_n64;
      AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;

      !NencLDC;
      Sync=S;



CLASS "LDC 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_64:size /AdMode(IA):ad /S(noS):sync
RegisterFAU:Rd ',' C:srcConst[UImm(5/0*):constBank]* [NonZeroRegisterFAU:Ra + SImm(17/0)*:sImm];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDCxlu_pipe =  0b10010;
        LDC =  0b10010;

    ENCODING
      Opcode52 = 0b01111_10;
      SubOpcodeX5X = Opcode;
      LSSize2 = 5;
      AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;

      !NencLDC;
      Sync=S;




CLASS "I LDC 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger_64:size /AdMode(IA):ad /S(noS):sync
RegisterFAU:Rd ',' C:srcConst[UImm(5/0*):constBank]* [ZeroRegister(RZ):Ra + SImm(17)*:immConstOffset];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDCxlu_pipe =  0b10010;
        LDC =  0b10010;

    ENCODING
      Opcode52 = 0b01111_10;
      SubOpcodeX5X = Opcode;
      LSSize2 = 5;
      AdMode = AdMode;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Dest = Rd;

      !NencLDC;
      Sync=S;




CLASS "VILD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' V:srcVert[NonZeroRegister:Ra + SImm(8/0)*:sImm];

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        VILDagu_pipe =  0b01111_11110_10;
        VILD =  0b01111_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm8 = sImm;
      !NencVILD;
      Sync=S;




CLASS "I VILD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' V:srcVert[ZeroRegister(RZ):Ra + UImm(8/0)*:uImm];

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        VILDagu_pipe =  0b01111_11110_10;
        VILD =  0b01111_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm8 = uImm;
      !NencVILD;
      Sync=S;




CLASS "I ALD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /P(noP):p /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register(RZ):Rb;

    CONDITIONS

        ERROR
          (((Rd)+((Rd)==255)) % ARegAlignment(AInteger)) == 0 :
            "Output register improperly aligned for specified operation size"

        ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register D is out of range"

        ERROR
          (P == `P@P) -> (Rb == `Register@RZ):
            "Register B is ignored when using the .P modifier"

        ERROR
          (P == `P@P) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

        ERROR
          (P == `P@noP) -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))):
            "Register B is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        ALDagu_pipe =  0b01111_11011_10;
        ALD =  0b01111_11011_10;

    ENCODING
      Opcode552 = Opcode;
      AIO = AIO;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegBALD = Rb;
      Imm10 = uImm;
      ALSize = AInteger;

      !NencALD;
      !msbImm11;
      Sync=S;




CLASS "ALD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /POnly:p /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register(RZ):Rb;

    CONDITIONS

        ERROR
          (((Rd)+((Rd)==255)) % ARegAlignment(AInteger)) == 0 :
            "Output register improperly aligned for specified operation size"

        ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register D is out of range"

        ERROR
          (Rb == `Register@RZ):
            "Register B is ignored when using the .P modifier"

        ERROR
          ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        ALDagu_pipe =  0b01111_11011_10;
        ALD =  0b01111_11011_10;

    ENCODING
      Opcode552 = Opcode;
      AIO = AIO;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegBALD = Rb;
      Imm11 = sImm;
      ALSize = AInteger;

      !NencALD;
      Sync=S;




CLASS "ALD PHYS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /Phys:phys /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A:srcAttr[NonZeroRegister:Ra]
             ',' Register(RZ):Rb;

    CONDITIONS

        ERROR
          (((Rd)+((Rd)==255)) % ARegAlignment(AInteger)) == 0 :
            "Output register improperly aligned for specified operation size"

        ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        ALDagu_pipe =  0b01111_11011_10;
        ALD =  0b01111_11011_10;

    ENCODING
      Opcode552 = Opcode;
      AIO = AIO;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegBALD = Rb;
      Imm11 = 0;
      ALSize = AInteger;

      !NencALD;
      Sync=S;



CLASS "I AST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /P(noP):p /AInteger("32"):size /S(noS):sync
             A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS

        ERROR
          (((Rb)+((Rb)==255)) % ARegAlignment(AInteger)) == 0 :
            "Input register improperly aligned for specified operation size"

        ERROR
          ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register B is out of range"

    OPCODES
        ASTagu_pipe =  0b01111_11100_10;
        AST =  0b01111_11100_10;

    ENCODING
      Opcode552 = Opcode;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegBAST = Rb;
      Imm10 = uImm;
      ALSize = AInteger;

      !AIO;
      !NencALD;
      !msbImm11;
      Sync=S;


CLASS "AST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /AInteger("32"):size /S(noS):sync
             A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS

        ERROR
          (((Rb)+((Rb)==255)) % ARegAlignment(AInteger)) == 0 :
            "Input register improperly aligned for specified operation size"

        ERROR
          ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register B is out of range"

        ERROR
          ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

    OPCODES
        ASTagu_pipe =  0b01111_11100_10;
        AST =  0b01111_11100_10;

    ENCODING
      Opcode552 = Opcode;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegBAST = Rb;
      Imm11 = sImm;
      ALSize = AInteger;

      !NencALD;
      !AIO;
      Sync=S;




CLASS "AST PHYS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Phys:phys /AInteger("32"):size /S(noS):sync
             A:srcAttr[NonZeroRegister:Ra] ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS

        ERROR
          (((Rb)+((Rb)==255)) % ARegAlignment(AInteger)) == 0 :
            "Input register improperly aligned for specified operation size"

        ERROR
          ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register B is out of range"

        ERROR
          ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

    OPCODES
        ASTagu_pipe =  0b01111_11100_10;
        AST =  0b01111_11100_10;

    ENCODING
      Opcode552 = Opcode;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegBAST = Rb;
      Imm11 = 0;
      ALSize = AInteger;

      !NencALD;
      !AIO;
      Sync=S;



CLASS "AL2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /AInteger("32"):size /S(noS):sync
             Register:Rd ',' NonZeroRegister:Ra ',' SImm(11/0):sImm;

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    OPCODES
        AL2Pxlu_pipe =  0b01111_10100_10;
        AL2P =  0b01111_10100_10;

    ENCODING
      Opcode552 = Opcode;
      ALSize = AInteger;
      AIO = AIO;
      Imm11 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      !NencALD;
      !RegC;
      !P;
      Sync=S;



CLASS "I AL2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /AInteger("32"):size /S(noS):sync
             Register:Rd ',' ZeroRegister(RZ):Ra ',' UImm(10/0):uImm;

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    OPCODES
        AL2Pxlu_pipe =  0b01111_10100_10;
        AL2P =  0b01111_10100_10;

    ENCODING
      Opcode552 = Opcode;
      ALSize = AInteger;
      AIO = AIO;
      Imm10 = uImm;
      Pred = Pg;
      PredNot = Pg@not;

      Dest = Rd;
      RegA =* Ra;

      !NencALD;
      !RegC;
      !P;
      !msbImm11;
      Sync=S;




CLASS "OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS





        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        OUTagu_pipe =  0b011;
        OUT =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11100;
      RegA = Ra;
      RegB = Rb;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      OutType = OutType;

      Sync=S;
      !NencOUT;
      Opcode2X2 = 0b11_10;
      !BFiller;



CLASS "Imm OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
             Register:Rd ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS





        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        OUTagu_pipe =  0b011;
        OUT =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11100;
      RegA = Ra;
      Bconst=uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      OutType = OutType;

      Sync=S;
      !NencOUT;
      Opcode1X2 = 0b1_01;




CLASS "Const OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
Register:Rd ',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"






        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        OUTagu_pipe =  0b011;
        OUT =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11100;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      OutType = OutType;

      Sync=S;
      !NencOUT;
      Opcode2X2 = 0b01_10;




 CLASS "PIXLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd ','
             [NonZeroRegister:Ra + SImm(8/0)*:sImm];

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        PIXLDfe_pipe =  0b01111_11101_10;
        PIXLD =  0b01111_11101_10;

    ENCODING
      Opcode552 = Opcode;
      DstPred = Pd;
      PixMode = PixMode;
      Imm8 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      Sync=S;
      !NencPIXLD;




 CLASS "I PIXLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd ','
             [ZeroRegister(RZ):Ra + UImm(8/0)*:uImm];

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        PIXLDfe_pipe =  0b01111_11101_10;
        PIXLD =  0b01111_11101_10;

    ENCODING
      Opcode552 = Opcode;
      DstPred = Pd;
      PixMode = PixMode;
      Imm8 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      Sync=S;
      !NencPIXLD;




 ALTERNATE CLASS "PIXLD simple"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd;

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        PIXLDfe_pipe =  0b01111_11101_10;
        PIXLD =  0b01111_11101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      DstPred = Pd;
      RegA = `Register@RZ;
      PixMode = PixMode;
      Imm8 = 0;

      Sync=S;
      !NencPIXLD;




 CLASS "LD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(32/0)*:sImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==255)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDagu_pipe =  0b110_00;
        LD =  0b110_00;

    ENCODING
      Opcode32 = Opcode;
      COP = LoadCacheOp;
      LSSize =* LDInteger;
      E = E;
      Imm32 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      Sync=S;
 CLASS "I LD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==255)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDagu_pipe =  0b110_00;
        LD =  0b110_00;

    ENCODING
      Opcode32 = Opcode;
      COP = LoadCacheOp;
      LSSize =* LDInteger;
      E = E;
      Imm32 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      Sync=S;
CLASS "SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             Register:Rc;

    CONDITIONS ERROR IsEven(Rb+(Rb==255)) && (Rc == (Rb+1)) : "Rb and Rc need to be vector-aligned"
 ERROR !(Rb==255): "Rb cannot be RZ"
 ERROR !(Rc==255): "Rc cannot be RZ"

    OPCODES
        SHFLagu_pipe =  0b01111_00010_10;
        SHFL =  0b01111_00010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      Shflmd = shflmd;

      !SHFLFiller;
      CFix_SHFL=0;
      BFix_SHFL=0;
      PredDest = Pd;
      Sync=S;
      !NencSHFL;




CLASS "b SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             UImm(5):uImm5 ','
             Register:Rc;



    OPCODES
        SHFLagu_pipe =  0b01111_00010_10;
        SHFL =  0b01111_00010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      shfl_imm5 = uImm5;
!bit6_RegB;
      RegC = Rc;
      Shflmd = shflmd;

      !SHFLFiller;
      CFix_SHFL=0;
      BFix_SHFL=1;
      PredDest = Pd;
      Sync=S;
      !NencSHFL;




CLASS "c b SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             UImm(5):uImm5 ','
             UImm(13):uImm13;



    OPCODES
        SHFLagu_pipe =  0b01111_00010_10;
        SHFL =  0b01111_00010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      shfl_imm5 = uImm5;
!bit6_RegB;
      Imm13 = uImm13;
      Shflmd = shflmd;


      CFix_SHFL=1;
      BFix_SHFL=1;
      PredDest = Pd;
      Sync=S;
      !NencSHFL;




CLASS "c SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             UImm(13):uImm13;



    OPCODES
        SHFLagu_pipe =  0b01111_00010_10;
        SHFL =  0b01111_00010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Imm13 = uImm13;
      Shflmd = shflmd;


      CFix_SHFL=1;
      BFix_SHFL=0;
      PredDest = Pd;
      Sync=S;
      !NencSHFL;




 CLASS "ST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

    OPCODES
        STagu_pipe =  0b111_00;
        ST =  0b111_00;

    ENCODING
      Opcode32 = Opcode;
      COP = StoreCacheOp;
      LSSize = CInteger;
      E = E;
      Imm32 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;

      Sync=S;




 CLASS "I ST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

    OPCODES
        STagu_pipe =  0b111_00;
        ST =  0b111_00;

    ENCODING
      Opcode32 = Opcode;
      COP = StoreCacheOp;
      LSSize = CInteger;
      E = E;
      Imm32 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;

      Sync=S;




 CLASS "ATOM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             NonZeroRegister:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb ',' Register(RZ)@:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           !(atom == `AtomOp@SAFEADD && size != `SQInteger@U64) :
             "ATOM.SAFEADD can only be used with size .U64"

         ERROR
           ((atom == `AtomOp@INC) || (atom == `AtomOp@DEC)) -> (size != `SQInteger@S32):
             "ATOM.INC/DEC cannot be used with S32"

         ERROR
           (size == `SQInteger@U64) -> ((atom == `AtomOp@EXCH) || (atom == `AtomOp@ADD) || (atom == `AtomOp@AND)
                                    || (atom == `AtomOp@OR) || (atom == `AtomOp@XOR) || (atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)
                                    || (atom == `AtomOp@SAFEADD)):
             "This operation is not supported with U64"

         ERROR
           (size == `SQInteger@S64) -> ((atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "Only ATOM.MIN/MAX can be used with S64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

    OPCODES
        ATOMagu_pipe =  0b01101_10;
        ATOM =  0b01101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest =* Rd;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      AtomE = E;
      Sync = S;


 CLASS "I ATOM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             NonZeroRegister:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb ',' Register(RZ)@:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           !(atom == `AtomOp@SAFEADD && size != `SQInteger@U64) :
             "ATOM.SAFEADD can only be used with size .U64"

         ERROR
           ((atom == `AtomOp@INC) || (atom == `AtomOp@DEC)) -> (size != `SQInteger@S32):
             "ATOM.INC/DEC cannot be used with S32"

         ERROR
           (size == `SQInteger@U64) -> ((atom == `AtomOp@EXCH) || (atom == `AtomOp@ADD) || (atom == `AtomOp@AND)
                                    || (atom == `AtomOp@OR) || (atom == `AtomOp@XOR) || (atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)
                                    || (atom == `AtomOp@SAFEADD)):
             "This operation is not supported with U64"

         ERROR
           (size == `SQInteger@S64) -> ((atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "Only ATOM.MIN/MAX can be used with S64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

    OPCODES
        ATOMagu_pipe =  0b01101_10;
        ATOM =  0b01101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest =* Rd;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      AtomE = E;
      Sync = S;


ALTERNATE CLASS "ATOM Rd is RZ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             ZeroRegister:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb ',' Register(RZ)@:Rc;

    CONDITIONS
         ERROR
           (Rd != `ZeroRegister@RZ) :
             "In SM4, ATOM instructions may not have Rd==RZ, since that is reserved for RED encoding"

         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           !(atom == `AtomOp@SAFEADD && size != `SQInteger@U64) :
             "ATOM.SAFEADD can only be used with size .U64"

         ERROR
           ((atom == `AtomOp@INC) || (atom == `AtomOp@DEC)) -> (size != `SQInteger@S32):
             "ATOM.INC/DEC cannot be used with S32"

         ERROR
           (size == `SQInteger@U64) -> ((atom == `AtomOp@EXCH) || (atom == `AtomOp@ADD) || (atom == `AtomOp@AND)
                                    || (atom == `AtomOp@OR) || (atom == `AtomOp@XOR) || (atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)
                                    || (atom == `AtomOp@SAFEADD)):
             "This operation is not supported with U64"

         ERROR
           (size == `SQInteger@S64) -> ((atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "Only ATOM.MIN/MAX can be used with S64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

    OPCODES
        ATOMagu_pipe =  0b01101_10;
        ATOM =  0b01101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      AtomE = E;
      Sync = S;


ALTERNATE CLASS "I ATOM Rd is RZ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             ZeroRegister:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb ',' Register(RZ)@:Rc;

    CONDITIONS
         ERROR
           (Rd != `ZeroRegister@RZ) :
             "In SM4, ATOM instructions may not have Rd==RZ, since that is reserved for RED encoding"

         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           !(atom == `AtomOp@SAFEADD && size != `SQInteger@U64) :
             "ATOM.SAFEADD can only be used with size .U64"

         ERROR
           ((atom == `AtomOp@INC) || (atom == `AtomOp@DEC)) -> (size != `SQInteger@S32):
             "ATOM.INC/DEC cannot be used with S32"

         ERROR
           (size == `SQInteger@U64) -> ((atom == `AtomOp@EXCH) || (atom == `AtomOp@ADD) || (atom == `AtomOp@AND)
                                    || (atom == `AtomOp@OR) || (atom == `AtomOp@XOR) || (atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)
                                    || (atom == `AtomOp@SAFEADD)):
             "This operation is not supported with U64"

         ERROR
           (size == `SQInteger@S64) -> ((atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "Only ATOM.MIN/MAX can be used with S64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

    OPCODES
        ATOMagu_pipe =  0b01101_10;
        ATOM =  0b01101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      AtomE = E;
      Sync = S;


 CLASS "ATOM CAS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

          ERROR
           (((Rd)+((Rd)==255)) % CASRegAlignment(CASInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==255)) == (((Rb)+((Rb)==255)) + CASRegAlignment(CASInteger))):
             "ATOM.CAS requires Rb and Rc to be vector-consecutive"

         ERROR
           (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==255))):
             "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

         ERROR
           (size == `CASInteger@"32") -> (((Rc)+((Rc)==255))%2 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

         ERROR
           (size == `CASInteger@"64") -> (((Rb)+((Rb)==255))%4 == 0):
             "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

         ERROR
           (size == `CASInteger@"64") -> (((Rc)+((Rc)==255))%4 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"


    PROPERTIES SECONDARY;

    OPCODES
        ATOMagu_pipe =  0b01110_1111_10;
        ATOM =  0b01110_1111_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Size1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      Dest = Rd;
      RegA =* Ra;
      Imm20a = sImm;
      bcRZ = 0;
      AtomE = E;
      Sync = S;


 CLASS "I ATOM CAS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' NonZeroRegister:Rb ',' NonZeroRegister:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

          ERROR
           (((Rd)+((Rd)==255)) % CASRegAlignment(CASInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==255)) == (((Rb)+((Rb)==255)) + CASRegAlignment(CASInteger))):
             "ATOM.CAS requires Rb and Rc to be vector-consecutive"

         ERROR
           (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==255))):
             "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

         ERROR
           (size == `CASInteger@"32") -> (((Rc)+((Rc)==255))%2 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.32 requires Rc to be 64bit vector-aligned (odd)"

         ERROR
           (size == `CASInteger@"64") -> (((Rb)+((Rb)==255))%4 == 0):
             "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"

         ERROR
           (size == `CASInteger@"64") -> (((Rc)+((Rc)==255))%4 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.64 requires Rc to be Rb+2 or RZ"


    PROPERTIES SECONDARY;

    OPCODES
        ATOMagu_pipe =  0b01110_1111_10;
        ATOM =  0b01110_1111_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Size1RegBC = ConsecutiveReg8(Rb,Rc,CASInteger);
      Dest = Rd;
      RegA =* Ra;
      Imm20a = uImm;
      bcRZ = 0;
      AtomE = E;
      Sync = S;


 CLASS "ATOM CAS Rb and RZ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb ',' ZeroRegister:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % CASRegAlignment(CASInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==255))):
             "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

         ERROR
           (size == `CASInteger@"64") -> (((Rb)+((Rb)==255))%4 == 0):
             "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"


    PROPERTIES SECONDARY;

    OPCODES
        ATOMagu_pipe =  0b01110_1111_10;
        ATOM =  0b01110_1111_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize1 = CASInteger;
      bcRZ = 1;
      AtomE = E;
      Sync = S;



 CLASS "I ATOM CAS Rb and RZ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb ',' ZeroRegister:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % CASRegAlignment(CASInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (size == `CASInteger@"32") -> IsEven(((Rb)+((Rb)==255))):
             "ATOM.CAS.32 requires Rb to be 64bit vector-aligned (even)"

         ERROR
           (size == `CASInteger@"64") -> (((Rb)+((Rb)==255))%4 == 0):
             "ATOM.CAS.64 requires Rb to be R4n+0 or RZ"


    PROPERTIES SECONDARY;

    OPCODES
        ATOMagu_pipe =  0b01110_1111_10;
        ATOM =  0b01110_1111_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize1 = CASInteger;
      bcRZ = 1;
      AtomE = E;
      Sync = S;



 CLASS "ATOM CAS RZ and Rc"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % CASRegAlignment(CASInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (size == `CASInteger@"32") -> (((Rc)+((Rc)==255))%2 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.32 requires Rc to be R2n+1 vector-aligned (odd)"

         ERROR
           (size == `CASInteger@"64") -> (((Rc)+((Rc)==255))%4 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.64 requires Rc to be R4n+2 vector-aligned"


    PROPERTIES SECONDARY;

    OPCODES
        ATOMagu_pipe =  0b01110_1111_10;
        ATOM =  0b01110_1111_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rc;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize1 = CASInteger;
      bcRZ = 2;
      AtomE = E;
      Sync = S;



 CLASS "I ATOM CAS RZ and Rc"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /CASInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' ZeroRegister:Rb ',' NonZeroRegister:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==255)) % CASRegAlignment(CASInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (size == `CASInteger@"32") -> (((Rc)+((Rc)==255))%2 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.32 requires Rc to be R2n+1 vector-aligned (odd)"

         ERROR
           (size == `CASInteger@"64") -> (((Rc)+((Rc)==255))%4 == CASRegAlignment(CASInteger)):
             "ATOM.CAS.64 requires Rc to be R4n+2 vector-aligned"


    PROPERTIES SECONDARY;

    OPCODES
        ATOMagu_pipe =  0b01110_1111_10;
        ATOM =  0b01110_1111_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rc;
      Dest = Rd;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize1 = CASInteger;
      bcRZ = 2;
      AtomE = E;
      Sync = S;



CLASS "RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)+((Rb)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (size == `SQInteger@S32) -> ((redop != `RedOp@INC) && (redop != `RedOp@DEC)):
             "INC/DEC cannot be applied to S32"

         ERROR
           (size == `SQInteger@U64) -> (redop == `RedOp@ADD):
             "Only Add can be applied to U64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (redop == `RedOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"


    PROPERTIES SECONDARY;

    OPCODES
        REDagu_pipe =  0b01101_10;
        RED =  0b01101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm20a = sImm;
      AtomSize = SQInteger;
      AtomOp = RedOp;
      AtomE = E;
      Sync = S;



CLASS "I RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==255))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)+((Rb)==255)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (size == `SQInteger@S32) -> ((redop != `RedOp@INC) && (redop != `RedOp@DEC)):
             "INC/DEC cannot be applied to S32"

         ERROR
           (size == `SQInteger@U64) -> (redop == `RedOp@ADD):
             "Only Add can be applied to U64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (redop == `RedOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"


    PROPERTIES SECONDARY;

    OPCODES
        REDagu_pipe =  0b01101_10;
        RED =  0b01101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = Rb;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm20a = uImm;
      AtomSize = SQInteger;
      AtomOp = RedOp;
      AtomE = E;
      Sync = S;



 CLASS "LDS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==255)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDSagu_pipe =  0b01111_01001_10;
        LDS =  0b01111_01001_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 =* LDInteger;
      Imm24 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      Sync=S;
      !COP2;
      !WriteCC;
      !aA2;



 CLASS "I LDS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==255)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDSagu_pipe =  0b01111_01001_10;
        LDS =  0b01111_01001_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 =* LDInteger;
      Imm24 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      Sync=S;
      !COP2;
      !WriteCC;
      !aA2;



 CLASS "LDSLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDSLKagu_pipe =  0b01110_11101_10;
        LDSLK =  0b01110_11101_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      DstPred = Pd;
      Imm24 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      !FTZ;
      Sync=S;




 CLASS "I LDSLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDSLKagu_pipe =  0b01110_11101_10;
        LDSLK =  0b01110_11101_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      DstPred = Pd;
      Imm24 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      !FTZ;
      Sync=S;




 CLASS "STS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
             "Register B is out of range"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

    OPCODES
        STSagu_pipe =  0b01111_01011_10;
        STS =  0b01111_01011_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 =* CInteger;
      Imm24 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;

      Sync=S;
      !COP2;
      !WriteCC;
      !aA2;



 CLASS "I STS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
             "Register B is out of range"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

    OPCODES
        STSagu_pipe =  0b01111_01011_10;
        STS =  0b01111_01011_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 =* CInteger;
      Imm24 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;

      Sync=S;
      !COP2;
      !WriteCC;
      !aA2;



 CLASS "STSCUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
            Predicate:Pd ',' [NonZeroRegister:Ra + SImm(24/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
        STSCULagu_pipe =  0b01111_00001_10;
        STSCUL =  0b01111_00001_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      Imm24 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      DstPred = Pd;
      !FTZ;
      Sync=S;



 CLASS "I STSCUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
            Predicate:Pd ',' [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
        STSCULagu_pipe =  0b01111_00001_10;
        STSCUL =  0b01111_00001_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      Imm24 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      DstPred = Pd;
      !FTZ;
      Sync=S;



 CLASS "CCTL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /CCTLOp:cctlop /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0)*:sImm] ;

    CONDITIONS
         ERROR
           (cctlop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                   "In CCTL.IVALL Register A should be zero register"

         ERROR
           (cctlop != `CCTLOp@WBALL) :
                   "WBALL is disallowed for CCTL"
         ERROR
           (cctlop != `CCTLOp@RSLB) :
                   "RSLB is disallowed for CCTL"

         ERROR
           (Cache3 != `Cache3@D) -> ((cctlop != `CCTLOp@RS) && (cctlop != `CCTLOp@PF1) && (cctlop != `CCTLOp@PF1.5) && (cctlop != `CCTLOp@PF2)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (cctlop == `CCTLOp@IV) -> ((Cache3 != `Cache3@C) && (Cache3 != `Cache3@I)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (E == `E@E) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))):
                   "Register A is out of range"

         ERROR
           (E == `E@E) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                   "Register A is not properly aligned"

         ERROR
           (E == `E@noE) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                   "Register A is out of range"

    OPCODES
        CCTLagu_pipe =  0b01111_011_10;
        CCTL =  0b01111_011_10;

    ENCODING
      Opcode532 = Opcode;
      Imm30a = sImm SCALE 4;
      E = E;
      Sync=S;
      Pred = Pg;
      PredNot = Pg@not;
      RegA =* Ra;
      Cache3 = Cache3;
      CCTLOp =* CCTLOp;
      !NencCCTL;





 CLASS "I CCTL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /CCTLOp:cctlop /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm] ;

    CONDITIONS
         ERROR
           (cctlop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                   "In CCTL.IVALL Register A should be zero register"

         ERROR
           (cctlop != `CCTLOp@WBALL) :
                   "WBALL is disallowed for CCTL"
         ERROR
           (cctlop != `CCTLOp@RSLB) :
                   "RSLB is disallowed for CCTL"

         ERROR
           (Cache3 != `Cache3@D) -> ((cctlop != `CCTLOp@RS) && (cctlop != `CCTLOp@PF1) && (cctlop != `CCTLOp@PF1.5) && (cctlop != `CCTLOp@PF2)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (cctlop == `CCTLOp@IV) -> ((Cache3 != `Cache3@C) && (Cache3 != `Cache3@I)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (E == `E@E) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))):
                   "Register A is out of range"

         ERROR
           (E == `E@E) -> ((((Ra)+((Ra)==255)) & 0x1) == 0):
                   "Register A is not properly aligned"

         ERROR
           (E == `E@noE) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                   "Register A is out of range"

    OPCODES
        CCTLagu_pipe =  0b01111_011_10;
        CCTL =  0b01111_011_10;

    ENCODING
      Opcode532 = Opcode;
      Imm30a = uImm SCALE 4;
      E = E;
      Sync=S;
      Pred = Pg;
      PredNot = Pg@not;
      RegA =* Ra;
      Cache3 = Cache3;
      CCTLOp =* CCTLOp;
      !NencCCTL;





 ALTERNATE CLASS "CCTL IVALL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /OnlyIvall:ivall /S(noS):sync
             ;

    OPCODES
        CCTLagu_pipe =  0b01111_011_10;
        CCTL =  0b01111_011_10;

    ENCODING
      Opcode532 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = `Register@RZ;
      Imm30a = 0;
      E = E;
      Cache3 = Cache3;
      CCTLOp =* OnlyIvall;

      Sync=S;
      !NencCCTL;



 CLASS "CCTL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /OnlyQry:op /S(noS):sync
             Register(RZ)@:Rd ',' [NonZeroRegister:Ra + SImm(32/0)*:sImm] ;

    OPCODES
        CCTLagu_pipe =  0b01111_011_10;
        CCTL =  0b01111_011_10;

    ENCODING
      Opcode532 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA =* Ra;
      Imm30a = sImm SCALE 4;
      E = E;
      Cache3 = Cache3;
      CCTLOp =* OnlyQry;

      Sync=S;
      !NencCCTL;







 CLASS "I CCTL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache3(D):cache /OnlyQry:op /S(noS):sync
             Register(RZ)@:Rd ',' [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm] ;

    OPCODES
        CCTLagu_pipe =  0b01111_011_10;
        CCTL =  0b01111_011_10;

    ENCODING
      Opcode532 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA =* Ra;
      Imm30a = uImm SCALE 4;
      E = E;
      Cache3 = Cache3;
      CCTLOp =* OnlyQry;

      Sync=S;
      !NencCCTL;







  CLASS "SUSTGA.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp3:clamp /Ofmt:ofmt /S(noS):sync
             [Register:Ra] ',' Register:Rb ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
                "Register B is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register C is out of range"

        ERROR
            (((Rc)+((Rc)==255)) % CRegAlignment(CInteger)) == 0:
                "Register C is not properly aligned"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SUSTGAagu_pipe =  0b01111_00111_10;
        SUSTGA =  0b01111_00111_10;

    ENCODING
      Opcode552 = Opcode;
      SrcPredSU = Pcl;
      SrcNotSU = Pcl@not;
      RegC = Rc;
      LSSize3 = CInteger;
      COP3 = StoreCacheOp;
      Ofmt2 = Ofmt;
      RGBAa =* RGBA_NONE;
      Clamp2 = Clamp3;
      Dest = Rb;
      RegA = Ra;
      PredNot = Pg@not;
      Pred = Pg;

      !NencSULDGA;
      Sync=S;




  CLASS "SUSTGA.B cimm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp3:clamp /Ofmt:ofmt /S(noS):sync
[Register:Ra] ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register C is out of range"

        ERROR
            (((Rc)+((Rc)==255)) % CRegAlignment(CInteger)) == 0:
                "Register C is not properly aligned"

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SUSTGAagu_pipe =  0b00111_10;
        SUSTGA =  0b00111_10;

    ENCODING
      Opcode52 = Opcode;
      LSSize = CInteger;
      COP1 = StoreCacheOp;
      SrcPredSU = Pcl;
      SrcNotSU = Pcl@not;
      RegC = Rc;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Ofmt3 = Ofmt;
      RGBAc =* RGBA_NONE;
      Clamp3 = Clamp3;
      RegA = Ra;
      PredNot = Pg@not;
      Pred = Pg;


      Sync=S;




  CLASS "SUSTGA.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3B(SD):rf /Clamp3(SDCL):clamp /Ofmt(U32):ofmt /S(noS):sync
             [Register:Ra] ',' Register:Rb ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
                "Register B is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register C is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SUSTGAagu_pipe =  0b01111_00111_10;
        SUSTGA =  0b01111_00111_10;

    ENCODING
      Opcode552 = Opcode;

      SrcPredSU = Pcl;
      SrcNotSU = Pcl@not;
      RegC = Rc;
      Rf3 = rf;
      COP3 = StoreCacheOp;
      Ofmt2 = Ofmt;
      RGBAa =* RGBA;
      Clamp2 = Clamp3;
      Dest = Rb;
      RegA = Ra;
      PredNot = Pg@not;
      Pred = Pg;

      !NencSULDGA;
      !AIO;

      Sync=S;




  CLASS "SUSTGA.P cimm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3B(SD):rf /Clamp3(SDCL):clamp /Ofmt(U32):ofmt /S(noS):sync
[Register:Ra] ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register C is out of range"

   PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SUSTGAagu_pipe =  0b00111_10;
        SUSTGA =  0b00111_10;

    ENCODING
      Opcode52 = Opcode;
      Rf = rf;
      COP1 = StoreCacheOp;
      SrcPredSU = Pcl;
      SrcNotSU = Pcl@not;
      RegC = Rc;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Ofmt3 = Ofmt;
      RGBAc =* RGBA;
      Clamp3 = Clamp3;
      RegA = Ra;
      PredNot = Pg@not;
      Pred = Pg;

      !SatHigh;
      Sync=S;


  CLASS "SULDGA.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp2:clamp /Ofmt:ofmt /S(noS):sync
             Register:Rd ',' [Register:Ra] ',' Register:Rb ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register D is out of range"

        ERROR
            ((Rd)+((Rd)==255)) % CRegAlignment(CInteger) == 0:
                "Register D is not properly aligned"

        ERROR
            (((Ra)+((Ra)==255)) & 0x1) == 0:
                "Register A is not properly aligned"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SULDGAagu_pipe =  0b01111_00110_10;
        SULDGA =  0b01111_00110_10;

    ENCODING
      Opcode552 = Opcode;
      Ofmt = Ofmt;
      RGBAb =* RGBA_NONE;
      Clamp = Clamp2;
      SrcPred = Pcl;
      SrcNot = Pcl@not;
      LSSize3 = CInteger;
      COP3 = LoadCacheOp;
      RegB = Rb;
      RegA = Ra;
      Dest = Rd;
      PredNot = Pg@not;
      Pred = Pg;

      !NencSULDGA;
      Sync=S;




  CLASS "SULDGA.B cimm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp2:clamp /Ofmt:ofmt /S(noS):sync
Register:Rd ',' [Register:Ra] ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register D is out of range"

        ERROR
            ((Rd)+((Rd)==255)) % CRegAlignment(CInteger) == 0:
                "Register D is not properly aligned"

        ERROR
            (((Ra)+((Ra)==255)) & 0x1) == 0:
                "Register A is not properly aligned"


     PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SULDGAagu_pipe =  0b00110_10;
        SULDGA =  0b00110_10;

    ENCODING
      Opcode52 = Opcode;
      LSSize = CInteger;
      COP1 = LoadCacheOp;
      Ofmt = Ofmt;
      RGBAb =* RGBA_NONE;
      Clamp = Clamp2;
      SrcPred = Pcl;
      SrcNot = Pcl@not;

Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      Dest = Rd;
      PredNot = Pg@not;
      Pred = Pg;

      Sync=S;
CLASS "SUCLAMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BDim("MD"):dim /Integer32(S32):us32 /Smode("SD.R1"):smd /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             SImm(6):sImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SUCLAMPxlu_pipe =  0b011;
        SUCLAMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX2X = 0b00;
      BDim2 = dim;
      SMode = smd;
      ASigned3 = IsSigned(us32);
      DstPred = Pcl;
      Imm06 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;

      Sync=S;

      Opcode2X2 = 0b11_10;
      !BFiller;
CLASS "Imm SUCLAMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BDim("MD"):dim /Integer32(S32):us32 /Smode("SD.R1"):smd /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             SImm(6):sImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SUCLAMPxlu_pipe =  0b011;
        SUCLAMP =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX2X = 0b00;
      BDim2 = dim;
      SMode = smd;
      ASigned3 = IsSigned(us32);
      DstPred = Pcl;
      Imm06 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;

      Sync=S;

      Opcode1X2 = 0b1_01;

CLASS "Const SUCLAMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BDim("MD"):dim /Integer32(S32):us32 /Smode("SD.R1"):smd /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             SImm(6):sImm;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SUCLAMPxlu_pipe =  0b011;
        SUCLAMP =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX2X = 0b00;
      BDim2 = dim;
      SMode = smd;
      ASigned3 = IsSigned(us32);
      DstPred = Pcl;
      Imm06 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);

      Sync=S;

      Opcode2X2 = 0b01_10;

CLASS "SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SUBFMxlu_pipe =  0b011;
        SUBFM =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11010;
      SUPDest = Pcl;
      BDim = dim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      Sync=S;
      Opcode2X2 = 0b11_10;
      !BFiller;
CLASS "Imm SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SUBFMxlu_pipe =  0b011;
        SUBFM =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11010;
      SUPDest = Pcl;
      BDim = dim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      Sync=S;
      Opcode1X2 = 0b1_01;

CLASS "Const SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SUBFMxlu_pipe =  0b011;
        SUBFM =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11010;
      SUPDest = Pcl;
      BDim = dim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      Sync=S;
      Opcode2X2 = 0b01_10;

CLASS "Const1 SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        SUBFMxlu_pipe =  0b011;
        SUBFM =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11010;
      SUPDest = Pcl;
      BDim = dim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      Sync=S;
      Opcode2X2 = 0b10_10;

CLASS "SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        SUEAUxlu_pipe =  0b011;
        SUEAU =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11011;
      !SUPDest;
      !BDim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      Sync=S;
      Opcode2X2 = 0b11_10;
      !BFiller;


CLASS "Imm SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        SUEAUxlu_pipe =  0b011;
        SUEAU =  0b011;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11011;
      !SUPDest;
      !BDim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      Sync=S;
      Opcode1X2 = 0b1_01;



CLASS "Const SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             Register:Rc;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        SUEAUxlu_pipe =  0b011;
        SUEAU =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11011;
      !SUPDest;
      !BDim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      Sync=S;
      Opcode2X2 = 0b01_10;



CLASS "Const1 SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    PROPERTIES
         ITYPE = ITYPE_ABC_CCST;

    OPCODES
        SUEAUxlu_pipe =  0b011;
        SUEAU =  0b011;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11011;
      !SUPDest;
      !BDim;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      Sync=S;
      Opcode2X2 = 0b10_10;



CLASS "I2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer(S32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                /SAT(noSAT):sat /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' [-][||]RegisterFAU:Rb /B1B0(B0):bytesel;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        I2Ixlu_pipe =  0b100;
        I2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11000;

      Pred = Pg;
      PredNot = Pg@not;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      By = B1B0;
      IDstFmt = IntSize( dstfmt );
      SrcFmt2 =* IntSize( srcfmt );
      Dest = Rd;
      RegB = Rb;
      Sync = S;

      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencI2I;



CLASS "Imm I2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer(S32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                /SAT(noSAT):sat /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        I2Ixlu_pipe =  0b100;
        I2I =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11000;

      Pred = Pg;
      PredNot = Pg@not;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      By = B1B0;
      IDstFmt = IntSize( dstfmt );
      SrcFmt2 =* IntSize( srcfmt );
      Dest = Rd;
      Bconst=uImm;
      Sync = S;

      Opcode1X2 = 0b1_01;

      !NencI2I;



CLASS "Const I2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer(S32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                /SAT(noSAT):sat /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        I2Ixlu_pipe =  0b100;
        I2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11000;

      Pred = Pg;
      PredNot = Pg@not;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      By = B1B0;
      IDstFmt = IntSize( dstfmt );
      SrcFmt2 =* IntSize( srcfmt );
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Sync = S;

      Opcode2X2 = 0b01_10;

      !NencI2I;



CLASS "I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel;

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        I2Ixlu_pipe =  0b100;
        I2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11000;

      Pred = Pg;
      PredNot = Pg@not;
      Sat = SAT;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      By = I2XH;
      IDstFmt = IntSize( dstfmt );
      SrcFmt2 =* IntSize( srcfmt );
      Dest = Rd;
      RegB = Rb;
      Sync = S;

      Opcode2X2 = 0b11_10;
      !BFiller;
      !NencI2I;


CLASS "Imm I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel;

    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        I2Ixlu_pipe =  0b100;
        I2I =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b11000;

      Pred = Pg;
      PredNot = Pg@not;
      Sat = SAT;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      By = I2XH;
      IDstFmt = IntSize( dstfmt );
      SrcFmt2 =* IntSize( srcfmt );
      Dest = Rd;
      Bconst=uImm;
      Sync = S;

      Opcode1X2 = 0b1_01;

      !NencI2I;


CLASS "Const I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel;

    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        I2Ixlu_pipe =  0b100;
        I2I =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b11000;

      Pred = Pg;
      PredNot = Pg@not;
      Sat = SAT;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      By = I2XH;
      IDstFmt = IntSize( dstfmt );
      SrcFmt2 =* IntSize( srcfmt );
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Sync = S;

      Opcode2X2 = 0b01_10;

      !NencI2I;


CLASS "I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Float(F32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
             ".F64 requires an even destination register"

         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (IsEven(((Rb)+((Rb)==255)))) :
             ".U64 requires an even source register"

         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

         ERROR
           ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
             ".U32/.S32 to .F16 is not supported"

         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
             ".U64/.S64 to .F16 is not supported"

         ERROR
           ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register D is out if range"

         ERROR
           ((srcfmt == `IntegerNo16@U64) || (srcfmt == `IntegerNo16@S64)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))):
             "Register B is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        I2FfmaX_pipe =  0b100;
        I2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10111;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      By = B1B0;
      RndLow = Round1;
      ISrcFmt =* IntSize ( srcfmt );
      DstFmt = dstfmt;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      !NencI2F;

      Sync=S;
      !BFiller;
      Opcode2X2 = 0b11_10;





CLASS "Imm I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Float(F32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
             ".F64 requires an even destination register"


         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

         ERROR
           ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
             ".U32/.S32 to .F16 is not supported"

         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
             ".U64/.S64 to .F16 is not supported"

         ERROR
           ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register D is out if range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        I2FfmaX_pipe =  0b100;
        I2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10111;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      By = B1B0;
      RndLow = Round1;
      ISrcFmt =* IntSize ( srcfmt );
      DstFmt = dstfmt;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      !NencI2F;

      Sync=S;

      Opcode1X2 = 0b1_01;





CLASS "Const I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Float(F32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==255)))) :
             ".F64 requires an even destination register"


         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

         ERROR
           ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
             ".U32/.S32 to .F16 is not supported"

         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
             ".U64/.S64 to .F16 is not supported"

         ERROR
           ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register D is out if range"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        I2FfmaX_pipe =  0b100;
        I2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10111;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      By = B1B0;
      RndLow = Round1;
      ISrcFmt =* IntSize ( srcfmt );
      DstFmt = dstfmt;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !NencI2F;

      Sync=S;

      Opcode2X2 = 0b01_10;





CLASS "I2F16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt != `Float@F64):
             ".U16/.S16 to .F64 is not supported"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
             "Register D is out if range"

         ERROR
           (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
             "Register B is out of range"

    PROPERTIES
         ITYPE = ITYPE_ABC_REG;

    OPCODES
        I2FfmaX_pipe =  0b100;
        I2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10111;
      aB = Rb@absolute;
      WriteCC = writeCC;
      nB = Rb@negate;
      By = I2XH;
      RndLow = Round1;
      ISrcFmt =* IntSize ( srcfmt );
      DstFmt = dstfmt;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      !NencI2F;


      Sync=S;
      !BFiller;
      Opcode2X2 = 0b11_10;

CLASS "Imm I2F16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt != `Float@F64):
             ".U16/.S16 to .F64 is not supported"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
             "Register D is out if range"


    PROPERTIES
         ITYPE = ITYPE_ABC_B20I;

    OPCODES
        I2FfmaX_pipe =  0b100;
        I2F =  0b100;

    ENCODING
      ABCOpcodeX3X_2 = Opcode;
      SubOpcodeX5X = 0b10111;
      aB = UnaryAbs;
      WriteCC = writeCC;
      nB = UnaryNeg;
      By = I2XH;
      RndLow = Round1;
      ISrcFmt =* IntSize ( srcfmt );
      DstFmt = dstfmt;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      !NencI2F;


      Sync=S;

      Opcode1X2 = 0b1_01;

CLASS "Const I2F16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (dstfmt != `Float@F64):
             ".U16/.S16 to .F64 is not supported"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
             "Register D is out if range"


    PROPERTIES
         ITYPE = ITYPE_ABC_BCST;

    OPCODES
        I2FfmaX_pipe =  0b100;
        I2F =  0b100;

    ENCODING
      ABCOpcodeX3X_1 = Opcode;
      SubOpcodeX5X = 0b10111;
      aB = srcConst@absolute;
      WriteCC = writeCC;
      nB = srcConst@negate;
      By = I2XH;
      RndLow = Round1;
      ISrcFmt =* IntSize ( srcfmt );
      DstFmt = dstfmt;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
Bcbank,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !NencI2F;


      Sync=S;

      Opcode2X2 = 0b01_10;

CLASS "BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            Register:Ra ',' Register:Rb;

    CONDITIONS ERROR ((Ra+(Ra==255)) == (Rb+(Rb==255))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      !Dest;

      !BarFiller;
      AFix_BAR=0;
      BFix_BAR=0;
      !BarRedOp;
      !NencBAR;
      !Sync;



CLASS "b BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            Register:Ra ',' UImm(12/0):uImm;



    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      !Dest;


      AFix_BAR=0;
      BFix_BAR=1;
      !BarRedOp;
      !NencBAR;
      !Sync;



CLASS "a b BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            UImm(4):barNum ',' UImm(12/0):uImm;



    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      !Dest;


      AFix_BAR=1;
      BFix_BAR=1;
      !BarRedOp;
      !NencBAR;
      !Sync;



CLASS "a BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            UImm(4):barNum ',' Register:Rb;



    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      SrcNot = 0;
      SrcPred = `Predicate@PT;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      !Dest;

      !BarFiller;
      AFix_BAR=1;
      BFix_BAR=0;
      !BarRedOp;
      !NencBAR;
      !Sync;



CLASS "BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            Register:Ra ',' Register:Rb;

    CONDITIONS ERROR ((Ra+(Ra==255)) == (Rb+(Rb==255))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      !Dest;

      !SrcPred;
      !SrcNot;
      !BarFiller;
      AFix_BAR=0;
       BFix_BAR=0;
      !BarRedOp;
      !NencBAR;
      !Sync;





CLASS "a BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            UImm(4):barNum ',' Register:Rb;



    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      !Dest;

      !SrcPred;
      !SrcNot;
      !BarFiller;
      AFix_BAR=1;
       BFix_BAR=0;
      !BarRedOp;
      !NencBAR;
      !Sync;





CLASS "BAR Arv imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            Register:Ra ',' UImm(12):uImm;


    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;

      !Dest;
      !SrcPred;
      !SrcNot;
      AFix_BAR=0;
       BFix_BAR=1;
      !BarRedOp;
      !NencBAR;
      !Sync;




CLASS "a BAR Arv imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            UImm(4):barNum ',' UImm(12):uImm;


    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;

      !Dest;
      !SrcPred;
      !SrcNot;
      AFix_BAR=1;
       BFix_BAR=1;
      !BarRedOp;
      !NencBAR;
      !Sync;




CLASS "BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            Register:Ra ',' Register:Rb ',' [!]Predicate:Pa;

    CONDITIONS ERROR ((Ra+(Ra==255)) == (Rb+(Rb==255))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"


    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;
      !BarFiller;
      AFix_BAR=0;
      BFix_BAR=0;
      !NencBAR;
      !Sync;




CLASS "b BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            Register:Ra ',' UImm(12/0):uImm ',' [!]Predicate:Pa;




    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;

      AFix_BAR=0;
      BFix_BAR=1;
      !NencBAR;
      !Sync;




CLASS "a b BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            UImm(4):barNum ',' UImm(12/0):uImm ',' [!]Predicate:Pa;




    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;

      AFix_BAR=1;
      BFix_BAR=1;
      !NencBAR;
      !Sync;




CLASS "a BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            UImm(4):barNum ',' Register:Rb ',' [!]Predicate:Pa;




    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;
      !BarFiller;
      AFix_BAR=1;
      BFix_BAR=0;
      !NencBAR;
      !Sync;




CLASS "BAR syncall"
    FORMAT Opcode /BarSYNCALL:barmode;

    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarSYNCALL;
      !Pred;
      !PredNot;
      !RegA;
      !RegB;
      !Dest;
      !SrcPred;
      !SrcNot;
      !BarFiller;
      !BarRedOp;
      !NencBAR2;
      !Sync;




 CLASS "BAR Scan"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            Register:Ra ',' Register:Rb ',' [!]Predicate:Pa;

    CONDITIONS ERROR ((Ra+(Ra==255)) == (Rb+(Rb==255))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"


    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarSCAN;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      !Dest;
       SrcPred = Pa;
       SrcNot = Pa@not;
      !BarFiller;
      AFix_BAR=0;
       BFix_BAR=0;
      !BarRedOp;
      !NencBAR;
      !Sync;





 CLASS "a BAR Scan"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            UImm(4):barNum ',' Register:Rb ',' [!]Predicate:Pa;




    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarSCAN;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      !Dest;
       SrcPred = Pa;
       SrcNot = Pa@not;
      !BarFiller;
      AFix_BAR=1;
       BFix_BAR=0;
      !BarRedOp;
      !NencBAR;
      !Sync;





CLASS "BAR scan imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            Register:Ra ',' UImm(12):uImm ',' [!]Predicate:Pa;

    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarSCAN;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      !Dest;
       SrcPred = Pa;
       SrcNot = Pa@not;
      AFix_BAR=0;
       BFix_BAR=1;
      !BarRedOp;
      !NencBAR;
      !Sync;


CLASS "a BAR scan imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSCAN:barmode
            UImm(4):barNum ',' UImm(12):uImm ',' [!]Predicate:Pa;

    OPCODES
        BARfe_pipe =  0b10000_10101_10;
        BAR =  0b10000_10101_10;

    ENCODING
      Opcode552 = Opcode;
      BarOp =* BarSCAN;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      !Dest;
       SrcPred = Pa;
       SrcNot = Pa@not;
      AFix_BAR=1;
       BFix_BAR=1;
      !BarRedOp;
      !NencBAR;
      !Sync;


CLASS "VADD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/ASel4("3210"):asel
             ',' [-]Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

         ERROR
           (AVRG -> (!Ra@negate && !Rb@negate)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD4xlu_pipe =  0b1101_01;
        VADD4 =  0b1101_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 =* bsel;
      AVGMode = VMode(AVRG,Ra@negate,Rb@negate);
      Sync = S;




CLASS "Imm VADD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/ASel4("3210"):asel
             ',' SSImm(9):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

         ERROR
           (AVRG -> (!Ra@negate && !uImm@sign)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD4xlu_pipe =  0b1101_01;
        VADD4 =  0b1101_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = 0xf;
      AVGMode = VMode(AVRG,Ra@negate,uImm@sign);
      Sync = S;




 CLASS "VABSDIFF4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra/ASel4("3210"):asel
             ',' RegisterFAU:Rb/BSel4("7654"):bsel
             ',' RegisterFAU:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF4fau_pipe =  0b10000_0_10;
        VABSDIFF4xlu_pipe =  0b10000_0_10;
        VABSDIFF4 =  0b10000_0_10;

    ENCODING
      Opcode512 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 =* bsel;
      Sync = S;





 CLASS "Imm VABSDIFF4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             RegisterFAU:Rd /optCC(noCC):writeCC
             ',' RegisterFAU:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' RegisterFAU:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF4fau_pipe =  0b10000_0_10;
        VABSDIFF4xlu_pipe =  0b10000_0_10;
        VABSDIFF4 =  0b10000_0_10;

    ENCODING
      Opcode512 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = 0xf;
      Sync = S;





 CLASS "VMNMX4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX4xlu_pipe =  0b11110_10;
        VMNMX4 =  0b11110_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 =* bsel;
      MN = MN;
      Sync = S;





 CLASS "Imm VMNMX4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX4xlu_pipe =  0b11110_10;
        VMNMX4 =  0b11110_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = 0xf;
      MN = MN;
      Sync = S;





 CLASS "VSET4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSET4xlu_pipe =  0b11101_10;
        VSET4 =  0b11101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = Integer8Signed(safmt);
      sbfmt2 = Integer8Signed(sbfmt);
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 =* bsel;
      VComp = ICmpAll;
      Sync = S;





 CLASS "Imm VSET4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSET4xlu_pipe =  0b11101_10;
        VSET4 =  0b11101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = Integer8Signed(safmt);
      sbfmt2 = Integer8Signed(sbfmt);
      VRed = VRed2;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = 0xf;
      VComp = ICmpAll;
      Sync = S;





 CLASS "VSEL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL4xlu_pipe =  0b10000_11101_10;
        VSEL4 =  0b10000_11101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed3 = VRed2;
      LaneMask4b = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 =* bsel;
      Sync = S;





 CLASS "Imm VSEL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL4xlu_pipe =  0b10000_11101_10;
        VSEL4 =  0b10000_11101_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat = SAT;
      VRed3 = VRed2;
      LaneMask4b = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = 0xf;
      Sync = S;





 CLASS "VADD2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/Sel2("10"):asel
             ',' [-]Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (AVRG -> (!Ra@negate && !Rb@negate)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD2xlu_pipe =  0b001_01;
        VADD2 =  0b001_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      SatHigh = SAT;
      VRed = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      AVGMode2 = VMode(AVRG,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller2;



 CLASS "Imm VADD2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/Sel2hi("10"):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (AVRG -> (!Ra@negate && !uImm@sign)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD2xlu_pipe =  0b001_01;
        VADD2 =  0b001_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      SatHigh = SAT;
      VRed = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      AVGMode2 = VMode(AVRG,Ra@negate,uImm@sign);
      Sync = S;

      BVideo=0;




 CLASS "VABSDIFF2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF2xlu_pipe =  0b10101_10;
        VABSDIFF2 =  0b10101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      SatHigh = SAT;
      VRed = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      Sync = S;

      BVideo=1;
      !BFiller2;



 CLASS "Imm VABSDIFF2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF2xlu_pipe =  0b10101_10;
        VABSDIFF2 =  0b10101_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      SatHigh = SAT;
      VRed = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      Sync = S;

      BVideo=0;




 CLASS "VMNMX2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX2xlu_pipe =  0b1111_01;
        VMNMX2 =  0b1111_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      SatHigh = SAT;
      VRed = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller2;



 CLASS "Imm VMNMX2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX2xlu_pipe =  0b1111_01;
        VMNMX2 =  0b1111_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      SatHigh = SAT;
      VRed = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      MN2 = MN;
      Sync = S;

      BVideo=0;




 CLASS "VSET2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    OPCODES
        VSET2xlu_pipe =  0b0001_10;
        VSET2 =  0b0001_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = Integer16Signed(safmt);
      sbfmt3 = Integer16Signed(sbfmt);
      VRed2 = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller2;



 CLASS "Imm VSET2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VSET2xlu_pipe =  0b0001_10;
        VSET2 =  0b0001_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = Integer16Signed(safmt);
      sbfmt3 = Integer16Signed(sbfmt);
      VRed2 = VRed2;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      VComp2 = ICmpAll;
      Sync = S;

      BVideo=0;




 CLASS "VSEL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL2xlu_pipe =  0b01111_0010_10;
        VSEL2 =  0b01111_0010_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed3 = VRed2;
      LaneMask2b = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      Sync = S;

      BVideo=1;
      !BFiller2;



 CLASS "Imm VSEL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed2(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed2@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL2xlu_pipe =  0b01111_0010_10;
        VSEL2 =  0b01111_0010_10;

    ENCODING
      Opcode542 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed3 = VRed2;
      LaneMask2b = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      Sync = S;

      BVideo=0;




 CLASS "VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,Rb@negate);
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,uImm@sign);
      Sync = S;

      BVideo=0;




 CLASS "a8 Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,uImm@sign);
      Sync = S;

      BVideo=0;




 CLASS "a32 Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b000_01;
        VADD =  0b000_01;

    ENCODING
      Opcode32 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode2 = PSign(PO,Ra@negate,uImm@sign);
      Sync = S;

      BVideo=0;




 CLASS "VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=0;




 CLASS "a8 Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=0;




 CLASS "a32 Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VABSDIFFxlu_pipe =  0b10100_10;
        VABSDIFF =  0b10100_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      Sync = S;

      BVideo=0;




 CLASS "VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=0;




 CLASS "a8 Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=0;




 CLASS "a32 Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VMNMXxlu_pipe =  0b1110_01;
        VMNMX =  0b1110_01;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN2 = MN;
      Sync = S;

      BVideo=0;




 CLASS "VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt } /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=0;




 CLASS "a8 Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=0;




 CLASS "a32 Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt } /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    OPCODES
        VSETxlu_pipe =  0b0000_10;
        VSET =  0b0000_10;

    ENCODING
      Opcode42 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp2 = ICmpAll;
      Sync = S;

      BVideo=0;




 CLASS "VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /U16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU16(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /U8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU8(sbfmt,bsel);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /U32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a8 b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /U32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "a32 b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /U32(U32):sbfmt } /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelectU =* VFormatU32(sbfmt);
      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = CWMode;
      Sync = S;

      BVideo=1;
      !BFiller3;



 CLASS "Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /UInteger:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);

      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = SM4vshlCW(CWMode,sbfmt);
      Sync = S;

      BVideo=0;




 CLASS "a8 Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /UInteger:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);

      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = SM4vshlCW(CWMode,sbfmt);
      Sync = S;

      BVideo=0;




 CLASS "a32 Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt } /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHRxlu_pipe =  0b10110_10;
        VSHR =  0b10110_10;
        VSHLxlu_pipe =  0b10111_10;
        VSHL =  0b10111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);

      SatHigh = SAT;
      VOP = VOP;
      WriteCC = writeCC;


      MV = SM4vshlCW(CWMode,sbfmt);
      Sync = S;

      BVideo=0;




 CLASS "VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "a8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop a8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "a32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop a32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "a8 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop a8 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "a32 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop a32 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "a8 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop a8 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "a32 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 ALTERNATE CLASS "NoBop a32 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=1;
      !BFiller3;



 CLASS "Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=0;




 ALTERNATE CLASS "NoBop Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=0;




 CLASS "a8 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=0;




 ALTERNATE CLASS "NoBop a8 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=0;




 CLASS "a32 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=0;




 ALTERNATE CLASS "NoBop a32 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' UImm(16):uImm
             ;

    OPCODES
        VSETPxlu_pipe =  0b10000_11110_10;
        VSETP =  0b10000_11110_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp3 = ICmpAll;
      Sync = S;


      !NencVSETP;
      BVideo=0;




 CLASS "VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "a8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "a32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "a8 b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "a32 b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "a8 b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "a32 b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=1;
      !BFiller3;


 CLASS "Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=0;



 CLASS "a8 Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=0;



 CLASS "a32 Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11111_10;
        VMAD =  0b11111_10;

    ENCODING
      Opcode52 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      SatHigh = SAT;
      WriteCC = writeCC;
      AVGMode3 = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      VScale = VMadScale;
      Sync = S;

      BVideo=0;



CLASS "PSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0 /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ',' [!]Predicate:Pa;

    OPCODES
        PSETPfau_pipe =  0b10000_10010_10;
        PSETPxlu_pipe =  0b10000_10010_10;
        PSETP =  0b10000_10010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop0 = bop0;
      Bop = bopopt;
      Sync = S;


      !NencPSETP;



ALTERNATE CLASS "NoBop PSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0 /S(noS):sync
                               Predicate:Pd
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ;

    OPCODES
        PSETPfau_pipe =  0b10000_10010_10;
        PSETPxlu_pipe =  0b10000_10010_10;
        PSETP =  0b10000_10010_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop0 = bop0;
      Bop = `Bop@AND;
      Sync = S;


      !NencPSETP;



CLASS "PSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0 /Bop:bopopt /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ',' [!]Predicate:Pa;

    OPCODES
        PSETfau_pipe =  0b10000_10001_10;
        PSETxlu_pipe =  0b10000_10001_10;
        PSET =  0b10000_10001_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop0 = bop0;
      Bop = bopopt;
      BVal = BVal;
      Sync = S;


      !NencPSET;


ALTERNATE CLASS "NoBop PSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0 /S(noS):sync
                               RegisterFAU:Rd /optCC(noCC):writeCC
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ;

    OPCODES
        PSETfau_pipe =  0b10000_10001_10;
        PSETxlu_pipe =  0b10000_10001_10;
        PSET =  0b10000_10001_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop0 = bop0;
      Bop = `Bop@AND;
      BVal = BVal;
      Sync = S;


      !NencPSET;


CLASS "MEMBAR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MemBarLevel:lvl /S(noS):sync;

    OPCODES
        MEMBARagu_pipe =  0b01111_10011_10;
        MEMBAR =  0b01111_10011_10;

    ENCODING
      Opcode552 = Opcode;
      MembarL = MemBarLevel;
      Pred = Pg;
      PredNot = Pg@not;
      Sync=S;
      !NencMEMBAR;


CLASS "LDL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDLagu_pipe =  0b01111_01000_10;
        LDL =  0b01111_01000_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      COP2 = LLoadCacheOp;
      Imm24 = sImm;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      !WriteCC;
      !aA2;
      Sync=S;



CLASS "I LDL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    PROPERTIES
         OPERATION_TYPE = MEMORY_LOAD;

    OPCODES
        LDLagu_pipe =  0b01111_01000_10;
        LDL =  0b01111_01000_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      COP2 = LLoadCacheOp;
      Imm24 = uImm;

      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;

      !WriteCC;
      !aA2;
      Sync=S;



 CLASS "STL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        STLagu_pipe =  0b01111_01010_10;
        STL =  0b01111_01010_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      COP2 = StoreCacheOp;
      Imm24 = sImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;

      !WriteCC;
      !aA2;
      Sync=S;



 CLASS "I STL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==255)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        STLagu_pipe =  0b01111_01010_10;
        STL =  0b01111_01010_10;

    ENCODING
      Opcode552 = Opcode;
      LSSize2 = CInteger;
      COP2 = StoreCacheOp;
      Imm24 = uImm;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;

      !WriteCC;
      !aA2;
      Sync=S;



 CLASS "CCTLL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLOp:cctllop /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0)*:sImm] ;

    CONDITIONS
         ERROR
           !(cctllop != `CCTLOp@WBALL && cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache != `LCache@CRS) :
                "WBALL is disallowed without CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache == `LCache@CRS && (Ra != `Register@RZ || sImm != 0)) :
                "Address operand must be [0] for CCTLL.CRS.WBALL"
         ERROR
           !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

         ERROR
           (cctllop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                "In CCTLL.IVALL Register A should be zero register"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b01111_10000_10;
        CCTLL =  0b01111_10000_10;

    ENCODING
      Opcode552 = Opcode;
      Imm22a = sImm SCALE 4;
      Sync=S;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Cache = cache;
      CCTLOp =* cctllop;

      !NencCCTLL;





 CLASS "I CCTLL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLOp:cctllop /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ;

    CONDITIONS
         ERROR
           !(cctllop != `CCTLOp@WBALL && cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache != `LCache@CRS) :
                "WBALL is disallowed without CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache == `LCache@CRS && (Ra != `Register@RZ || uImm != 0)) :
                "Address operand must be [0] for CCTLL.CRS.WBALL"
         ERROR
           !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

         ERROR
           (cctllop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                "In CCTLL.IVALL Register A should be zero register"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b01111_10000_10;
        CCTLL =  0b01111_10000_10;

    ENCODING
      Opcode552 = Opcode;
      Imm22a = uImm SCALE 4;
      Sync=S;
      PredNot = Pg@not;
      Pred = Pg;
      RegA =* Ra;
      Cache = cache;
      CCTLOp =* cctllop;

      !NencCCTLL;





 ALTERNATE CLASS "CCTLL NoOperands"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLLOp2:cctllop /S(noS):sync
             ;

    CONDITIONS
         ERROR
           !(cctllop != `CCTLOp@WBALL && cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache != `LCache@CRS) :
                "WBALL is disallowed without CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

    OPCODES
        CCTLLagu_pipe =  0b01111_10000_10;
        CCTLL =  0b01111_10000_10;

    ENCODING
      Opcode552 = Opcode;
      Imm22a = 0;
      Sync=S;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = `Register@RZ;
      Cache = cache;
      CCTLOp =* cctllop;

      !NencCCTLL;





 CLASS "CCTLL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /OnlyQry:op /S(noS):sync
              Register(RZ)@:Rd ',' [NonZeroRegister:Ra + SImm(24/0)*:sImm] ;

    CONDITIONS
         ERROR
           !(cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"

         ERROR
           ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b01111_10000_10;
        CCTLL =  0b01111_10000_10;

    ENCODING
      Opcode552 = Opcode;
      Imm22a = sImm SCALE 4;
      Sync=S;
      Pred = Pg;
      PredNot = Pg@not;
      RegA =* Ra;

      CCTLOp =* OnlyQry;
      Cache = cache;

      !NencCCTLL;





 CLASS "I CCTLL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /OnlyQry:op /S(noS):sync
              Register(RZ)@:Rd ',' [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ;

    CONDITIONS
         ERROR
           !(cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"

         ERROR
           ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b01111_10000_10;
        CCTLL =  0b01111_10000_10;

    ENCODING
      Opcode552 = Opcode;
      Imm22a = uImm SCALE 4;
      Sync=S;
      Pred = Pg;
      PredNot = Pg@not;
      RegA =* Ra;

      CCTLOp =* OnlyQry;
      Cache = cache;

      !NencCCTLL;





 CLASS "CCTLS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CCTLOpRSLB:cctlop /S(noS):sync;

    CONDITIONS

    OPCODES
        CCTLSagu_pipe =  0b01111_10001_10;
        CCTLS =  0b01111_10001_10;

    ENCODING
      Opcode552 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !RegA;
      !Imm22a;
      !CCTLOp;
      !Cache;
      !NencCCTLL;
      Sync=S;



 CLASS "SETCRSPTR"
    FORMAT Opcode Register:Ra ;

    OPCODES
        SETCRSPTRbru_pipe =  0b000_10_1110_00;
        SETCRSPTR =  0b000_10_1110_00;

    ENCODING
      Opcode362 = Opcode;
      RegA = Ra;
      !Dest;
      !NencCRSLMEM;



 CLASS "GETCRSPTR"
    FORMAT Opcode Register:Rd ;

    OPCODES
        GETCRSPTRbru_pipe =  0b000_10_1100_00;
        GETCRSPTR =  0b000_10_1100_00;

    ENCODING
      Opcode362 = Opcode;
      Dest = Rd;
      !RegA;
      !NencCRSLMEM;



 CLASS "SETLMEMBASE"
    FORMAT Opcode Register:Ra ;

    OPCODES
        SETLMEMBASEagu_pipe =  0b000_10_1111_00;
        SETLMEMBASE =  0b000_10_1111_00;

    ENCODING
      Opcode362 = Opcode;
      RegA = Ra;
      !Dest;
      !NencCRSLMEM;



 CLASS "GETLMEMBASE"
    FORMAT Opcode Register:Rd ;

    OPCODES
        GETLMEMBASEagu_pipe =  0b000_10_1101_00;
        GETLMEMBASE =  0b000_10_1101_00;

    ENCODING
      Opcode362 = Opcode;
      Dest = Rd;
      !RegA;
      !NencCRSLMEM;
