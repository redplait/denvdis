ARCHITECTURE "Fermi"

   PROCESSOR_ID Fermi;
   ISSUE_SLOTS 1;
   WORD_SIZE 64;
   BRANCH_DELAY 0;
   ELF_ID 190;
   ELF_ABI 0x33;
   ELF_ABI_VERSION 7;


   ELF_VERSION 75;

   RELOCATORS
  { "R_CUDA_NONE", 0, False, False, 0,0, { { 0, 0} } }
  { "R_CUDA_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_G32", "R_CUDA_G32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_G64", "R_CUDA_G64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS32_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_TEX_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_SAMP_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 20, 12} } }
  { "R_CUDA_SURF_HW_DESC", "R_CUDA_SURF_HW_DESC", 32 }
  { "R_CUDA_SURF_HW_SW_DESC", "R_CUDA_SURF_HW_SW_DESC", 32 }
  { "R_CUDA_ABS32_LO_26", 0x00000000ffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_HI_26", 0xffffffff00000000, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS24_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 24} } }
  { "R_CUDA_ABS24_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS16_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 16} } }
  { "R_CUDA_ABS16_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 16} } }
  { "R_CUDA_TEX_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 32, 8} } }
  { "R_CUDA_SAMP_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 40, 5} } }
  { "R_CUDA_SURF_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 26, 6} } }
  { "R_CUDA_TEX_BINDLESSOFF13_32", 0xffffffffffffffff, False, False, 0,2, { { 32, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_47", 0xffffffffffffffff, False, False, 0,2, { { 47, 13} } }
  { "R_CUDA_CONST_FIELD19_28", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 28, 18},
  { 26, 1} } }
  { "R_CUDA_CONST_FIELD19_23", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 23, 19} } }
  { "R_CUDA_TEX_SLOT9_49", 0xffffffffffffffff, False, False, 0,0, { { 49, 9} } }
  { "R_CUDA_6_31", 0xffffffffffffffff, False, False, 0,0, { { 31, 6} } }
  { "R_CUDA_2_47", 0xffffffffffffffff, False, False, 0,0, { { 47, 2} } }
  { "R_CUDA_TEX_BINDLESSOFF13_41", 0xffffffffffffffff, False, False, 0,2, { { 41, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_45", 0xffffffffffffffff, False, False, 0,2, { { 45, 13} } }
  { "R_CUDA_FUNC_DESC32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC_32", "R_CUDA_FUNC_DESC_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_FUNC_DESC_64", "R_CUDA_FUNC_DESC_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_CONST_FIELD21_26", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 26, 21} } }
  { "R_CUDA_QUERY_DESC21_37", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 37, 21} } }
  { "R_CUDA_CONST_FIELD19_26", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 26, 19} } }
  { "R_CUDA_CONST_FIELD21_23", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 23, 21} } }
  { "R_CUDA_PCREL_IMM24_26", 0xffffffffffffffff, True, False, 0,0, { { 26, 24} } }
  { "R_CUDA_PCREL_IMM24_23", 0xffffffffffffffff, True, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS24_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 24} } }
  { "R_CUDA_ABS16_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 16} } }
  { "R_CUDA_FUNC_DESC32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_CONST_FIELD19_20", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 20, 19} } }
  { "R_CUDA_BINDLESSOFF13_36", 0xffffffffffffffff, False, False, 0,2, { { 36, 13} } }
  { "R_CUDA_SURF_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_INSTRUCTION8", "R_CUDA_INSTRUCTION8", 8 }
  { "R_CUDA_CONST_FIELD21_20", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 20, 21} } }
      ;


   OPTIONS NOCHECK_OPCLASS_AMBIGUITY,
           CASE_INSENSITIVE_SYNTAX;

   EMPTY_INSTRUCTION = "NOP;";


CONSTANTS
    ITYPE_OTHER = 0
    ITYPE_ABC_REG = 1
    ITYPE_ABC_BCST = 2
    ITYPE_ABC_CCST = 3
    ITYPE_ABC_B20I = 4

REGISTERS

    UnaryInv noINV, INV;
    UnaryNeg noNEG, NEG;
    UnaryAbs noABS, ABS;

    Predicate P(0..7), PT=7;

    Register R0(0 .. 9), R(0..63)=(0..63), RZ=63;
    NonZeroRegister R0(0 .. 9), R(0..62)=(0..62);
    ZeroRegister R63=63, RZ=63;


    SpecialRegister SR(0..255)=(0..255),
                      SR_LANEID = 0,
                      SR_CLOCK,
                      SR_VIRTCFG,
                      SR_VIRTID,
                      SR_PM(0..7),

                      SR_PRIM_TYPE=16,
                      SR_INVOCATION_ID,
                      SR_Y_DIRECTION,
                      SR_THREAD_KILL,
                      SM_SHADER_TYPE,

                      SR_MACHINE_ID_(0..3)=(24..27),
                      SR_AFFINITY,

                      SR_TID=32, "SR_TID.X", "SR_TID.Y", "SR_TID.Z",
                      SR_CTAPARAM, SR_CTA_PARAM=36,
                      "SR_CTAID.X", "SR_CTAID.Y", "SR_CTAID.Z",
                      SR_NTID, "SR_NTID.X", "SR_NTID.Y", "SR_NTID.Z",
                      SR_GRIDPARAM,
                      "SR_NCTAID.X", "SR_NCTAID.Y", "SR_NCTAID.Z",
                      SR_SWINLO, SR_SWINSZ,
                      SR_SMEMSZ, SR_SMEMBANKS,
                      SR_LWINLO, SR_LWINSZ,
                      SR_LMEMLOSZ, SR_LMEMHIOFF,
                      SR_EQMASK, SR_LTMASK, SR_LEMASK, SR_GTMASK, SR_GEMASK,

                      SR_GLOBALERRORSTATUS=64,

                      SR_WARPERRORSTATUS=66, SR_WARPERRORSTATUSCLEAR,

                      SR_CLOCKLO=80, SR_CLOCKHI;







    Round1 RN, RM, RP, RZ;
    F2FRound1 RN=1, PASS, RM, PASS, RP, PASS, RZ, PASS=0, ROUND, FLOOR=3, CEIL=5, TRUNC=7;
    F2FRound2 PASS, ROUND=0, FLOOR, CEIL, TRUNC, RN=0, RM, RP, RZ;
    Round3 ROUND, FLOOR, CEIL, TRUNC;
    VOP MRG_16H, MRG_16L, MRG_8B0, MRG_8B2, ACC, MIN, MAX, PASS;
    IPAOp PASS, MUL, CONSTANT, SC;
    VRed SIMD_MRG, SIMD_MIN, SIMD_MAX, REDOP3, INVALIDRED3=3, ACC, MIN, MAX, REDOP7, INVALIDRED7=7;
    AtomOp INVALIDATOMOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR,EXCH,CAS;
    RedOp INVALIDREDOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR;
    SUOp INVALIDSUREDOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR;
    VMadScale PASS,SHR_7,SHR_15,INVALIDVMADSCALE3;
    INC NOINC,INC;
    IPAOpN MUL, SC;
    Bop AND, OR, XOR, INVALIDBOP03,INVALIDBOP13=3,INVALIDBOP3=3;
    LOP AND, OR, XOR, PASS_B;
    Red POPC,AND,OR,INVALIDBARMODE3;

    CC CC;
    optCC noCC, CC;

    Float INVALIDFPDEST0, INVALIDFPSRC0=0, F16, F32, F64;
    Float16 F16=1;
    Float32 INVALIDFPDEST0, INVALIDFPSRC0=0, F32=2;
    Float64 F64=3;
    F32 F32;
    F2Ffmts1 "INVALIDFPDEST0.INVALIDFPSRC0"=0, "F32.F32"=10;
    F2Ffmts1_16 "F16.F16"=5;
    F2Ffmts1_64 "F64.F64"=15;
    F2Ffmts2 "F16.INVALIDFPSRC0"=1, "F32.INVALIDFPSRC0"=2, "F64.INVALIDFPSRC0"=3,
                      "INVALIDFPDEST0.F32"=8, "F16.F32"=9, "F64.F32"=11;
    F2Ffmts2_16 "INVALIDFPDEST0.F16"=4, "F32.F16"=6, "F64.F16"=7;
    F2Ffmts2_64 "INVALIDFPDEST0.F64"=12, "F16.F64"=13, "F32.F64"=14;

    Integer8 U8 = 0, S8 = 1;
    Integer16 U16 = 2, S16 = 3;
    Integer32 U32 = 4, S32 = 5;
    Integer64 U64 = 6, S64 = 7;
    Integer128 U128= 8, S128= 9;

    VInteger32 U32 = 4, S32 = 5, INVALIDASEL7, INVALIDASEL7,
                      INVALIDBSEL7=6, INVALIDBSEL7, INVALIDSEL7=6, INVALIDSEL7;

    Integer = Integer8 + Integer16 + Integer32 + Integer64;
    LInteger = Integer8 + Integer16 + Integer32 + Integer64 + Integer128;
    Integer1632 = Integer16 + Integer32;
    IntegerNo16 = Integer8 + Integer32 + Integer64;




    LDInteger "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128";
    BVOnly INVALIDSIZE7=7,BV=7;
    CInteger SD=0, "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", INVALIDSIZE7;
    AInteger "32", "64", "96", "128";
    QInteger "32", "64";
    BQInteger "64", "128";
    SQInteger "8"=0, "16"=2, "32"=4, "64"=5, "128"=6, F32=11, U8=0, S8, U16, S16, U32, U64, U128, S32,
                      S64, S128, F16, "F32.FTZ.RN", F64, INVALIDATOMICSIZE(13..15);
    DFormat UD,SD;

    Pipe HW, FMA64, FMA32, XLU, ALU, AGU, SU, FU, FMUL,
              INVALIDPIPE49, INVALID0PIPE4A, INVALID0PIPE4B, INVALID0PIPE4C, INVALID0PIPE4D, INVALID0PIPE4E,
              INVALID0PIPE4F, INVALID9=9, INVALID0A, INVALID0B, INVALID0C, INVALID0D, INVALID0E, INVALID0F;
    Pipe2 HW, XLU, ALU, INVALIDPIPEA3, INVALID=3;
    Pipe2FMALite HW, FMA, MUL, INVALIDPIPE3, FMA2=2, INVALID;

    Test FALSE=0, ZFF=5, ZF0=5, LEG=7, U=8, ZFT=10, ZF1=10, TRUE=15, NOT_OVERFLOW=16, "0FF"=16,
              CFF=17, CARRY=17, ABOVE=18, SF0=18, SIGN=19, SF1=21, CFT=22, CF1=22, OF1=23, OVERFLOW=23,
              NOT_SIGN=28, BELOW_OR_EQUAL=29, NOT_CARRY=30, "1E"=30, "1F"=31,
              F=0, LT, EQ, LE, GT, NE, GE, NUM, NAN, LTU, EQU, LEU, GTU,
              NEU, GEU, T, OFF, LO, SFF, LS, HI, SFT, HS, OFT, CSM_TA,
              CSM_TR, CSM_MX, FCSM_TA, FCSM_TR, FCSM_MX, RLE, RGT;

    Scale NONE, D2, D4, D8, M8, M4, M2, INVALIDSCALE37;

    ICmpAll F, LT, EQ, LE, GT, NE, GE, T;
    ICmpU LO=1, LS=3, HI=4, HS=6;

    TPhase noPhase,T,P,INVALIDPHASE3;
    ITypeI I;
    ITypeF F;
    BVal BM, BF;

    PR PR;
    H1H0 H0,H1;
    B1B0 H0, H1=2, B(0..3)=(0..3);
    I2XH B(0..3), H0=1, H0=0, H1=3, H1=2;
    HILO LO,HI;
    RelOpt REL;

    X noX, X;
    XMode noX, XLO, XMED, XHI;
    XXHI noX, INVALIDSHRXMODE1, X, XHI;

    C C, c=0;
    V V, v=0;
    A A, a=0;
    CWMode C,W;
    B noB, B;
    I noI, I;
    P noP, P;
    E noE, E;
    EU noEU, EU;
    U noU, U;
    S noS, S;
    DC noDC, DC;
    MS noMS, MS;
    CL noCL, CL;
    PO noPO, ILLEGAL1, ILLEGAL2, PO;
    SH noSH, SH;
    NDV noNDV, NDV;
    LMT noLMT, LMT;
    FTZ noFTZ, FTZ;
    SAT noSAT, SAT;
    AVRG noAVRG, AVRG;
    TOFF1 noTOFF, AOFFI;
    TOFF2 noTOFF, AOFFI, INVALIDBTOFF02, PTP=2, INVALIDBTOFF03;
    BREV noBREV, BREV;
    NODEP noNODEP, NODEP;

    BOnly B;
    POnly P;

    SD U8, U32, S32, F32, SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    SD3 "8", S8, "16", U16=2, S16, "32", "64", "128", INVALIDSIZE7,
              U8=0, U32, S32, F32, SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    FMZ noFTZ, FTZ, FMZ, INVALIDFMZ3;
    LOD noLOD, LZ, LB, LL, INVALIDBLOD(4..5), LBA, LLA;
    LOD1 LZ,LL;
    LODLEN LOD,LEN;

    PMode IDX, F4E, B4E, RC8, ECL, ECR, RC16, INVALIDPMODE7;
    VoteOp ALL,ANY,EQ,INVALIDVMODE3,INVALIDVMODE4;
    VTGMode "VTG.R"=5, "VTG.A", "VTG.RA";

    BPTMode DRAIN,CAL,PAUSE,TRAP;

    CMode SP, DP0Z, DP1XY, INVALIDFCCO3, DP1Z=3;
    AdMode IA, IL, IS, ISL;
    MN MN,MX;

    OutType INVALIDOUTSTYPE0, EMIT, CUT, EMIT_THEN_CUT;

    PixMode MSCOUNT,COVMASK,COVERED,OFFSET,CENTROID_OFFSET,MY_INDEX,INVALIDPIXMODE(6..7),INVALID(0..1)=(6..7);
    MSI C=0,INVALIDMSI3=3,CENTER=0,CENTROID,OFFSET,INVALID;


    MufuOp COS, SIN, EX2, LG2, RCP, RSQ, RCP64H, RSQ64H,
                   INVALIDMUFUOPCODE(8..9), INVALIDMUFUOPCODEA, INVALIDMUFUOPCODEB, INVALIDMUFUOPCODEC,
                   INVALIDMUFUOPCODED, INVALIDMUFUOPCODEE, INVALIDMUFUOPCODEF;
    BarSyncArv SYNC, ARV;
    BarSync SYNC = 0;
    BarArv ARV = 1;
    BARRED RED;
    Arv SYNC,ARV;
    RTTOp NoTERMINATE, TERMINATE;
    RROOp SINCOS, EX2;
    AIO I, O;
    Trig noTRIG, TRIG;
    STPMode noWAIT, WAIT;

    OnlyNoDep NODEP;
    OnlyT T;

    LoadCacheOp0 CA, CG;
    LoadCacheOp LU=2, CA=0, CG, CS, CV;
    LLoadCacheOp CS=2, CA=0, CG, LU, CV;
    StoreCacheOp WB, CG, CS, WT;
    CCTLOp PF1=1, PF1.5, PF2, WB, IV, IVALL, RS, INVALIDCCTLOP(8..31);
    OnlyQry QRY1;
    OnlyIvall IVALL=6;
    SuqOp RANK,PIXFMT,SMPLSZ,DIM,RGBA,BLKSZ,INVALIDSUQOP(6..31);
    RGBA_NONE INVALIDRGBAMASK0, noRGBA=0;
    RGBA INVALIDRGBAMASK(1..15)=(1..15),
                   R=1, G, RG, B, RB, GB, RGB, A, RA, GA, RGA, BA, RBA, GBA, RGBA;
    Dim "1D", "2D", INVALIDSURFACEDIM2, "3D"=2, "E2D";
    Clamp0 Z,NEAR,TRAP,INVALIDSURFACECLAMP3;
    Clamp1 IGN,NEAR,TRAP,INVALIDSURFACECLAMP3;

    TexComp R,G,B,A;

    TXQMode TEX_HEADER_DIMENSION, TEX_HEADER_TEXTURE_TYPE, TEX_HEADER_SAMPLER_POS, "3", "4", "5", "6", "7",
                   TEX_SAMPLER_FILTER, TEX_SAMPLER_LOD, TEX_SAMPLER_WRAP, TEX_SAMPLER_BORDER_COLOR, "12", "13",
                   "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
                   "30", "31";

    ParamA "_1D" = 0b00_0,
                   "1D" = 0b00_0,
                   RECT = 0b01_0,
                   "_2D" = 0b01_0,
                   "2D" = 0b01_0,
                   "_3D" = 0b10_0,
                   "3D" = 0b10_0,
                   CUBE = 0b11_0,
                   ARRAY_1D = 0b00_1,
                   ARRAY_RECT = 0b01_1,
                   ARRAY_2D = 0b01_1,
                   ARRAY_3D = 0b10_1,
                   CUBEARRAY = 0b11_1,
                   ARRAY_CUBE = 0b11_1;

    MemBarLevel CTA,GL,SYS,INVALIDMEMBAR3;

    Cache D,U,C,I;




    LaneMask2
        X = 0b01,
        Y = 0b10,
        XY = 0b11;

    LaneMask4
        X = 0b0100,
        Y = 0b1000,
        Z = 0b0001,
        W = 0b0010,
        XW = 0b0110,
        YW = 0b1010,
        ZW = 0b0011,
        XZ = 0b0101,
        YZ = 0b1001,
        XY = 0b1100,
        YZW = 0b1011,
        XZW = 0b0111,
        XYW = 0b1110,
        XYZ = 0b1101,
        XYZW = 0b1111
        ;

   SWZMode
        "0000","1111","2222","3333","1032","2301",INVALIDSWIZZLEMODE(6..7);

   ASel4
        "0000","1111","2222","3333","3210","4321","5432","6543","3201","3012","0213","3120","1230","2310",
        ASEL4E, ASEL4F, INVALIDASEL4E=14, INVALIDASEL4F;

   BSel4
        "4444","5555","6666","7777","7654","6543","5432","4321","4567","6745","5476",BSEL4B,BSEL4C,BSEL4D,
        BSEL4E, BSEL4F, INVALIDBSEL4B=11, INVALIDBSEL4C, INVALIDBSEL4D, INVALIDBSEL4E, INVALIDBSEL4F;

   Sel2
        "00","01","02","03",
        "10","11","12","13",
        "20","21","22","23",
        "30","31","32","33";


   Sel2hi
        "00","01",
        "10","11";


    PNWord
        PPPPPPPP,PPPPPPNP,PPPPPPPN,PPPPPPZP,PPPPNPPP,PPPPNPNP,PPPPNPPN,PPPPNPZP,
        PPPPPNPP,PPPPPNNP,PPPPPNPN,PPPPPNZP,PPPPZPPP,PPPPZPNP,PPPPZPPN,PPPPZPZP,
        PPNPPPPP,PPNPPPNP,PPNPPPPN,PPNPPPZP,PPNPNPPP,PPNPNPNP,PPNPNPPN,PPNPNPZP,
        PPNPPNPP,PPNPPNNP,PPNPPNPN,PPNPPNZP,PPNPZPPP,PPNPZPNP,PPNPZPPN,PPNPZPZP,
        PPPNPPPP,PPPNPPNP,PPPNPPPN,PPPNPPZP,PPPNNPPP,PPPNNPNP,PPPNNPPN,PPPNNPZP,
        PPPNPNPP,PPPNPNNP,PPPNPNPN,PPPNPNZP,PPPNZPPP,PPPNZPNP,PPPNZPPN,PPPNZPZP,
        PPZPPPPP,PPZPPPNP,PPZPPPPN,PPZPPPZP,PPZPNPPP,PPZPNPNP,PPZPNPPN,PPZPNPZP,
        PPZPPNPP,PPZPPNNP,PPZPPNPN,PPZPPNZP,PPZPZPPP,PPZPZPNP,PPZPZPPN,PPZPZPZP,
        NPPPPPPP,NPPPPPNP,NPPPPPPN,NPPPPPZP,NPPPNPPP,NPPPNPNP,NPPPNPPN,NPPPNPZP,
        NPPPPNPP,NPPPPNNP,NPPPPNPN,NPPPPNZP,NPPPZPPP,NPPPZPNP,NPPPZPPN,NPPPZPZP,
        NPNPPPPP,NPNPPPNP,NPNPPPPN,NPNPPPZP,NPNPNPPP,NPNPNPNP,NPNPNPPN,NPNPNPZP,
        NPNPPNPP,NPNPPNNP,NPNPPNPN,NPNPPNZP,NPNPZPPP,NPNPZPNP,NPNPZPPN,NPNPZPZP,
        NPPNPPPP,NPPNPPNP,NPPNPPPN,NPPNPPZP,NPPNNPPP,NPPNNPNP,NPPNNPPN,NPPNNPZP,
        NPPNPNPP,NPPNPNNP,NPPNPNPN,NPPNPNZP,NPPNZPPP,NPPNZPNP,NPPNZPPN,NPPNZPZP,
        NPZPPPPP,NPZPPPNP,NPZPPPPN,NPZPPPZP,NPZPNPPP,NPZPNPNP,NPZPNPPN,NPZPNPZP,
        NPZPPNPP,NPZPPNNP,NPZPPNPN,NPZPPNZP,NPZPZPPP,NPZPZPNP,NPZPZPPN,NPZPZPZP,
        PNPPPPPP,PNPPPPNP,PNPPPPPN,PNPPPPZP,PNPPNPPP,PNPPNPNP,PNPPNPPN,PNPPNPZP,
        PNPPPNPP,PNPPPNNP,PNPPPNPN,PNPPPNZP,PNPPZPPP,PNPPZPNP,PNPPZPPN,PNPPZPZP,
        PNNPPPPP,PNNPPPNP,PNNPPPPN,PNNPPPZP,PNNPNPPP,PNNPNPNP,PNNPNPPN,PNNPNPZP,
        PNNPPNPP,PNNPPNNP,PNNPPNPN,PNNPPNZP,PNNPZPPP,PNNPZPNP,PNNPZPPN,PNNPZPZP,
        PNPNPPPP,PNPNPPNP,PNPNPPPN,PNPNPPZP,PNPNNPPP,PNPNNPNP,PNPNNPPN,PNPNNPZP,
        PNPNPNPP,PNPNPNNP,PNPNPNPN,PNPNPNZP,PNPNZPPP,PNPNZPNP,PNPNZPPN,PNPNZPZP,
        PNZPPPPP,PNZPPPNP,PNZPPPPN,PNZPPPZP,PNZPNPPP,PNZPNPNP,PNZPNPPN,PNZPNPZP,
        PNZPPNPP,PNZPPNNP,PNZPPNPN,PNZPPNZP,PNZPZPPP,PNZPZPNP,PNZPZPPN,PNZPZPZP,
        ZPPPPPPP,ZPPPPPNP,ZPPPPPPN,ZPPPPPZP,ZPPPNPPP,ZPPPNPNP,ZPPPNPPN,ZPPPNPZP,
        ZPPPPNPP,ZPPPPNNP,ZPPPPNPN,ZPPPPNZP,ZPPPZPPP,ZPPPZPNP,ZPPPZPPN,ZPPPZPZP,
        ZPNPPPPP,ZPNPPPNP,ZPNPPPPN,ZPNPPPZP,ZPNPNPPP,ZPNPNPNP,ZPNPNPPN,ZPNPNPZP,
        ZPNPPNPP,ZPNPPNNP,ZPNPPNPN,ZPNPPNZP,ZPNPZPPP,ZPNPZPNP,ZPNPZPPN,ZPNPZPZP,
        ZPPNPPPP,ZPPNPPNP,ZPPNPPPN,ZPPNPPZP,ZPPNNPPP,ZPPNNPNP,ZPPNNPPN,ZPPNNPZP,
        ZPPNPNPP,ZPPNPNNP,ZPPNPNPN,ZPPNPNZP,ZPPNZPPP,ZPPNZPNP,ZPPNZPPN,ZPPNZPZP,
        ZPZPPPPP,ZPZPPPNP,ZPZPPPPN,ZPZPPPZP,ZPZPNPPP,ZPZPNPNP,ZPZPNPPN,ZPZPNPZP,
        ZPZPPNPP,ZPZPPNNP,ZPZPPNPN,ZPZPPNZP,ZPZPZPPP,ZPZPZPNP,ZPZPZPPN,ZPZPZPZP;
TABLES

   IntSize
          Integer@U8 -> 0b00_0
          Integer@S8 -> 0b00_1
          Integer@U16 -> 0b01_0
          Integer@S16 -> 0b01_1
          Integer@U32 -> 0b10_0
          Integer@S32 -> 0b10_1
          Integer@U64 -> 0b11_0
          Integer@S64 -> 0b11_1
          ;

   IsSigned
          Integer32@U32 -> 0
          Integer32@S32 -> 1
          ;

   IsSameSigned
          Integer32@U32 Integer32@U32 -> 0
          Integer32@S32 Integer32@S32 -> 1
          Integer32@S32 Integer32@U32 -> 0
          Integer32@U32 Integer32@S32 -> 0
          ;

   I2I_N_Sizes
          Integer1632@U16 Integer1632@U16 -> 0b0000
          Integer1632@S16 Integer1632@U16 -> 0b0010
          Integer1632@U32 Integer1632@U16 -> 0b0100
          Integer1632@S32 Integer1632@U16 -> 0b0110

          Integer1632@U16 Integer1632@S16 -> 0b0001
          Integer1632@S16 Integer1632@S16 -> 0b0011
          Integer1632@U32 Integer1632@S16 -> 0b0101
          Integer1632@S32 Integer1632@S16 -> 0b0111

          Integer1632@U16 Integer1632@U32 -> 0b1000
          Integer1632@S16 Integer1632@U32 -> 0b1010
          Integer1632@U32 Integer1632@U32 -> 0b1100
          Integer1632@S32 Integer1632@U32 -> 0b1110

          Integer1632@U16 Integer1632@S32 -> 0b1001
          Integer1632@S16 Integer1632@S32 -> 0b1011
          Integer1632@U32 Integer1632@S32 -> 0b1101
          Integer1632@S32 Integer1632@S32 -> 0b1111
          ;

Integer8Signed
          Integer8@U8 -> 0
          Integer8@S8 -> 1
          ;

Integer16Signed
          Integer16@U16 -> 0
          Integer16@S16 -> 1
          ;

IntegerSigned
          Integer@U16 -> 0
          Integer@S16 -> 1
          Integer@U8 -> 0
          Integer@S8 -> 1
          Integer@U32 -> 0
          Integer@S32 -> 1
          Integer@U64 -> 0
          Integer@S64 -> 1
          ;

Integer8x8Signed
          Integer8@U8 Integer8@U8 -> 0
          Integer8@S8 Integer8@S8 -> 1
          Integer8@S8 Integer8@U8 -> 0
          Integer8@U8 Integer8@S8 -> 0
          ;

Integer16x16Signed
          Integer16@U16 Integer16@U16 -> 0
          Integer16@S16 Integer16@S16 -> 1
          Integer16@S16 Integer16@U16 -> 0
          Integer16@U16 Integer16@S16 -> 0
          ;

    PSign
       PO@noPO 0 0 -> 0b00
       PO@noPO 0 1 -> 0b01
       PO@noPO 1 0 -> 0b10
       PO@noPO 1 1 -> 0b00
         PO@PO 0 0 -> 0b11
         PO@PO 0 1 -> 0b11
         PO@PO 1 0 -> 0b11
         PO@PO 1 1 -> 0b11
   PO@ILLEGAL1 0 0 -> 0b01
   PO@ILLEGAL1 0 1 -> 0b01
   PO@ILLEGAL1 1 0 -> 0b01
   PO@ILLEGAL1 1 1 -> 0b01
   PO@ILLEGAL2 0 0 -> 0b10
   PO@ILLEGAL2 0 1 -> 0b10
   PO@ILLEGAL2 1 0 -> 0b10
   PO@ILLEGAL2 1 1 -> 0b10
          ;

    VMode
        AVRG@noAVRG 0 0 -> 0
        AVRG@noAVRG 0 1 -> 1
        AVRG@noAVRG 1 0 -> 2
        AVRG@noAVRG 1 1 -> 0
          AVRG@AVRG 0 0 -> 3
          AVRG@AVRG 0 1 -> 3
          AVRG@AVRG 1 0 -> 3
          AVRG@AVRG 1 1 -> 3
          ;

    PSign32
        PO@noPO 0 -> 0b00
        PO@noPO 1 -> 0b10
          PO@PO 0 -> 0b11
          PO@PO 1 -> 0b00
    PO@ILLEGAL1 0 -> 0b01
    PO@ILLEGAL1 1 -> 0b01
    PO@ILLEGAL2 0 -> 0b10
    PO@ILLEGAL2 1 -> 0b10
          ;

    PSignFFMA
          0 0 -> 0
          1 0 -> 1
          0 1 -> 1
          1 1 -> 0
          ;

    PSignMAD
       PO@noPO 0 0 0 -> 0b00
       PO@noPO 1 1 0 -> 0b00
       PO@noPO 0 0 1 -> 0b01
       PO@noPO 1 0 0 -> 0b10
       PO@noPO 0 1 0 -> 0b10
       PO@noPO 1 1 1 -> 0b01
       PO@noPO 0 1 1 -> 0b00
       PO@noPO 1 0 1 -> 0b00
         PO@PO 0 0 0 -> 0b11
         PO@PO 0 0 1 -> 0b11
         PO@PO 0 1 0 -> 0b11
         PO@PO 0 1 1 -> 0b11
         PO@PO 1 0 0 -> 0b11
         PO@PO 1 0 1 -> 0b11
         PO@PO 1 1 0 -> 0b11
         PO@PO 1 1 1 -> 0b11
   PO@ILLEGAL1 0 0 0 -> 0b01
   PO@ILLEGAL1 0 0 1 -> 0b01
   PO@ILLEGAL1 0 1 0 -> 0b01
   PO@ILLEGAL1 0 1 1 -> 0b01
   PO@ILLEGAL1 1 0 0 -> 0b01
   PO@ILLEGAL1 1 0 1 -> 0b01
   PO@ILLEGAL1 1 1 0 -> 0b01
   PO@ILLEGAL1 1 1 1 -> 0b01
   PO@ILLEGAL2 0 0 0 -> 0b10
   PO@ILLEGAL2 0 0 1 -> 0b10
   PO@ILLEGAL2 0 1 0 -> 0b10
   PO@ILLEGAL2 0 1 1 -> 0b10
   PO@ILLEGAL2 1 0 0 -> 0b10
   PO@ILLEGAL2 1 0 1 -> 0b10
   PO@ILLEGAL2 1 1 0 -> 0b10
   PO@ILLEGAL2 1 1 1 -> 0b10
          ;

    CombineBP
          1 0 -> 0
          0 1 -> 1
          0 0 -> 0
          1 1 -> 0
          ;

    RCIConstBank
          0 -> 0b010
          1 -> 0b100
         16 -> 0b110
          2 -> 0b010
          3 -> 0b010
          4 -> 0b010
          5 -> 0b010
          6 -> 0b010
          7 -> 0b010
          8 -> 0b010
          9 -> 0b010
         10 -> 0b010
         11 -> 0b010
         12 -> 0b010
         13 -> 0b010
         14 -> 0b010
         15 -> 0b010
         17 -> 0b010
         18 -> 0b010
         19 -> 0b010
         20 -> 0b010
         21 -> 0b010
         22 -> 0b010
         23 -> 0b010
         24 -> 0b010
         25 -> 0b010
         26 -> 0b010
         27 -> 0b010
         28 -> 0b010
         29 -> 0b010
         30 -> 0b010
         31 -> 0b010
          ;

    CNSConstBank
          0 -> 0b01
          1 -> 0b10
         16 -> 0b11
          2 -> 0b01
          3 -> 0b01
          4 -> 0b01
          5 -> 0b01
          6 -> 0b01
          7 -> 0b01
          8 -> 0b01
          9 -> 0b01
         10 -> 0b01
         11 -> 0b01
         12 -> 0b01
         13 -> 0b01
         14 -> 0b01
         15 -> 0b01
         17 -> 0b01
         18 -> 0b01
         19 -> 0b01
         20 -> 0b01
         21 -> 0b01
         22 -> 0b01
         23 -> 0b01
         24 -> 0b01
         25 -> 0b01
         26 -> 0b01
         27 -> 0b01
         28 -> 0b01
         29 -> 0b01
         30 -> 0b01
         31 -> 0b01
          ;

    LDCNConstBank
          0 -> 0b000
          1 -> 0b001
          2 -> 0b010
          3 -> 0b011
          4 -> 0b100
          5 -> 0b101
          6 -> 0b110
         16 -> 0b111
          7 -> 0b000
          8 -> 0b000
          9 -> 0b000
         10 -> 0b000
         11 -> 0b000
         12 -> 0b000
         13 -> 0b000
         14 -> 0b000
         15 -> 0b000
         17 -> 0b000
         18 -> 0b000
         19 -> 0b000
         20 -> 0b000
         21 -> 0b000
         22 -> 0b000
         23 -> 0b000
         24 -> 0b000
         25 -> 0b000
         26 -> 0b000
         27 -> 0b000
         28 -> 0b000
         29 -> 0b000
         30 -> 0b000
         31 -> 0b000
          ;

    CRegAlignment
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 1
          CInteger@S16 -> 1
          CInteger@"32" -> 1
          CInteger@"64" -> 2
          CInteger@"128" -> 4
          CInteger@INVALIDSIZE7 -> 1
          ;

    BQRegAlignment
          BQInteger@"64" -> 2
          BQInteger@"128" -> 4
          ;

    ARegAlignment
          AInteger@"32" -> 1
          AInteger@"64" -> 2
          AInteger@"96" -> 4
          AInteger@"128" -> 4
          ;

    QRegAlignment
          QInteger@"32" -> 1
          QInteger@"64" -> 2
          ;

    SQRegAlignment
          SQInteger@U8 -> 1
          SQInteger@S8 -> 1
          SQInteger@U16 -> 1
          SQInteger@S16 -> 1
          SQInteger@F16 -> 1
          SQInteger@U32 -> 1
          SQInteger@S32 -> 1
          SQInteger@"F32.FTZ.RN" -> 1
          SQInteger@INVALIDATOMICSIZE13 -> 1
          SQInteger@INVALIDATOMICSIZE14 -> 1
          SQInteger@INVALIDATOMICSIZE15 -> 1
          SQInteger@U64 -> 2
          SQInteger@S64 -> 2
          SQInteger@F64 -> 2
          SQInteger@U128 -> 4
          SQInteger@S128 -> 4
          ;

    CIntSize
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 2
          CInteger@S16 -> 2
          CInteger@"32" -> 4
          CInteger@"64" -> 8
          CInteger@"128" -> 16
          ;

    Video4ImmSel
          ASel4@"0000" -> 1
          ASel4@"1111" -> 1
          ASel4@"2222" -> 1
          ASel4@"3333" -> 1
          ASel4@"3210" -> 1
          ASel4@"4321" -> 1
          ASel4@"5432" -> 1
          ASel4@"6543" -> 1
          ASel4@"3201" -> 1
          ASel4@"3012" -> 1
          ASel4@"0213" -> 1
          ASel4@"3120" -> 1
          ASel4@"1230" -> 1
          ASel4@"2310" -> 1
          ASel4@INVALIDASEL4E -> 1
          ASel4@INVALIDASEL4F -> 1
          ;

    TXQModeDim
          TXQMode@TEX_HEADER_DIMENSION -> 0b00000_1
          TXQMode@TEX_HEADER_TEXTURE_TYPE -> 0b00001_0
          TXQMode@TEX_HEADER_SAMPLER_POS -> 0b00010_1
          TXQMode@"3" -> 0b00011_0
          TXQMode@"4" -> 0b00100_0
          TXQMode@"5" -> 0b00101_0
          TXQMode@"6" -> 0b00110_0
          TXQMode@"7" -> 0b00111_0
          TXQMode@TEX_SAMPLER_FILTER -> 0b01000_0
          TXQMode@TEX_SAMPLER_LOD -> 0b01001_0
          TXQMode@TEX_SAMPLER_WRAP -> 0b01010_0
          TXQMode@TEX_SAMPLER_BORDER_COLOR -> 0b01011_0
          TXQMode@"12" -> 0b01100_0
          TXQMode@"13" -> 0b01101_0
          TXQMode@"14" -> 0b01110_0
          TXQMode@"15" -> 0b01111_0
          TXQMode@"16" -> 0b10000_0
          TXQMode@"17" -> 0b10001_0
          TXQMode@"18" -> 0b10010_0
          TXQMode@"19" -> 0b10011_0
          TXQMode@"20" -> 0b10100_0
          TXQMode@"21" -> 0b10101_0
          TXQMode@"22" -> 0b10110_0
          TXQMode@"23" -> 0b10111_0
          TXQMode@"24" -> 0b11000_0
          TXQMode@"25" -> 0b11001_0
          TXQMode@"26" -> 0b11010_0
          TXQMode@"27" -> 0b11011_0
          TXQMode@"28" -> 0b11100_0
          TXQMode@"29" -> 0b11101_0
          TXQMode@"30" -> 0b11110_0
          TXQMode@"31" -> 0b11111_0
          ;

    ldbvCopMerge
          BQInteger@"64" LoadCacheOp0@CA -> 0
          BQInteger@"64" LoadCacheOp0@CG -> 1
          BQInteger@"128" LoadCacheOp0@CA -> 2
          BQInteger@"128" LoadCacheOp0@CG -> 3
          ;

    abSize
          CInteger@U8 CInteger@U8 -> 0
          CInteger@U8 CInteger@S8 -> 1
          CInteger@U8 CInteger@U16 -> 2
          CInteger@U8 CInteger@S16 -> 3
          CInteger@U8 CInteger@"32" -> 4

          CInteger@S8 CInteger@U8 -> 5
          CInteger@S8 CInteger@S8 -> 6
          CInteger@S8 CInteger@U16 -> 7
          CInteger@S8 CInteger@S16 -> 8
          CInteger@S8 CInteger@"32" -> 9

          CInteger@U16 CInteger@U8 -> 10
          CInteger@U16 CInteger@S8 -> 11
          CInteger@U16 CInteger@U16 -> 12
          CInteger@U16 CInteger@S16 -> 13
          CInteger@U16 CInteger@"32" -> 14

          CInteger@S16 CInteger@U8 -> 15
          CInteger@S16 CInteger@S8 -> 16
          CInteger@S16 CInteger@U16 -> 17
          CInteger@S16 CInteger@S16 -> 18
          CInteger@S16 CInteger@"32" -> 19

          CInteger@"32" CInteger@U8 -> 20
          CInteger@"32" CInteger@S8 -> 21
          CInteger@"32" CInteger@U16 -> 22
          CInteger@"32" CInteger@S16 -> 23
          CInteger@"32" CInteger@"32" -> 24
          CInteger@"32" CInteger@"64" -> 25
          CInteger@"32" CInteger@"128" -> 26

          CInteger@"64" CInteger@"32" -> 27
          CInteger@"64" CInteger@"64" -> 28
          CInteger@"64" CInteger@"128" -> 29

          CInteger@"128" CInteger@"32" -> 30
          CInteger@"128" CInteger@"64" -> 31

          CInteger@U8 CInteger@"64" -> 0
          CInteger@U8 CInteger@"128" -> 0
          CInteger@S8 CInteger@"64" -> 0
          CInteger@S8 CInteger@"128" -> 0
          CInteger@U16 CInteger@"64" -> 0
          CInteger@U16 CInteger@"128" -> 0
          CInteger@S16 CInteger@"64" -> 0
          CInteger@S16 CInteger@"128" -> 0
          CInteger@"64" CInteger@U8 -> 0
          CInteger@"64" CInteger@S8 -> 0
          CInteger@"64" CInteger@U16 -> 0
          CInteger@"64" CInteger@S16 -> 0
          CInteger@"128" CInteger@U8 -> 0
          CInteger@"128" CInteger@S8 -> 0
          CInteger@"128" CInteger@U16 -> 0
          CInteger@"128" CInteger@S16 -> 0
          CInteger@"128" CInteger@"128" -> 0
          ;

    VFormat8
          Integer@U8 B1B0@B0 -> 0b000_0
          Integer@U8 B1B0@B1 -> 0b001_0
          Integer@U8 B1B0@B2 -> 0b010_0
          Integer@U8 B1B0@B3 -> 0b011_0
          Integer@S8 B1B0@B0 -> 0b000_1
          Integer@S8 B1B0@B1 -> 0b001_1
          Integer@S8 B1B0@B2 -> 0b010_1
          Integer@S8 B1B0@B3 -> 0b011_1
          ;

    VFormat16
          Integer@U16 H1H0@H0 -> 0b100_0
          Integer@U16 H1H0@H1 -> 0b101_0
          Integer@S16 H1H0@H0 -> 0b100_1
          Integer@S16 H1H0@H1 -> 0b101_1
          ;

    VFormat32
          VInteger32@U32 -> 0b110_0
          VInteger32@S32 -> 0b110_1
          6 -> 0b111_1
          7 -> 0b111_0
          ;






    VFormat8_N
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b0_0_00000
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b0_0_00001
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b0_0_00010
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b0_0_00011
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b0_0_00100
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b0_0_00101
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b0_0_00110
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b0_0_00111
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b0_0_01000
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b0_0_01001
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b0_0_01010
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b0_0_01011
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b0_0_01100
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b0_0_01101
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b0_0_01110
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b0_0_01111
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b0_1_00000
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b0_1_00001
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b0_1_00010
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b0_1_00011
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b0_1_00100
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b0_1_00101
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b0_1_00110
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b0_1_00111
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b0_1_01000
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b0_1_01001
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b0_1_01010
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b0_1_01011
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b0_1_01100
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b0_1_01101
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b0_1_01110
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b0_1_01111
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b1_0_00000
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b1_0_00001
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b1_0_00010
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b1_0_00011
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b1_0_00100
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b1_0_00101
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b1_0_00110
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b1_0_00111
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b1_0_01000
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b1_0_01001
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b1_0_01010
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b1_0_01011
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b1_0_01100
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b1_0_01101
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b1_0_01110
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b1_0_01111
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b1_1_00000
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b1_1_00001
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b1_1_00010
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b1_1_00011
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b1_1_00100
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b1_1_00101
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b1_1_00110
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b1_1_00111
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b1_1_01000
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b1_1_01001
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b1_1_01010
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b1_1_01011
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b1_1_01100
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b1_1_01101
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b1_1_01110
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b1_1_01111
          ;

    VFormat32_8_N
          Integer@U32 Integer@U8 B1B0@B0 -> 0b0_0_10000
          Integer@U32 Integer@U8 B1B0@B1 -> 0b0_0_10001
          Integer@U32 Integer@U8 B1B0@B2 -> 0b0_0_10010
          Integer@U32 Integer@U8 B1B0@B3 -> 0b0_0_10011
          Integer@U32 Integer@S8 B1B0@B0 -> 0b0_1_10000
          Integer@U32 Integer@S8 B1B0@B1 -> 0b0_1_10001
          Integer@U32 Integer@S8 B1B0@B2 -> 0b0_1_10010
          Integer@U32 Integer@S8 B1B0@B3 -> 0b0_1_10011
          Integer@S32 Integer@U8 B1B0@B0 -> 0b1_0_10000
          Integer@S32 Integer@U8 B1B0@B1 -> 0b1_0_10001
          Integer@S32 Integer@U8 B1B0@B2 -> 0b1_0_10010
          Integer@S32 Integer@U8 B1B0@B3 -> 0b1_0_10011
          Integer@S32 Integer@S8 B1B0@B0 -> 0b1_1_10000
          Integer@S32 Integer@S8 B1B0@B1 -> 0b1_1_10001
          Integer@S32 Integer@S8 B1B0@B2 -> 0b1_1_10010
          Integer@S32 Integer@S8 B1B0@B3 -> 0b1_1_10011
          ;

    VFormat8_32_N
          Integer@U8 B1B0@B0 Integer@U32 -> 0b0_0_10100
          Integer@U8 B1B0@B1 Integer@U32 -> 0b0_0_10101
          Integer@U8 B1B0@B2 Integer@U32 -> 0b0_0_10110
          Integer@U8 B1B0@B3 Integer@U32 -> 0b0_0_10111
          Integer@U8 B1B0@B0 Integer@S32 -> 0b0_1_10100
          Integer@U8 B1B0@B1 Integer@S32 -> 0b0_1_10101
          Integer@U8 B1B0@B2 Integer@S32 -> 0b0_1_10110
          Integer@U8 B1B0@B3 Integer@S32 -> 0b0_1_10111
          Integer@S8 B1B0@B0 Integer@U32 -> 0b1_0_10100
          Integer@S8 B1B0@B1 Integer@U32 -> 0b1_0_10101
          Integer@S8 B1B0@B2 Integer@U32 -> 0b1_0_10110
          Integer@S8 B1B0@B3 Integer@U32 -> 0b1_0_10111
          Integer@S8 B1B0@B0 Integer@S32 -> 0b1_1_10100
          Integer@S8 B1B0@B1 Integer@S32 -> 0b1_1_10101
          Integer@S8 B1B0@B2 Integer@S32 -> 0b1_1_10110
          Integer@S8 B1B0@B3 Integer@S32 -> 0b1_1_10111
          ;

    VFormat16_N
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b0_0_11000
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b0_0_11001
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b0_0_11010
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b0_0_11011
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b0_1_11000
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b0_1_11001
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b0_1_11010
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b0_1_11011
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b1_0_11000
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b1_0_11001
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b1_0_11010
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b1_0_11011
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b1_1_11000
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b1_1_11001
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b1_1_11010
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b1_1_11011
          ;

    VFormat32_16_N
          Integer@U32 Integer@U16 H1H0@H0 -> 0b0_0_11100
          Integer@U32 Integer@U16 H1H0@H1 -> 0b0_0_11101
          Integer@U32 Integer@S16 H1H0@H0 -> 0b0_1_11100
          Integer@U32 Integer@S16 H1H0@H1 -> 0b0_1_11101
          Integer@S32 Integer@U16 H1H0@H0 -> 0b1_0_11100
          Integer@S32 Integer@U16 H1H0@H1 -> 0b1_0_11101
          Integer@S32 Integer@S16 H1H0@H0 -> 0b1_1_11100
          Integer@S32 Integer@S16 H1H0@H1 -> 0b1_1_11101
          ;

    VFormat16_32_N
          Integer@U16 H1H0@H0 Integer@U32 -> 0b0_0_11110
          Integer@U16 H1H0@H1 Integer@U32 -> 0b0_0_11111
          Integer@U16 H1H0@H0 Integer@S32 -> 0b0_1_11110
          Integer@U16 H1H0@H1 Integer@S32 -> 0b0_1_11111
          Integer@S16 H1H0@H0 Integer@U32 -> 0b1_0_11110
          Integer@S16 H1H0@H1 Integer@U32 -> 0b1_0_11111
          Integer@S16 H1H0@H0 Integer@S32 -> 0b1_1_11110
          Integer@S16 H1H0@H1 Integer@S32 -> 0b1_1_11111
          ;

OPERATION PROPERTIES
    IWIDTH
    ITYPE
    SPA
    SECONDARY
    TERTIARY
    ;

FUNIT uC
   ISSUE_SLOTS 0;
   ENCODING WIDTH 64;




  Canvas32 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX................................'

  LockPred '.....X................................................XX........'
  LockPreda '...........XXX..................................................'
  Pred '...................................................XXX..........'
  PredNot '..................................................X.............'
  Pred32b '...............................................XXX..............'
  Pred32a '.........................................XXX....................'
  Pred32Notb '.......................................X........................'
  Pred32Nota '........................................X.......................'
  NopSync '.................................................X..............'
  Sync '...........................................................X....'
  CCC32_1 '.......................................XXXXX....................'
  SReg '..............................XXXXXXXX..........................'
  SReg32 '....................................XXXXXXXX....................'
  Dest '............................................XXXXXX..............'
  DestA '..........................XXXXXX................................'
  RegA '......................................XXXXXX....................'
  RegB '................................XXXXXX..........................'
  RegC '.........XXXXXX.................................................'
  RegDa '...............XXXXXX...........................................'
  RegB32 '......................................XXXXXX....................'
  RegC32 '..................................................XXXXXX........'

  BFiller '..................XXXXXXXXXXXXXX................................'
  BarFiller '..........................XXXXXX................................'
  BcbankHi '.....................................X..........................'
  BcbankLo '..................XXXX..........................................'
  Bcaddr '......................XXXXXXXXXXXXXX............................'
  Bgap '....................................X...........................'
  Bconst '..................XXXXXXXXXXXXXXXXXXXX..........................'

  BFiller1 '..............................XX................................'
  BFiller2 '............................XXXX................................'
  BFiller3 '......................XXXXXXX...................................'

  VPDest '.......XXX......................................................'
  PredDest '........XXX.....................................................'
  PDest '............................................XXX.................'
  PNDest '...............................................XXX..............'
  CCC_1 '......................................................XXXXX.....'
  CCC_2 '.......................................XXXXX....................'




  Imm5I '......................................................XXXXX.....'
  Imm5_32 '.................................XXXXX..........................'
  Imm8_32 '..............................................XXXXXXXX..........'
  Imm8_32a '....................................XXXXXXXX....................'
  Imm8_32b '......................................XXXXXX..........XX........'
  Imm8_32c '................................XXXXXX................XX........'
  Imm12_32 '................................XXXXXXXXXXXX....................'
  Imm14_32 '....................................XXXXXXXXXXXXXX..............'
  Imm18_32 '.....................................XXXXXXXXXXXXXXXXXX.........'
  Imm22_32 '....................................XXXXXXXXXXXXXXXXXXXXXX......'
 aImm10 '...........XXXXXXXXXX...........................................'
 bImm10 '.....................XXXXX............................XXXXX.....'
  Imm8 '..............................XXXXXXXX..........................'
  Imm10 '......................XXXXXXXXXX................................'
  Imm11 '.....................XXXXXXXXXXX................................'
  Imm12 '..........................XXXXXXXXXXXX..........................'
  Imm16 '......................XXXXXXXXXXXXXXXX..........................'
  Imm20 '..................XXXXXXXXXXXXXXXXXXXX..........................'
  Imm20a '......XXX............XXXXXXXXXXXXXXXXX..........................'
  Imm22a '..............XXXXXXXXXXXXXXXXXXXXXX............................'
  Imm24 '..............XXXXXXXXXXXXXXXXXXXXXXXX..........................'
  Imm28 '..........XXXXXXXXXXXXXXXXXXXXXXXXXXXX..........................'
  Imm30a '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX............................'
  Imm32 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..........................'
  CBank '.................XXXXX..........................................'
  By '.......XX.......................................................'
  SH '.........................................................X......'
  M '......................................................X.........'
  MV '........................................................X.......'
  aE '....X...........................................................'
  bE '.....X..........................................................'
  E '.....X..........................................................'
  E32 '.........................................................X......'
  LOP '........................................................XX......'
  LOP32 '.........................................................XX.....'
  Bpt '................................................XX..............'
  Bpt32 '.........................................................XX.....'
  AdMode '......................................................XX........'
  PixMode '........................................................XXX.....'
  LSSize '........................................................XXX.....'
  abSize '......XXXXX.....................................................'
  ALSize '.........................................................XX.....'
  ALSize32 '........................................................XX......'
  OutType '.........................................................XX.....'
  COP '......................................................XX........'
  AtomOp '.......................................................XXXX.....'
  AtomSize '..XXX.................................................X.........'
  CCTLOp '......................................................XXXXX.....'
  Cache '....................................XX..........................'
  SuqOp '......................................................XXXXX.....'
  MembarL '.........................................................XX.....'




  TexQuery '.....XXXXX.X....................................................'
  TexComp '.........................................................XX.....'
  TOFF1 '.........X......................................................'
  MS '........X.......................................................'
  CL '.......X........................................................'
  DC '.......X........................................................'
  NODEP '......................................................X.........'
  TOFF2 '........XX......................................................'
  ParamA '..........XXX...................................................'
  AI '.............X..................................................'
  LOD '....XXX.........................................................'
  LOD1 '......X.........................................................'
  LODLEN '.......X........................................................'
  NDV '......................................................X.........'
  NDVa '..................X.............................................'
  SWZMode '.......................................................XXX......'
  PNWord '.......................XXXXXXXXX................................'
  Smp '...................XXXXX........................................'
  Tid '........................XXXXXXXX................................'
  Wmsk '..............XXXX..............................................'
  Smp32 '....................................XX................X.........'
  Tid32 '................................XXXX............................'
  Wmsk32 '.......................................................X........'

  shift '.........................................................X......'
  ASigned '........................................................X.......'
  BSigned '..........................................................X.....'
  ABSigned '.........................................................X......'
  ABSigned1 '..........................................................X.....'
  Signed '..........................................................X.....'
  Signed32 '......................................................X.........'
  Bop '.........XX.....................................................'
  Bop0 '................................XX..............................'
  Bop32 '.....................................XX.........................'
  BAddr '......X.........................................................'
  DstFmt '..........................................XX....................'
  IDstFmt '..........................................XX............X.......'
  ISrcFmt '.......................................XX.............X.........'
  PMode '.......................................................XXXX.....'
  XMode '........................................................XX......'
  SrcFmt '.......................................XX.......................'
  SrcDstFmt '.......................................XX.XX....................'
  DstPred '........XXX.....................................................'
  SrcPred '............XXX.................................................'
  SrcNot '...........X....................................................'
  SrcPred32 '.......................................................XXX......'
  SrcNot32 '......................................................X.........'
  Src1Pred '...................................XXX..........................'
  Src1Not '..................................X.............................'
  Src2Pred '.........................................XXX....................'
  Src2Not '........................................X.......................'
  ConstC '..........................................................X.....'




  MN '........................................................X.......'
  VOP '......XXX.......................................................'
  DFormat '......X.........................................................'
  DFormat2 '.....................X..........................................'
  VScale '.......XX.......................................................'
  safmt '.........................................................X......'
  sbfmt '..........................................................X.....'
  safmt32 '...................................................X............'
  sbfmt32 '....................................................X...........'
  DFormat32 '..................................................X.............'
  sabfmt32 '...................................................X............'
  VRed '.................XXX............................................'
  LaneMask4 '.......XX...................XX..................................'
  LaneMask2 '.......XX.......................................................'
  asel4 '....................XXXX........................................'
  bsel4 '........................XXXX....................................'
  asel2 '....................XXXX........................................'
  bsel2 '........................XXXX....................................'
  asel2hi '....................XX..........................................'
  aSelect '.................XXX.....................................X......'
  bSelect '.............................XXX..........................X.....'
  abSelect32 '...................................................XXXXXX.......'
  abSelect32a '..................................................XXXXXXX.......'

  AVGMode '.......................................................XX.......'

  Scale '............XXX.................................................'
  VComp '......................................................XXX.......'
  FComp '.....XXXX.......................................................'
  FComp32 '...............................................XXX......X.......'
  RGBA '...........XXXX.................................................'
  RGBAa '............................XXXX................................'
  Xoffset '............................XXXX................................'
  Yoffset '........................XXXX....................................'
  Zoffset '....................XXXX........................................'
  BP '.......................................................X........'
  Dim '..................XX............................................'
  Clamp '...............XX...............................................'
  Pipe4 '.........XXXX...................................................'
  Pipe2 '......................................................XX........'
  Pipe2a '.......XX.......................................................'
  Pipe2b '........................................................XX......'
  Pipe2c '.....XX.........................................................'
  QuadMask '.......................................................XXXX.....'
  WriteCC '...............X................................................'
  WriteCC32 '........................................X.......................'
  WriteCCI '.....X..........................................................'
  BVal '..........................................................X.....'
  BVal1 '........................................................X.......'
  Rnd '.............XX.................................................'
  Rnd1 '.......XX.......................................................'
  RndIR '.............XX.........................................X.......'
  IR '........................................................X.......'
  Rnd32 '..........................................XX....................'
  RndIR32 '..........................................XX..........X.........'
  Xm '.........................................................X......'
  Xm1 '........X.......................................................'
  Xm_I '..........................................................X.....'
  Brev '.......................................................X........'
  PSign '......................................................XX........'
  PSign2 '.......XX.......................................................'
  Sat '..........................................................X.....'
  Sat1 '.......X........................................................'
  Sat2 '..............X.................................................'
  Sat3 '......................................................X.........'
  Sat32 '.......................................X........................'
  SDest32 '.......................................X........................'
  I2ISizes32 '.......................................X..XX..........X.........'
  nA32 '.........................................................X......'
  nA32a '........................................................X.......'
  aA32b '.................................X..............................'
  nA32c '....................................................X...........'
  nA32d '.........................................................X......'
  nA_L '......................................................X.........'
  nB_L '.......................................................X........'
  nB '.......................................................X........'
  aB '.........................................................X......'
  nB32 '.........................................X......................'
  aB32 '......................................X.........................'
  nA1 '......................................................X.........'
  nB1 '.......................................................X........'
  aA1 '........................................................X.......'
  aB1 '.........................................................X......'
  nAB '......X.........................................................'
  nABa '......................................................X.........'
  nAB32 '...........................................................X....'
  FTZ '........X.......................................................'
  FTZ1 '..........................................................X.....'
  FTZ2 '....X...........................................................'
  FMZ '........................................................XX......'
  H1H0 '.......X........................................................'
  H1H0a '..........................................................X.....'
  HILO '.........................................................X......'
  Float '......................................................X.........'




  ABC '................XX..............................................'
  BFix_A '.................X..............................................'
  CNS_B '......................................................XX........'
  CNS_A '........................................................XX......'
  CNSIFix '......................................................XXX.......'

  RCI '......................................................XXX.......'
  I '........................................................X.......'
  RCImm '................................XXXXXX................XX........'


  AFix_BAR32 '.....................................X..........................'
  AFix_BAR '................X...............................................'
  BFix_BAR '.................X..............................................'
  BVideo '................X...............................................'
  MBLevel '.........................................................XX.....'

  Quad '........................................................X.......'
  Phase '.......................................................XX.......'
  Phase32 '.......................................XX.......................'
  VMode '........................................................XXX.....'
  IComp '......XXX.......................................................'
  IComp32 '...............................................XXX..............'
  CA '.................................................X..............'
  CA2 '...............................................X................'
  U '................................................X...............'
  LMT '...............................................X................'
  U32 '...................................X............................'
  LMT32 '..................................X.............................'
  INC '...............................................X................'
  INC32 '..........................................................X.....'
  CBank32 '........................................................XXX.....'
  CAddr32 '................................XXXXXX................XX........'
  SUOp '.......................................................XXXX.....'
  SD '.......XX.......................................................'
  CMode '.....XX.........................................................'
  MSI '......................................................XX........'
  MufuOp '..................................XXXX..........................'
  BarOpN '....................................X...........................'
  BarOp '........................................................X.......'
  BarRedOp '.........................................................XX.....'
  RTTOp '.................................................X..............'
  IPAOp '........................................................XX......'
  IPAOpN '........................................................X.......'
  RROOp '..........................................................X.....'
  RROOpN '.....................................X..........................'
  AIO '......................................................X.........'
  P '.......................................................X........'
  Trig '.............X..................................................'
  STPMode '..........................................................X.....'




  Opcode1 '................................XXXXX.................XXXXXXXXXX'
  Opcode2 'XXXXXX......................................................XXXX'
  Opcode3 'XXXXX.......................................................XXXX'
  Opcode4 '.......................................................XXXXXXXXX'
  Opcode5 '......................................................XXXXXXXXXX'
  Opcode6 '........................................................XXXXXXXX'
  Opcode7 '..........................................................XXXXXX'
  Opcode8 '................................XXXX..................XXXXXXXXXX'
  Opcode9 '................................X.....................XXXXXXXXXX'
  Opcode10 '...........................................................XXXXX'
  Opcode14 '................................XX.........................XXXXX'
  Opcode15 '................................XXXX.......................XXXXX'
  Opcode16 '................................XXXXX......................XXXXX'
  Opcode18 'XXXXXX......................................................XXXX'
  Opcode20 '.........................................................XXXXXXX'
  Opcode21 'XX..........................................................XXXX'
  Opcode22 'XXXXXX.X....................................................XXXX'
  Opcode23 '.........................................................XXXXXXX'
  Opcode24 'XXXX........................................................XXXX'
  Opcode25 '............................................................XXXX'
  Opcode26 'XXXX........................................................XXXX'
  Opcode27 'XXXXX...................................................XX..XXXX'
  Opcode29 'XXXXX.......................................................XXXX'
  Opcode30 '................................X.....................XXXXXXXXXX'
  Opcode31 '................................XXXX........................XXXX'
  Opcode32 '.....................................................XXXXXXXXXXX'




  Nenc0 '.....................................XXXXXXXXXXXX...............'
  Nenc1 '......XXX.....XXXXXXXX................XXXXXXXXXXXX..............'
  Nenc2 '.....................................XX........XXX..............'
  Nenc3 '......XXX......XXXXXXXXXXXXXXXXXXXXXXXX.................XXX.....'
  Nenc4 '......XXX.......XXXXXXXXXXXXXXXXXXXXXXX.................XX......'
  Nenc5 '......XXX......XXXXXXXXXXXXXXXXX......XX................XXX.....'
  Nenc6 '......XXX.......XXXXXXXXXXXXXXXX......XX................XX......'
  Nenc7 '......X..XXXX.........................X..X............X.........'
  Nenc8 '......X..XXXX.........................X..X............X...X.....'
  Nenc9 '......X..XXXXXX.......................X..X......................'
  Nenc10 '......X..XXXX.........................X..X..............X.X.....'
  Nenc11 '................................XXXXXX..........................'
  Nenc12 '.....X................................XXXXXX..........X.........'
  Nenc13 '......X..XXXXXXX......................XXXXXX..........X.........'
  Nenc14 '......XXXXX....X........................................XXX.....'
  Nenc15 '......XXXXXXXXXXXXXXXXXXXXXXXX........XXXXXX............XXX.....'
  Nenc16 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..................XXX.....'
  Nenc17 '......XXXXXXXXXX........................................XX......'
  Nenc18 '......XXXXXXXXXX............................XXXXXX......XX......'
  Nenc19 '......X........X......................................X.........'
  Nenc20 '.....XX..XXXXXX.........................................X.......'
  Nenc21 '........................................................X.......'
  Nenc22 '.....XX..XXXXXX.................................................'
  Nenc23 '.....XXXX.............................................XXXX......'
  Nenc24 '.....XXXXXX.....................................................'
  Nenc25 '.....XXXXXXXXXX.......................................X.XX......'
  Nenc26 '.....XXXX.............................................XXXXX.....'
  Nenc27 '.....XXXXXXXXXX.................................................'
  Nenc28 '.....XXXXXXXXXX........................................XX.X.....'
  Nenc29 '.........................................................XX.....'
  Nenc30 '.....XXXXXXXXXX.......................XXXXXX..........X.X.......'
  Nenc31 '......XXXXXXXXX.........................................XXX.....'
  Nenc32 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX............XXX.....'
  Nenc33 '......XXXXXXXXXXXXXXXXXXXXXXXX........XXXXXXXXXXXXXXXXX..X......'
  Nenc34 '.....................................XX..XX.XX..................'
  Nenc35 '......X...............................XXX.............XX........'
  Nenc36 '......X...XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..............XX........'
  Nenc37 '.....X..........................................................'
  Nenc38 '.....X.........X......................................XXXX......'
  Nenc39 '.....X.........X........................................X.......'
  Nenc40 '.....XXXXXXXXXX.......................................XX........'
  Nenc41 '......................................................XX........'
  Nenc42 '.....XX.........................................................'
  Nenc43 '.....XXXXXXXXX........................XXXXXXXXX............X....'
  Nenc44 '.....XXXXXXXXXXXX.....................XXXXXXXXX............X....'
  Nenc45 '.....XXXXXXXXX..............................XXX.X..........X....'
  Nenc46 '.....XXXXXXXXXXXX...........................XXX.X..........X....'
  Nenc47 '.....X................................XXXXXXXXX............X....'
  Nenc48 '.....X......................................XXX.X..........X....'
  Nenc49 '.....XXXXXXXXX........................XXXXXXXXX.X.XXXXXXXXXX....'
  Nenc50 '.....XXXXXXXXXXXX.....................XXXXXXXXX.X.XXXXXXXXXX....'
  Nenc51 '.....X................................XXXXXXXXX.X.XXXXXXXXXX....'
  Nenc52 '.....XXXXXXXXX........................XXXXXXXXX.XXXXXXXXXXXX....'
  Nenc53 '.....XXXXXXXXXXXX.....................XXXXXXXXX.XXXXXXXXXXXX....'
  Nenc54 '..................................................XXXXXXXXX.....'
  Nenc55 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.........X....'
  Nenc56 '.....................................XXXXXXXXXXXXX..............'
  Nenc57 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....'
  Nenc58 '.....XXXXXXXXXXXXX....................XXXXXXXXXX..XXXXXXXXXX....'
  Nenc59 '.......................................................XX.......'
  Nenc60 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.XXXXXXXXXX....'
  Nenc62 '......XX.......X..XXXXXXXX............................XX.XX.....'
  Nenc64 '......XX.......X..XXXXXXXX............................XX........'
  Nenc65 '............................................XXXXXX..............'
  Nenc66 '......XXXXXXXXXXX...............................................'
  Nenc67 '.......XXXXXXXXXXXXXXX................................XXXXX.....'
  Nenc68 '.......XXXXXXXXXXXXXX...................................X.......'
  Nenc69 '.......XX......XXXXXX.......................XXXXXX....X.X.......'
  Nenc70 '......XXXXXXXXXX......................................XXX.......'
  Nenc71 '......XX...XXXXXXXXXXXXXXXXXXX........................XX........'
  Nenc72 '....XX............XXXXXX.................................XX.....'
  Nenc73 '......X.XXXXXX..................................................'
  Nenc74 '......XXXXX...........................................XX........'
  Nenc75 '......XXXXXXXX......................XX..........................'
  Nenc76 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXX.......'
  Nenc77 '......XXXXXXXXXXX.XXXXXXXXXXXXXX......XXXXXX....................'
  Nenc78 '......X...XXXXX.......................................X.........'
  Nenc79 '......XXXXX.....................................................'
  Nenc80 '......X..XXXXXX.....XXXXXXXX..........................X.........'
  Nenc81 '.........XXXXX..................................................'
  Nenc82 '....XXX.........................................................'
  Nenc83 '...............X......................................X.........'
  Nenc84 '.....X...XXX....................................................'
  Nenc85 '....XXX.XX......................XXXXXX...................XX.....'
  Nenc86 '.....XX..XXXXXX.XXXXXXX.........................................'
  Nenc87 '.......XX......X......................................XXXXX.....'
  Nenc88 '...............X..........................................X.....'
  Nenc89 '.....XXXX......XXXXXX...........................................'
  Nenc90 '.....XXXXXXXXXXX......................XXXXXX....................'
  Nenc91 '....................................X...........................'
  Nenc92 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXX.....................X.X......'
  Nenc93 '.....XX.................................................XXX.....'
  Nenc94 '.....XX..XXXXXX...........................................X.....'
  Nenc95 '.....XX..XXXXXX........................................XXXX.....'
  Nenc96 '.....XXXXXX...............................................X.....'
  Nenc97 '....XXXXXXXXXX..................XXXXXX...................XX.....'
  Nenc98 '....XXXXX.........X......................................XX.....'
  Nenc99 '....X.....X.X.....X.............XXXXXX...................XX.....'
  Nenc100 '.......................................................X........'
  Nenc101 '.......................................................X..X.....'
  Nenc102 '.........XX............................................XX.......'
  Nenc103 '.....X..............X...........................................'
  Nenc104 '.....X..............X..................................XX.......'
  Nenc105 '.....X..............X..................................X........'
  Nenc106 '.....X..............XX..........................................'
  Nenc107 '.....X..............X..................................X........'
  Nenc108 '.....XXXX......X....XX..........................................'
  Nenc109 '....................XX..........................................'
  Nenc110 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXX.......'
  Nenc111 '.......XXXXXXXXXXXXXXX..................................X.......'
  Nenc112 '.......XX......XXXXXXX......................XXXXXX....X.X.......'
  Nenc113 '.....XXXX......XXXXXXX..........................................'



CLASS "NOP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync;

        PROPERTIES IWIDTH = 4;
OPCODES
         NOP_N = 0b00000_000000_1_000;

    ENCODING
      Opcode1 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      NopSync = S;

      !Canvas32;
      !Nenc0;


CLASS "NOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Trig(noTRIG):trig /Pipe(HW):pipe /S(noS):sync
                           { CC(CC)/Test(T):fcomp ',' } UImm(16/0):uImm;

    OPCODES
         NOP = 0b010000_0_100;

    ENCODING
      Opcode18 = Opcode;
      Trig = Trig;
      Pred = Pg;
      PredNot = Pg@not;
      Pipe4 = Pipe;
      Imm16 = uImm;
      CCC_1 = Test;
      !Nenc1;
      Sync=S;

 CLASS "LEPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync Register:Rd;

    OPCODES
         LEPC = 0b010001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      !Pipe2;
      !Nenc32;
      Sync=S;


 CLASS "POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' [~]Register:Ra ',' [~]Register:Rb;

    CONDITIONS

    OPCODES
         POPC = 0b010101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      nA_L = Ra@invert;
      nB_L = Rb@invert;

      Sync=S;
      !BFiller;
      !Nenc31;
      ABC=0;
      !WriteCC;


 CLASS "Imm POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' [~]Register:Ra ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    CONDITIONS

    OPCODES
         POPC = 0b010101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      nA_L = Ra@invert;
      nB_L = UnaryInv;

      Sync=S;

      !Nenc31;
      ABC = 3;
      !WriteCC;


 CLASS "Const POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
Register:Rd ',' [~]Register:Ra ',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         POPC = 0b010101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA_L = Ra@invert;
      nB_L = srcConst@invert;

      Sync=S;

      !Nenc31;
      ABC = 1;
      !WriteCC;


 CLASS "VOTE.VTG"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VTGMode:vtgmode /S(noS):sync UImm(28):uImm;

    OPCODES
         VOTE = 0b010010_0_100;

    ENCODING
      Opcode2 = Opcode;
      VMode =* VTGMode;
      Pred = Pg;
      PredNot = Pg@not;
      Imm28 = Imm;
      VPDest = `Predicate@PT;
      Src2Pred = `Predicate@PT;
      Dest = `Register@RZ;

      Sync=S;
      !Nenc35;


 CLASS "VOTE"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VoteOp(ALL):voteop /S(noS):sync
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VoteOp:voteop /S(noS):sync
##ENDIF
        { Register(RZ):Rd ',' }
        Predicate:Pd ',' [!]Predicate:Pa;

    OPCODES
         VOTE = 0b010010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      VMode =* VoteOp;
      Dest = Rd;
      VPDest = Pd;
      Src2Pred = Pa;
      Src2Not = Pa@not;

      Sync=S;
      !Nenc36;



CLASS "CSETP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest
                               Predicate:Pd ',' CC:inputCC;

        PROPERTIES IWIDTH = 4;
OPCODES
         CSETP_N = 0b00010_000000_1_000;

    ENCODING
      Opcode1 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      CCC32_1 = CCTest;

      !Canvas32;
      !Nenc2;


CLASS "CSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' CC:inputCC ',' [!]Predicate:Pa;

    OPCODES
         CSETP = 0b000001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;


      !Nenc3;
      Sync=S;


ALTERNATE CLASS "NoBop CSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest /S(noS):sync
                               Predicate:Pd
                                    ',' CC:inputCC ;

    OPCODES
         CSETP = 0b000001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;


      !Nenc3;
      Sync=S;


CLASS "CSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' CC:dummyCC
                                    ',' [!]Predicate:Pa;

    OPCODES
         CSET = 0b000000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;


      !Nenc4;
      Sync=S;


ALTERNATE CLASS "NoBop CSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' CC:dummyCC
                                    ;

    OPCODES
         CSET = 0b000000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;


      !Nenc4;
      Sync=S;


CLASS "PSETP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop
                               Predicate:Pd
                               ',' [!]Predicate:Pa
                               ',' [!]Predicate:Pb;
        PROPERTIES IWIDTH = 4;
OPCODES
         PSETP_N = 0b00011_000000_1_000;

    ENCODING
      Opcode1 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      Bop32 = bop;
      Pred32a = Pa;
      Pred32b = Pb;
      Pred32Nota = Pa@not;
      Pred32Notb = Pb@not;

      !Canvas32;


CLASS "ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;

ALTERNATE CLASS "NoBop ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;

CLASS "Imm ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;

ALTERNATE CLASS "NoBop Imm ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;

CLASS "Const ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;

ALTERNATE CLASS "NoBop Const ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;

ALTERNATE CLASS "ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "Imm ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "Const ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISET = 0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;


CLASS "ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;


CLASS "Imm ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;


CLASS "Const ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;

ALTERNATE CLASS "NoBop ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;

ALTERNATE CLASS "Imm ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;

ALTERNATE CLASS "NoBop Imm ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;

ALTERNATE CLASS "Const ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;

ALTERNATE CLASS "NoBop Const ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ISETP = 0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;

CLASS "ISETP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb;
        PROPERTIES IWIDTH = 4;
OPCODES
         ISETP_N = 0b100_1_000;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB = Rb;
      IComp32 = ICmpAll;

      RCI=0;
      !Canvas32;

CLASS "Imm ISETP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' SImm(8):uImm;
        PROPERTIES IWIDTH = 4;
OPCODES
         ISETP_N = 0b100_1_000;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RCImm=uImm ROR 6;
      IComp32 = ICmpAll;

      I = 0b1;
      !Canvas32;

CLASS "Const ISETP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];
        PROPERTIES IWIDTH = 4;
OPCODES
         ISETP_N = 0b100_1_000;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      IComp32 = ICmpAll;

      RCI =* RCIConstBank(constBank);
      !Canvas32;

ALTERNATE CLASS "ISETP_N U illegal"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb;
    CONDITIONS
         ERROR
           (ICmpU IN ICmpAll):
             "This comparison is not allowed in a signed integer compare"

        PROPERTIES IWIDTH = 4;
OPCODES
         ISETP_N = 0b100_1_000;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB = Rb;
      IComp32 = ICmpU;

      RCI=0;
      !Canvas32;


ALTERNATE CLASS "Imm ISETP_N U illegal"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' SImm(8):uImm;
    CONDITIONS
         ERROR
           (ICmpU IN ICmpAll):
             "This comparison is not allowed in a signed integer compare"

        PROPERTIES IWIDTH = 4;
OPCODES
         ISETP_N = 0b100_1_000;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RCImm=uImm ROR 6;
      IComp32 = ICmpU;

      I = 0b1;
      !Canvas32;


ALTERNATE CLASS "Const ISETP_N U illegal"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];
    CONDITIONS ERROR RCIConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"
         ERROR
           (ICmpU IN ICmpAll):
             "This comparison is not allowed in a signed integer compare"

        PROPERTIES IWIDTH = 4;
OPCODES
         ISETP_N = 0b100_1_000;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      IComp32 = ICmpU;

      RCI =* RCIConstBank(constBank);
      !Canvas32;


CLASS "ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' Register:Rc;
    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      IComp = ICmpAll;

      !BFiller;
      !Nenc38;
      Sync=S;
      ABC=0;


CLASS "Imm ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' Register:Rc;
    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      IComp = ICmpAll;


      !Nenc38;
      Sync=S;
      ABC = 3;


CLASS "Const ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' Register:Rc;
    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      IComp = ICmpAll;


      !Nenc38;
      Sync=S;
      ABC = 1;


CLASS "Const1 ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      IComp = ICmpAll;


      !Nenc38;
      Sync=S;
      ABC = 2;


ALTERNATE CLASS "ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' Register:Rc;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      IComp = ICmpU;

      !BFiller;
      !Nenc38;
      Sync=S;
      ABC=0;




ALTERNATE CLASS "Imm ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' Register:Rc;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      IComp = ICmpU;


      !Nenc38;
      Sync=S;
      ABC = 3;




ALTERNATE CLASS "Const ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      IComp = ICmpU;


      !Nenc38;
      Sync=S;
      ABC = 1;




ALTERNATE CLASS "Const1 ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
         ICMP = 0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      IComp = ICmpU;


      !Nenc38;
      Sync=S;
      ABC = 2;




 CLASS "BRA_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
             { CC(CC):TestCC/Test(T):CCTest ',' } RSImm(16)*:sImm;

        PROPERTIES IWIDTH = 4;
OPCODES
         BRA_N = 0b00_1_1_111;

    ENCODING
      Opcode14 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      U32 = U;
      LMT32 = LMT;
      Imm14_32 = sImm SCALE 4;

      !Canvas32;

 CLASS "BRA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } RSImm(24)*:sImm;

    OPCODES
         BRA = 0b01000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm24 = sImm;
      U = U;
      LMT = LMT;


      !Nenc43;

 CLASS "BRA c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
         BRA = 0b01000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      U = U;
      LMT = LMT;

      !Nenc44;


 CLASS "BRX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } Register:Ra SImm(24/0):sImm;

    OPCODES
         BRX = 0b01001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm24 = sImm;
      RegA = Ra;
      LMT = LMT;

      !Nenc45;


 CLASS "BRX c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    OPCODES
         BRX = 0b01001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      RegA = Ra;
      LMT = LMT;

      !Nenc46;


 CLASS "JMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } UImm(32)*:sImm;

    OPCODES
         JMP = 0b00000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm32 = sImm;
      U = U;
      LMT = LMT;

      !Nenc47;


 CLASS "JMP c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
         JMP = 0b00000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      U = U;
      LMT = LMT;

      !Nenc44;


 CLASS "JMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } Register:Ra SImm(32/0):sImm;

    OPCODES
         JMX = 0b00001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm32 = sImm;
      RegA = Ra;
      LMT = LMT;

      !Nenc48;


 CLASS "JMX c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    OPCODES
         JMX = 0b00001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      RegA = Ra;
      LMT = LMT;

      !Nenc46;


CLASS "CAL_N"
    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm;

        PROPERTIES IWIDTH = 4;
OPCODES
         CAL_N = 0b0101_1_1_111;

    ENCODING
      Opcode15 = Opcode;
      Imm22_32 = sImm SCALE 4;
      INC32 = INC;

      !Canvas32;

 CLASS "CAL"
    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm;

    OPCODES
         CAL = 0b01010_0_111;
         PRET = 0b01111_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 0;
      Imm24 = sImm;
      INC = INC;

      !Nenc49;

 CLASS "CAL c"
FORMAT Opcode /INC(INC):inc C[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
         CAL = 0b01010_0_111;
         PRET = 0b01111_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;
      !Nenc50;


 CLASS "JCAL"
    FORMAT Opcode /INC(INC):inc UImm(32)*:sImm;

    OPCODES
         JCAL = 0b00010_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 0;
      Imm32 = sImm;
      INC = INC;
      !Nenc51;


 CLASS "JCAL c"
FORMAT Opcode /INC(INC):inc C[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
         JCAL = 0b00010_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;
      !Nenc50;


 CLASS "SSY_N"
    FORMAT Opcode RSImm(16)*:sImm;

        PROPERTIES IWIDTH = 4;
OPCODES
         SSY_N = 0b0100_1_1_111;

    ENCODING
      Opcode15 = Opcode;
      Imm14_32 = sImm SCALE 4;

      !Canvas32;
      !Nenc54;

 CLASS "SSY"
    FORMAT Opcode RSImm(24)*:sImm;

    OPCODES
         SSY = 0b01100_0_111;
         PCNT = 0b01110_0_111;
         PLONGJMP = 0b01011_0_111;
         PBK = 0b01101_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA2 = 0;
      Imm24 = sImm;

      !Nenc52;

 CLASS "SSY c"
FORMAT Opcode C[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
         SSY = 0b01100_0_111;
         PCNT = 0b01110_0_111;
         PLONGJMP = 0b01011_0_111;
         PBK = 0b01101_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA2 = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      !Nenc53;



 CLASS "RET_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest;

        PROPERTIES IWIDTH = 4;
OPCODES
         RET_N = 0b10010_1_1_111;
         EXIT_N = 0b10001_1_1_111;

    ENCODING
      Opcode16 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;

      !Nenc56;
      !Canvas32;



 CLASS "RET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest;

    OPCODES
         EXIT = 0b10000_0_111;
         LONGJMP = 0b10001_0_111;
         RET = 0b10010_0_111;
         KIL = 0b10011_0_111;
         BRK = 0b10101_0_111;
         CONT = 0b10110_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      !Nenc55;


 CLASS "SAM"
    FORMAT Opcode;

    OPCODES
         SAM = 0b11000_0_111;
         RAM = 0b11001_0_111;

    ENCODING
      Opcode3 = Opcode;
      !Nenc57;


 CLASS "BPT"
    FORMAT Opcode /BPTMode:bpt UImm(20/0):sImm;

    OPCODES
         BPT = 0b11010_0_111;

    ENCODING
      Opcode3 = Opcode;
      Imm20 = sImm;
      Bpt = BPTMode;
      !Nenc58;


 CLASS "BPT_N"
    FORMAT Opcode /BPTMode:bpt UImm(20/0):sImm;

        PROPERTIES IWIDTH = 4;
OPCODES
         BPT_N = 0b10000_1_1_111;

    ENCODING
      Opcode16 = Opcode;
      Imm18_32 = sImm SCALE 4;
      Bpt32 = BPTMode;
      !Canvas32;
      !Nenc59;


 CLASS "RTT"
    FORMAT Opcode /RTTOp(NoTERMINATE):rttop;

    OPCODES
         RTT = 0b10100_0_111;

    ENCODING
      Opcode29 = Opcode;
      RTTOp = RTTOp;
      !Nenc60;




 CLASS "DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
        && IsEven(((Rc)+((Rc)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DFMA = 0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = Rc@negate;

      Sync=S;
      !BFiller;
      !Nenc93;
      ABC=0;


 CLASS "Imm DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rc)+((Rc)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DFMA = 0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,UnaryNeg);
      nB1 = Rc@negate;

      Sync=S;

      !Nenc93;
      ABC = 3;


 CLASS "Const DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' [-]Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rc)+((Rc)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DFMA = 0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,srcConst@negate);
      nB1 = Rc@negate;

      Sync=S;

      !Nenc93;
      ABC = 1;


 CLASS "Const1 DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DFMA = 0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = srcConst@negate;

      Sync=S;

      !Nenc93;
      ABC = 2;


 CLASS "DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DADD = 0b01001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc94;
      ABC=0;


 CLASS "Imm DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DADD = 0b01001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc94;
      ABC = 3;


 CLASS "Const DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DADD = 0b01001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc94;
      ABC = 1;


 CLASS "DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DMUL = 0b01010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;

      Rnd1 = Round1;
      nABa = PSignFFMA(Ra@negate,Rb@negate);

      Sync=S;
      !BFiller;
      !Nenc95;
      ABC=0;


 CLASS "Imm DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DMUL = 0b01010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;

      Rnd1 = Round1;
      nABa = PSignFFMA(Ra@negate,UnaryNeg);

      Sync=S;

      !Nenc95;
      ABC = 3;


 CLASS "Const DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DMUL = 0b01010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;

      Rnd1 = Round1;
      nABa = PSignFFMA(Ra@negate,srcConst@negate);

      Sync=S;

      !Nenc95;
      ABC = 1;


 CLASS "DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb
                    ',' [!]Predicate:Pa;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DMNMX = 0b00001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc96;
      ABC=0;


 CLASS "Imm DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                    ',' [!]Predicate:Pa;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DMNMX = 0b00001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc96;
      ABC = 3;


 CLASS "Const DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                    ',' [!]Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"


    OPCODES
         DMNMX = 0b00001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc96;
      ABC = 1;


CLASS "DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSET = 0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;




      !BFiller;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSET = 0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;




      !BFiller;
      Sync=S;
      ABC=0;


CLASS "Imm DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSET = 0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;





      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSET = 0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;





      Sync=S;
      ABC = 3;


CLASS "Const DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSET = 0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;





      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSET = 0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;





      Sync=S;
      ABC = 1;


CLASS "DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSETP = 0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;




ALTERNATE CLASS "NoBop DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSETP = 0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;




CLASS "Imm DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSETP = 0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;



      !Nenc88;
      Sync=S;
      ABC = 3;




ALTERNATE CLASS "NoBop Imm DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSETP = 0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;



      !Nenc88;
      Sync=S;
      ABC = 3;




CLASS "Const DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSETP = 0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;



      !Nenc88;
      Sync=S;
      ABC = 1;




ALTERNATE CLASS "NoBop Const DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
         DSETP = 0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;



      !Nenc88;
      Sync=S;
      ABC = 1;




 CLASS "FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
                                       ',' [-]Register:Rc;
    CONDITIONS

    OPCODES
         FFMA = 0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = Rc@negate;
      Pipe2c = pipe2;
      Sync=S;
      !BFiller;
      ABC=0;

 CLASS "Imm FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg
                                       ',' [-]Register:Rc;
    CONDITIONS

    OPCODES
         FFMA = 0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,UnaryNeg);
      nB1 = Rc@negate;
      Pipe2c = pipe2;
      Sync=S;

      ABC = 3;

 CLASS "Const FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' [-]Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FFMA = 0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,srcConst@negate);
      nB1 = Rc@negate;
      Pipe2c = pipe2;
      Sync=S;

      ABC = 1;

 CLASS "Const1 FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FFMA = 0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = srcConst@negate;
      Pipe2c = pipe2;
      Sync=S;

      ABC = 2;

 CLASS "FFMA_N"
    FORMAT Opcode
             Register:Rd ',' [-]Register:Ra
                                ',' [-]Register:Rb
                                ',' Register:Rc;
    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         FFMA_N = 0b1_110;

    ENCODING
      Opcode25 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC32 = Rc;
      nAB32 = PSignFFMA(Ra@negate,Rb@negate);
      ConstC = 0;
      CNS_A=0;
      !Canvas32;


 CLASS "Const FFMA_N"
    FORMAT Opcode
             Register:Rd ',' [-]Register:Ra
                                ',' [-]C:srcConst[UImm(5):constBank][UImm(8):immConstOffset]
                                ',' Register:Rc;
    CONDITIONS ERROR CNSConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         FFMA_N = 0b1_110;

    ENCODING
      Opcode25 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      RegC32 = Rc;
      nAB32 = PSignFFMA(Ra@negate,srcConst@negate);
      ConstC = 0;
      CNS_A =* CNSConstBank(constBank);
      !Canvas32;


 CLASS "FFMA_N 1"
    FORMAT Opcode
             Register:Rd ',' [-]Register:Ra
                                ',' [-]Register:Rb
                                ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];
    CONDITIONS
         ERROR
           CNSConstBank(constBank) :
             "Constant bank must be 0, 1 or 16 for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         FFMA_N = 0b1_110;

    ENCODING
      Opcode25 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC32 = immConstOffset SCALE 4;
      nAB32 = PSignFFMA(Ra@negate,Rb@negate);
      ConstC = 1;
      CNS_A =* CNSConstBank(constBank);
      !Canvas32;


 CLASS "FFMA32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):fImm
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           Rd == Rc :
             "Output register must be the same as last input register"

    OPCODES
         FFMA32I = 0b00100_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = IDENTICAL(Rd,Rc);
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZ = FMZ;
      Sat = SAT;
      nA1 = Ra@negate;
      nB1 = Rc@negate;

      Sync=S;

 ALTERNATE CLASS "FFMA32I 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):fImm;
    CONDITIONS

    OPCODES
         FFMA32I = 0b00100_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZ = FMZ;
      Sat = SAT;
      nA1 = Ra@negate;
      nB1 = 0;

      Sync=S;

 CLASS "FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb;

    CONDITIONS

    OPCODES
         FADD = 0b01010_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Sat2 = SAT;
      FTZ1 = FTZ;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      Pipe2c = pipe2;
      Sync=S;
      !BFiller;
      !Nenc81;
      ABC=0;


 CLASS "Imm FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS

    OPCODES
         FADD = 0b01010_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Sat2 = SAT;
      FTZ1 = FTZ;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      Pipe2c = pipe2;
      Sync=S;

      !Nenc81;
      ABC = 3;


 CLASS "Const FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FADD = 0b01010_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Sat2 = SAT;
      FTZ1 = FTZ;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      Pipe2c = pipe2;
      Sync=S;

      !Nenc81;
      ABC = 1;


 CLASS "FADD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' [-]Register:Ra ',' Register:Rb;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         FADD_N = 0b100_1_001;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      nA32a = Ra@negate;
      CNS_B=0;
      !Canvas32;


 CLASS "Const FADD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' [-]Register:Ra ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];

    CONDITIONS ERROR CNSConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         FADD_N = 0b100_1_001;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      nA32a = Ra@negate;
      CNS_B =* CNSConstBank(constBank);
      !Canvas32;


 CLASS "FADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F32Imm(64):fImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    OPCODES
         FADD32I = 0b00101_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;


 CLASS "FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register:Rb
                                       ',' Register:Rc;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
         FCMP = 0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;
      !BFiller;
      !Nenc83;
      ABC=0;


 CLASS "Imm FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' F32Imm(64):uImm
                                       ',' Register:Rc;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
         FCMP = 0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;

      !Nenc83;
      ABC = 3;


 CLASS "Const FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
         FCMP = 0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;

      !Nenc83;
      ABC = 1;


 CLASS "Const1 FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
         FCMP = 0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;

      !Nenc83;
      ABC = 2;


 CLASS "FSWZ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SWZMode:swz /FTZ(noFTZ):ftz /Round1(RN):rnd /NDV(noNDV):ndv /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb
                    ',' PNWord:uImm;
    OPCODES
         FSWZ = 0b01001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Rnd1 = Round1;
      FTZ1 = FTZ;
      NDV = NDV;
      SWZMode = SWZMode;
      PNWord = PNWord;

      Sync=S;
      !Nenc86;



 CLASS "FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb;

    CONDITIONS

    OPCODES
         FMUL = 0b01011_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;

      FMZ = FMZ;
      Scale = Scale;
      Rnd1 = Round1;
      Sat = SAT;
      Pipe2 = pipe2;
      nAB = PSignFFMA(Ra@negate,Rb@negate);

      Sync=S;
      !BFiller;
      !Nenc84;
      ABC=0;


 CLASS "Imm FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS

    OPCODES
         FMUL = 0b01011_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;

      FMZ = FMZ;
      Scale = Scale;
      Rnd1 = Round1;
      Sat = SAT;
      Pipe2 = pipe2;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);

      Sync=S;

      !Nenc84;
      ABC = 3;


 CLASS "Const FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FMUL = 0b01011_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;

      FMZ = FMZ;
      Scale = Scale;
      Rnd1 = Round1;
      Sat = SAT;
      Pipe2 = pipe2;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);

      Sync=S;

      !Nenc84;
      ABC = 1;


 CLASS "FMUL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         FMUL_N = 0b1010_1_000;

    ENCODING
      Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      CNS_B=0;
      !Canvas32;


 CLASS "Const FMUL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' Register:Ra ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];

    CONDITIONS ERROR CNSConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         FMUL_N = 0b1010_1_000;

    ENCODING
      Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      CNS_B =* CNSConstBank(constBank);
      !Canvas32;


 CLASS "FMUL32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' F32Imm(64):fImm;

    OPCODES
         FMUL32I = 0b00110_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZ = FMZ;
      Sat = SAT;
      Pipe2 = pipe2;
      Sync=S;


 CLASS "FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb
                    ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         FMNMX = 0b00001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc24;
      ABC=0;


 CLASS "Imm FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                    ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         FMNMX = 0b00001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc24;
      ABC = 3;


 CLASS "Const FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                    ',' [!]Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FMNMX = 0b00001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc24;
      ABC = 1;


 CLASS "FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
             ',' Register:Ra ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS

    OPCODES
         FCCO = 0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      ABC=0;
      !Nenc87;
      !BFiller;


 CLASS "Imm FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
             ',' Register:Ra ',' F32Imm(64):uImm ',' Register(RZ):Rc;

    CONDITIONS

    OPCODES
         FCCO = 0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      ABC = 3;
      !Nenc87;



 CLASS "Const FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register(RZ):Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FCCO = 0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      ABC = 1;
      !Nenc87;



 CLASS "Const1 FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FCCO = 0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      CMode = CMode;

      Sync=S;
      ABC = 2;
      !Nenc87;



CLASS "FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSET = 0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      FTZ2 = FTZ;


      !BFiller;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSET = 0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      FTZ2 = FTZ;


      !BFiller;
      Sync=S;
      ABC=0;


CLASS "Imm FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSET = 0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSET = 0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 3;


CLASS "Const FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSET = 0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSET = 0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 1;


CLASS "FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSETP = 0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      FTZ2 = FTZ;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSETP = 0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      FTZ2 = FTZ;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;


CLASS "Imm FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSETP = 0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSETP = 0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 3;


CLASS "Const FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSETP = 0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
         FSETP = 0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 1;


CLASS "FSETP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

        PROPERTIES IWIDTH = 4;
OPCODES
         FSETP_N = 0b101_1_001;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB = Rb;
      FComp32 = Test;

      CNS_B=0;
      !Canvas32;


CLASS "Const FSETP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];
    CONDITIONS ERROR CNSConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

        PROPERTIES IWIDTH = 4;
OPCODES
         FSETP_N = 0b101_1_001;

    ENCODING
      Opcode20 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      FComp32 = Test;

      CNS_B =* CNSConstBank(constBank);
      !Canvas32;


 CLASS "IPA 1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A[NonZeroRegister:Ra + SImm(11/0):sImm]
             ',' Register:Rb ',' Register(RZ):Rc ;

    OPCODES
         IPA = 0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      RegC = Rc;
      Imm11 = sImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc89;


 CLASS "I IPA 1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A[ZeroRegister(RZ):Ra + UImm(10/0):uImm]
             ',' Register:Rb ',' Register(RZ):Rc ;

    OPCODES
         IPA = 0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      RegC = Rc;
      Imm10 = uImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc113;


 ALTERNATE CLASS "IPA 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A[NonZeroRegister:Ra + SImm(11/0):sImm] ;

    OPCODES
         IPA = 0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      Imm11 = sImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc89;


 ALTERNATE CLASS "I IPA 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A[ZeroRegister(RZ):Ra + UImm(10/0):uImm] ;

    OPCODES
         IPA = 0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      Imm10 = uImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc113;


 CLASS "IPA_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOpN(MUL):ipaop
             Register:Rd
             ',' A[UImm(10):uImm]
             ',' Register(RZ):Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         IPA_N = 0b000_1_001;

    ENCODING
      Opcode20 = Opcode;
      IPAOpN = IPAOpN;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm8_32c = uImm SCALE 4 ROR 6;
      RegB32 = Rb;
      !Canvas32;


 CLASS "RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
             Register:Rd ',' [-][||]Register:Rb;

    CONDITIONS

    OPCODES
         RRO = 0b01100_0_000;

    ENCODING
      Opcode29 = Opcode;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      !nA1;
      nB1 = Rb@negate;
      !aA1;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc90;
      ABC=0;


 CLASS "Imm RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
             Register:Rd ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS

    OPCODES
         RRO = 0b01100_0_000;

    ENCODING
      Opcode29 = Opcode;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      !nA1;
      nB1 = UnaryNeg;
      !aA1;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc90;
      ABC = 3;


 CLASS "Const RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
Register:Rd ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         RRO = 0b01100_0_000;

    ENCODING
      Opcode29 = Opcode;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !nA1;
      nB1 = srcConst@negate;
      !aA1;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc90;
      ABC = 1;


 CLASS "RRO_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop
             Register:Rd ',' Register:Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         RRO_N = 0b0111_000_000_1_000;

    ENCODING
      Opcode8 = Opcode;
      RROOpN = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB32 = Rb;
      !Canvas32;
      !Nenc91;


 CLASS "MUFU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MufuOp:mufu /SAT(noSAT):sat /S(noS):sync
             Register:Rd ',' [-][||]Register:Ra;

    OPCODES
         MUFU = 0b11001_0_000;

    ENCODING
      Opcode29 = Opcode;
      MufuOp = MufuOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      nA1 = Ra@negate;
      aA1 = Ra@absolute;
      Sat = SAT;

      Sync=S;
      !Nenc92;


 CLASS "MUFU_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MufuOp:mufu
             Register:Rd ',' [||]Register:Ra;

        PROPERTIES IWIDTH = 4;
OPCODES
         MUFU_N = 0b1_000_000_1_000;

    ENCODING
      Opcode30 = Opcode;
      MufuOp = MufuOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB32 = Ra;
      aA32b = Ra@absolute;
      !Canvas32;




CLASS "F2F_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         F2F_N = 0b01001_1_000;

    ENCODING
      Opcode4 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      Sat32 = SAT;
      RndIR32 = rnd;
      WriteCC32 = writeCC;
      Dest = Rd;
      RegB = Rb;
      nB32 = Rb@negate;
      aB32 = Rb@absolute;

      !Canvas32;

CLASS "F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      RndIR = rnd;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      RndIR = rnd;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      RndIR = rnd;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      Rnd = rnd;
      !IR;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      Rnd = rnd;
      !IR;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      Rnd = rnd;
      !IR;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      RndIR = rnd;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      RndIR = rnd;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      RndIR = rnd;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      Rnd = rnd;
      !IR;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;

CLASS "Imm F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      Rnd = rnd;
      !IR;
      ABC = 3;

      Sync=S;
      !Nenc7;

CLASS "Const F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      Rnd = rnd;
      !IR;
      ABC = 1;

      Sync=S;
      !Nenc7;

CLASS "F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rb)+((Rb)==63))) :
             "F64 as source format requires an even source register"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      RndIR = rnd;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      RndIR = rnd;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      RndIR = rnd;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"
         ERROR
           ( fmts == `F2Ffmts2_64@"F32.F64" ) -> IsEven(((Rb)+((Rb)==63))) :
             "F64 as source format requires an even source register"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      Rnd = rnd;
      !IR;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      Rnd = rnd;
      !IR;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

    OPCODES
         F2F = 0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      Rnd = rnd;
      !IR;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2I_N"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):dstfmt /F32(F32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32:dstfmt /F32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         F2I_N = 0b101000_1_000;

    ENCODING
      Opcode5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      Rnd32 = Round3;
      WriteCC32 = writeCC;
      Dest = Rd;
      SDest32 = IsSigned(dstfmt);
      RegB = Rb;
      nB32 = Rb@negate;
      aB32 = Rb@absolute;

      !Canvas32;


CLASS "F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float32(F32):srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc8;

CLASS "Imm F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float32(F32):srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc8;

CLASS "Const F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float32(F32):srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc8;

CLASS "F2I 16"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float16:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc8;


CLASS "Imm F2I 16"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float16:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc8;


CLASS "Const F2I 16"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float16:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc8;


CLASS "F2I 64"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float64:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (srcfmt == `Float64@F64) -> IsEven(((Rb)+((Rb)==63))) :
             "F64 as source format requires an even source register"
         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc8;

CLASS "Imm F2I 64"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float64:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc8;

CLASS "Const F2I 64"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer(S32):dstfmt /Float64:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

    OPCODES
         F2I = 0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc8;

CLASS "I2I_N"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer1632(S32):dstfmt /Integer1632(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer1632:dstfmt /Integer1632:srcfmt
##ENDIF
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         I2I_N = 0b00001_1_000;

    ENCODING
      Opcode4 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      WriteCC32 = writeCC;
      Dest = Rd;
      RegB = Rb;
      I2ISizes32 = I2I_N_Sizes(dstfmt,srcfmt);
      nB32 = Rb@negate;
      aB32 = Rb@absolute;

      !Canvas32;


CLASS "I2F_N"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /F32(F32):dstfmt /Integer(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /F32:dstfmt /Integer:srcfmt
##ENDIF
                                  /Round1(RN):rnd
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         I2F_N = 0b001000_1_000;

    ENCODING
      Opcode5 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      WriteCC32 = writeCC;
      Dest = Rd;
      RegB = Rb;
      Rnd32 = Round1;
      SDest32 = IsSigned(srcfmt);

      nB32 = Rb@negate;
      aB32 = Rb@absolute;

      !Canvas32;


CLASS "MOVI_N F"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ITypeF
             Register:Rd ','
             F32Imm(12):fImm;

        PROPERTIES IWIDTH = 4;
OPCODES
         MOVI_N = 0b10001_1_000;

    ENCODING
      Opcode4 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Float = 1;
      Dest = Rd;
      Imm12_32 = fImm;

      !Canvas32;


CLASS "MOVI_N I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ITypeI(I)
             Register:Rd ','
             SImm(12):sImm;

        PROPERTIES IWIDTH = 4;
OPCODES
         MOVI_N = 0b10001_1_000;

    ENCODING
      Opcode4 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Float = 0;
      Dest = Rd;
      Imm12_32 = sImm;

      !Canvas32;

CLASS "MOV_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ','
             Register:Rb;

    CONDITIONS


        PROPERTIES IWIDTH = 4;
OPCODES
         MOV_N = 0b0010_1_000;

    ENCODING
      Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB32 = Rb;

      !Nenc11;
      !Canvas32;
      CNS_B=0;


CLASS "Const MOV_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ','
             C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];

    CONDITIONS ERROR CNSConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"


        PROPERTIES IWIDTH = 4;
OPCODES
         MOV_N = 0b0010_1_000;

    ENCODING
      Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB32=immConstOffset SCALE 4;

      !Nenc11;
      !Canvas32;
      CNS_B =* CNSConstBank(constBank);


CLASS "MOV32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             UImm(32)*:uImm ',' UImm(4/0xf):quadMask;

    OPCODES
         MOV32I = 0b00011_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm32 = uImm;
      QuadMask = quadMask;

      Sync=S;
      !Nenc12;


CLASS "MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW):pipe /S(noS):sync
             Register:Rd ','
             Register:Rb ',' UImm(4/0xf):quadMask;

    CONDITIONS

    OPCODES
         MOV = 0b001010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      QuadMask = quadMask;
      Pipe2a = Pipe2;

      Sync=S;
      !Nenc13;
      ABC=0;
      !BFiller;


CLASS "Imm MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW):pipe /S(noS):sync
             Register:Rd ','
             SImm(20):uImm ',' UImm(4/0xf):quadMask;

    CONDITIONS

    OPCODES
         MOV = 0b001010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      QuadMask = quadMask;
      Pipe2a = Pipe2;

      Sync=S;
      !Nenc13;
      ABC = 3;



CLASS "Const MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW):pipe /S(noS):sync
             Register:Rd ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' UImm(4/0xf):quadMask;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         MOV = 0b001010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      QuadMask = quadMask;
      Pipe2a = Pipe2;

      Sync=S;
      !Nenc13;
      ABC = 1;



CLASS "SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             [!] Predicate:Pa;

    CONDITIONS

    OPCODES
         SEL = 0b001000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !Nenc14;
      ABC=0;
      !BFiller;

CLASS "Imm SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             [!] Predicate:Pa;

    CONDITIONS

    OPCODES
         SEL = 0b001000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !Nenc14;
      ABC = 3;


CLASS "Const SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             [!] Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         SEL = 0b001000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !Nenc14;
      ABC = 1;


CLASS "S2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             SpecialRegister:SR;

    OPCODES
         S2R = 0b001011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      SReg = SR;
      !Pipe2;
      Sync=S;
      !Nenc15;


CLASS "S2R_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ','
             SpecialRegister:SR;

        PROPERTIES IWIDTH = 4;
OPCODES
         S2R_N = 0b0100_000000_1_000;

    ENCODING
      Opcode8 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      SReg32 = SR;
      !Canvas32;


CLASS "B2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd ','
             UImm(4):uImm;

    OPCODES
         B2R = 0b001110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = uImm;
      Sync=S;
      !Nenc16;
      Pipe2 = pipe2;


CLASS "P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
         P2R = 0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC=0;
      !BFiller;

CLASS "Imm P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
         P2R = 0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC = 3;


CLASS "Const P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         P2R = 0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC = 1;


ALTERNATE CLASS "Simple P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR;

    CONDITIONS

    OPCODES
         P2R = 0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = `Register@RZ;
      Bconst = 0xFFFF;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC = 3;

 CLASS "R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             PR ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
         R2P = 0b001101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc18;
      !BFiller;
      ABC = 0;

 CLASS "Imm R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             PR ',' Register:Ra ',' UImm(20/0xffff):uImm;

    CONDITIONS

    OPCODES
         R2P = 0b001101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst = uImm;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc18;
      ABC = 3;

 CLASS "Const R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
PR ',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
        ERROR constBank <= 17 :
              "Only constant banks 0..17 are legal"
        ERROR (immConstOffset & 0x3) == 0 :
              "Constant offsets must be aligned on a 4B boundary"

    OPCODES
         R2P = 0b001101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      !Bgap;

BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc18;
      ABC = 1;

 CLASS "PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
             Register:Rb ',' Register:Rc;

    CONDITIONS

    OPCODES
         PRMT = 0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      !Pipe2a;
      PMode = PMode;
      Sync=S;
      !BFiller;
      !Nenc19;
      ABC=0;




 CLASS "Imm PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
             SImm(20):uImm ',' Register:Rc;

    CONDITIONS

    OPCODES
         PRMT = 0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      !Pipe2a;
      PMode = PMode;
      Sync=S;

      !Nenc19;
      ABC = 3;




 CLASS "Const PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         PRMT = 0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      !Pipe2a;
      PMode = PMode;
      Sync=S;

      !Nenc19;
      ABC = 1;




 CLASS "Const1 PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         PRMT = 0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      !Pipe2a;
      PMode = PMode;
      Sync=S;

      !Nenc19;
      ABC = 2;




 CLASS "IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
            ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (X -> (!Ra@negate || !Rb@negate)) :
             ".X cannot be used with '-' on both of the inputs"

    OPCODES
         IADD = 0b01001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,Rb@negate);
      Xm = xmode;

      Sync=S;
      !BFiller;
      !Nenc20;
      ABC=0;

 CLASS "Imm IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
            ) ) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         IADD = 0b01001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,UnaryNeg);
      Xm = xmode;

      Sync=S;

      !Nenc20;
      ABC = 3;

 CLASS "Const IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
            ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (X -> (!Ra@negate || !srcConst@negate)) :
             ".X cannot be used with '-' on both of the inputs"

    OPCODES
         IADD = 0b01001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,srcConst@negate);
      Xm = xmode;

      Sync=S;

      !Nenc20;
      ABC = 1;

##IF !DEFINED(ARCH_SEMANTICS)


 CLASS "ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;
    OPCODES
         ISUB = 0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), %%Register(Ra) , -%%Register(Rb)";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Imm ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;
    OPCODES
         ISUB = 0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), %%Register(Ra) , uImm .NEG";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Imm ISUB1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm ',' Register:Ra;
    OPCODES
         ISUB = 0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), -%%Register(Ra) , uImm";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Const ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    OPCODES
         ISUB = 0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), %%Register(Ra) , -C[constBank][immConstOffset]";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Const ISUB1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Ra;
    OPCODES
         ISUB = 0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), -%%Register(Ra) , C[constBank][immConstOffset]";
##ENDIF

 CLASS "IADD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' [-]Register:Ra ',' Register:Rb;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         IADD_N = 0b10_1_100;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      nA32 = Ra@negate;
      RCI=0;
      !Canvas32;


 CLASS "Imm IADD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' [-]Register:Ra ',' SImm(8):uImm;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         IADD_N = 0b10_1_100;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RCImm=uImm ROR 6;
      nA32 = Ra@negate;
      I = 0b1;
      !Canvas32;


 CLASS "Const IADD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' [-]Register:Ra ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];

    CONDITIONS ERROR RCIConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         IADD_N = 0b10_1_100;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      nA32 = Ra@negate;
      RCI =* RCIConstBank(constBank);
      !Canvas32;


 CLASS "IADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(32):sImm;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> !Ra@negate) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         IADD32I = 0b00001_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      Sat = SAT;
      PSign = PSign32(PO,Ra@negate);
      Xm = xmode;

      Sync=S;
      !Nenc21;


 CLASS "ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb ',' UImm(5):shift;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         ISCADD = 0b01000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign2 = PSign(PO,Ra@negate,Rb@negate);

      Sync=S;
      !BFiller;
      !Nenc22;
      ABC=0;

 CLASS "Imm ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg ',' UImm(5):shift;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         ISCADD = 0b01000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign2 = PSign(PO,Ra@negate,UnaryNeg);

      Sync=S;

      !Nenc22;
      ABC = 3;

 CLASS "Const ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' UImm(5):shift;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         ISCADD = 0b01000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Imm5I = shift;
      PSign2 = PSign(PO,Ra@negate,srcConst@negate);

      Sync=S;

      !Nenc22;
      ABC = 1;

 CLASS "ISCADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(32):sImm ',' UImm(5):shift;

    OPCODES
         ISCADD32I = 0b01000_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      Imm5I = shift;

      Sync=S;


 CLASS "ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS

    OPCODES
         ISAD = 0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;
      !BFiller;
      !Nenc23;
      ABC=0;

 CLASS "Imm ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS

    OPCODES
         ISAD = 0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc23;
      ABC = 3;

 CLASS "Const ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         ISAD = 0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc23;
      ABC = 1;

 CLASS "Const1 ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         ISAD = 0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc23;
      ABC = 2;

 CLASS "IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         IMNMX = 0b00001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;
      XMode = XMode;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;
      !BFiller;
      !Nenc24;
      ABC=0;


 CLASS "Imm IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         IMNMX = 0b00001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;
      XMode = XMode;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc24;
      ABC = 3;


 CLASS "Const IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [!]Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         IMNMX = 0b00001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;
      XMode = XMode;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc24;
      ABC = 1;


 CLASS "BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
         BFE = 0b01110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;

      Sync=S;
      !BFiller;
      !Nenc25;
      ABC=0;


 CLASS "Imm BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
         BFE = 0b01110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;

      Sync=S;

      !Nenc25;
      ABC = 3;


 CLASS "Const BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         BFE = 0b01110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;

      Sync=S;

      !Nenc25;
      ABC = 1;


 CLASS "BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS

    OPCODES
         BFI = 0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;

      Sync=S;
      !BFiller;
      !Nenc26;
      ABC=0;


 CLASS "Imm BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS

    OPCODES
         BFI = 0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;

      Sync=S;

      !Nenc26;
      ABC = 3;


 CLASS "Const BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         BFI = 0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;

      Sync=S;

      !Nenc26;
      ABC = 1;


 CLASS "Const1 BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         BFI = 0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;

      Sync=S;

      !Nenc26;
      ABC = 2;


 CLASS "SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
         SHR = 0b01011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      XMode = XXHI;
      M = CWMode;

      Sync=S;
      !BFiller;
      !Nenc27;
      ABC=0;


 CLASS "Imm SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
         SHR = 0b01011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      XMode = XXHI;
      M = CWMode;

      Sync=S;

      !Nenc27;
      ABC = 3;


 CLASS "Const SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         SHR = 0b01011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      XMode = XXHI;
      M = CWMode;

      Sync=S;

      !Nenc27;
      ABC = 1;


 CLASS "SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
         SHL = 0b01100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      M = CWMode;
      Xm = X;

      Sync=S;
      !BFiller;
      !Nenc28;
      ABC=0;


 CLASS "Imm SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
         SHL = 0b01100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      M = CWMode;
      Xm = X;

      Sync=S;

      !Nenc28;
      ABC = 3;


 CLASS "Const SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         SHL = 0b01100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      M = CWMode;
      Xm = X;

      Sync=S;

      !Nenc28;
      ABC = 1;


 CLASS "SHR_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' Register:Ra ',' UImm(5):uImm;

        PROPERTIES IWIDTH = 4;
OPCODES
         SHL_N = 0b0_100000_1_000;
         SHR_N = 0b1_100000_1_000;

    ENCODING
      Opcode9 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm5_32 = uImm;
      !Canvas32;


 CLASS "LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Ra ',' [~]Register:Rb;

    CONDITIONS

    OPCODES
         LOP = 0b01101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = Rb@invert;

      Sync=S;
      !BFiller;
      !Nenc22;
      ABC=0;


 CLASS "Imm LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Ra ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    CONDITIONS

    OPCODES
         LOP = 0b01101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = UnaryInv;

      Sync=S;

      !Nenc22;
      ABC = 3;


 CLASS "Const LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [~]Register:Ra ',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         LOP = 0b01101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = srcConst@invert;

      Sync=S;

      !Nenc22;
      ABC = 1;


 CLASS "LOP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         LOP_N = 0b1_1_101;

    ENCODING
      Opcode10 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      LOP32 = LOP;
      RCI=0;
      !Canvas32;


 CLASS "Imm LOP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop
             Register:Rd ',' Register:Ra ',' SImm(8):uImm;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         LOP_N = 0b1_1_101;

    ENCODING
      Opcode10 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RCImm=uImm ROR 6;
      LOP32 = LOP;
      I = 0b1;
      !Canvas32;


 CLASS "Const LOP_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop
             Register:Rd ',' Register:Ra ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];

    CONDITIONS ERROR RCIConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         LOP_N = 0b1_1_101;

    ENCODING
      Opcode10 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      LOP32 = LOP;
      RCI =* RCIConstBank(constBank);
      !Canvas32;


 CLASS "LOP32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Ra ',' UImm(32):uImm /UnaryInv(noINV):jinv ;

    OPCODES
         LOP32I = 0b00111_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = uImm;
      WriteCCI = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = UnaryInv;
      Sync=S;


 CLASS "FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Rb;

    CONDITIONS

    OPCODES
         FLO = 0b01111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      SH = SH;
      nB_L = Rb@invert;

      Sync=S;
      !BFiller;
      !Nenc30;
      ABC=0;


 CLASS "Imm FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    CONDITIONS

    OPCODES
         FLO = 0b01111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      SH = SH;
      nB_L = UnaryInv;

      Sync=S;

      !Nenc30;
      ABC = 3;


 CLASS "Const FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         FLO = 0b01111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      SH = SH;
      nB_L = srcConst@invert;

      Sync=S;

      !Nenc30;
      ABC = 1;


 CLASS "IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
         IMUL = 0b01010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;
      !BFiller;
      !Nenc40;
      ABC=0;


 CLASS "Imm IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
         IMUL = 0b01010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;

      !Nenc40;
      ABC = 3;


 CLASS "Const IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         IMUL = 0b01010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;

      !Nenc40;
      ABC = 1;


 CLASS "IMUL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS
         ERROR
           us32 == us32b :
             "MUL_N requires operands to be both signed, or both unsigned"

        PROPERTIES IWIDTH = 4;
OPCODES
         IMUL_N = 0b10_1_010;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      ABSigned = IsSameSigned(us32,us32b);
      RCI=0;
      !Canvas32;


 CLASS "Imm IMUL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             Register:Rd ',' Register:Ra ',' SImm(8):uImm;

    CONDITIONS
         ERROR
           us32 == us32b :
             "MUL_N requires operands to be both signed, or both unsigned"

        PROPERTIES IWIDTH = 4;
OPCODES
         IMUL_N = 0b10_1_010;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RCImm=uImm ROR 6;
      ABSigned = IsSameSigned(us32,us32b);
      I = 0b1;
      !Canvas32;


 CLASS "Const IMUL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             Register:Rd ',' Register:Ra ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset];

    CONDITIONS ERROR RCIConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"
         ERROR
           us32 == us32b :
             "MUL_N requires operands to be both signed, or both unsigned"

        PROPERTIES IWIDTH = 4;
OPCODES
         IMUL_N = 0b10_1_010;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      ABSigned = IsSameSigned(us32,us32b);
      RCI =* RCIConstBank(constBank);
      !Canvas32;


 CLASS "IMUL32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(32):sImm;

    OPCODES
         IMUL32I = 0b00010_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;
      !Nenc41;


 CLASS "IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

    OPCODES
         IMAD = 0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);

      Sync=S;
      !BFiller;
      !Nenc42;
      ABC=0;


 CLASS "Imm IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

    OPCODES
         IMAD = 0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,UnaryNeg,Rc@negate);

      Sync=S;

      !Nenc42;
      ABC = 3;


 CLASS "Const IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [-]Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

    OPCODES
         IMAD = 0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,srcConst@negate,Rc@negate);

      Sync=S;

      !Nenc42;
      ABC = 1;


 CLASS "Const1 IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]Register:Rb ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

    OPCODES
         IMAD = 0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,Rb@negate,srcConst@negate);

      Sync=S;

      !Nenc42;
      ABC = 2;


 CLASS "IMAD_N"
    FORMAT Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             Register:Rd ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
           us32 == us32b :
             "MUL_N requires operands to be both signed, or both unsigned"

        PROPERTIES IWIDTH = 4;
OPCODES
         IMAD_N = 0b0_1_101;

    ENCODING
      Opcode10 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC32 = Rc;
      ABSigned1 = IsSameSigned(us32,us32b);
      CNS_A=0;
      !Canvas32;


 CLASS "Const IMAD_N"
    FORMAT Opcode { /Integer32(S32):us32 /Integer32(S32):us32b }
             Register:Rd ',' Register:Ra ',' C:srcConst[UImm(5):constBank][UImm(8):immConstOffset] ',' Register:Rc;

    CONDITIONS ERROR CNSConstBank(constBank) : "Constant bank must be 0, 1 or 16 for this operation"
         ERROR
           us32 == us32b :
             "MUL_N requires operands to be both signed, or both unsigned"

        PROPERTIES IWIDTH = 4;
OPCODES
         IMAD_N = 0b0_1_101;

    ENCODING
      Opcode10 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB=immConstOffset SCALE 4;
      RegC32 = Rc;
      ABSigned1 = IsSameSigned(us32,us32b);
      CNS_A =* CNSConstBank(constBank);
      !Canvas32;


 CLASS "IMAD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                            { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(32):sImm ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
            Rd == Rc :
             "Destination register must be the same as input register 3"

    OPCODES
         IMAD32I = 0b00000_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = IDENTICAL(Rd,Rc);
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      PSign = PSign(PO,Ra@negate,Rc@negate);

      Sync=S;




 CLASS "STP"
    FORMAT Opcode /STPMode(noWAIT):stpmode /TPhase(noPhase):phase /S(noS):sync UImm(8):uImm;

    OPCODES
         STP = 0b010011_0_100;

    ENCODING
      Opcode18 = Opcode;
      STPMode = STPMode;
      Imm8 = Imm;
      Phase = TPhase;
      !Nenc33;
      Sync=S;

 CLASS "TEX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /I(noI):indexed /LOD(noLOD):lod /TOFF2(noTOFF):toff /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb ','
##IF DEFINED(ARCH_SEMANTICS)
             UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TEX = 0b1000_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Tid = tid;
      Smp = smp;
      Wmsk = wmsk;
      AI = I;
      LOD = LOD;
      TOFF2 = TOFF2;
      DC = DC;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc29;
      Sync=S;


 CLASS "TEX_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyNoDep /OnlyT
             Register:Rd
             ',' Register:Ra
             ',' UImm(4):tid ',' UImm(3):smp ',' UImm(1):wmsk ;

        PROPERTIES IWIDTH = 4;
OPCODES
         TEX_N = 0b1011_1_000;

    ENCODING
      Opcode6 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Tid32 = tid;
      Smp32 = smp;
      Wmsk32 = wmsk;
      !Canvas32;


 CLASS "TLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /I(noI):indexed /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms /CL(noCL):clamp /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TLD = 0b1001_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Tid = tid;
      Wmsk = wmsk;
      AI = I;
      LOD1 = LOD1;
      TOFF1 = TOFF1;
      MS = MS;
      CL = CL;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc72;
      Sync=S;


  CLASS "TLD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /TexComp:tcomp /I(noI):indexed /TOFF2(noTOFF):toff /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TLD4 = 0b1010_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Tid = tid;
      Smp = smp;
      Wmsk = wmsk;
      TexComp = TexComp;
      AI = I;
      TOFF2 = TOFF2;
      DC = DC;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc82;
      Sync=S;


  CLASS "TMML"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /I(noI):indexed /LODLEN /NDV(noNDV):ndv /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TMML = 0b1011_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Tid = tid;
      Smp = smp;
      Wmsk = wmsk;
      AI = I;
      LODLEN = LODLEN;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc85;
      Sync=S;


  CLASS "TXA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /NDV(noNDV):ndv /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
##IF DEFINED(ARCH_SEMANTICS)
             ',' Register:Ra ',' UImm(8)*:tid ',' UImm(5)*:smp ',' UImm(4/15):wmsk ;
##ELSE
             ',' Register:Ra ',' UImm(8)*:tid ',' UImm(5)*:smp ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TXA = 0b1101_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Tid = tid;
      Smp = smp;
      Wmsk = wmsk;
      NDVa = NDV;
      NODEP = NODEP;
      Phase = TPhase;
      !Nenc97;
      Sync=S;


  CLASS "TXD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /I(noI):indexed /TOFF1(noTOFF):toff /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register:Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TXD = 0b1110_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Tid = tid;
      Smp = smp;
      Wmsk = wmsk;
      TOFF1 = TOFF1;
      AI = I;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc98;
      Sync=S;


  CLASS "TXQ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /I(noI):indexed /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' TXQMode:query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TXQ = 0b1100_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Tid = tid;
      Wmsk = wmsk;
      AI = I;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(TXQMode);
      Smp = smp;
      !Nenc99;
      Sync=S;


  ALTERNATE CLASS "TXQ Imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /I(noI):indexed /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' UImm(5):query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8)*:tid ',' UImm(5)*:smp ',' UImm(4):wmsk ;
##ENDIF

    OPCODES
         TXQ = 0b1100_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Tid = tid;
      Wmsk = wmsk;
      AI = I;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(query);
      Smp = smp;
      !Nenc99;
      Sync=S;





CLASS "LDC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /AdMode(IA):ad /S(noS):sync
Register:Rd ',' C[UImm(5/0*):constBank]* [NonZeroRegister:Ra + SImm(17/0)*:immConstOffset];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    OPCODES
         LDC = 0b000101_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      AdMode = AdMode;
      LSSize = CInteger;
      Dest = Rd;
      RegA =* Ra;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);

      !Nenc66;
      Sync=S;


CLASS "I LDC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /AdMode(IA):ad /S(noS):sync
Register:Rd ',' C[UImm(5/0*):constBank]* [ZeroRegister(RZ):Ra + SImm(17)*:immConstOffset];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    OPCODES
         LDC = 0b000101_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      AdMode = AdMode;
      LSSize = CInteger;
      Dest = Rd;
      RegA =* Ra;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);

      !Nenc66;
      Sync=S;


CLASS "LDC_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' C[UImm(5):constBank][NonZeroRegister:Ra + SImm(10/0):sImm];

    CONDITIONS
         ERROR
           (constBank <= 6 || constBank == 16) :
             "Only constant banks 0..6,16 are legal"

        PROPERTIES IWIDTH = 4;
OPCODES
         LDC_N = 0b1_1_100;

    ENCODING
      Opcode10 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      CBank32 = LDCNConstBank(constBank);
      CAddr32 = sImm SCALE 4 ROR 6;

      !Canvas32;


CLASS "I LDC_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             Register:Rd ',' C[UImm(5):constBank][ZeroRegister(RZ):Ra + UImm(10):immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 6 || constBank == 16) :
             "Only constant banks 0..6,16 are legal"

        PROPERTIES IWIDTH = 4;
OPCODES
         LDC_N = 0b1_1_100;

    ENCODING
      Opcode10 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      CBank32 = LDCNConstBank(constBank);
      CAddr32 = immConstOffset SCALE 4 ROR 6;

      !Canvas32;


CLASS "VILD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' V[NonZeroRegister:Ra + SImm(16/0):sImm];

    OPCODES
         VILD = 0b000000_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm16 = sImm;
      !BAddr;

      !Nenc67;
      Sync=S;

CLASS "I VILD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' V[ZeroRegister(RZ):Ra + UImm(16/0):uImm];

    OPCODES
         VILD = 0b000000_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm16 = uImm;
      !BAddr;

      !Nenc67;
      Sync=S;

CLASS "ALD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /P(noP):p /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A[NonZeroRegister:Ra + SImm(11/0):sImm]
             ',' Register(RZ):Rb;

    CONDITIONS






    OPCODES
         ALD = 0b000001_0_110;

    ENCODING
      Opcode18 = Opcode;
      AIO = AIO;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      Imm11 = sImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc68;
      Sync=S;


CLASS "I ALD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /P(noP):p /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A[ZeroRegister(RZ):Ra + UImm(10/0):uImm]
             ',' Register(RZ):Rb;

    CONDITIONS






    OPCODES
         ALD = 0b000001_0_110;

    ENCODING
      Opcode18 = Opcode;
      AIO = AIO;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      Imm10 = uImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc111;
      Sync=S;


CLASS "ALD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AInteger("32"):size
             Register:Rd ',' A[UImm(10):uImm]
             ',' Register(RZ):Rb;

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % ARegAlignment(AInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         ALD_N = 0b10_1_001;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      Imm8_32b = uImm SCALE 4 ROR 6;
      ALSize32 = AInteger;

      !Canvas32;


CLASS "AST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /P(noP):p /AInteger("32"):size /S(noS):sync
             A[NonZeroRegister:Ra + SImm(11/0):sImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS






    OPCODES
         AST = 0b000010_0_110;

    ENCODING
      Opcode2 = Opcode;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegB = Rb;
      Imm11 = sImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc69;
      Sync=S;


CLASS "I AST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /P(noP):p /AInteger("32"):size /S(noS):sync
             A[ZeroRegister(RZ):Ra + UImm(10/0):uImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS






    OPCODES
         AST = 0b000010_0_110;

    ENCODING
      Opcode2 = Opcode;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegB = Rb;
      Imm10 = uImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc112;
      Sync=S;


CLASS "AST_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AInteger("32")
             A[UImm(10):uImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % ARegAlignment(AInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         AST_N = 0b11_1_001;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegB = Rb;
      Imm8_32b = uImm SCALE 4 ROR 6;
      ALSize32 = AInteger;

      !Canvas32;


CLASS "OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
         OUT = 0b000111_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      OutType = OutType;

      !Nenc70;
      Sync=S;
      ABC=0;
      !BFiller;


CLASS "Imm OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
             Register:Rd ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
         OUT = 0b000111_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      OutType = OutType;

      !Nenc70;
      Sync=S;
      ABC = 3;



CLASS "Const OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
Register:Rd ',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
         OUT = 0b000111_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      OutType = OutType;

      !Nenc70;
      Sync=S;
      ABC = 1;



 CLASS "PIXLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd ','
             [NonZeroRegister:Ra + SImm(8/0):sImm];

    OPCODES
         PIXLD = 0b000100_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      PredDest = Pd;
      RegA =* Ra;
      PixMode = PixMode;
      Imm8 = sImm;

      Sync=S;
      !Nenc71;


 CLASS "I PIXLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd ','
             [ZeroRegister(RZ):Ra + UImm(8/0):uImm];

    OPCODES
         PIXLD = 0b000100_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      PredDest = Pd;
      RegA =* Ra;
      PixMode = PixMode;
      Imm8 = uImm;

      Sync=S;
      !Nenc71;


 ALTERNATE CLASS "PIXLD simple"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd;

    OPCODES
         PIXLD = 0b000100_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      PredDest = Pd;
      RegA = `Register@RZ;
      PixMode = PixMode;
      Imm8 = 0;

      Sync=S;
      !Nenc71;


 CLASS "LD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(32/0):sImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LD = 0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize =* LDInteger;
      E = E;
      COP = LoadCacheOp;

      Sync=S;

 CLASS "I LD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LD = 0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize =* LDInteger;
      E = E;
      COP = LoadCacheOp;

      Sync=S;

CLASS "LD.BV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /BVOnly:bv /LoadCacheOp0(CA):cop /BQInteger:size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(32/0):sImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % BQRegAlignment(BQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LD = 0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize =* BVOnly;
      E = E;
      COP = ldbvCopMerge(BQInteger, LoadCacheOp0);

      Sync=S;


CLASS "I LD.BV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /BVOnly:bv /LoadCacheOp0(CA):cop /BQInteger:size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % BQRegAlignment(BQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LD = 0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize =* BVOnly;
      E = E;
      COP = ldbvCopMerge(BQInteger, LoadCacheOp0);

      Sync=S;


ALTERNATE CLASS "LD.BV illegal"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /BVOnly:bv /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(32/0):sImm];

    CONDITIONS
         ERROR
           (bv != `BVOnly@BV) :
             "This LD syntax illegal. Please see spec for LD.BV."

    OPCODES
         LD = 0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize =* BVOnly;
      E = E;
      COP = LoadCacheOp;

      Sync=S;


ALTERNATE CLASS "I LD.BV illegal"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /BVOnly:bv /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm];

    CONDITIONS
         ERROR
           (bv != `BVOnly@BV) :
             "This LD syntax illegal. Please see spec for LD.BV."

    OPCODES
         LD = 0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize =* BVOnly;
      E = E;
      COP = LoadCacheOp;

      Sync=S;


 CLASS "LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(32/0):sImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDU = 0b10001_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize = CInteger;
      E = E;

      Sync=S;
      !COP;


 CLASS "I LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDU = 0b10001_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize = CInteger;
      E = E;

      Sync=S;
      !COP;


 CLASS "LDLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [NonZeroRegister:Ra + SImm(32/0):sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDLK = 0b10100_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize = CInteger;
      LockPred = Pd;
      Sync=S;


 CLASS "I LDLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDLK = 0b10100_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize = CInteger;
      LockPred = Pd;
      Sync=S;


  CLASS "LD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /QInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(11/0):sImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % QRegAlignment(QInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         LD_N = 0b00_1_011;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm8_32c = sImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;
      E32 = E;

      !Canvas32;


  CLASS "I LD_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /QInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(11/0):uImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % QRegAlignment(QInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         LD_N = 0b00_1_011;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm8_32c = uImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;
      E32 = E;

      !Canvas32;


 CLASS "ST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0):sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

    OPCODES
         ST = 0b10010_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize = CInteger;
      E = E;
      COP = StoreCacheOp;

      Sync=S;


 CLASS "I ST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

    OPCODES
         ST = 0b10010_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize = CInteger;
      E = E;
      COP = StoreCacheOp;

      Sync=S;


 CLASS "STUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0):sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

    OPCODES
         STUL = 0b111010_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize = CInteger;
      Sync=S;
      !Nenc41;


 CLASS "I STUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

    OPCODES
         STUL = 0b111010_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize = CInteger;
      Sync=S;
      !Nenc41;


  CLASS "ST_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /QInteger("32"):size
             [NonZeroRegister:Ra + SImm(11/0):sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % QRegAlignment(QInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         ST_N = 0b01_1_011;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm8_32c = sImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;
      E32 = E;
      !Canvas32;


  CLASS "I ST_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /QInteger("32"):size
             [ZeroRegister(RZ):Ra + UImm(11/0):uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % QRegAlignment(QInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         ST_N = 0b01_1_011;

    ENCODING
      Opcode7 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm8_32c = uImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;
      E32 = E;
      !Canvas32;


 CLASS "ATOM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0):sImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Comparison register improperly aligned for specified operation size"

    OPCODES
         ATOM = 0b01_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegDa = Rd;
      RegA =* Ra;
      RegC = Rc;
      Imm20a = sImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      E = E;
      Sync=S;


 CLASS "I ATOM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0):uImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Comparison register improperly aligned for specified operation size"

    OPCODES
         ATOM = 0b01_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegDa = Rd;
      RegA =* Ra;
      RegC = Rc;
      Imm20a = uImm;
      AtomSize = SQInteger;
      AtomOp = AtomOp;
      E = E;
      Sync=S;


 CLASS "RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0):sImm]
             ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

    OPCODES
         RED = 0b00_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = sImm;
      AtomSize = SQInteger;
      AtomOp = RedOp;
      E = E;
      Sync=S;


 CLASS "I RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm]
             ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

    OPCODES
         RED = 0b00_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = uImm;
      AtomSize = SQInteger;
      AtomOp = RedOp;
      E = E;
      Sync=S;


 CLASS "LDL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0):sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDL = 0b110000_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      COP = LLoadCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "I LDL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDL = 0b110000_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      COP = LLoadCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "LDS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0):sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDS = 0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize =* LDInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "I LDS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDS = 0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize =* LDInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "LDS.BV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVOnly:bv /BQInteger:size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0):sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % BQRegAlignment(BQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDS = 0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize =* BVOnly;
      COP = ldbvCopMerge(BQInteger, 0);

      !Nenc73;
      Sync=S;


 CLASS "I LDS.BV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVOnly:bv /BQInteger:size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % BQRegAlignment(BQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDS = 0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize =* BVOnly;
      COP = ldbvCopMerge(BQInteger, 0);

      !Nenc73;
      Sync=S;


 ALTERNATE CLASS "LDS.BV illegal"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVOnly:bv /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0):sImm];

    CONDITIONS
         ERROR
           (bv != `BVOnly@BV) :
             "This syntax of LDS.BV is illegal. Please see spec for LDS.BV."

    OPCODES
         LDS = 0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize =* BVOnly;

      !Nenc73;
      Sync=S;
      !COP;


 ALTERNATE CLASS "I LDS.BV illegal"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVOnly:bv /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm];

    CONDITIONS
         ERROR
           (bv != `BVOnly@BV) :
             "This syntax of LDS.BV is illegal. Please see spec for LDS.BV."

    OPCODES
         LDS = 0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize =* BVOnly;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "LDSLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0):sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDSLK = 0b110001_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      LockPreda = Pd;
      !Nenc74;
      Sync=S;


 CLASS "I LDSLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         LDSLK = 0b110001_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      LockPreda = Pd;
      !Nenc74;
      Sync=S;


  CLASS "LDL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /QInteger("32"):size
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(11/0):sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % QRegAlignment(QInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         LDL_N = 0b0_00_1_010;
         LDS_N = 0b1_00_1_010;

    ENCODING
      Opcode23 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm8_32c = sImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;

      !Canvas32;


  CLASS "I LDL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /QInteger("32"):size
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(11/0):uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % QRegAlignment(QInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         LDL_N = 0b0_00_1_010;
         LDS_N = 0b1_00_1_010;

    ENCODING
      Opcode23 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm8_32c = uImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;

      !Canvas32;


 CLASS "STL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0):sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         STL = 0b110010_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      COP = StoreCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "I STL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         STL = 0b110010_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      COP = StoreCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "STS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0):sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         STS = 0b110010_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "I STS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         STS = 0b110010_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "STSUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0):sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         STSUL = 0b110011_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      !LockPreda;
      !Nenc74;
      Sync=S;


 CLASS "I STSUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
         STSUL = 0b110011_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      !LockPreda;
      !Nenc74;
      Sync=S;


  CLASS "STL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /QInteger("32"):size
             [NonZeroRegister:Ra + SImm(11/0):sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % QRegAlignment(QInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         STL_N = 0b0_01_1_010;
         STS_N = 0b1_01_1_010;

    ENCODING
      Opcode23 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm8_32c = sImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;

      !Canvas32;


  CLASS "I STL_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /QInteger("32"):size
             [ZeroRegister(RZ):Ra + UImm(11/0):uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % QRegAlignment(QInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

        PROPERTIES IWIDTH = 4;
OPCODES
         STL_N = 0b0_01_1_010;
         STS_N = 0b1_01_1_010;

    ENCODING
      Opcode23 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm8_32c = uImm SCALE (QInteger+1)*4 ROR 6;
      Quad = QInteger;

      !Canvas32;


 CLASS "LD_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /EU(noEU):eu { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [NonZeroRegister:Ra + SImm(14/0):sImm] ','
             [NonZeroRegister:Rb + SImm(14/0):sImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           e -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"
         ERROR
           eu -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.EU' is specified"

    OPCODES
         LD_LDU = 0b1011_0_101;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = sImm SCALE CIntSize(size);
      bImm10 = sImmb SCALE CIntSize(sizeb);

      aE = e;
      bE = eu;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "I LD_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /EU(noEU):eu { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [ZeroRegister(RZ):Ra + UImm(14/0):uImm] ','
             [NonZeroRegister:Rb + SImm(14/0):sImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           e -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"
         ERROR
           eu -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.EU' is specified"

    OPCODES
         LD_LDU = 0b1011_0_101;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = uImm SCALE CIntSize(size);
      bImm10 = sImmb SCALE CIntSize(sizeb);

      aE = e;
      bE = eu;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "IU LD_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /EU(noEU):eu { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [NonZeroRegister:Ra + SImm(14/0):sImm] ','
             [ZeroRegister(RZ):Rb + UImm(14/0):uImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           e -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"
         ERROR
           eu -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.EU' is specified"

    OPCODES
         LD_LDU = 0b1011_0_101;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = sImm SCALE CIntSize(size);
      bImm10 = uImmb SCALE CIntSize(sizeb);

      aE = e;
      bE = eu;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "I IU LD_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /EU(noEU):eu { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [ZeroRegister(RZ):Ra + UImm(14/0):uImm] ','
             [ZeroRegister(RZ):Rb + UImm(14/0):uImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           e -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"
         ERROR
           eu -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.EU' is specified"

    OPCODES
         LD_LDU = 0b1011_0_101;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = uImm SCALE CIntSize(size);
      bImm10 = uImmb SCALE CIntSize(sizeb);

      aE = e;
      bE = eu;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "LDS_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [NonZeroRegister:Ra + SImm(14/0):sImm] ','
             [NonZeroRegister:Rb + SImm(14/0):sImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           E -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.E' is specified"

    OPCODES
         LDS_LDU = 0b10101_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = sImm SCALE CIntSize(size);
      bImm10 = sImmb SCALE CIntSize(sizeb);

      E = E;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "I LDS_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [ZeroRegister(RZ):Ra + UImm(14/0):uImm] ','
             [NonZeroRegister:Rb + SImm(14/0):sImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           E -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.E' is specified"

    OPCODES
         LDS_LDU = 0b10101_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = uImm SCALE CIntSize(size);
      bImm10 = sImmb SCALE CIntSize(sizeb);

      E = E;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "IU LDS_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [NonZeroRegister:Ra + SImm(14/0):sImm] ','
             [ZeroRegister(RZ):Rb + UImm(14/0):uImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           E -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.E' is specified"

    OPCODES
         LDS_LDU = 0b10101_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = sImm SCALE CIntSize(size);
      bImm10 = uImmb SCALE CIntSize(sizeb);

      E = E;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "I IU LDS_LDU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e { /CInteger("32"):size /CInteger("32"):sizeb } /S(noS):sync
             Register:Rd ',' Register:Rdb ','
             [ZeroRegister(RZ):Ra + UImm(14/0):uImm] ','
             [ZeroRegister(RZ):Rb + UImm(14/0):uImmb];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(size)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           (((Rdb)+((Rdb)==63)) % CRegAlignment(sizeb)) == 0 :
             "Output register improperly aligned for specified operation size"
         ERROR
           E -> IsEven(((Rb)+((Rb)==63))) :
             "An even address register is required when '.E' is specified"

    OPCODES
         LDS_LDU = 0b10101_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DestA = Rd;
      Dest = Rdb;
      RegA =* Ra;
      RegB =* Rb;
      aImm10 = uImm SCALE CIntSize(size);
      bImm10 = uImmb SCALE CIntSize(sizeb);

      E = E;
      abSize = abSize(size,sizeb);

      Sync=S;


 CLASS "CCTL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /CCTLOp:cctlop /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0):sImm] ;

    OPCODES
         CCTL = 0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm30a = sImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* CCTLOp;

      Sync=S;


 CLASS "I CCTL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /CCTLOp:cctlop /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm] ;

    OPCODES
         CCTL = 0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm30a = uImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* CCTLOp;

      Sync=S;


 ALTERNATE CLASS "CCTL IVALL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyIvall:ivall /S(noS):sync
             ;

    OPCODES
         CCTL = 0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA = `Register@RZ;
      Imm30a = 0;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyIvall;

      Sync=S;


 CLASS "CCTL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             Register:Rd ',' [NonZeroRegister:Ra + SImm(32/0):sImm] ;

    OPCODES
         CCTL = 0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm30a = sImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;

 CLASS "I CCTL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             Register:Rd ',' [ZeroRegister(RZ):Ra + UImm(32/0):uImm] ;

    OPCODES
         CCTL = 0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm30a = uImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;

 ALTERNATE CLASS "CCTL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0):sImm] ;

    OPCODES
         CCTL = 0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm30a = sImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;

 ALTERNATE CLASS "I CCTL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0):uImm] ;

    OPCODES
         CCTL = 0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm30a = uImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;

 CLASS "CCTLL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CCTLOp:cctlop /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0):sImm] ;

    OPCODES
         CCTLL = 0b110100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm22a = sImm SCALE 4;
      CCTLOp =* CCTLOp;

      !Nenc75;
      Sync=S;

 CLASS "I CCTLL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CCTLOp:cctlop /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0):uImm] ;

    OPCODES
         CCTLL = 0b110100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm22a = uImm SCALE 4;
      CCTLOp =* CCTLOp;

      !Nenc75;
      Sync=S;

 ALTERNATE CLASS "CCTLL IVALL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyIvall:ivall /S(noS):sync
             ;

    OPCODES
         CCTLL = 0b110100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA = `Register@RZ;
      Imm22a = 0;
      CCTLOp =* OnlyIvall;

      !Nenc75;
      Sync=S;


 CLASS "CCTLL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyQry:op /S(noS):sync
              Register:Rd ',' [NonZeroRegister:Ra + SImm(24/0):sImm] ;

    OPCODES
         CCTLL = 0b110100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm22a = sImm SCALE 4;
      CCTLOp =* OnlyQry;

      !Nenc75;
      Sync=S;


 CLASS "I CCTLL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyQry:op /S(noS):sync
              Register:Rd ',' [ZeroRegister(RZ):Ra + UImm(24/0):uImm] ;

    OPCODES
         CCTLL = 0b110100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm22a = uImm SCALE 4;
      CCTLOp =* OnlyQry;

      !Nenc75;
      Sync=S;


 ALTERNATE CLASS "CCTLL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyQry:op /S(noS):sync
              [NonZeroRegister:Ra + SImm(24/0):sImm] ;

    OPCODES
         CCTLL = 0b110100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm22a = sImm SCALE 4;
      CCTLOp =* OnlyQry;

      !Nenc75;
      Sync=S;


 ALTERNATE CLASS "I CCTLL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OnlyQry:op /S(noS):sync
              [ZeroRegister(RZ):Ra + UImm(24/0):uImm] ;

    OPCODES
         CCTLL = 0b110100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm22a = uImm SCALE 4;
      CCTLOp =* OnlyQry;

      !Nenc75;
      Sync=S;


 CLASS "SUQ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SuqOp:suq /S(noS):sync
             Register:Rd ',' Register:Rb;

    OPCODES
         SUQ = 0b111001_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      SuqOp = SuqOp;
      Dest = Rd;
      RegB = Rb;

      BFix_A=0;
      !Nenc77;
      Sync=S;


 CLASS "Imm SUQ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SuqOp:suq /S(noS):sync
             Register:Rd ',' UImm(6):uImm;

    OPCODES
         SUQ = 0b111001_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      SuqOp = SuqOp;
      Dest = Rd;
      RegB=uImm;

      BFix_A=1;
      !Nenc77;
      Sync=S;


 CLASS "SULEA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /B(noB):b /P(noP):p /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             { Predicate(PT):Pd ',' } Register:Rd
             ',' Register:Rb ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb };

    CONDITIONS
         ERROR
           P ^ B :
             "Either .P or .B must be specified for this operation"

    OPCODES
         SULEA = 0b111100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      VPDest = Pd;
      RegA = Ra;
      RegB = Rb;
      Dim = Dim;
      Clamp = Clamp0;
      BP = CombineBP(B,P);
      LSSize = CInteger;
      Xoffset = sImm;
      Yoffset = sImmb;

      BFix_A=0;
      !Nenc78;
      !Zoffset;
      Sync=S;

 CLASS "Imm SULEA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /B(noB):b /P(noP):p /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             { Predicate(PT):Pd ',' } Register:Rd
             ',' UImm(6):uImm ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb };

    CONDITIONS
         ERROR
           P ^ B :
             "Either .P or .B must be specified for this operation"

    OPCODES
         SULEA = 0b111100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      VPDest = Pd;
      RegA = Ra;
      RegB=uImm;
      Dim = Dim;
      Clamp = Clamp0;
      BP = CombineBP(B,P);
      LSSize = CInteger;
      Xoffset = sImm;
      Yoffset = sImmb;

      BFix_A=1;
      !Nenc78;
      !Zoffset;
      Sync=S;

ALTERNATE CLASS "SULEA OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /B(noB):b /P(noP):p /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             { Predicate(PT):Pd ',' } Register:Rd
             ',' Register:Rb ',' Register:Ra
             ',' SImm(4):sImm;

    CONDITIONS
         ERROR
           P ^ B :
             "Either .P or .B must be specified for this operation"

    OPCODES
         SULEA = 0b111100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      VPDest = Pd;
      RegA = Ra;
      RegB = Rb;
      Dim = Dim;
      Clamp = Clamp0;
      BP = CombineBP(B,P);
      LSSize = CInteger;
      Xoffset = sImm;
      Yoffset = 0;

      BFix_A=0;
      !Nenc78;
      !Zoffset;
      Sync=S;


ALTERNATE CLASS "Imm SULEA OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /B(noB):b /P(noP):p /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             { Predicate(PT):Pd ',' } Register:Rd
             ',' UImm(6):uImm ',' Register:Ra
             ',' SImm(4):sImm;

    CONDITIONS
         ERROR
           P ^ B :
             "Either .P or .B must be specified for this operation"

    OPCODES
         SULEA = 0b111100_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      VPDest = Pd;
      RegA = Ra;
      RegB=uImm;
      Dim = Dim;
      Clamp = Clamp0;
      BP = CombineBP(B,P);
      LSSize = CInteger;
      Xoffset = sImm;
      Yoffset = 0;

      BFix_A=1;
      !Nenc78;
      !Zoffset;
      Sync=S;


 CLASS "SUST.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp1(IGN):clamp /S(noS):sync
             Register:Rb
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB = Rb;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = CInteger;
      COP = StoreCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;


 CLASS "Imm SUST.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp1(IGN):clamp /S(noS):sync
             UImm(6):uImm
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB=uImm;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = CInteger;
      COP = StoreCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;


ALTERNATE CLASS "SUST.B OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp1(IGN):clamp /S(noS):sync
             Register:Rb
             ',' Register:Ra
             ',' SImm(4):sImm ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB = Rb;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = CInteger;
      COP = StoreCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;

ALTERNATE CLASS "Imm SUST.B OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp1(IGN):clamp /S(noS):sync
             UImm(6):uImm
             ',' Register:Ra
             ',' SImm(4):sImm ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB=uImm;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = CInteger;
      COP = StoreCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;

 CLASS "SUST.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp1(IGN):clamp /S(noS):sync
             Register:Rb
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Dest = Rc;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = SD3;
      COP = StoreCacheOp;
      RGBA =* RGBA;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;


 CLASS "Imm SUST.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp1(IGN):clamp /S(noS):sync
             UImm(6):uImm
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB=uImm;
      Dest = Rc;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = SD3;
      COP = StoreCacheOp;
      RGBA =* RGBA;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;


ALTERNATE CLASS "SUST.P OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp1(IGN):clamp /S(noS):sync
             Register:Rb
             ',' Register:Ra
             ',' SImm(4):sImm ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Dest = Rc;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = SD3;
      COP = StoreCacheOp;
      RGBA =* RGBA;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;

ALTERNATE CLASS "Imm SUST.P OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp1(IGN):clamp /S(noS):sync
             UImm(6):uImm
             ',' Register:Ra
             ',' SImm(4):sImm ',' Register:Rc;

    OPCODES
         SUST = 0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB=uImm;
      Dest = Rc;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp1;
      LSSize = SD3;
      COP = StoreCacheOp;
      RGBA =* RGBA;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;

 CLASS "SULD.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' Register:Rb
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = CInteger;
      COP = LoadCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;

 CLASS "Imm SULD.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' UImm(6):uImm
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=uImm;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = CInteger;
      COP = LoadCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;

ALTERNATE CLASS "SULD.B OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' Register:Rb
             ',' Register:Ra
             ',' SImm(4):sImm ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = CInteger;
      COP = LoadCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;

ALTERNATE CLASS "Imm SULD.B OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger("32"):size /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' UImm(6):uImm
             ',' Register:Ra
             ',' SImm(4):sImm ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=uImm;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = CInteger;
      COP = LoadCacheOp;
      RGBA =* RGBA_NONE;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;

 CLASS "SULD.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /LoadCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' Register:Rb
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = SD3;
      COP = LoadCacheOp;
      RGBA =* rgba;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;

 CLASS "Imm SULD.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /LoadCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' UImm(6):uImm
             ',' Register:Ra
             ',' { SImm(4/0):sImm ',' SImm(4/0):sImmb } ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=uImm;
      Xoffset = sImm;
      Yoffset = sImmb;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = SD3;
      COP = LoadCacheOp;
      RGBA =* rgba;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;

ALTERNATE CLASS "SULD.P OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /LoadCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' Register:Rb
             ',' Register:Ra
             ',' SImm(4):sImm ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = SD3;
      COP = LoadCacheOp;
      RGBA =* rgba;

      BFix_A=0;
      !Nenc79;
      !Zoffset;
      Sync=S;


ALTERNATE CLASS "Imm SULD.P OneImm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Dim:dim /POnly:p /LoadCacheOp(CG):cop /RGBA(RGBA):rgba /SD3(SD):rf /Clamp0(NEAR):clamp /S(noS):sync
             Register:Rd
             ',' UImm(6):uImm
             ',' Register:Ra
             ',' SImm(4):sImm ;

    OPCODES
         SULD = 0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB=uImm;
      Xoffset = sImm;
      Yoffset = 0;

      Dim = Dim;
      Clamp = Clamp0;
      LSSize = SD3;
      COP = LoadCacheOp;
      RGBA =* rgba;

      BFix_A=1;
      !Nenc79;
      !Zoffset;
      Sync=S;


 CLASS "SURED.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SUOp:atom /Dim:dim /POnly:p /RGBA(RGBA):rgba /SD(SD):rf /Clamp1(NEAR):clamp /S(noS):sync
             Register:Rb
             ',' Register:Ra
             ',' Register:Rc;

    OPCODES
         SURED = 0b110110_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB = Rb;

      Dim = Dim;
      Clamp = Clamp1;
      SUOp = SUOp;
      SD = SD;
      RGBAa =* RGBA;

      BFix_A=0;
      !Nenc80;
      Sync=S;

 CLASS "Imm SURED.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SUOp:atom /Dim:dim /POnly:p /RGBA(RGBA):rgba /SD(SD):rf /Clamp1(NEAR):clamp /S(noS):sync
             UImm(6):uImm
             ',' Register:Ra
             ',' Register:Rc;

    OPCODES
         SURED = 0b110110_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB=uImm;

      Dim = Dim;
      Clamp = Clamp1;
      SUOp = SUOp;
      SD = SD;
      RGBAa =* RGBA;

      BFix_A=1;
      !Nenc80;
      Sync=S;

 CLASS "SURED.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SUOp:atom /Dim:dim /BOnly:b /RGBA_NONE(noRGBA):rgba /SD(SD):rf /Clamp1(IGN):clamp /S(noS):sync
             Register:Rb
             ',' Register:Ra
             ',' Register:Rc;

    OPCODES
         SURED = 0b110110_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB = Rb;

      Dim = Dim;
      Clamp = Clamp1;
      SUOp = SUOp;
      SD = SD;
      RGBAa =* RGBA_NONE;

      BFix_A=0;
      !Nenc80;
      Sync=S;

 CLASS "Imm SURED.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SUOp:atom /Dim:dim /BOnly:b /RGBA_NONE(noRGBA):rgba /SD(SD):rf /Clamp1(IGN):clamp /S(noS):sync
             UImm(6):uImm
             ',' Register:Ra
             ',' Register:Rc;

    OPCODES
         SURED = 0b110110_0_101;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rc;
      RegA = Ra;
      RegB=uImm;

      Dim = Dim;
      Clamp = Clamp1;
      SUOp = SUOp;
      SD = SD;
      RGBAa =* RGBA_NONE;

      BFix_A=1;
      !Nenc80;
      Sync=S;

CLASS "I2I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):bytesel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      By = B1B0;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc9;

CLASS "Imm I2I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      By = B1B0;

      ABC = 3;

      Sync=S;
      !Nenc9;

CLASS "Const I2I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      By = B1B0;

      ABC = 1;

      Sync=S;
      !Nenc9;

ALTERNATE CLASS "I2I default"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):bytesel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( `Integer@S32 );
      ISrcFmt =* IntSize( `IntegerNo16@S32 );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      By = B1B0;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc9;


ALTERNATE CLASS "Imm I2I default"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( `Integer@S32 );
      ISrcFmt =* IntSize( `IntegerNo16@S32 );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      By = B1B0;

      ABC = 3;

      Sync=S;
      !Nenc9;


ALTERNATE CLASS "Const I2I default"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( `Integer@S32 );
      ISrcFmt =* IntSize( `IntegerNo16@S32 );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      By = B1B0;

      ABC = 1;

      Sync=S;
      !Nenc9;


CLASS "I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );
      By = I2XH;

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc9;
CLASS "Imm I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );
      By = I2XH;

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc9;
CLASS "Const I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel;

    OPCODES
         I2I = 0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );
      By = I2XH;

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc9;
CLASS "I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float(F32):dstfmt /IntegerNo16(S32):srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF

                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"
         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (IsEven(((Rb)+((Rb)==63)))) :
             ".U64 requires an even source register"
         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

    OPCODES
         I2F = 0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );

      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      Rnd = Round1;
      nB = Rb@negate;
      aB = Rb@absolute;
      By = B1B0;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc10;


CLASS "Imm I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float(F32):dstfmt /IntegerNo16(S32):srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF

                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"
         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

    OPCODES
         I2F = 0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );

      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      Rnd = Round1;
      nB = UnaryNeg;
      aB = UnaryAbs;
      By = B1B0;

      ABC = 3;

      Sync=S;
      !Nenc10;


CLASS "Const I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float(F32):dstfmt /IntegerNo16(S32):srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF

                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"
         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

    OPCODES
         I2F = 0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );

      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Rnd = Round1;
      nB = srcConst@negate;
      aB = srcConst@absolute;
      By = B1B0;

      ABC = 1;

      Sync=S;
      !Nenc10;


CLASS "I2F16"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float(F32):dstfmt /Integer16:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"

    OPCODES
         I2F = 0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );
      By = I2XH;

      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      Rnd = Round1;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc10;
CLASS "Imm I2F16"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float(F32):dstfmt /Integer16:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"

    OPCODES
         I2F = 0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );
      By = I2XH;

      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      Rnd = Round1;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc10;
CLASS "Const I2F16"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float(F32):dstfmt /Integer16:srcfmt
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"

    OPCODES
         I2F = 0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );
      By = I2XH;

      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Rnd = Round1;
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc10;
 CLASS "BAR_N"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSyncArv:barmode
            Register:Ra;

        PROPERTIES IWIDTH = 4;
OPCODES
         BAR_N = 0b0101_000_000_1_000;

    ENCODING
      Opcode8 = Opcode;
      BarOpN = BarSyncArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      AFix_BAR32 = 0;
      !Canvas32;
      !Nenc65;

 CLASS "BAR_N barrier"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSyncArv:barmode
            UImm(4):barNum;

        PROPERTIES IWIDTH = 4;
OPCODES
         BAR_N = 0b0101_000_000_1_000;

    ENCODING
      Opcode8 = Opcode;
      BarOpN = BarSyncArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      AFix_BAR32 = 1;
      !Canvas32;
      !Nenc65;


 CLASS "BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode /S(noS):sync
            Register:Ra ',' Register:Rb;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      !SrcPred;
      !SrcNot;
      !BarFiller;
      AFix_BAR=0;
      BFix_BAR=0;
      !Nenc62;
      Sync=S;

 CLASS "b BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode /S(noS):sync
            Register:Ra ',' UImm(12/0):uImm;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      !SrcPred;
      !SrcNot;

      AFix_BAR=0;
      BFix_BAR=1;
      !Nenc62;
      Sync=S;

 CLASS "a b BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode /S(noS):sync
            UImm(4):barNum ',' UImm(12/0):uImm;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      !SrcPred;
      !SrcNot;

      AFix_BAR=1;
      BFix_BAR=1;
      !Nenc62;
      Sync=S;

 CLASS "a BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode /S(noS):sync
            UImm(4):barNum ',' Register:Rb;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      !SrcPred;
      !SrcNot;
      !BarFiller;
      AFix_BAR=1;
      BFix_BAR=0;
      !Nenc62;
      Sync=S;

 CLASS "BAR RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BARRED /Red:barmode /S(noS):sync
            Register:Rd
            ',' Predicate(PT):Pd
            ',' Register:Ra ',' Register:Rb
            ',' [!]Predicate:Pa;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BARRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Dest = Rd;
      DstPred = Pd;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !BarFiller;
      AFix_BAR=0;
      BFix_BAR=0;
      !Nenc64;
      Sync=S;


 CLASS "b BAR RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BARRED /Red:barmode /S(noS):sync
            Register:Rd
            ',' Predicate(PT):Pd
            ',' Register:Ra ',' UImm(12/0):uImm
            ',' [!]Predicate:Pa;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BARRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      Dest = Rd;
      DstPred = Pd;
      SrcPred = Pa;
      SrcNot = Pa@not;

      AFix_BAR=0;
      BFix_BAR=1;
      !Nenc64;
      Sync=S;


 CLASS "a b BAR RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BARRED /Red:barmode /S(noS):sync
            Register:Rd
            ',' Predicate(PT):Pd
            ',' UImm(4):barNum ',' UImm(12/0):uImm
            ',' [!]Predicate:Pa;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BARRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      Dest = Rd;
      DstPred = Pd;
      SrcPred = Pa;
      SrcNot = Pa@not;

      AFix_BAR=1;
      BFix_BAR=1;
      !Nenc64;
      Sync=S;


 CLASS "a BAR RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BARRED /Red:barmode /S(noS):sync
            Register:Rd
            ',' Predicate(PT):Pd
            ',' UImm(4):barNum ',' Register:Rb
            ',' [!]Predicate:Pa;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BARRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      Dest = Rd;
      DstPred = Pd;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !BarFiller;
      AFix_BAR=1;
      BFix_BAR=0;
      !Nenc64;
      Sync=S;


 ALTERNATE CLASS "BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode /S(noS):sync
            Register:Ra ',' Register:Rb;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      SrcPred = `Predicate@PT;
      !SrcNot;
      !BarFiller;
      AFix_BAR=0;
      BFix_BAR=0;
      !Nenc62;
      Sync=S;
 ALTERNATE CLASS "b BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode /S(noS):sync
            Register:Ra ',' UImm(12/0):uImm;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      SrcPred = `Predicate@PT;
      !SrcNot;

      AFix_BAR=0;
      BFix_BAR=1;
      !Nenc62;
      Sync=S;
 ALTERNATE CLASS "a b BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode /S(noS):sync
            UImm(4):barNum ',' UImm(12/0):uImm;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      SrcPred = `Predicate@PT;
      !SrcNot;

      AFix_BAR=1;
      BFix_BAR=1;
      !Nenc62;
      Sync=S;
 ALTERNATE CLASS "a BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode /S(noS):sync
            UImm(4):barNum ',' Register:Rb;

    OPCODES
         BAR = 0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      Dest = `Register@RZ;
      DstPred = `Predicate@PT;
      SrcPred = `Predicate@PT;
      !SrcNot;
      !BarFiller;
      AFix_BAR=1;
      BFix_BAR=0;
      !Nenc62;
      Sync=S;
 CLASS "VADD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/ASel4("3210"):asel
             ',' [-]Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (AVRG -> (!Ra@negate && !Rb@negate)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD4 = 0b100000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      AVGMode = VMode(AVRG,Ra@negate,Rb@negate);
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VADD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/ASel4("3210"):asel
             ',' SSImm(9):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"
         ERROR
           (AVRG -> (!Ra@negate && !uImm@sign)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD4 = 0b100000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      AVGMode = VMode(AVRG,Ra@negate,uImm@sign);
      BVideo=0;

      Sync=S;


 CLASS "VADD4_N"
    FORMAT Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
             Register:Rd ',' [-]Register:Ra ',' Register:Rb;

    CONDITIONS
         ERROR
           safmt == sbfmt :
             "Input register types must be identical for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         VADD4_N = 0b1110000_1_000;

    ENCODING
      Opcode32 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      DFormat32 = DFormat;
      sabfmt32 = Integer8x8Signed(safmt,sbfmt);
      nA32c = Ra@negate;
      !Canvas32;



 CLASS "VABSDIFF4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF4 = 0b100010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      !Nenc59;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VABSDIFF4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

    OPCODES
         VABSDIFF4 = 0b100010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      !Nenc59;
      BVideo=0;

      Sync=S;


 CLASS "VABSDIFF4_N"
    FORMAT Opcode
                  /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         VABSDIFF4_N = 0b1010000_1_000;

    ENCODING
      Opcode32 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      DFormat32 = DFormat;
      safmt32 = Integer8Signed(safmt);
      sbfmt32 = Integer8Signed(sbfmt);
      !Canvas32;


 CLASS "VMNMX4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX4 = 0b100001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      MN = MN;

      !Nenc100;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VMNMX4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

    OPCODES
         VMNMX4 = 0b100001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      MN = MN;

      !Nenc100;
      BVideo=0;

      Sync=S;


 CLASS "VSET4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET4 = 0b100011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      VComp = ICmpAll;

      !DFormat;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VSET4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

    OPCODES
         VSET4 = 0b100011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      VComp = ICmpAll;

      !DFormat;
      BVideo=0;

      Sync=S;


 CLASS "VSHL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8(S8):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("4444"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSHL4 = 0b100101_0_100;
         VSHR4 = 0b100100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      MV = CWMode;

      !Nenc101;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VSHL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8(S8):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

    OPCODES
         VSHL4 = 0b100101_0_100;
         VSHR4 = 0b100100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      MV = CWMode;

      !Nenc101;
      BVideo=0;

      Sync=S;


 CLASS "VSEL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSEL4 = 0b100110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;

      !Nenc102;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VSEL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

    OPCODES
         VSEL4 = 0b100110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;

      !Nenc102;
      BVideo=0;

      Sync=S;


 CLASS "VADD2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/Sel2("10"):asel
             ',' [-]Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (AVRG -> (!Ra@negate && !Rb@negate)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD2 = 0b101000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      AVGMode = VMode(AVRG,Ra@negate,Rb@negate);
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VADD2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/Sel2hi("10"):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (AVRG -> (!Ra@negate && !uImm@sign)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD2 = 0b101000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      AVGMode = VMode(AVRG,Ra@negate,uImm@sign);
      BVideo=0;

      Sync=S;


 CLASS "VADD2_N"
    FORMAT Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
             Register:Rd ',' [-]Register:Ra ',' Register:Rb;

    CONDITIONS
         ERROR
           safmt == sbfmt :
             "Input register types must be identical for this operation"

        PROPERTIES IWIDTH = 4;
OPCODES
         VADD2_N = 0b0110000_1_000;

    ENCODING
      Opcode32 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      DFormat32 = DFormat;
      sabfmt32 = Integer16x16Signed(safmt,sbfmt);
      nA32c = Ra@negate;
      !Canvas32;



 CLASS "VABSDIFF2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF2 = 0b101010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      !Nenc59;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VABSDIFF2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF2 = 0b101010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      !Nenc59;
      BVideo=0;

      Sync=S;


 CLASS "VABSDIFF2_N"
    FORMAT Opcode
                  /DFormat(UD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS

        PROPERTIES IWIDTH = 4;
OPCODES
         VABSDIFF2_N = 0b0010000_1_000;

    ENCODING
      Opcode32 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      DFormat32 = DFormat;
      safmt32 = Integer16Signed(safmt);
      sbfmt32 = Integer16Signed(sbfmt);
      !Canvas32;


 CLASS "VMNMX2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX2 = 0b101001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      MN = MN;

      !Nenc100;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VMNMX2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX2 = 0b101001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      MN = MN;

      !Nenc100;
      BVideo=0;

      Sync=S;


 CLASS "VSET2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET2 = 0b101011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      VComp = ICmpAll;

      !DFormat;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VSET2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET2 = 0b101011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      VComp = ICmpAll;

      !DFormat;
      BVideo=0;

      Sync=S;


 CLASS "VSHL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16(S16):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("22"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSHL2 = 0b101101_0_100;
         VSHR2 = 0b101100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      MV = CWMode;

      !Nenc101;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VSHL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16(S16):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSHL2 = 0b101101_0_100;
         VSHR2 = 0b101100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      MV = CWMode;

      !Nenc101;
      BVideo=0;

      Sync=S;


 CLASS "VSEL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSEL2 = 0b101110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;

      !Nenc102;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VSEL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSEL2 = 0b101110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;


      !Nenc102;
      BVideo=0;

      Sync=S;


 CLASS "VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a8 b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a32 b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a8 b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a32 b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,uImm@sign);
      !Nenc103;
      BVideo=0;

      Sync=S;

 CLASS "a8 Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,uImm@sign);
      !Nenc103;
      BVideo=0;

      Sync=S;

 CLASS "a32 Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
         VADD = 0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,uImm@sign);
      !Nenc103;
      BVideo=0;

      Sync=S;

 CLASS "VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VABSDIFF = 0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=0;

      Sync=S;


 CLASS "VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VMNMX = 0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=0;

      Sync=S;


 CLASS "VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt } /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt } /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
         VSET = 0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=0;

      Sync=S;


 CLASS "VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt } /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt } /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
         VSHL = 0b11101_0_100;
         VSHR = 0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=0;

      Sync=S;


 CLASS "VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a8 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a32 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a8 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a32 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 ALTERNATE CLASS "NoBop Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 ALTERNATE CLASS "NoBop a8 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 ALTERNATE CLASS "NoBop a32 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' UImm(16):uImm
             ;

    CONDITIONS

    OPCODES
         VSETP = 0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 CLASS "VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a8 b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a32 b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a8 b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a32 b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=0;

      Sync=S;




 CLASS "a8 Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=0;

      Sync=S;




 CLASS "a32 Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
         VMAD = 0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=0;

      Sync=S;




 CLASS "VMAD_N"
    FORMAT Opcode /Integer16:safmt /Integer16:sbfmt
             Register:Rd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel;

        PROPERTIES IWIDTH = 4;
OPCODES
         VMAD_N = 0b101_1_000;

    ENCODING
      Opcode20 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      abSelect32a =* VFormat16_N(safmt,asel,sbfmt,bsel);

      !Canvas32;




 CLASS "ab8 VMAD_N"
    FORMAT Opcode /Integer8:safmt /Integer8:sbfmt
             Register:Rd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel;

        PROPERTIES IWIDTH = 4;
OPCODES
         VMAD_N = 0b101_1_000;

    ENCODING
      Opcode20 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      abSelect32a =* VFormat8_N(safmt,asel,sbfmt,bsel);

      !Canvas32;




 CLASS "a32b8 VMAD_N"
    FORMAT Opcode /Integer32:safmt /Integer8:sbfmt
             Register:Rd
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel;

        PROPERTIES IWIDTH = 4;
OPCODES
         VMAD_N = 0b101_1_000;

    ENCODING
      Opcode20 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      abSelect32a =* VFormat32_8_N(safmt,sbfmt,bsel);

      !Canvas32;




 CLASS "a8b32 VMAD_N"
    FORMAT Opcode /Integer8:safmt /Integer32:sbfmt
             Register:Rd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         VMAD_N = 0b101_1_000;

    ENCODING
      Opcode20 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      abSelect32a =* VFormat8_32_N(safmt,asel,sbfmt);

      !Canvas32;




 CLASS "a32b16 VMAD_N"
    FORMAT Opcode /Integer32:safmt /Integer16:sbfmt
             Register:Rd
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel;

        PROPERTIES IWIDTH = 4;
OPCODES
         VMAD_N = 0b101_1_000;

    ENCODING
      Opcode20 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      abSelect32a =* VFormat32_16_N(safmt,sbfmt,bsel);

      !Canvas32;




 CLASS "a16b32 VMAD_N"
    FORMAT Opcode /Integer16:safmt /Integer32:sbfmt
             Register:Rd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb;

        PROPERTIES IWIDTH = 4;
OPCODES
         VMAD_N = 0b101_1_000;

    ENCODING
      Opcode20 = Opcode;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      abSelect32a =* VFormat16_32_N(safmt,asel,sbfmt);

      !Canvas32;




CLASS "PSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0 /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ',' [!]Predicate:Pa;

    OPCODES
         PSETP = 0b000011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop0 = bop0;
      Bop = bopopt;


      !Nenc5;
      Sync=S;


ALTERNATE CLASS "NoBop PSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0 /S(noS):sync
                               Predicate:Pd
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ;

    OPCODES
         PSETP = 0b000011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop0 = bop0;
      Bop = `Bop@AND;


      !Nenc5;
      Sync=S;


CLASS "PSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0 /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ',' [!]Predicate:Pa;

    OPCODES
         PSET = 0b000010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop0 = bop0;
      Bop = bopopt;
      BVal = BVal;


      !Nenc6;
      Sync=S;
ALTERNATE CLASS "NoBop PSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0 /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ;

    OPCODES
         PSET = 0b000010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop0 = bop0;
      Bop = `Bop@AND;
      BVal = BVal;


      !Nenc6;
      Sync=S;
 CLASS "MEMBAR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MemBarLevel:lvl /S(noS):sync;

    OPCODES
         MEMBAR = 0b111000_0_101;

    ENCODING
      Opcode2 = Opcode;
      MembarL = MemBarLevel;
      Pred = Pg;
      PredNot = Pg@not;
      Sync=S;
      !Nenc110;
