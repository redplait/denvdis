ARCHITECTURE "Kepler"

   PROCESSOR_ID Kepler;
    ISSUE_SLOTS 2;
   WORD_SIZE 64;
   BRANCH_DELAY 0;
   ELF_ID 190;
   ELF_ABI 0x33;
   ELF_ABI_VERSION 7;


   ELF_VERSION 101;

   RELOCATORS
  { "R_CUDA_NONE", 0, False, False, 0,0, { { 0, 0} } }
  { "R_CUDA_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_G32", "R_CUDA_G32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_G64", "R_CUDA_G64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS32_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_TEX_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_SAMP_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 20, 12} } }
  { "R_CUDA_SURF_HW_DESC", 4, 0, 32 }
  { "R_CUDA_SURF_HW_SW_DESC", 5, 0, 32 }
  { "R_CUDA_ABS32_LO_26", 0x00000000ffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_HI_26", 0xffffffff00000000, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS24_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 24} } }
  { "R_CUDA_ABS24_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS16_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 16} } }
  { "R_CUDA_ABS16_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 16} } }
  { "R_CUDA_TEX_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 32, 8} } }
  { "R_CUDA_SAMP_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 40, 5} } }
  { "R_CUDA_SURF_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 26, 6} } }
  { "R_CUDA_TEX_BINDLESSOFF13_32", 0xffffffffffffffff, False, False, 0,2, { { 32, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_47", 0xffffffffffffffff, False, False, 0,2, { { 47, 13} } }
  { "R_CUDA_CONST_FIELD19_28", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 28, 18},
  { 26, 1} } }
  { "R_CUDA_CONST_FIELD19_23", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 23, 19} } }
  { "R_CUDA_TEX_SLOT9_49", 0xffffffffffffffff, False, False, 0,0, { { 49, 9} } }
  { "R_CUDA_6_31", 0xffffffffffffffff, False, False, 0,0, { { 31, 6} } }
  { "R_CUDA_2_47", 0xffffffffffffffff, False, False, 0,0, { { 47, 2} } }
  { "R_CUDA_TEX_BINDLESSOFF13_41", 0xffffffffffffffff, False, False, 0,2, { { 41, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_45", 0xffffffffffffffff, False, False, 0,2, { { 45, 13} } }
  { "R_CUDA_FUNC_DESC32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC_32", "R_CUDA_FUNC_DESC_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_FUNC_DESC_64", "R_CUDA_FUNC_DESC_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_CONST_FIELD21_26", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 26, 21} } }
  { "R_CUDA_QUERY_DESC21_37", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 37, 21} } }
  { "R_CUDA_CONST_FIELD19_26", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 26, 19} } }
  { "R_CUDA_CONST_FIELD21_23", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 23, 21} } }
  { "R_CUDA_PCREL_IMM24_26", 0xffffffffffffffff, True, False, 0,0, { { 26, 24} } }
  { "R_CUDA_PCREL_IMM24_23", 0xffffffffffffffff, True, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS24_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 24} } }
  { "R_CUDA_ABS16_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 16} } }
  { "R_CUDA_FUNC_DESC32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_CONST_FIELD19_20", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 20, 19} } }
  { "R_CUDA_BINDLESSOFF13_36", 0xffffffffffffffff, False, False, 0,2, { { 36, 13} } }
  { "R_CUDA_SURF_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_INSTRUCTION64", 17, 0, 64 }
  { "R_CUDA_CONST_FIELD21_20", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 20, 21} } }
  { "R_CUDA_ABS32_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS32_LO_32", 0x00000000ffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS32_HI_32", 0xffffffff00000000, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_ABS47_34", 0xffffffffffffffff, False, False, 0,2, { { 34, 47} } }
  { "R_CUDA_ABS16_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 16} } }
  { "R_CUDA_ABS24_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 24} } }
  { "R_CUDA_FUNC_DESC32_32", 0xffffffffffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_32", 0x00000000ffffffff, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_32", 0xffffffff00000000, False, False, 0,0, { { 32, 32} } }
  { "R_CUDA_CONST_FIELD19_40", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 40, 19} } }
  { "R_CUDA_BINDLESSOFF14_40", 0xffffffffffffffff, False, False, 0,2, { { 40, 14} } }
  { "R_CUDA_CONST_FIELD21_38", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 38, 21} } }
  { "R_CUDA_INSTRUCTION128", 17, 0, 128 }
  { "R_CUDA_YIELD_OPCODE9_0", 18, 0, 9 }
  { "R_CUDA_YIELD_CLEAR_PRED4_87", 19, 87, 4 }
  { "R_CUDA_32_LO", 0x00000000ffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_32_HI", 0xffffffff00000000, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_UNUSED_CLEAR32", "R_CUDA_UNUSED_CLEAR32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_UNUSED_CLEAR64", "R_CUDA_UNUSED_CLEAR64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS24_40", 0xffffffffffffffff, False, False, 0,0, { { 40, 24} } }
      ;


   OPTIONS NOCHECK_OPCLASS_AMBIGUITY,
                           CASE_INSENSITIVE_SYNTAX,
                           VLIW_BRACE_NOTATION;

   EMPTY_INSTRUCTION = "NOP;";

PARAMETERS
    MAX_REG_COUNT = 63

CONSTANTS
    ITYPE_OTHER = 0
    ITYPE_ABC_REG = 1
    ITYPE_ABC_BCST = 2
    ITYPE_ABC_CCST = 3
    ITYPE_ABC_B20I = 4

    BRT_CALL = 1
    BRT_RETURN = 2
    BRT_BRANCH = 3
    BRT_BRANCHOUT = 4

    MEMORY_LOAD = 1


REGISTERS

    UnaryInv noINV, INV;
    UnaryNeg noNEG, NEG;
    UnaryAbs noABS, ABS;

    Predicate P(0..7), PT=7;

    NonZeroRegister R0(0 .. 9), R(0..62)=(0..62);
    ZeroRegister R63=63, RZ=63;

    Register = NonZeroRegister + ZeroRegister;




    SpecialRegister SR(0..255)=(0..255),
                      SR_LANEID = 0,
                      SR_CLOCK,
                      SR_VIRTCFG,
                      SR_VIRTID,
                      SR_PM(0..7),

                      SR_PRIM_TYPE=16,
                      SR_INVOCATION_ID,
                      SR_Y_DIRECTION,
                      SR_THREAD_KILL,
                      SM_SHADER_TYPE,

                      SR_MACHINE_ID_(0..3)=(24..27),
                      SR_AFFINITY,

                      SR_TID=32, "SR_TID.X", "SR_TID.Y", "SR_TID.Z",
                      SR_CTAPARAM, SR_CTA_PARAM=36,
                      "SR_CTAID.X", "SR_CTAID.Y", "SR_CTAID.Z",
                      SR_NTID,

                      SR_SWINLO=48, SR_SWINSZ,
                      SR_SMEMSZ, SR_SMEMBANKS,
                      SR_LWINLO, SR_LWINSZ,
                      SR_LMEMLOSZ, SR_LMEMHIOFF,
                      SR_EQMASK, SR_LTMASK, SR_LEMASK, SR_GTMASK, SR_GEMASK,
                      SR_REGALLOC, SR_CTXADDR,

                      SR_GLOBALERRORSTATUS=64,

                      SR_WARPERRORSTATUS=66, SR_WARPERRORSTATUSCLEAR,

                      SR_CLOCKLO=80, SR_CLOCKHI,
                      SR_GLOBALTIMERLO, SR_GLOBALTIMERHI;







    Round1 RN, RM, RP, RZ;
    F2FRound1 RN=1, PASS, RM, PASS, RP, PASS, RZ, PASS=0, ROUND, FLOOR=3, CEIL=5, TRUNC=7;
    F2FRound2 PASS, ROUND=0, FLOOR, CEIL, TRUNC, RN=0, RM, RP, RZ;
    Round3 ROUND, FLOOR, CEIL, TRUNC;
    VOP MRG_16H, MRG_16L, MRG_8B0, MRG_8B2, ACC, MIN, MAX, PASS;
    IPAOp PASS, MUL, CONSTANT, SC;
    VRed SIMD_MRG, SIMD_MIN, SIMD_MAX, REDOP3, INVALIDRED3=3, ACC, MIN, MAX, REDOP7, INVALIDRED7=7;
    AtomOp ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR,EXCH;
    CAS CAS=9;
    RedOp INVALIDREDOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR;
    SUOp INVALIDSUREDOP(0..15),ADD=0,MIN,MAX,INC,DEC,AND,OR,XOR;
    VMadScale PASS,SHR_7,SHR_15,INVALIDVMADSCALE3;
    INC NOINC,INC;
    IPAOpN MUL, SC;
    Bop AND, OR, XOR, INVALIDBOP03,INVALIDBOP13=3,INVALIDBOP3=3;
    LOP AND, OR, XOR, PASS_B;
    Red POPC,AND,OR,INVALIDBARMODE3;

    CC CC=1;
    optCC noCC, CC;

    Float INVALIDFPDEST0, INVALIDFPSRC0=0, F16, F32, F64;
    Float16 F16=1;
    Float32 INVALIDFPDEST0, INVALIDFPSRC0=0, F32=2;
    Float64 F64=3;
    F32 F32;
    F2Ffmts1 "INVALIDFPDEST0.INVALIDFPSRC0"=0, "F32.F32"=10;
    F2Ffmts1_16 "F16.F16"=5;
    F2Ffmts1_64 "F64.F64"=15;
    F2Ffmts2 "F16.INVALIDFPSRC0"=1, "F32.INVALIDFPSRC0"=2, "F64.INVALIDFPSRC0"=3,
                      "INVALIDFPDEST0.F32"=8, "F16.F32"=9, "F64.F32"=11;
    F2Ffmts2_16 "INVALIDFPDEST0.F16"=4, "F32.F16"=6, "F64.F16"=7;
    F2Ffmts2_64 "INVALIDFPDEST0.F64"=12, "F16.F64"=13, "F32.F64"=14;

    Integer8 U8 = 0, S8 = 1;
    Integer16 U16 = 2, S16 = 3;
    Integer32 U32 = 4, S32 = 5;
    Integer64 U64 = 6, S64 = 7;
    Integer128 U128= 8, S128= 9;

    IntegerSPA U32, S32, U24, S24, U16H0, S16H0, U16H1, S16H1;
    IntegerSPB U16H0, S16H0, U24, S24;
    IntegerSPC U32, S32, U24, S24, U16H0, S16H0;
    IMADSP_SD SD=3;

    VInteger32 U32 = 4, S32 = 5, INVALIDASEL7, INVALIDASEL7,
                      INVALIDBSEL7=6, INVALIDBSEL7, INVALIDSEL7=6, INVALIDSEL7;

    Integer = Integer8 + Integer16 + Integer32 + Integer64;
    LInteger = Integer8 + Integer16 + Integer32 + Integer64 + Integer128;
    Integer1632 = Integer16 + Integer32;
    IntegerNo16 = Integer8 + Integer32 + Integer64;




    LDInteger "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", "U.128";
    CInteger SD=0, "8"=0, "16"=2, U8=0, S8, U16, S16, "32", "64", "128", INVALIDSIZE7;
    Ofmt U32=0, S32=1, U8=2, S8=3;

    AInteger "32", "64", "96", "128";
    QInteger "32", "64";
    BQInteger "64", "128";
    SQInteger "8"=0, "16"=2, "32"=4, "64"=5, "128"=6, F32=11, U8=0, S8, U16, S16, U32, U64, U128, S32,
                      S64, S128, F16, "F32.FTZ.RN", F64, INVALIDATOMICSIZE(13..15);
    DFormat UD,SD;

    Pipe HW, FMA64, FMA32, XLU, ALU, AGU, SU, FU, FMUL,
              INVALIDPIPE49, INVALID0PIPE4A, INVALID0PIPE4B, INVALID0PIPE4C, INVALID0PIPE4D, INVALID0PIPE4E,
              INVALID0PIPE4F, INVALID9=9, INVALID0A, INVALID0B, INVALID0C, INVALID0D, INVALID0E, INVALID0F;
    Pipe2 HW, XLU, ALU, INVALIDPIPEA3, INVALID=3;
    Pipe2FMALite HW, FMA, MUL, INVALIDPIPE3, FMA2=2, INVALID;

    Test FALSE=0, ZFF=5, ZF0=5, LEG=7, U=8, ZFT=10, ZF1=10, TRUE=15, NOT_OVERFLOW=16, "0FF"=16,
              CFF=17, CARRY=17, ABOVE=18, SF0=18, SIGN=19, SF1=21, CFT=22, CF1=22, OF1=23, OVERFLOW=23,
              NOT_SIGN=28, BELOW_OR_EQUAL=29, NOT_CARRY=30, "1E"=30, "1F"=31,
              F=0, LT, EQ, LE, GT, NE, GE, NUM, NAN, LTU, EQU, LEU, GTU,
              NEU, GEU, T, OFF, LO, SFF, LS, HI, SFT, HS, OFT, CSM_TA,
              CSM_TR, CSM_MX, FCSM_TA, FCSM_TR, FCSM_MX, RLE, RGT;

    Scale NONE, D2, D4, D8, M8, M4, M2, INVALIDSCALE37;

    ICmpAll F, LT, EQ, LE, GT, NE, GE, T;
    ICmpU LO=1, LS=3, HI=4, HS=6;

    IDEAction EN,DI;

    TPhase noPhase,T,P,INVALIDPHASE3;
    ITypeI I;
    ITypeF F;
    BVal BM, BF;

    PR PR;
    H1H0 H0,H1;
    B1B0 H0, H1=2, B(0..3)=(0..3);
    I2XH B(0..3), H0=1, H0=0, H1=3, H1=2;
    HILO LO,HI;
    RelOpt REL;

    X noX, X;
    XMode noX, XLO, XMED, XHI;
    XXHI noX, INVALIDSHRXMODE1, X, XHI;

    C C, c=0;
    V V, v=0;
    A A, a=0;
    CWMode C,W;
    B noB, B;
    P noP, P;
    Phys PHYS;
    E noE, E;
    U noU, U;
    S noS, S;
    DC noDC, DC;
    MS noMS, MS;
    CL noCL, CL;
    PO noPO, ILLEGAL1, ILLEGAL2, PO;
    SH noSH, SH;
    NDV noNDV, NDV;
    LMT noLMT, LMT;
    FTZ noFTZ, FTZ;
    SAT noSAT, SAT;
    AVRG noAVRG, AVRG;
    TOFF1 noTOFF, AOFFI;
    TOFF2 noTOFF, AOFFI, INVALIDBTOFF02, PTP=2, INVALIDBTOFF03;
    BREV noBREV, BREV;
    NODEP noNODEP, NODEP;

    BOnly B=1;
    POnly P;

    SD U8, U32, S32, F32, SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    SD3 "8", S8, "16", U16=2, S16, "32", "64", "128", INVALIDSIZE7,
              U8=0, U32, S32, F32, SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    SD3B SD=0, INVALIDRF1, INVALIDRF2, INVALIDRF3;
    FMZ noFTZ, FTZ, FMZ, INVALIDFMZ3;
    LOD noLOD, LZ, LB, LL, INVALIDBLOD(4..5), LBA, LLA;
    LOD1 LZ,LL;
    LODLEN LOD,LEN;

    PMode IDX, F4E, B4E, RC8, ECL, ECR, RC16, INVALIDPMODE7;
    VoteOp ALL,ANY,EQ,INVALIDVMODE3,INVALIDVMODE4;
    VTGMode "VTG.R"=5, "VTG.A", "VTG.RA";

    BPTMode DRAIN,CAL,PAUSE,TRAP,INT;
    BPTModeN DRAIN,CAL,PAUSE;
    BPTModeN2 TRAP=3;

    KeepRefCount noKEEPREFCOUNT, KEEPREFCOUNT;

    ChkMode DIVIDE, INVALIDCHKMODE(1..63);

    CMode SP, DP0Z, DP1XY, INVALIDFCCO3, DP1Z=3;
    AdMode IA, IL, IS, ISL;
    MN MN,MX;

    Shflmd IDX=0, UP, DOWN, BFLY;

    Barmd BAR, RESULT, WARP, INVALID;
    BarmdBAR BAR = 0, INVALID=3;
    BarmdRESULT RESULT = 1;
    BarmdWARP WARP = 2;

    OutType INVALIDOUTSTYPE0, EMIT, CUT, EMIT_THEN_CUT;

    PixMode MSCOUNT,COVMASK,COVERED,OFFSET,CENTROID_OFFSET,MY_INDEX,INVALIDPIXMODE(6..7),INVALID(0..1)=(6..7);
    MSI C=0,INVALIDMSI3=3,CENTER=0,CENTROID,OFFSET,INVALID;


    MufuOp COS, SIN, EX2, LG2, RCP, RSQ, RCP64H, RSQ64H,
                   INVALIDMUFUOPCODE(8..9), INVALIDMUFUOPCODEA, INVALIDMUFUOPCODEB, INVALIDMUFUOPCODEC,
                   INVALIDMUFUOPCODED, INVALIDMUFUOPCODEE, INVALIDMUFUOPCODEF;
    BarSyncArv SYNC, ARV;
    BarSync SYNC = 0;
    BarArv ARV = 1;
    BarRED RED = 2;
    BarSCAN SCAN = 3;
    BarSYNCALL SYNCALL = 4;


    Arv SYNC,ARV;
    RTTOp POPCRS, TERMINATE, ILLEGALRTTOP2, ILLEGALRTTOP3;
    RROOp SINCOS, EX2;
    AIO I, O;
    Trig noTRIG, TRIG;
    STPMode noWAIT, WAIT;

    OnlyNoDep NODEP;
    OnlyT T;

    LoadCacheOp0 CA, CG;
    LoadCacheOp LU=2, CA=0, CG, CS, CV;
    LLoadCacheOp CS=2, CA=0, CG, LU, CV;
    StoreCacheOp WB, CG, CS, WT;
    CCTLOp PF1=1, PF1.5, PF2, WB, IV, IVALL, RS, WBALL, RSLB, INVALIDCCTLOP(10..31);
    OnlyQry QRY1;
    OnlyIvall IVALL=6;
    CCTLLOp2 IVALL=6, WBALL=8;
    SuqOp RANK,PIXFMT,SMPLSZ,DIM,RGBA,BLKSZ,INVALIDSUQOP(6..31);
    RGBA_NONE INVALIDRGBAMASK0, noRGBA=0;
    RGBA INVALIDRGBAMASK(1..15)=(1..15),
                   R=1, G, RG, B, RB, GB, RGB, A, RA, GA, RGA, BA, RBA, GBA, RGBA;
    Dim "1D", "2D", INVALIDSURFACEDIM2, "3D"=2, "E2D";

    BDim "1D", "MD";
    ThreeD "2D", "3D";
    Smode "SD.R1" = 0,
                   "SD.R2" = 1,
                   "SD.R4" = 2,
                   "SD.R8" = 3,
                   "SD.R16" = 4,
                   "PL.R1" = 5,
                   "PL.R2" = 6,
                   "PL.R4" = 7,
                   "PL.R8" = 8,
                   "PL.R16" = 9,
                   "BL.R1" = 10,
                   "BL.R2" = 11,
                   "BL.R4" = 12,
                   "BL.R8" = 13,
                   "BL.R16" = 14,
                   "INVALIDSMODE15" = 15;

    Clamp0 Z,NEAR,TRAP,INVALIDSURFACECLAMP3;
    Clamp1 IGN,NEAR,TRAP,INVALIDSURFACECLAMP3;


    Clamp2 Z,TRAP,INVALIDSURFACECLAMP3, SDCL;
    Clamp3 IGN,TRAP,INVALIDSURFACECLAMP3, SDCL;


    TexComp R,G,B,A;

    TXQMode TEX_HEADER_DIMENSION, TEX_HEADER_TEXTURE_TYPE, TEX_HEADER_SAMPLER_POS, "3", "4", "5", "6", "7",
                   TEX_SAMPLER_FILTER, TEX_SAMPLER_LOD, TEX_SAMPLER_WRAP, TEX_SAMPLER_BORDER_COLOR, "12", "13",
                   "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29",
                   "30", "31";

    ParamA "_1D" = 0b00_0,
                   "1D" = 0b00_0,
                   RECT = 0b01_0,
                   "_2D" = 0b01_0,
                   "2D" = 0b01_0,
                   "_3D" = 0b10_0,
                   "3D" = 0b10_0,
                   CUBE = 0b11_0,
                   ARRAY_1D = 0b00_1,
                   ARRAY_RECT = 0b01_1,
                   ARRAY_2D = 0b01_1,
                   ARRAY_3D = 0b10_1,
                   CUBEARRAY = 0b11_1,
                   ARRAY_CUBE = 0b11_1;

    MemBarLevel CTA,GL,SYS,INVALIDMEMBAR3;

    Cache D,U,C,I;
    LCache D,CRS;




    LaneMask2
        X = 0b01,
        Y = 0b10,
        XY = 0b11;

    LaneMask4
        X = 0b0100,
        Y = 0b1000,
        Z = 0b0001,
        W = 0b0010,
        XW = 0b0110,
        YW = 0b1010,
        ZW = 0b0011,
        XZ = 0b0101,
        YZ = 0b1001,
        XY = 0b1100,
        YZW = 0b1011,
        XZW = 0b0111,
        XYW = 0b1110,
        XYZ = 0b1101,
        XYZW = 0b1111
        ;

   SWZMode
        "0000","1111","2222","3333","1032","2301",INVALIDSWIZZLEMODE(6..7);

   ASel4
        "0000","1111","2222","3333","3210","4321","5432","6543","3201","3012","0213","3120","1230","2310",
        ASEL4E, ASEL4F, INVALIDASEL4E=14, INVALIDASEL4F;

   BSel4
        "4444","5555","6666","7777","7654","6543","5432","4321","4567","6745","5476",BSEL4B,BSEL4C,BSEL4D,
        BSEL4E, BSEL4F, INVALIDBSEL4B=11, INVALIDBSEL4C, INVALIDBSEL4D, INVALIDBSEL4E, INVALIDBSEL4F;

   Sel2
        "00","01","02","03",
        "10","11","12","13",
        "20","21","22","23",
        "30","31","32","33";


   Sel2hi
        "00","01",
        "10","11";


    PNWord
        PPPPPPPP,PPPPPPNP,PPPPPPPN,PPPPPPZP,PPPPNPPP,PPPPNPNP,PPPPNPPN,PPPPNPZP,
        PPPPPNPP,PPPPPNNP,PPPPPNPN,PPPPPNZP,PPPPZPPP,PPPPZPNP,PPPPZPPN,PPPPZPZP,
        PPNPPPPP,PPNPPPNP,PPNPPPPN,PPNPPPZP,PPNPNPPP,PPNPNPNP,PPNPNPPN,PPNPNPZP,
        PPNPPNPP,PPNPPNNP,PPNPPNPN,PPNPPNZP,PPNPZPPP,PPNPZPNP,PPNPZPPN,PPNPZPZP,
        PPPNPPPP,PPPNPPNP,PPPNPPPN,PPPNPPZP,PPPNNPPP,PPPNNPNP,PPPNNPPN,PPPNNPZP,
        PPPNPNPP,PPPNPNNP,PPPNPNPN,PPPNPNZP,PPPNZPPP,PPPNZPNP,PPPNZPPN,PPPNZPZP,
        PPZPPPPP,PPZPPPNP,PPZPPPPN,PPZPPPZP,PPZPNPPP,PPZPNPNP,PPZPNPPN,PPZPNPZP,
        PPZPPNPP,PPZPPNNP,PPZPPNPN,PPZPPNZP,PPZPZPPP,PPZPZPNP,PPZPZPPN,PPZPZPZP,
        NPPPPPPP,NPPPPPNP,NPPPPPPN,NPPPPPZP,NPPPNPPP,NPPPNPNP,NPPPNPPN,NPPPNPZP,
        NPPPPNPP,NPPPPNNP,NPPPPNPN,NPPPPNZP,NPPPZPPP,NPPPZPNP,NPPPZPPN,NPPPZPZP,
        NPNPPPPP,NPNPPPNP,NPNPPPPN,NPNPPPZP,NPNPNPPP,NPNPNPNP,NPNPNPPN,NPNPNPZP,
        NPNPPNPP,NPNPPNNP,NPNPPNPN,NPNPPNZP,NPNPZPPP,NPNPZPNP,NPNPZPPN,NPNPZPZP,
        NPPNPPPP,NPPNPPNP,NPPNPPPN,NPPNPPZP,NPPNNPPP,NPPNNPNP,NPPNNPPN,NPPNNPZP,
        NPPNPNPP,NPPNPNNP,NPPNPNPN,NPPNPNZP,NPPNZPPP,NPPNZPNP,NPPNZPPN,NPPNZPZP,
        NPZPPPPP,NPZPPPNP,NPZPPPPN,NPZPPPZP,NPZPNPPP,NPZPNPNP,NPZPNPPN,NPZPNPZP,
        NPZPPNPP,NPZPPNNP,NPZPPNPN,NPZPPNZP,NPZPZPPP,NPZPZPNP,NPZPZPPN,NPZPZPZP,
        PNPPPPPP,PNPPPPNP,PNPPPPPN,PNPPPPZP,PNPPNPPP,PNPPNPNP,PNPPNPPN,PNPPNPZP,
        PNPPPNPP,PNPPPNNP,PNPPPNPN,PNPPPNZP,PNPPZPPP,PNPPZPNP,PNPPZPPN,PNPPZPZP,
        PNNPPPPP,PNNPPPNP,PNNPPPPN,PNNPPPZP,PNNPNPPP,PNNPNPNP,PNNPNPPN,PNNPNPZP,
        PNNPPNPP,PNNPPNNP,PNNPPNPN,PNNPPNZP,PNNPZPPP,PNNPZPNP,PNNPZPPN,PNNPZPZP,
        PNPNPPPP,PNPNPPNP,PNPNPPPN,PNPNPPZP,PNPNNPPP,PNPNNPNP,PNPNNPPN,PNPNNPZP,
        PNPNPNPP,PNPNPNNP,PNPNPNPN,PNPNPNZP,PNPNZPPP,PNPNZPNP,PNPNZPPN,PNPNZPZP,
        PNZPPPPP,PNZPPPNP,PNZPPPPN,PNZPPPZP,PNZPNPPP,PNZPNPNP,PNZPNPPN,PNZPNPZP,
        PNZPPNPP,PNZPPNNP,PNZPPNPN,PNZPPNZP,PNZPZPPP,PNZPZPNP,PNZPZPPN,PNZPZPZP,
        ZPPPPPPP,ZPPPPPNP,ZPPPPPPN,ZPPPPPZP,ZPPPNPPP,ZPPPNPNP,ZPPPNPPN,ZPPPNPZP,
        ZPPPPNPP,ZPPPPNNP,ZPPPPNPN,ZPPPPNZP,ZPPPZPPP,ZPPPZPNP,ZPPPZPPN,ZPPPZPZP,
        ZPNPPPPP,ZPNPPPNP,ZPNPPPPN,ZPNPPPZP,ZPNPNPPP,ZPNPNPNP,ZPNPNPPN,ZPNPNPZP,
        ZPNPPNPP,ZPNPPNNP,ZPNPPNPN,ZPNPPNZP,ZPNPZPPP,ZPNPZPNP,ZPNPZPPN,ZPNPZPZP,
        ZPPNPPPP,ZPPNPPNP,ZPPNPPPN,ZPPNPPZP,ZPPNNPPP,ZPPNNPNP,ZPPNNPPN,ZPPNNPZP,
        ZPPNPNPP,ZPPNPNNP,ZPPNPNPN,ZPPNPNZP,ZPPNZPPP,ZPPNZPNP,ZPPNZPPN,ZPPNZPZP,
        ZPZPPPPP,ZPZPPPNP,ZPZPPPPN,ZPZPPPZP,ZPZPNPPP,ZPZPNPNP,ZPZPNPPN,ZPZPNPZP,
        ZPZPPNPP,ZPZPPNNP,ZPZPPNPN,ZPZPPNZP,ZPZPZPPP,ZPZPZPNP,ZPZPZPPN,ZPZPZPZP;
TABLES

   IntSize
          Integer@U8 -> 0b00_0
          Integer@S8 -> 0b00_1
          Integer@U16 -> 0b01_0
          Integer@S16 -> 0b01_1
          Integer@U32 -> 0b10_0
          Integer@S32 -> 0b10_1
          Integer@U64 -> 0b11_0
          Integer@S64 -> 0b11_1
          ;

   IsSigned
          Integer32@U32 -> 0
          Integer32@S32 -> 1
          ;

   IsSPASigned
          IntegerSPA@U32 -> 0
          IntegerSPA@U24 -> 0
          IntegerSPA@U16H0 -> 0
          IntegerSPA@U16H1 -> 0
          IntegerSPA@S32 -> 1
          IntegerSPA@S24 -> 1
          IntegerSPA@S16H0 -> 1
          IntegerSPA@S16H1 -> 1
          ;

   IsSPBSigned
          IntegerSPB@U24 -> 0
          IntegerSPB@U16H0 -> 0
          IntegerSPB@S24 -> 1
          IntegerSPB@S16H0 -> 1
          ;

   IsSPCSigned
          IntegerSPC@U32 -> 0
          IntegerSPC@U24 -> 0
          IntegerSPC@U16H0 -> 0
          IntegerSPC@S32 -> 1
          IntegerSPC@S24 -> 1
          IntegerSPC@S16H0 -> 1
          ;

   GetSPExtract
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_000_00
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b00_000_10
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_010_00
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b00_010_10
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_100_00
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b00_100_10
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_110_00
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b00_110_10

          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@U24 -> 0b01_000_00
          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b01_000_10
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@U24 -> 0b01_010_00
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b01_010_10
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b01_100_00
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b01_100_10
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b01_110_00
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b01_110_10

          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@U24 -> 0b10_000_00
          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_000_10
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@U24 -> 0b10_010_00
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_010_10
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b10_100_00
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_100_10
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b10_110_00
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_110_10

          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@S24 -> 0b00_000_01
          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b00_000_11
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@S24 -> 0b00_010_01
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b00_010_11
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b00_100_01
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b00_100_11
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b00_110_01
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b00_110_11

          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_001_00
          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b00_001_10
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_011_00
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b00_011_10
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_101_00
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b00_101_10
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_111_00
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b00_111_10

          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@S24 -> 0b00_001_01
          IntegerSPC@S32 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b00_001_11
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@S24 -> 0b00_011_01
          IntegerSPC@S32 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b00_011_11
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b00_101_01
          IntegerSPC@S32 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b00_101_11
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b00_111_01
          IntegerSPC@S32 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b00_111_11

          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_000_01
          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b01_000_11
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_010_01
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b01_010_11
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_100_01
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b01_100_11
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_110_01
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b01_110_11

          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@U24 -> 0b01_001_00
          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b01_001_10
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@U24 -> 0b01_011_00
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b01_011_10
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b01_101_00
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b01_101_10
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b01_111_00
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b01_111_10

          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_001_01
          IntegerSPC@S24 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b01_001_11
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_011_01
          IntegerSPC@S24 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b01_011_11
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_101_01
          IntegerSPC@S24 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b01_101_11
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_111_01
          IntegerSPC@S24 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b01_111_11

          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@S24 -> 0b10_000_01
          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b10_000_11
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@S24 -> 0b10_010_01
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b10_010_11
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b10_100_01
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b10_100_11
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b10_110_01
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b10_110_11

          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@U24 -> 0b10_001_00
          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_001_10
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@U24 -> 0b10_011_00
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_011_10
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b10_101_00
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_101_10
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b10_111_00
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_111_10

          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@S24 -> 0b10_001_01
          IntegerSPC@S16H0 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b10_001_11
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@S24 -> 0b10_011_01
          IntegerSPC@S16H0 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b10_011_11
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b10_101_01
          IntegerSPC@S16H0 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b10_101_11
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b10_111_01
          IntegerSPC@S16H0 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b10_111_11


          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@S24 -> 0b00_000_01
          IntegerSPC@U32 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b00_000_11
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@S24 -> 0b00_010_01
          IntegerSPC@U32 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b00_010_11
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b00_100_01
          IntegerSPC@U32 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b00_100_11
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b00_110_01
          IntegerSPC@U32 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b00_110_11

          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@U24 -> 0b00_001_00
          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b00_001_10
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@U24 -> 0b00_011_00
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b00_011_10
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b00_101_00
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b00_101_10
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b00_111_00
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b00_111_10

          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@S24 -> 0b00_001_01
          IntegerSPC@U32 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b00_001_11
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@S24 -> 0b00_011_01
          IntegerSPC@U32 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b00_011_11
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b00_101_01
          IntegerSPC@U32 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b00_101_11
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b00_111_01
          IntegerSPC@U32 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b00_111_11

          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@S24 -> 0b01_000_01
          IntegerSPC@U24 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b01_000_11
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@S24 -> 0b01_010_01
          IntegerSPC@U24 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b01_010_11
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b01_100_01
          IntegerSPC@U24 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b01_100_11
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b01_110_01
          IntegerSPC@U24 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b01_110_11

          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@U24 -> 0b01_001_00
          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b01_001_10
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@U24 -> 0b01_011_00
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b01_011_10
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b01_101_00
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b01_101_10
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b01_111_00
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b01_111_10

          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@S24 -> 0b01_001_01
          IntegerSPC@U24 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b01_001_11
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@S24 -> 0b01_011_01
          IntegerSPC@U24 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b01_011_11
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b01_101_01
          IntegerSPC@U24 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b01_101_11
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b01_111_01
          IntegerSPC@U24 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b01_111_11

          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@S24 -> 0b10_000_01
          IntegerSPC@U16H0 IntegerSPA@U32 IntegerSPB@S16H0 -> 0b10_000_11
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@S24 -> 0b10_010_01
          IntegerSPC@U16H0 IntegerSPA@U24 IntegerSPB@S16H0 -> 0b10_010_11
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@S24 -> 0b10_100_01
          IntegerSPC@U16H0 IntegerSPA@U16H0 IntegerSPB@S16H0 -> 0b10_100_11
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@S24 -> 0b10_110_01
          IntegerSPC@U16H0 IntegerSPA@U16H1 IntegerSPB@S16H0 -> 0b10_110_11

          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@U24 -> 0b10_001_00
          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@U16H0 -> 0b10_001_10
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@U24 -> 0b10_011_00
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@U16H0 -> 0b10_011_10
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@U24 -> 0b10_101_00
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@U16H0 -> 0b10_101_10
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@U24 -> 0b10_111_00
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@U16H0 -> 0b10_111_10

          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@S24 -> 0b10_001_01
          IntegerSPC@U16H0 IntegerSPA@S32 IntegerSPB@S16H0 -> 0b10_001_11
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@S24 -> 0b10_011_01
          IntegerSPC@U16H0 IntegerSPA@S24 IntegerSPB@S16H0 -> 0b10_011_11
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@S24 -> 0b10_101_01
          IntegerSPC@U16H0 IntegerSPA@S16H0 IntegerSPB@S16H0 -> 0b10_101_11
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@S24 -> 0b10_111_01
          IntegerSPC@U16H0 IntegerSPA@S16H1 IntegerSPB@S16H0 -> 0b10_111_11

          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@U24 -> 0b00_000_00
          IntegerSPC@S32 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b00_000_10
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@U24 -> 0b00_010_00
          IntegerSPC@S32 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b00_010_10
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b00_100_00
          IntegerSPC@S32 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b00_100_10
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b00_110_00
          IntegerSPC@S32 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b00_110_10

          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@U24 -> 0b01_000_00
          IntegerSPC@S24 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b01_000_10
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@U24 -> 0b01_010_00
          IntegerSPC@S24 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b01_010_10
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b01_100_00
          IntegerSPC@S24 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b01_100_10
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b01_110_00
          IntegerSPC@S24 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b01_110_10

          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@U24 -> 0b10_000_00
          IntegerSPC@S16H0 IntegerSPA@U32 IntegerSPB@U16H0 -> 0b10_000_10
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@U24 -> 0b10_010_00
          IntegerSPC@S16H0 IntegerSPA@U24 IntegerSPB@U16H0 -> 0b10_010_10
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@U24 -> 0b10_100_00
          IntegerSPC@S16H0 IntegerSPA@U16H0 IntegerSPB@U16H0 -> 0b10_100_10
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@U24 -> 0b10_110_00
          IntegerSPC@S16H0 IntegerSPA@U16H1 IntegerSPB@U16H0 -> 0b10_110_10
        ;

   IsSameSigned
          Integer32@U32 Integer32@U32 -> 0
          Integer32@S32 Integer32@S32 -> 1
          Integer32@S32 Integer32@U32 -> 0
          Integer32@U32 Integer32@S32 -> 0
          ;

   I2I_N_Sizes
          Integer1632@U16 Integer1632@U16 -> 0b0000
          Integer1632@S16 Integer1632@U16 -> 0b0010
          Integer1632@U32 Integer1632@U16 -> 0b0100
          Integer1632@S32 Integer1632@U16 -> 0b0110

          Integer1632@U16 Integer1632@S16 -> 0b0001
          Integer1632@S16 Integer1632@S16 -> 0b0011
          Integer1632@U32 Integer1632@S16 -> 0b0101
          Integer1632@S32 Integer1632@S16 -> 0b0111

          Integer1632@U16 Integer1632@U32 -> 0b1000
          Integer1632@S16 Integer1632@U32 -> 0b1010
          Integer1632@U32 Integer1632@U32 -> 0b1100
          Integer1632@S32 Integer1632@U32 -> 0b1110

          Integer1632@U16 Integer1632@S32 -> 0b1001
          Integer1632@S16 Integer1632@S32 -> 0b1011
          Integer1632@U32 Integer1632@S32 -> 0b1101
          Integer1632@S32 Integer1632@S32 -> 0b1111
          ;

Integer8Signed
          Integer8@U8 -> 0
          Integer8@S8 -> 1
          ;

Integer16Signed
          Integer16@U16 -> 0
          Integer16@S16 -> 1
          ;

IntegerSigned
          Integer@U16 -> 0
          Integer@S16 -> 1
          Integer@U8 -> 0
          Integer@S8 -> 1
          Integer@U32 -> 0
          Integer@S32 -> 1
          Integer@U64 -> 0
          Integer@S64 -> 1
          ;

Integer8x8Signed
          Integer8@U8 Integer8@U8 -> 0
          Integer8@S8 Integer8@S8 -> 1
          Integer8@S8 Integer8@U8 -> 0
          Integer8@U8 Integer8@S8 -> 0
          ;

Integer16x16Signed
          Integer16@U16 Integer16@U16 -> 0
          Integer16@S16 Integer16@S16 -> 1
          Integer16@S16 Integer16@U16 -> 0
          Integer16@U16 Integer16@S16 -> 0
          ;

    PSign
       PO@noPO 0 0 -> 0b00
       PO@noPO 0 1 -> 0b01
       PO@noPO 1 0 -> 0b10
       PO@noPO 1 1 -> 0b00
         PO@PO 0 0 -> 0b11
         PO@PO 0 1 -> 0b11
         PO@PO 1 0 -> 0b11
         PO@PO 1 1 -> 0b11
   PO@ILLEGAL1 0 0 -> 0b01
   PO@ILLEGAL1 0 1 -> 0b01
   PO@ILLEGAL1 1 0 -> 0b01
   PO@ILLEGAL1 1 1 -> 0b01
   PO@ILLEGAL2 0 0 -> 0b10
   PO@ILLEGAL2 0 1 -> 0b10
   PO@ILLEGAL2 1 0 -> 0b10
   PO@ILLEGAL2 1 1 -> 0b10
          ;

    VMode
        AVRG@noAVRG 0 0 -> 0
        AVRG@noAVRG 0 1 -> 1
        AVRG@noAVRG 1 0 -> 2
        AVRG@noAVRG 1 1 -> 0
          AVRG@AVRG 0 0 -> 3
          AVRG@AVRG 0 1 -> 3
          AVRG@AVRG 1 0 -> 3
          AVRG@AVRG 1 1 -> 3
          ;

    PSign32
        PO@noPO 0 -> 0b00
        PO@noPO 1 -> 0b10
          PO@PO 0 -> 0b11
          PO@PO 1 -> 0b00
    PO@ILLEGAL1 0 -> 0b01
    PO@ILLEGAL1 1 -> 0b01
    PO@ILLEGAL2 0 -> 0b10
    PO@ILLEGAL2 1 -> 0b10
          ;

    PSignFFMA
          0 0 -> 0
          1 0 -> 1
          0 1 -> 1
          1 1 -> 0
          ;

    PSignMAD
       PO@noPO 0 0 0 -> 0b00
       PO@noPO 1 1 0 -> 0b00
       PO@noPO 0 0 1 -> 0b01
       PO@noPO 1 0 0 -> 0b10
       PO@noPO 0 1 0 -> 0b10
       PO@noPO 1 1 1 -> 0b01
       PO@noPO 0 1 1 -> 0b00
       PO@noPO 1 0 1 -> 0b00
         PO@PO 0 0 0 -> 0b11
         PO@PO 0 0 1 -> 0b11
         PO@PO 0 1 0 -> 0b11
         PO@PO 0 1 1 -> 0b11
         PO@PO 1 0 0 -> 0b11
         PO@PO 1 0 1 -> 0b11
         PO@PO 1 1 0 -> 0b11
         PO@PO 1 1 1 -> 0b11
   PO@ILLEGAL1 0 0 0 -> 0b01
   PO@ILLEGAL1 0 0 1 -> 0b01
   PO@ILLEGAL1 0 1 0 -> 0b01
   PO@ILLEGAL1 0 1 1 -> 0b01
   PO@ILLEGAL1 1 0 0 -> 0b01
   PO@ILLEGAL1 1 0 1 -> 0b01
   PO@ILLEGAL1 1 1 0 -> 0b01
   PO@ILLEGAL1 1 1 1 -> 0b01
   PO@ILLEGAL2 0 0 0 -> 0b10
   PO@ILLEGAL2 0 0 1 -> 0b10
   PO@ILLEGAL2 0 1 0 -> 0b10
   PO@ILLEGAL2 0 1 1 -> 0b10
   PO@ILLEGAL2 1 0 0 -> 0b10
   PO@ILLEGAL2 1 0 1 -> 0b10
   PO@ILLEGAL2 1 1 0 -> 0b10
   PO@ILLEGAL2 1 1 1 -> 0b10
          ;

    CombineBP
          1 0 -> 0
          0 1 -> 1
          0 0 -> 0
          1 1 -> 0
          ;

    RCIConstBank
          0 -> 0b010
          1 -> 0b100
         16 -> 0b110
          2 -> 0b010
          3 -> 0b010
          4 -> 0b010
          5 -> 0b010
          6 -> 0b010
          7 -> 0b010
          8 -> 0b010
          9 -> 0b010
         10 -> 0b010
         11 -> 0b010
         12 -> 0b010
         13 -> 0b010
         14 -> 0b010
         15 -> 0b010
         17 -> 0b010
         18 -> 0b010
         19 -> 0b010
         20 -> 0b010
         21 -> 0b010
         22 -> 0b010
         23 -> 0b010
         24 -> 0b010
         25 -> 0b010
         26 -> 0b010
         27 -> 0b010
         28 -> 0b010
         29 -> 0b010
         30 -> 0b010
         31 -> 0b010
          ;

    CNSConstBank
          0 -> 0b01
          1 -> 0b10
         16 -> 0b11
          2 -> 0b01
          3 -> 0b01
          4 -> 0b01
          5 -> 0b01
          6 -> 0b01
          7 -> 0b01
          8 -> 0b01
          9 -> 0b01
         10 -> 0b01
         11 -> 0b01
         12 -> 0b01
         13 -> 0b01
         14 -> 0b01
         15 -> 0b01
         17 -> 0b01
         18 -> 0b01
         19 -> 0b01
         20 -> 0b01
         21 -> 0b01
         22 -> 0b01
         23 -> 0b01
         24 -> 0b01
         25 -> 0b01
         26 -> 0b01
         27 -> 0b01
         28 -> 0b01
         29 -> 0b01
         30 -> 0b01
         31 -> 0b01
          ;

    LDCNConstBank
          0 -> 0b000
          1 -> 0b001
          2 -> 0b010
          3 -> 0b011
          4 -> 0b100
          5 -> 0b101
          6 -> 0b110
         16 -> 0b111
          7 -> 0b000
          8 -> 0b000
          9 -> 0b000
         10 -> 0b000
         11 -> 0b000
         12 -> 0b000
         13 -> 0b000
         14 -> 0b000
         15 -> 0b000
         17 -> 0b000
         18 -> 0b000
         19 -> 0b000
         20 -> 0b000
         21 -> 0b000
         22 -> 0b000
         23 -> 0b000
         24 -> 0b000
         25 -> 0b000
         26 -> 0b000
         27 -> 0b000
         28 -> 0b000
         29 -> 0b000
         30 -> 0b000
         31 -> 0b000
          ;

    CRegAlignment
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 1
          CInteger@S16 -> 1
          CInteger@"32" -> 1
          CInteger@"64" -> 2
          CInteger@"128" -> 4
          CInteger@INVALIDSIZE7 -> 1
          ;

    LDRegAlignment
          LDInteger@U8 -> 1
          LDInteger@S8 -> 1
          LDInteger@U16 -> 1
          LDInteger@S16 -> 1
          LDInteger@"32" -> 1
          LDInteger@"64" -> 2
          LDInteger@"128" -> 4
          LDInteger@"U.128" -> 4
          ;

    BQRegAlignment
          BQInteger@"64" -> 2
          BQInteger@"128" -> 4
          ;

    ARegAlignment
          AInteger@"32" -> 1
          AInteger@"64" -> 2
          AInteger@"96" -> 4
          AInteger@"128" -> 4
          ;

    QRegAlignment
          QInteger@"32" -> 1
          QInteger@"64" -> 2
          ;

    SQRegAlignment
          SQInteger@U8 -> 1
          SQInteger@S8 -> 1
          SQInteger@U16 -> 1
          SQInteger@S16 -> 1
          SQInteger@F16 -> 1
          SQInteger@U32 -> 1
          SQInteger@S32 -> 1
          SQInteger@"F32.FTZ.RN" -> 1
          SQInteger@INVALIDATOMICSIZE13 -> 1
          SQInteger@INVALIDATOMICSIZE14 -> 1
          SQInteger@INVALIDATOMICSIZE15 -> 1
          SQInteger@U64 -> 2
          SQInteger@S64 -> 2
          SQInteger@F64 -> 2
          SQInteger@U128 -> 4
          SQInteger@S128 -> 4
          ;

    CIntSize
          CInteger@U8 -> 1
          CInteger@S8 -> 1
          CInteger@U16 -> 2
          CInteger@S16 -> 2
          CInteger@"32" -> 4
          CInteger@"64" -> 8
          CInteger@"128" -> 16
          ;

    Video4ImmSel
          ASel4@"0000" -> 1
          ASel4@"1111" -> 1
          ASel4@"2222" -> 1
          ASel4@"3333" -> 1
          ASel4@"3210" -> 1
          ASel4@"4321" -> 1
          ASel4@"5432" -> 1
          ASel4@"6543" -> 1
          ASel4@"3201" -> 1
          ASel4@"3012" -> 1
          ASel4@"0213" -> 1
          ASel4@"3120" -> 1
          ASel4@"1230" -> 1
          ASel4@"2310" -> 1
          ASel4@INVALIDASEL4E -> 1
          ASel4@INVALIDASEL4F -> 1
          ;

    TXQModeDim
          TXQMode@TEX_HEADER_DIMENSION -> 0b00000_1
          TXQMode@TEX_HEADER_TEXTURE_TYPE -> 0b00001_0
          TXQMode@TEX_HEADER_SAMPLER_POS -> 0b00010_1
          TXQMode@"3" -> 0b00011_0
          TXQMode@"4" -> 0b00100_0
          TXQMode@"5" -> 0b00101_0
          TXQMode@"6" -> 0b00110_0
          TXQMode@"7" -> 0b00111_0
          TXQMode@TEX_SAMPLER_FILTER -> 0b01000_0
          TXQMode@TEX_SAMPLER_LOD -> 0b01001_0
          TXQMode@TEX_SAMPLER_WRAP -> 0b01010_0
          TXQMode@TEX_SAMPLER_BORDER_COLOR -> 0b01011_0
          TXQMode@"12" -> 0b01100_0
          TXQMode@"13" -> 0b01101_0
          TXQMode@"14" -> 0b01110_0
          TXQMode@"15" -> 0b01111_0
          TXQMode@"16" -> 0b10000_0
          TXQMode@"17" -> 0b10001_0
          TXQMode@"18" -> 0b10010_0
          TXQMode@"19" -> 0b10011_0
          TXQMode@"20" -> 0b10100_0
          TXQMode@"21" -> 0b10101_0
          TXQMode@"22" -> 0b10110_0
          TXQMode@"23" -> 0b10111_0
          TXQMode@"24" -> 0b11000_0
          TXQMode@"25" -> 0b11001_0
          TXQMode@"26" -> 0b11010_0
          TXQMode@"27" -> 0b11011_0
          TXQMode@"28" -> 0b11100_0
          TXQMode@"29" -> 0b11101_0
          TXQMode@"30" -> 0b11110_0
          TXQMode@"31" -> 0b11111_0
          ;

    ldbvCopMerge
          BQInteger@"64" LoadCacheOp0@CA -> 0
          BQInteger@"64" LoadCacheOp0@CG -> 1
          BQInteger@"128" LoadCacheOp0@CA -> 2
          BQInteger@"128" LoadCacheOp0@CG -> 3
          ;

    abSize
          CInteger@U8 CInteger@U8 -> 0
          CInteger@U8 CInteger@S8 -> 1
          CInteger@U8 CInteger@U16 -> 2
          CInteger@U8 CInteger@S16 -> 3
          CInteger@U8 CInteger@"32" -> 4

          CInteger@S8 CInteger@U8 -> 5
          CInteger@S8 CInteger@S8 -> 6
          CInteger@S8 CInteger@U16 -> 7
          CInteger@S8 CInteger@S16 -> 8
          CInteger@S8 CInteger@"32" -> 9

          CInteger@U16 CInteger@U8 -> 10
          CInteger@U16 CInteger@S8 -> 11
          CInteger@U16 CInteger@U16 -> 12
          CInteger@U16 CInteger@S16 -> 13
          CInteger@U16 CInteger@"32" -> 14

          CInteger@S16 CInteger@U8 -> 15
          CInteger@S16 CInteger@S8 -> 16
          CInteger@S16 CInteger@U16 -> 17
          CInteger@S16 CInteger@S16 -> 18
          CInteger@S16 CInteger@"32" -> 19

          CInteger@"32" CInteger@U8 -> 20
          CInteger@"32" CInteger@S8 -> 21
          CInteger@"32" CInteger@U16 -> 22
          CInteger@"32" CInteger@S16 -> 23
          CInteger@"32" CInteger@"32" -> 24
          CInteger@"32" CInteger@"64" -> 25
          CInteger@"32" CInteger@"128" -> 26

          CInteger@"64" CInteger@"32" -> 27
          CInteger@"64" CInteger@"64" -> 28
          CInteger@"64" CInteger@"128" -> 29

          CInteger@"128" CInteger@"32" -> 30
          CInteger@"128" CInteger@"64" -> 31

          CInteger@U8 CInteger@"64" -> 0
          CInteger@U8 CInteger@"128" -> 0
          CInteger@S8 CInteger@"64" -> 0
          CInteger@S8 CInteger@"128" -> 0
          CInteger@U16 CInteger@"64" -> 0
          CInteger@U16 CInteger@"128" -> 0
          CInteger@S16 CInteger@"64" -> 0
          CInteger@S16 CInteger@"128" -> 0
          CInteger@"64" CInteger@U8 -> 0
          CInteger@"64" CInteger@S8 -> 0
          CInteger@"64" CInteger@U16 -> 0
          CInteger@"64" CInteger@S16 -> 0
          CInteger@"128" CInteger@U8 -> 0
          CInteger@"128" CInteger@S8 -> 0
          CInteger@"128" CInteger@U16 -> 0
          CInteger@"128" CInteger@S16 -> 0
          CInteger@"128" CInteger@"128" -> 0
          ;

    VFormat8
          Integer@U8 B1B0@B0 -> 0b000_0
          Integer@U8 B1B0@B1 -> 0b001_0
          Integer@U8 B1B0@B2 -> 0b010_0
          Integer@U8 B1B0@B3 -> 0b011_0
          Integer@S8 B1B0@B0 -> 0b000_1
          Integer@S8 B1B0@B1 -> 0b001_1
          Integer@S8 B1B0@B2 -> 0b010_1
          Integer@S8 B1B0@B3 -> 0b011_1
          ;

    VFormat16
          Integer@U16 H1H0@H0 -> 0b100_0
          Integer@U16 H1H0@H1 -> 0b101_0
          Integer@S16 H1H0@H0 -> 0b100_1
          Integer@S16 H1H0@H1 -> 0b101_1
          ;

    VFormat32
          VInteger32@U32 -> 0b110_0
          VInteger32@S32 -> 0b110_1
          6 -> 0b111_1
          7 -> 0b111_0
          ;






    VFormat8_N
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b0_0_00000
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b0_0_00001
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b0_0_00010
          Integer@U8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b0_0_00011
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b0_0_00100
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b0_0_00101
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b0_0_00110
          Integer@U8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b0_0_00111
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b0_0_01000
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b0_0_01001
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b0_0_01010
          Integer@U8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b0_0_01011
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b0_0_01100
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b0_0_01101
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b0_0_01110
          Integer@U8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b0_0_01111
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b0_1_00000
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b0_1_00001
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b0_1_00010
          Integer@U8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b0_1_00011
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b0_1_00100
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b0_1_00101
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b0_1_00110
          Integer@U8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b0_1_00111
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b0_1_01000
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b0_1_01001
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b0_1_01010
          Integer@U8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b0_1_01011
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b0_1_01100
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b0_1_01101
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b0_1_01110
          Integer@U8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b0_1_01111
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B0 -> 0b1_0_00000
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B1 -> 0b1_0_00001
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B2 -> 0b1_0_00010
          Integer@S8 B1B0@B0 Integer@U8 B1B0@B3 -> 0b1_0_00011
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B0 -> 0b1_0_00100
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B1 -> 0b1_0_00101
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B2 -> 0b1_0_00110
          Integer@S8 B1B0@B1 Integer@U8 B1B0@B3 -> 0b1_0_00111
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B0 -> 0b1_0_01000
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B1 -> 0b1_0_01001
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B2 -> 0b1_0_01010
          Integer@S8 B1B0@B2 Integer@U8 B1B0@B3 -> 0b1_0_01011
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B0 -> 0b1_0_01100
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B1 -> 0b1_0_01101
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B2 -> 0b1_0_01110
          Integer@S8 B1B0@B3 Integer@U8 B1B0@B3 -> 0b1_0_01111
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B0 -> 0b1_1_00000
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B1 -> 0b1_1_00001
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B2 -> 0b1_1_00010
          Integer@S8 B1B0@B0 Integer@S8 B1B0@B3 -> 0b1_1_00011
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B0 -> 0b1_1_00100
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B1 -> 0b1_1_00101
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B2 -> 0b1_1_00110
          Integer@S8 B1B0@B1 Integer@S8 B1B0@B3 -> 0b1_1_00111
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B0 -> 0b1_1_01000
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B1 -> 0b1_1_01001
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B2 -> 0b1_1_01010
          Integer@S8 B1B0@B2 Integer@S8 B1B0@B3 -> 0b1_1_01011
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B0 -> 0b1_1_01100
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B1 -> 0b1_1_01101
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B2 -> 0b1_1_01110
          Integer@S8 B1B0@B3 Integer@S8 B1B0@B3 -> 0b1_1_01111
          ;

    VFormat32_8_N
          Integer@U32 Integer@U8 B1B0@B0 -> 0b0_0_10000
          Integer@U32 Integer@U8 B1B0@B1 -> 0b0_0_10001
          Integer@U32 Integer@U8 B1B0@B2 -> 0b0_0_10010
          Integer@U32 Integer@U8 B1B0@B3 -> 0b0_0_10011
          Integer@U32 Integer@S8 B1B0@B0 -> 0b0_1_10000
          Integer@U32 Integer@S8 B1B0@B1 -> 0b0_1_10001
          Integer@U32 Integer@S8 B1B0@B2 -> 0b0_1_10010
          Integer@U32 Integer@S8 B1B0@B3 -> 0b0_1_10011
          Integer@S32 Integer@U8 B1B0@B0 -> 0b1_0_10000
          Integer@S32 Integer@U8 B1B0@B1 -> 0b1_0_10001
          Integer@S32 Integer@U8 B1B0@B2 -> 0b1_0_10010
          Integer@S32 Integer@U8 B1B0@B3 -> 0b1_0_10011
          Integer@S32 Integer@S8 B1B0@B0 -> 0b1_1_10000
          Integer@S32 Integer@S8 B1B0@B1 -> 0b1_1_10001
          Integer@S32 Integer@S8 B1B0@B2 -> 0b1_1_10010
          Integer@S32 Integer@S8 B1B0@B3 -> 0b1_1_10011
          ;

    VFormat8_32_N
          Integer@U8 B1B0@B0 Integer@U32 -> 0b0_0_10100
          Integer@U8 B1B0@B1 Integer@U32 -> 0b0_0_10101
          Integer@U8 B1B0@B2 Integer@U32 -> 0b0_0_10110
          Integer@U8 B1B0@B3 Integer@U32 -> 0b0_0_10111
          Integer@U8 B1B0@B0 Integer@S32 -> 0b0_1_10100
          Integer@U8 B1B0@B1 Integer@S32 -> 0b0_1_10101
          Integer@U8 B1B0@B2 Integer@S32 -> 0b0_1_10110
          Integer@U8 B1B0@B3 Integer@S32 -> 0b0_1_10111
          Integer@S8 B1B0@B0 Integer@U32 -> 0b1_0_10100
          Integer@S8 B1B0@B1 Integer@U32 -> 0b1_0_10101
          Integer@S8 B1B0@B2 Integer@U32 -> 0b1_0_10110
          Integer@S8 B1B0@B3 Integer@U32 -> 0b1_0_10111
          Integer@S8 B1B0@B0 Integer@S32 -> 0b1_1_10100
          Integer@S8 B1B0@B1 Integer@S32 -> 0b1_1_10101
          Integer@S8 B1B0@B2 Integer@S32 -> 0b1_1_10110
          Integer@S8 B1B0@B3 Integer@S32 -> 0b1_1_10111
          ;

    VFormat16_N
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b0_0_11000
          Integer@U16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b0_0_11001
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b0_0_11010
          Integer@U16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b0_0_11011
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b0_1_11000
          Integer@U16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b0_1_11001
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b0_1_11010
          Integer@U16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b0_1_11011
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H0 -> 0b1_0_11000
          Integer@S16 H1H0@H0 Integer@U16 H1H0@H1 -> 0b1_0_11001
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H0 -> 0b1_0_11010
          Integer@S16 H1H0@H1 Integer@U16 H1H0@H1 -> 0b1_0_11011
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H0 -> 0b1_1_11000
          Integer@S16 H1H0@H0 Integer@S16 H1H0@H1 -> 0b1_1_11001
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H0 -> 0b1_1_11010
          Integer@S16 H1H0@H1 Integer@S16 H1H0@H1 -> 0b1_1_11011
          ;

    VFormat32_16_N
          Integer@U32 Integer@U16 H1H0@H0 -> 0b0_0_11100
          Integer@U32 Integer@U16 H1H0@H1 -> 0b0_0_11101
          Integer@U32 Integer@S16 H1H0@H0 -> 0b0_1_11100
          Integer@U32 Integer@S16 H1H0@H1 -> 0b0_1_11101
          Integer@S32 Integer@U16 H1H0@H0 -> 0b1_0_11100
          Integer@S32 Integer@U16 H1H0@H1 -> 0b1_0_11101
          Integer@S32 Integer@S16 H1H0@H0 -> 0b1_1_11100
          Integer@S32 Integer@S16 H1H0@H1 -> 0b1_1_11101
          ;

    VFormat16_32_N
          Integer@U16 H1H0@H0 Integer@U32 -> 0b0_0_11110
          Integer@U16 H1H0@H1 Integer@U32 -> 0b0_0_11111
          Integer@U16 H1H0@H0 Integer@S32 -> 0b0_1_11110
          Integer@U16 H1H0@H1 Integer@S32 -> 0b0_1_11111
          Integer@S16 H1H0@H0 Integer@U32 -> 0b1_0_11110
          Integer@S16 H1H0@H1 Integer@U32 -> 0b1_0_11111
          Integer@S16 H1H0@H0 Integer@S32 -> 0b1_1_11110
          Integer@S16 H1H0@H1 Integer@S32 -> 0b1_1_11111
          ;

OPERATION PROPERTIES
    IWIDTH
    ITYPE
    SPA
    SECONDARY
    TERTIARY
    BRANCH_TARGET_INDEX
    OPERATION_TYPE
    BRANCH_TYPE
    CC_INDEX
    ;

OPERATION PREDICATES
    ;

FUNIT uC
    ISSUE_SLOTS 0 1;
   ENCODING WIDTH 64;




  Canvas32 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX................................'

  LockPred '.....X................................................XX........'
  Shflmd '.......XX.......................................................'
  LockPreda '...........XXX..................................................'
  Pred '...................................................XXX..........'
  PredNot '..................................................X.............'
  Pred32b '...............................................XXX..............'
  Pred32a '.........................................XXX....................'
  Pred32Notb '.......................................X........................'
  Pred32Nota '........................................X.......................'
  NopSync '.................................................X..............'
  Sync '...........................................................X....'
  CCC32_1 '.......................................XXXXX....................'
  SReg '..............................XXXXXXXX..........................'
  SReg32 '....................................XXXXXXXX....................'
  Dest '............................................XXXXXX..............'
  RegA '......................................XXXXXX....................'
  RegB '................................XXXXXX..........................'
  RegC '.........XXXXXX.................................................'
  RegDa '...............XXXXXX...........................................'
  RegB32 '......................................XXXXXX....................'
  RegC32 '..................................................XXXXXX........'
  RegC2 '............................................XXXXXX..............'
  BFiller '..................XXXXXXXXXXXXXX................................'
  BarFiller '..........................XXXXXX................................'
  BcbankHi '.....................................X..........................'
  BcbankLo '..................XXXX..........................................'
  Bcaddr '......................XXXXXXXXXXXXXX............................'
  Bgap '....................................X...........................'
  Bconst '..................XXXXXXXXXXXXXXXXXXXX..........................'

  BFiller1 '..............................XX................................'
  BFiller2 '............................XXXX................................'
  BFiller3 '......................XXXXXXX...................................'

  SUPDest '......XXX.......................................................'
  VPDest '.......XXX......................................................'
  PredDest '........XXX.....................................................'
  PDest '............................................XXX.................'
  PNDest '...............................................XXX..............'
  CCC_1 '......................................................XXXXX.....'
  CCC_2 '.......................................XXXXX....................'




  Imm5I '......................................................XXXXX.....'
  Imm24sh '....XXXXXXXXXXXXXXXXXXXXXXXX....................................'
  Imm32sh '............................XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....'
  Imm4o '..................................XXXX..........................'
  Imm4n '....XXXX........................................................'
  Imm4m '........XXXX....................................................'
  Imm4l '............XXXX................................................'
  Imm4k '................XXXX............................................'
  Imm4j '....................XXXX........................................'
  Imm4i '........................XXXX....................................'
  Imm4h '............................XXXX................................'
  Imm4g '................................XXXX............................'
  Imm4f '....................................XXXX........................'
  Imm4e '........................................XXXX....................'
  Imm4d '............................................XXXX................'
  Imm4c '................................................XXXX............'
  Imm4b '....................................................XXXX........'
  Imm4a '........................................................XXXX....'
  Imm5_32 '.................................XXXXX..........................'
  Imm8_32 '..............................................XXXXXXXX..........'
  Imm8_32a '....................................XXXXXXXX....................'
  Imm8_32b '......................................XXXXXX..........XX........'
  Imm8_32c '................................XXXXXX................XX........'
  Imm12_32 '................................XXXXXXXXXXXX....................'
  Imm14_32 '....................................XXXXXXXXXXXXXX..............'
  Imm18_32 '.....................................XXXXXXXXXXXXXXXXXX.........'
  Imm22_32 '....................................XXXXXXXXXXXXXXXXXXXXXX......'
  Imm8 '..............................XXXXXXXX..........................'
  Imm10 '......................XXXXXXXXXX................................'
  Imm11 '.....................XXXXXXXXXXX................................'
  Imm12 '..........................XXXXXXXXXXXX..........................'
  Imm13 '.........XXXXXXXXXXXXX..........................................'


  Imm14 '........................XXXXXXXXXXXXXX..........................'
  Imm16 '......................XXXXXXXXXXXXXXXX..........................'
  Imm20 '..................XXXXXXXXXXXXXXXXXXXX..........................'
  Imm20a '......XXX............XXXXXXXXXXXXXXXXX..........................'
  Imm22a '..............XXXXXXXXXXXXXXXXXXXXXX............................'
  Imm24 '..............XXXXXXXXXXXXXXXXXXXXXXXX..........................'
  Imm28 '..........XXXXXXXXXXXXXXXXXXXXXXXXXXXX..........................'
  Imm30a '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX............................'
  Imm32 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..........................'
  Imm06 '.........XXXXXX.................................................'
  CBank '.................XXXXX..........................................'
  CBank2 '...................XXXXX........................................'
  By '.......XX.......................................................'
  SH '.........................................................X......'
  M '......................................................X.........'
  MV '........................................................X.......'
  aE '....X...........................................................'
  bE '.....X..........................................................'
  E '.....X..........................................................'
  E32 '.........................................................X......'
  LOP '........................................................XX......'
  LOP32 '.........................................................XX.....'
  Bpt '...............................................XXX..............'
  Bpt32 '.........................................................XX.....'
  AdMode '......................................................XX........'
  PixMode '........................................................XXX.....'
  LSSize '........................................................XXX.....'
  abSize '......XXXXX.....................................................'
  ALSize '.........................................................XX.....'
  ALSize32 '........................................................XX......'
  OutType '.........................................................XX.....'
  COP '......................................................XX........'
  AtomOp '.......................................................XXXX.....'
  AtomSize '..XXX.................................................X.........'
  CCTLOp '......................................................XXXXX.....'
  Cache '....................................XX..........................'
  SuqOp '......................................................XXXXX.....'
  MembarL '.........................................................XX.....'




  TexQuery '.....XXXXX.X....................................................'
  TexComp '.........................................................XX.....'
  TOFF1 '.........X......................................................'
  MS '........X.......................................................'
  CL '.......X........................................................'
  DC '.......X........................................................'
  NODEP '......................................................X.........'
  TOFF2 '........XX......................................................'
  ParamA '..........XXX...................................................'
  Bindless '.............X..................................................'
  LOD '....XXX.........................................................'
  LOD1 '......X.........................................................'
  LODLEN '.......X........................................................'
  NDV '......................................................X.........'
  NDVa '..................X.............................................'
  SWZMode '.......................................................XXX......'
  PNWord '.......................XXXXXXXXX................................'
  Wmsk '..............XXXX..............................................'
  Wmsk32 '.......................................................X........'
  TidB '...................XXXXXXXXXXXXX................................'
  TidBTEX '........................XXXXXXXX................................'
  TidBSAMP '...................XXXXX........................................'
  TidB32 '................................XXXXXX................X.........'
  TidB32TEX '...................................XXX................X.........'
  TidB32SMP '................................XXX.............................'

  shift '.........................................................X......'
  ASigned '........................................................X.......'
  BSigned '..........................................................X.....'
  ABSigned '.........................................................X......'
  ABSigned1 '..........................................................X.....'

  SAExt '......................................................XXX.......'
  SBExt '.........................................................XX.....'
  SCExt '.......XX.......................................................'
  SABCExt '.......XX.............................................XXXXX.....'

  Signed '..........................................................X.....'
  Signed32 '......................................................X.........'
  Bop '.........XX.....................................................'
  Bop0 '................................XX..............................'
  Bop32 '.....................................XX.........................'
  BAddr '......X.........................................................'
  DstFmt '..........................................XX....................'
  IDstFmt '..........................................XX............X.......'
  ISrcFmt '.......................................XX.............X.........'
  PMode '.......................................................XXXX.....'
  XMode '........................................................XX......'
  SrcFmt '.......................................XX.......................'
  SrcDstFmt '.......................................XX.XX....................'
  DstPred '........XXX.....................................................'
  SrcPred '............XXX.................................................'
  SrcNot '...........X....................................................'
  SrcPred32 '.......................................................XXX......'
  SrcNot32 '......................................................X.........'
  Src1Pred '...................................XXX..........................'
  Src1Not '..................................X.............................'
  Src2Pred '.........................................XXX....................'
  Src2Not '........................................X.......................'
  ConstC '..........................................................X.....'




  MN '........................................................X.......'
  VOP '......XXX.......................................................'
  DFormat '......X.........................................................'
  DFormat2 '.....................X..........................................'
  VScale '.......XX.......................................................'
  safmt '.........................................................X......'
  sbfmt '..........................................................X.....'
  safmt32 '...................................................X............'
  sbfmt32 '....................................................X...........'
  DFormat32 '..................................................X.............'
  sabfmt32 '...................................................X............'
  VRed '.................XXX............................................'
  LaneMask4 '.......XX...................XX..................................'
  LaneMask2 '.......XX.......................................................'
  asel4 '....................XXXX........................................'
  bsel4 '........................XXXX....................................'
  asel2 '....................XXXX........................................'
  bsel2 '........................XXXX....................................'
  asel2hi '....................XX..........................................'
  aSelect '.................XXX.....................................X......'
  bSelect '.............................XXX..........................X.....'
  abSelect32 '...................................................XXXXXX.......'
  abSelect32a'..................................................XXXXXXX.......'

  AVGMode '.......................................................XX.......'

  Scale '............XXX.................................................'
  VComp '......................................................XXX.......'
  FComp '.....XXXX.......................................................'
  FComp32 '...............................................XXX......X.......'
  RGBA '...........XXXX.................................................'
  RGBAa '............................XXXX................................'
  RGBAb '......XXXX......................................................'
  Ofmt '.................XX.............................................'
  Bc '..........X.....................................................'
  Rf '.........................................................XX.....'
  DI '...............................................X................'

  Xoffset '............................XXXX................................'
  Yoffset '........................XXXX....................................'
  Zoffset '....................XXXX........................................'
  BP '.......................................................X........'
  Dim '..................XX............................................'
  Clamp '...............XX...............................................'
  Pipe4 '.........XXXX...................................................'
  Pipe2 '......................................................XX........'
  Pipe2a '.......XX.......................................................'
  Pipe2b '........................................................XX......'
  Pipe2c '.....XX.........................................................'
  QuadMask '.......................................................XXXX.....'
  WriteCC '...............X................................................'
  WriteCC32 '........................................X.......................'
  WriteCCI '.....X..........................................................'
  BVal '..........................................................X.....'
  BVal1 '........................................................X.......'
  Rnd '.............XX.................................................'
  Rnd1 '.......XX.......................................................'
  RndIR '.............XX.........................................X.......'
  IR '........................................................X.......'
  Rnd32 '..........................................XX....................'
  RndIR32 '..........................................XX..........X.........'
  Xm '.........................................................X......'
  Xm1 '........X.......................................................'
  Xm_I '..........................................................X.....'
  Brev '.......................................................X........'
  PSign '......................................................XX........'
  PSign2 '.......XX.......................................................'
  Sat '..........................................................X.....'
  Sat1 '.......X........................................................'
  Sat2 '..............X.................................................'
  Sat3 '......................................................X.........'
  Sat32 '.......................................X........................'
  SDest32 '.......................................X........................'
  I2ISizes32 '.......................................X..XX..........X.........'
  nA32 '.........................................................X......'
  nA32a '........................................................X.......'
  aA32b '.................................X..............................'
  nA32c '....................................................X...........'
  nA32d '.........................................................X......'
  nA_L '......................................................X.........'
  nB_L '.......................................................X........'
  nB '.......................................................X........'
  aB '.........................................................X......'
  nB32 '.........................................X......................'
  aB32 '......................................X.........................'
  nA1 '......................................................X.........'
  nB1 '.......................................................X........'
  aA1 '........................................................X.......'
  aB1 '.........................................................X......'
  nAB '......X.........................................................'
  nABa '......................................................X.........'
  nAB32 '...........................................................X....'
  FTZ '........X.......................................................'
  FTZ1 '..........................................................X.....'
  FTZ2 '....X...........................................................'
  FMZ '........................................................XX......'
  H1H0 '.......X........................................................'
  H1H0a '..........................................................X.....'
  HILO '.........................................................X......'
  Float '......................................................X.........'




  ABC '................XX..............................................'
  BFix_A '.................X..............................................'
  CNS_B '......................................................XX........'
  CNS_A '........................................................XX......'
  CNSIFix '......................................................XXX.......'

  RCI '......................................................XXX.......'
  I '........................................................X.......'
  RCImm '................................XXXXXX................XX........'


  shfl_imm5 '.................................XXXXX..........................'
  bit6_RegB '................................X...............................'
  BFix_SHFL '..........................................................X.....'
  CFix_SHFL '.........................................................X......'
  SHFLFiller '...............XXXXXXX..........................................'


  AFix_BAR32 '.....................................X..........................'
  AFix_BAR '................X...............................................'
  BFix_BAR '.................X..............................................'
  BVideo '................X...............................................'
  MBLevel '.........................................................XX.....'

  Quad '........................................................X.......'
  Phase '.......................................................XX.......'
  Phase32 '.......................................XX.......................'
  VMode '........................................................XXX.....'
  IComp '......XXX.......................................................'
  IComp32 '...............................................XXX..............'
  CA '.................................................X..............'
  CA2 '...............................................X................'
  U '................................................X...............'
  LMT '...............................................X................'
  U32 '...................................X............................'
  LMT32 '..................................X.............................'
  INC '...............................................X................'
  INC32 '..........................................................X.....'
  CBank32 '........................................................XXX.....'
  CAddr32 '................................XXXXXX................XX........'
  SUOp '.......................................................XXXX.....'
  SD '.......XX.......................................................'
  CMode '.....XX.........................................................'
  Barmd '.............XX.................................................'
  BarName '........................................XXXX....................'
  MSI '......................................................XX........'
  MufuOp '..................................XXXX..........................'
  BarOpN '....................................X...........................'
  BarOp '......................................................XXX.......'
  BarRedOp '.........................................................XX.....'
  RTTOp '................................................XX..............'
  IPAOp '........................................................XX......'
  IPAOpN '........................................................X.......'
  RROOp '..........................................................X.....'
  RROOpN '.....................................X..........................'
  AIO '......................................................X.........'
  P '.......................................................X........'
  Trig '.............X..................................................'
  STPMode '..........................................................X.....'
  KeepRefCnt '.................................................X..............'
  ChkModeF '.........XXXXXX.................................................'

  BDim '...............X................................................'
  SMode '.......................................................XXXX.....'





  Opcode1 '................................XXXXX.................XXXXXXXXXX'
  Opcode2 'XXXXXX......................................................XXXX'
  Opcode3 'XXXXX.......................................................XXXX'
  Opcode4 '.......................................................XXXXXXXXX'
  Opcode5 '......................................................XXXXXXXXXX'
  Opcode6 '........................................................XXXXXXXX'
  Opcode7 '..........................................................XXXXXX'
  Opcode8 '................................XXXX..................XXXXXXXXXX'
  Opcode9 '................................X.....................XXXXXXXXXX'
  Opcode10 '...........................................................XXXXX'
  Opcode14 '................................XX.........................XXXXX'
  Opcode15 '................................XXXX.......................XXXXX'
  Opcode16 '................................XXXXX......................XXXXX'
  Opcode18 'XXXXXX......................................................XXXX'
  Opcode20 '.........................................................XXXXXXX'
  Opcode21 'XX..........................................................XXXX'
  Opcode22 'XXXXXX.X....................................................XXXX'
  Opcode23 '.........................................................XXXXXXX'
  Opcode24 'XXXX........................................................XXXX'
  Opcode25 '............................................................XXXX'
  Opcode26 'XXXX........................................................XXXX'
  Opcode27 'XXXXX...................................................XX..XXXX'
  Opcode29 'XXXXX.......................................................XXXX'
  Opcode30 '................................X.....................XXXXXXXXXX'
  Opcode31 '................................XXXX........................XXXX'
  Opcode32 '.....................................................XXXXXXXXXXX'




  Nenc0 '.....................................XXXXXXXXXXXX...............'
  Nenc1 '......XXX.....XXXXXXXX................XXXXXXXXXXXX..............'
  Nenc2 '.....................................XX........XXX..............'
  Nenc3 '......XXX......XXXXXXXXXXXXXXXXXXXXXXXX.................XXX.....'
  Nenc4 '......XXX.......XXXXXXXXXXXXXXXXXXXXXXX.................XX......'
  Nenc5 '......XXX......XXXXXXXXXXXXXXXXX......XX................XXX.....'
  Nenc6 '......XXX.......XXXXXXXXXXXXXXXX......XX................XX......'
  Nenc7 '......X..XXXX.........................X..X............X.........'
  Nenc8 '......X..XXXX.........................X..X............X...X.....'
  Nenc9 '......X..XXXXXX.......................X..X......................'
  Nenc10 '......X..XXXX.........................X..X..............X.X.....'
  Nenc11 '................................XXXXXX..........................'
  Nenc12 '.....X................................XXXXXX..........X.........'
  Nenc13 '......X..XXXXXXX......................XXXXXX..........X.........'
  Nenc14 '......XXXXX....X........................................XXX.....'
  Nenc15 '......XXXXXXXXXXXXXXXXXXXXXXXX........XXXXXX............XXX.....'
  Nenc16 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..................XXX.....'
  Nenc17 '......XXXXXXXXXX........................................XX......'
  Nenc18 '......XXXXXXXXXX............................XXXXXX......XX......'
  Nenc19 '......X........X......................................X.........'
  Nenc20 '.....XX..XXXXXX.........................................X.......'
  Nenc21 '........................................................X.......'
  Nenc22 '.....XX..XXXXXX.................................................'
  Nenc23 '.....XXXX.............................................XXXX......'
  Nenc24 '.....XXXXXX.....................................................'
  Nenc25 '.....XXXXXXXXXX.......................................X.XX......'
  Nenc26 '.....XXXX.............................................XXXXX.....'
  Nenc27 '.....XXXXXXXXXX.................................................'
  Nenc28 '.....XXXXXXXXXX........................................XX.X.....'
  Nenc29 '.........................................................XX.....'
  Nenc30 '.....XXXXXXXXXX.......................XXXXXX..........X.X.......'
  Nenc31 '......XXXXXXXXX.........................................XXX.....'
  Nenc32 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX............XXX.....'
  Nenc33 '......XXXXXXXXXXXXXXXXXXXXXXXX........XXXXXXXXXXXXXXXXX..X......'
  Nenc34 '.....................................XX..XX.XX..................'
  Nenc35 '......X...............................XXX.............XX........'
  Nenc36 '......X...XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..............XX........'
  Nenc37 '.....X..........................................................'
  Nenc38 '.....X.........X......................................XXXX......'
  Nenc39 '.....X.........X........................................X.......'
  Nenc40 '.....XXXXXXXXXX.......................................XX........'
  Nenc41 '......................................................XX........'
  Nenc42 '.....XX.........................................................'
  Nenc43 '.....XXXXXXXXX........................XXXXXXXXX............X....'
  Nenc44 '.....XXXXXXXXXXXX.....................XXXXXXXXX............X....'
  Nenc45 '.....XXXXXXXXX..............................XXX.X..........X....'
  Nenc46 '.....XXXXXXXXXXXX...........................XXX.X..........X....'
  Nenc47 '.....X................................XXXXXXXXX............X....'
  Nenc48 '.....X......................................XXX.X..........X....'
  Nenc49 '.....XXXXXXXXX........................XXXXXXXXX.X.XXXXXXXXXX....'
  Nenc50 '.....XXXXXXXXXXXX.....................XXXXXXXXX.X.XXXXXXXXXX....'
  Nenc51 '.....X................................XXXXXXXXX.X.XXXXXXXXXX....'
  Nenc52 '.....XXXXXXXXX........................XXXXXXXXX.XXXXXXXXXXXX....'
  Nenc53 '.....XXXXXXXXXXXX.....................XXXXXXXXX.XXXXXXXXXXXX....'
  Nenc54 '..................................................XXXXXXXXX.....'
  Nenc55 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.........X....'
  Nenc56 '.....................................XXXXXXXXXXXXX..............'
  Nenc57 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....'
  Nenc58 '.....XXXXXXXXXXXXX....................XXXXXXXXX...XXXXXXXXXX....'
  Nenc59 '.......................................................XX.......'
  Nenc60 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..XXXXXXXXXX....'
  Nenc62 '......XX.......X..XXXXXXXX......................................'
  Nenc64 '......XX.......X..XXXXXXXX............................XX........'
  Nenc65 '............................................XXXXXX..............'
  Nenc66 '......XXXXXXXXXXX...............................................'
  Nenc67 '.......XXXXXXXXXXXXXXX................................XXXXX.....'
  Nenc68 '.......XXXXXXXXXXXXXX...................................X.......'
  Nenc69 '.......XX......XXXXXX.......................XXXXXX....X.X.......'
  Nenc70 '......XXXXXXXXXX......................................XXX.......'
  Nenc71 '......XX...XXXXXXXXXXXXXXXXXXX........................XX........'
  Nenc72 '....XX............XXXXXX.................................XX.....'
  Nenc73 '......X.XXXXXX..................................................'
  Nenc74 '......XXXXXXXX..................................................'
  Nenc75 '.......XXXXXXX..................................................'
  Nenc76 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXX.......'
  Nenc77 '......XXXXXXXXXXX.XXXXXXXXXXXXXX......XXXXXX....................'
  Nenc78 '......X...XXXXX.......................................X.........'
  Nenc79 '......XXXXX.....................................................'
  Nenc80 '......X..XXXXXX.....XXXXXXXX..........................X.........'
  Nenc81 '.........XXXXX..................................................'
  Nenc82 '....XXX.........................................................'
  Nenc83 '...............X......................................X.........'
  Nenc84 '.....X...XXX....................................................'
  Nenc85 '....XXX.XX...............................................XX.....'
  Nenc86 '.....XX..XXXXXX.XXXXXXX.........................................'
  Nenc87 '.......XX......X......................................XXXXX.....'
  Nenc88 '...............X..........................................X.....'
  Nenc89 '.....XXXX......XXXXXX...........................................'
  Nenc90 '.....XXXXXXXXXXX......................XXXXXX....................'
  Nenc91 '....................................X...........................'
  Nenc92 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXX.....................X.X......'
  Nenc93 '.....XX.................................................XXX.....'
  Nenc94 '.....XX..XXXXXX...........................................X.....'
  Nenc95 '.....XX..XXXXXX........................................XXXX.....'
  Nenc96 '.....XXXXXX...............................................X.....'
  Nenc97 '....XXXXXXXXXX..................XXXXXX...................XX.....'
  Nenc98 '....XXXXX.........X......................................XX.....'
  Nenc99 '....X.....X.X.....X.............XXXXXX...................XX.....'
  Nenc100 '.......................................................X........'
  Nenc101 '.......................................................X..X.....'
  Nenc102 '.........XX............................................XX.......'
  Nenc103 '.....X..............X...........................................'
  Nenc104 '.....X..............X..................................XX.......'
  Nenc105 '.....X..............X..................................X........'
  Nenc106 '.....X..............XX..........................................'
  Nenc107 '.....X..............X..................................X........'
  Nenc108 '.....XXXX......X....XX..........................................'
  Nenc109 '....................XX..........................................'
  Nenc110 '......XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX....XXX.......'
  Nenc111 '.......XXXXXXXXXXXXXXX..................................X.......'
  Nenc112 '.......XX......XXXXXXX......................XXXXXX....X.X.......'
  Nenc113 '.....XXXX......XXXXXXX..........................................'
  Nenc114 '......XXXXXXXXXXXXXXXXXXXXXXXXXX......XXXXXXXXXXXX....XXXXX.....'
  Nenc115 '....................................XX......XXXXXX..............'
  Nenc116 '......XX...XX..X.XXXXXXXXXXXXXXXXXXXXX................XXXXX.....'
  Nenc117 '......XXXXXXX..XXXXXXXXXXXXXXXXX......XX....XXXXXX......XXX.....'
  Nenc118 '......XXXXXXX..XXXXXXXXXXXXXXXXXXXXXXXXX................XXX.....'

  Nenc119 '......XX.......XXXXXXXXXXX......................................'

  Nenc120 '......XXXXXXXXXXXXXXXXXXXXXXXXXX............XXXXXX......XXX.....'
  Nenc121 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX............XXXXXXXXXX....'
  Nenc122 '.......................................................XX.......'
  Nenc123 '.....XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..........X....'
  Nenc124 '.....................................XXXXXXXXXXXX...............'
  Nenc125 '.....XXXX......X...............................XXX........X.....'
  Nenc126 '......X.XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX..............'
  Nenc130 '....XX............X......................................XX.....'
  Nenc131 '......X...X....X.......................................X........'
  Nenc132 '...................XXXXXXXXXXXXX................................'
  Nenc133 '...................XXXXXXXXXXXXX........................X.......'
  Nenc134 '........................................................X.......'
  Nenc135 '.....XX.........................................................'
  Nenc136 '......XXXXXXXXXXXXXXX...........XXXXXX.................XX.......'
  Nenc137 '......XXXXXXXXXXXXXXXX..........XXXXXX.................XX.......'
  Nenc138 '......X...............XXXXXXXXXX........................X.......'
  Nenc139 '.....XXXXXXXXXXXXXXXXX................XXXXXXXXX.XXXXXXXXXXXX....'


  ALL 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'

NOP_ENCODING
  ALL = 0x4000000000001de4;

CLASS "SHINT"
    FORMAT Opcode UImm(24):uImmMsb ',' UImm(32):uImmLsb;

    OPCODES
        SHINTfe_pipe =  0b0010_0_111;
        SHINT =  0b0010_0_111;

    ENCODING
      Opcode24 = Opcode;
      Imm24sh = uImmMsb;
      Imm32sh = uImmLsb;


ALTERNATE CLASS "SHINT nibbles"
    FORMAT Opcode UImm(4):uImmA ',' UImm(4):uImmB ',' UImm(4):uImmC ',' UImm(4):uImmD ','
                  UImm(4):uImmE ',' UImm(4):uImmF ',' UImm(4):uImmG ',' UImm(4):uImmH ','
                  UImm(4):uImmI ',' UImm(4):uImmJ ',' UImm(4):uImmK ',' UImm(4):uImmL ','
                  UImm(4):uImmM ',' UImm(4):uImmN;

    OPCODES
        SHINTfe_pipe =  0b0010_0_111;
        SHINT =  0b0010_0_111;

    ENCODING
      Opcode24 = Opcode;
      Imm4a = uImmA;
      Imm4b = uImmB;
      Imm4c = uImmC;
      Imm4d = uImmD;
      Imm4e = uImmE;
      Imm4f = uImmF;
      Imm4g = uImmG;
      Imm4h = uImmH;
      Imm4i = uImmI;
      Imm4j = uImmJ;
      Imm4k = uImmK;
      Imm4l = uImmL;
      Imm4m = uImmM;
      Imm4n = uImmN;


CLASS "NOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Trig(noTRIG):trig /Pipe(HW):pipe /S(noS):sync
                               { CC(CC):TestCC/Test(T):fcomp ',' } UImm(16/0):uImm;

    OPCODES
        NOPbru_pipe =  0b010000_0_100;
        NOP =  0b010000_0_100;

    ENCODING
      Opcode18 = Opcode;
      Trig = Trig;
      Pred = Pg;
      PredNot = Pg@not;
      Pipe4 = Pipe;
      Imm16 = uImm;
      CCC_1 = Test;
      !Nenc1;
      Sync=S;


 CLASS "LEPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync Register:Rd;

    OPCODES
        LEPCxlu_pipe =  0b010001_0_100;
        LEPC =  0b010001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      !Pipe2;
      !Nenc32;
      Sync=S;


 CLASS "POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' [~]Register:Ra ',' [~]Register:Rb;

    CONDITIONS

    OPCODES
        POPCfmaX_pipe =  0b010101_0_100;
        POPC =  0b010101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      nA_L = Ra@invert;
      nB_L = Rb@invert;

      Sync=S;
      !BFiller;
      !Nenc31;
      ABC=0;
      !WriteCC;


 CLASS "Imm POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' [~]Register:Ra ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    CONDITIONS

    OPCODES
        POPCfmaX_pipe =  0b010101_0_100;
        POPC =  0b010101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      nA_L = Ra@invert;
      nB_L = UnaryInv;

      Sync=S;

      !Nenc31;
      ABC = 3;
      !WriteCC;


 CLASS "Const POPC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
Register:Rd ',' [~]Register:Ra ',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        POPCfmaX_pipe =  0b010101_0_100;
        POPC =  0b010101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA_L = Ra@invert;
      nB_L = srcConst@invert;

      Sync=S;

      !Nenc31;
      ABC = 1;
      !WriteCC;


 CLASS "VOTE.VTG"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VTGMode:vtgmode /S(noS):sync UImm(28):uImm;

    OPCODES
        VOTEbar_pipe =  0b010010_0_100;
        VOTE =  0b010010_0_100;

    ENCODING
      Opcode2 = Opcode;
      VMode =* VTGMode;
      Pred = Pg;
      PredNot = Pg@not;
      Imm28 = Imm;
      VPDest = `Predicate@PT;
      Src2Pred = `Predicate@PT;
      Dest = `Register@RZ;

      Sync=S;
      !Nenc35;


 CLASS "VOTE"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VoteOp(ALL):voteop /S(noS):sync
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /VoteOp:voteop /S(noS):sync
##ENDIF
        { Register(RZ):Rd ',' }
        Predicate:Pd ',' [!]Predicate:Pa;

    OPCODES
        VOTEbar_pipe =  0b010010_0_100;
        VOTE =  0b010010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      VMode =* VoteOp;
      Dest = Rd;
      VPDest = Pd;
      Src2Pred = Pa;
      Src2Not = Pa@not;

      Sync=S;
      !Nenc36;



CLASS "CSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' CC:inputCC ',' [!]Predicate:Pa;

    OPCODES
        CSETPxlu_pipe =  0b000001_0_100;
        CSETP =  0b000001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;


      !Nenc3;
      Sync=S;


ALTERNATE CLASS "NoBop CSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:CCTest /S(noS):sync
                               Predicate:Pd
                                    ',' CC:inputCC ;

    OPCODES
        CSETPxlu_pipe =  0b000001_0_100;
        CSETP =  0b000001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;


      !Nenc3;
      Sync=S;


CLASS "CSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' CC:dummyCC
                                    ',' [!]Predicate:Pa;

    OPCODES
        CSETxlu_pipe =  0b000000_0_100;
        CSET =  0b000000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;


      !Nenc4;
      Sync=S;


ALTERNATE CLASS "NoBop CSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:CCTest /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' CC:dummyCC
                                    ;

    OPCODES
        CSETxlu_pipe =  0b000000_0_100;
        CSET =  0b000000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      CCC_2 = CCTest;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;


      !Nenc4;
      Sync=S;


CLASS "ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;

ALTERNATE CLASS "NoBop ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;

CLASS "Imm ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;

ALTERNATE CLASS "NoBop Imm ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;

CLASS "Const ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;

ALTERNATE CLASS "NoBop Const ISET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;

ALTERNATE CLASS "ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc37;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "Imm ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "Const ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal1 = BVal;
      Bop = bopopt;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const ISET U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode
                               /S(noS):sync Register:Rd /optCC(noCC):writeCC
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETfau_pipe =  0b00010_0_011;
        ISETxlu_pipe =  0b00010_0_011;
        ISET =  0b00010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal1 = BVal;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc37;
      Sync=S;
      ABC = 1;


CLASS "ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;


CLASS "Imm ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;


CLASS "Const ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const ISETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpAll;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;


      !BFiller;
      !Nenc39;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "Imm ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "Const ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Bop:bopopt /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const ISETP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
                               Predicate:Pd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ISETPfau_pipe =  0b00011_0_011;
        ISETPxlu_pipe =  0b00011_0_011;
        ISETP =  0b00011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      Pipe2 = Pipe2;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      IComp = ICmpU;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      Xm = X;



      !Nenc39;
      Sync=S;
      ABC = 1;


CLASS "ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' Register:Rc;
    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      IComp = ICmpAll;

      !BFiller;
      !Nenc38;
      Sync=S;
      ABC=0;


CLASS "Imm ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' Register:Rc;
    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      IComp = ICmpAll;


      !Nenc38;
      Sync=S;
      ABC = 3;


CLASS "Const ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' Register:Rc;
    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      IComp = ICmpAll;


      !Nenc38;
      Sync=S;
      ABC = 1;


CLASS "Const1 ICMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp /Integer32(S32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      IComp = ICmpAll;


      !Nenc38;
      Sync=S;
      ABC = 2;


ALTERNATE CLASS "ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
                                    ',' Register:Rc;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      IComp = ICmpU;

      !BFiller;
      !Nenc38;
      Sync=S;
      ABC=0;




ALTERNATE CLASS "Imm ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' SImm(20):uImm
                                    ',' Register:Rc;
    CONDITIONS
         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      IComp = ICmpU;


      !Nenc38;
      Sync=S;
      ABC = 3;




ALTERNATE CLASS "Const ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      IComp = ICmpU;


      !Nenc38;
      Sync=S;
      ABC = 1;




ALTERNATE CLASS "Const1 ICMP U"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpU:icomp /Integer32(U32):us32 /S(noS):sync
                               Register:Rd
                                    ',' Register:Ra
                                    ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (Integer32 == `Integer@U32):
             "This comparison is not allowed in a signed integer compare"

    OPCODES
        ICMPfau_pipe =  0b00110_0_011;
        ICMPxlu_pipe =  0b00110_0_011;
        ICMP =  0b00110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Signed = IsSigned(Integer32);
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      IComp = ICmpU;


      !Nenc38;
      Sync=S;
      ABC = 2;




 CLASS "BRA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } RSImm(24)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRAbru_pipe =  0b01000_0_111;
        BRA =  0b01000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm24 = sImm;
      U = U;
      LMT = LMT;


      !Nenc43;

 CLASS "BRA c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRAbru_pipe =  0b01000_0_111;
        BRA =  0b01000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      U = U;
      LMT = LMT;

      !Nenc44;


 CLASS "BRX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } Register:Ra SImm(24/0):sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRXadu_pipe =  0b01001_0_111;
        BRXbru_pipe =  0b01001_0_111;
        BRX =  0b01001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm24 = sImm;
      RegA = Ra;
      LMT = LMT;

      !Nenc45;


 CLASS "BRX c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:sImm];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        BRXadu_pipe =  0b01001_0_111;
        BRXbru_pipe =  0b01001_0_111;
        BRX =  0b01001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
      RegA = Ra;
      LMT = LMT;

      !Nenc46;


 CLASS "JMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } UImm(32)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMPbru_pipe =  0b00000_0_111;
        JMP =  0b00000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm32 = sImm;
      U = U;
      LMT = LMT;

      !Nenc47;


 CLASS "JMP c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /U(noU):uniform /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMPbru_pipe =  0b00000_0_111;
        JMP =  0b00000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      U = U;
      LMT = LMT;

      !Nenc44;


 CLASS "JMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
            { CC(CC):TestCC/Test(T):CCTest ',' } Register:Ra SImm(32/0):sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMXadu_pipe =  0b00001_0_111;
        JMXbru_pipe =  0b00001_0_111;
        JMX =  0b00001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 0;
      Imm32 = sImm;
      RegA = Ra;
      LMT = LMT;

      !Nenc48;


 CLASS "JMX c"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LMT(noLMT):lmt
{ CC(CC):TestCC/Test(T):CCTest ',' } C:srcConst[UImm(5/0*):constBank]* [Register(RZ):Ra + SImm(17/0)*:sImm];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(Ra);

         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        JMXadu_pipe =  0b00001_0_111;
        JMXbru_pipe =  0b00001_0_111;
        JMX =  0b00001_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);
      RegA = Ra;
      LMT = LMT;

      !Nenc46;


 CLASS "CAL"
    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        CALbru_pipe =  0b01010_0_111;
        CAL =  0b01010_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 0;
      Imm24 = sImm;
      INC = INC;

      !Nenc49;

 CLASS "PRET"
    FORMAT Opcode /INC(INC):inc RSImm(24)*:sImm;

    OPCODES
        PRETbru_pipe =  0b01111_0_111;
        PRET =  0b01111_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 0;
      Imm24 = sImm;
      INC = INC;

      !Nenc49;

 CLASS "CAL c"
FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        CALbru_pipe =  0b01010_0_111;
        CAL =  0b01010_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;
      !Nenc50;


 CLASS "PRET c"
FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
        PRETbru_pipe =  0b01111_0_111;
        PRET =  0b01111_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;
      !Nenc50;


 CLASS "JCAL"
    FORMAT Opcode /INC(INC):inc UImm(32)*:sImm;

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(sImm);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        JCALbru_pipe =  0b00010_0_111;
        JCAL =  0b00010_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 0;
      Imm32 = sImm;
      INC = INC;
      !Nenc51;


 CLASS "JCAL c"
FORMAT Opcode /INC(INC):inc C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    PROPERTIES
         BRANCH_TARGET_INDEX = INDEX(immConstOffset);

         BRANCH_TYPE = BRT_CALL;

    OPCODES
        JCALbru_pipe =  0b00010_0_111;
        JCAL =  0b00010_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      INC = INC;
      !Nenc50;


 CLASS "SSY"
    FORMAT Opcode RSImm(24)*:sImm;

    OPCODES
        SSYbru_pipe =  0b01100_0_111;
        SSY =  0b01100_0_111;
        PCNTbru_pipe =  0b01110_0_111;
        PCNT =  0b01110_0_111;
        PLONGJMPbru_pipe =  0b01011_0_111;
        PLONGJMP =  0b01011_0_111;
        PBKbru_pipe =  0b01101_0_111;
        PBK =  0b01101_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA2 = 0;
      Imm24 = sImm;

      !Nenc52;

 CLASS "SSY c"
FORMAT Opcode C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"
         ERROR
           (immConstOffset & 0x3) == 0 :
             "Constant offsets must be aligned on a 4B boundary"

    OPCODES
        SSYbru_pipe =  0b01100_0_111;
        SSY =  0b01100_0_111;
        PCNTbru_pipe =  0b01110_0_111;
        PCNT =  0b01110_0_111;
        PLONGJMPbru_pipe =  0b01011_0_111;
        PLONGJMP =  0b01011_0_111;
        PBKbru_pipe =  0b01101_0_111;
        PBK =  0b01101_0_111;

    ENCODING
      Opcode3 = Opcode;
      CA2 = 1;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);
      !Nenc53;



 CLASS "RET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest;

    PROPERTIES
         BRANCH_TYPE = BRT_RETURN;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        RETbru_pipe =  0b10010_0_111;
        RET =  0b10010_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      !Nenc55;


 CLASS "BRK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode CC(CC):TestCC/Test(T):CCTest;

    PROPERTIES
         BRANCH_TYPE = BRT_BRANCH;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        LONGJMPbru_pipe =  0b10001_0_111;
        LONGJMP =  0b10001_0_111;
        KILbru_pipe =  0b10011_0_111;
        KIL =  0b10011_0_111;
        BRKbru_pipe =  0b10101_0_111;
        BRK =  0b10101_0_111;
        CONTbru_pipe =  0b10110_0_111;
        CONT =  0b10110_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      !Nenc55;


 CLASS "EXIT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                 CC(CC):TestCC/Test(T):CCTest;

    PROPERTIES
         BRANCH_TYPE = BRT_BRANCHOUT;
         CC_INDEX = INDEX(CCTest);

    OPCODES
        EXITbru_pipe =  0b10000_0_111;
        EXIT =  0b10000_0_111;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      CCC_1 = Test;
      KeepRefCnt = 0;

      !Nenc123;


 CLASS "SAM"
    FORMAT Opcode;

    OPCODES
        SAMbru_pipe =  0b11000_0_111;
        SAM =  0b11000_0_111;
        RAMbru_pipe =  0b11001_0_111;
        RAM =  0b11001_0_111;

    ENCODING
      Opcode3 = Opcode;
      !Nenc57;


 CLASS "BPT"
    FORMAT Opcode /BPTMode:bpt UImm(20/0):sImm;

    CONDITIONS
         ERROR
           !(bpt == `BPTMode@TRAP && (sImm != 1)) :
             "BPT.TRAP immediate must be 1 for SM3.0"

    OPCODES
        BPTbru_pipe =  0b11010_0_111;
        BPT =  0b11010_0_111;

    ENCODING
      Opcode3 = Opcode;
      Imm20 = sImm;
      Bpt = BPTMode;
      !Nenc58;


 CLASS "RTT"
    FORMAT Opcode /RTTOp(POPCRS):rttop;

    PROPERTIES
            BRANCH_TYPE = BRT_RETURN;

    OPCODES
        RTTbru_pipe =  0b10100_0_111;
        RTT =  0b10100_0_111;

    ENCODING
      Opcode29 = Opcode;
      RTTOp = RTTOp;
      !Nenc60;




 CLASS "DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
        && IsEven(((Rc)+((Rc)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DFMAfmaX_pipe =  0b00100_0_001;
        DFMA =  0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = Rc@negate;

      Sync=S;
      !BFiller;
      !Nenc93;
      ABC=0;


 CLASS "Imm DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rc)+((Rc)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DFMAfmaX_pipe =  0b00100_0_001;
        DFMA =  0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,UnaryNeg);
      nB1 = Rc@negate;

      Sync=S;

      !Nenc93;
      ABC = 3;


 CLASS "Const DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' [-]Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rc)+((Rc)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DFMAfmaX_pipe =  0b00100_0_001;
        DFMA =  0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,srcConst@negate);
      nB1 = Rc@negate;

      Sync=S;

      !Nenc93;
      ABC = 1;


 CLASS "Const1 DFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DFMAfmaX_pipe =  0b00100_0_001;
        DFMA =  0b00100_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = srcConst@negate;

      Sync=S;

      !Nenc93;
      ABC = 2;


 CLASS "DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DADDfmaX_pipe =  0b01001_0_001;
        DADD =  0b01001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc94;
      ABC=0;


 CLASS "Imm DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DADDfmaX_pipe =  0b01001_0_001;
        DADD =  0b01001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc94;
      ABC = 3;


 CLASS "Const DADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DADDfmaX_pipe =  0b01001_0_001;
        DADD =  0b01001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc94;
      ABC = 1;


 CLASS "DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DMULfmaX_pipe =  0b01010_0_001;
        DMUL =  0b01010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;

      Rnd1 = Round1;
      nABa = PSignFFMA(Ra@negate,Rb@negate);

      Sync=S;
      !BFiller;
      !Nenc95;
      ABC=0;


 CLASS "Imm DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DMULfmaX_pipe =  0b01010_0_001;
        DMUL =  0b01010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;

      Rnd1 = Round1;
      nABa = PSignFFMA(Ra@negate,UnaryNeg);

      Sync=S;

      !Nenc95;
      ABC = 3;


 CLASS "Const DMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DMULfmaX_pipe =  0b01010_0_001;
        DMUL =  0b01010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;

      Rnd1 = Round1;
      nABa = PSignFFMA(Ra@negate,srcConst@negate);

      Sync=S;

      !Nenc95;
      ABC = 1;


 CLASS "DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb
                    ',' [!]Predicate:Pa;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DMNMXfmaX_pipe =  0b00001_0_001;
        DMNMX =  0b00001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc96;
      ABC=0;


 CLASS "Imm DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                    ',' [!]Predicate:Pa;

    CONDITIONS
         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DMNMXfmaX_pipe =  0b00001_0_001;
        DMNMX =  0b00001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc96;
      ABC = 3;


 CLASS "Const DMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                    ',' [!]Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Rd)+((Rd)==63)))
        && IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

    OPCODES
        DMNMXfmaX_pipe =  0b00001_0_001;
        DMNMX =  0b00001_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc96;
      ABC = 1;


CLASS "DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETfmaX_pipe =  0b0010_0_001;
        DSET =  0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;




      !BFiller;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETfmaX_pipe =  0b0010_0_001;
        DSET =  0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;




      !BFiller;
      Sync=S;
      ABC=0;


CLASS "Imm DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETfmaX_pipe =  0b0010_0_001;
        DSET =  0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;





      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETfmaX_pipe =  0b0010_0_001;
        DSET =  0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;





      Sync=S;
      ABC = 3;


CLASS "Const DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETfmaX_pipe =  0b0010_0_001;
        DSET =  0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;





      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const DSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETfmaX_pipe =  0b0010_0_001;
        DSET =  0b0010_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;





      Sync=S;
      ABC = 1;


CLASS "DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETPfmaX_pipe =  0b0011_0_001;
        DSETP =  0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETPfmaX_pipe =  0b0011_0_001;
        DSETP =  0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;


CLASS "Imm DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETPfmaX_pipe =  0b0011_0_001;
        DSETP =  0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;



      !Nenc88;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETPfmaX_pipe =  0b0011_0_001;
        DSETP =  0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;



      !Nenc88;
      Sync=S;
      ABC = 3;


CLASS "Const DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETPfmaX_pipe =  0b0011_0_001;
        DSETP =  0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;



      !Nenc88;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const DSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))
         : "Register is out of range"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for DSET"

    OPCODES
        DSETPfmaX_pipe =  0b0011_0_001;
        DSETP =  0b0011_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;



      !Nenc88;
      Sync=S;
      ABC = 1;


CLASS "DCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
        && IsEven(((Rb)+((Rb)==63)))
         : "Register numbers must be even for double float operations"

    OPCODES
        DCHKfmaX_pipe =  0b00111_0_001;
        DCHK =  0b00111_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      ChkModeF = mode;

      !BFiller;
      !Nenc125;
      Sync=S;
      ABC=0;




CLASS "Imm DCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;
    CONDITIONS
         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

    OPCODES
        DCHKfmaX_pipe =  0b00111_0_001;
        DCHK =  0b00111_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      ChkModeF = mode;


      !Nenc125;
      Sync=S;
      ABC = 3;




CLASS "Const DCHK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ChkMode:mode /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           IsEven(((Ra)+((Ra)==63)))
         : "Register numbers must be even for double float operations"

    OPCODES
        DCHKfmaX_pipe =  0b00111_0_001;
        DCHK =  0b00111_0_001;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      ChkModeF = mode;


      !Nenc125;
      Sync=S;
      ABC = 1;




 CLASS "FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
                                       ',' [-]Register:Rc;
    CONDITIONS

    OPCODES
        FFMAfau_pipe =  0b00110_0_000;
        FFMAfmaliteW_pipe =  0b00110_0_000;
        FFMAfmaX_pipe =  0b00110_0_000;
        FFMA =  0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = Rc@negate;
      Pipe2c = pipe2;
      Sync=S;
      !BFiller;
      ABC=0;


 CLASS "Imm FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg
                                       ',' [-]Register:Rc;
    CONDITIONS

    OPCODES
        FFMAfau_pipe =  0b00110_0_000;
        FFMAfmaliteW_pipe =  0b00110_0_000;
        FFMAfmaX_pipe =  0b00110_0_000;
        FFMA =  0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,UnaryNeg);
      nB1 = Rc@negate;
      Pipe2c = pipe2;
      Sync=S;

      ABC = 3;


 CLASS "Const FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' [-]Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        FFMAfau_pipe =  0b00110_0_000;
        FFMAfmaliteW_pipe =  0b00110_0_000;
        FFMAfmaX_pipe =  0b00110_0_000;
        FFMA =  0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,srcConst@negate);
      nB1 = Rc@negate;
      Pipe2c = pipe2;
      Sync=S;

      ABC = 1;


 CLASS "Const1 FFMA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Round1(RN):rnd /SAT(noSAT):sat
           /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb
',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        FFMAfau_pipe =  0b00110_0_000;
        FFMAfmaliteW_pipe =  0b00110_0_000;
        FFMAfmaX_pipe =  0b00110_0_000;
        FFMA =  0b00110_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Sat = SAT;
      FMZ = FMZ;
      Rnd1 = Round1;
      nA1 = PSignFFMA(Ra@negate,Rb@negate);
      nB1 = srcConst@negate;
      Pipe2c = pipe2;
      Sync=S;

      ABC = 2;


 CLASS "FFMA32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):fImm
                                       ',' [-]Register:Rc;
    CONDITIONS
         ERROR
           Rd == Rc :
             "Output register must be the same as last input register"

    OPCODES
        FFMA32Ifau_pipe =  0b00100_0_010;
        FFMA32IfmaliteW_pipe =  0b00100_0_010;
        FFMA32IfmaX_pipe =  0b00100_0_010;
        FFMA32I =  0b00100_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = IDENTICAL(Rd,Rc);
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZ = FMZ;
      Sat = SAT;
      nA1 = Ra@negate;
      nB1 = Rc@negate;

      Sync=S;

 ALTERNATE CLASS "FFMA32I 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):fImm;
    CONDITIONS

    OPCODES
        FFMA32Ifau_pipe =  0b00100_0_010;
        FFMA32IfmaliteW_pipe =  0b00100_0_010;
        FFMA32IfmaX_pipe =  0b00100_0_010;
        FFMA32I =  0b00100_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZ = FMZ;
      Sat = SAT;
      nA1 = Ra@negate;
      nB1 = 0;

      Sync=S;

 CLASS "FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb;

    CONDITIONS

    OPCODES
        FADDfau_pipe =  0b01010_0_000;
        FADDfmaliteW_pipe =  0b01010_0_000;
        FADDfmaX_pipe =  0b01010_0_000;
        FADD =  0b01010_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Sat2 = SAT;
      FTZ1 = FTZ;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      Pipe2c = pipe2;
      Sync=S;
      !BFiller;
      !Nenc81;
      ABC=0;


 CLASS "Imm FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS

    OPCODES
        FADDfau_pipe =  0b01010_0_000;
        FADDfmaliteW_pipe =  0b01010_0_000;
        FADDfmaX_pipe =  0b01010_0_000;
        FADD =  0b01010_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Sat2 = SAT;
      FTZ1 = FTZ;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      Pipe2c = pipe2;
      Sync=S;

      !Nenc81;
      ABC = 3;


 CLASS "Const FADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Round1(RN):rnd /SAT(noSAT):sat
             /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        FADDfau_pipe =  0b01010_0_000;
        FADDfmaliteW_pipe =  0b01010_0_000;
        FADDfmaX_pipe =  0b01010_0_000;
        FADD =  0b01010_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Sat2 = SAT;
      FTZ1 = FTZ;
      Rnd1 = Round1;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      Pipe2c = pipe2;
      Sync=S;

      !Nenc81;
      ABC = 1;


 CLASS "FADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F32Imm(64):fImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    OPCODES
        FADD32Ifau_pipe =  0b00101_0_010;
        FADD32IfmaliteW_pipe =  0b00101_0_010;
        FADD32IfmaX_pipe =  0b00101_0_010;
        FADD32I =  0b00101_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;


 CLASS "FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register:Rb
                                       ',' Register:Rc;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
        FCMPfau_pipe =  0b00111_0_000;
        FCMPxlu_pipe =  0b00111_0_000;
        FCMP =  0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;
      !BFiller;
      !Nenc83;
      ABC=0;


 CLASS "Imm FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' F32Imm(64):uImm
                                       ',' Register:Rc;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
        FCMPfau_pipe =  0b00111_0_000;
        FCMPxlu_pipe =  0b00111_0_000;
        FCMP =  0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;

      !Nenc83;
      ABC = 3;


 CLASS "Const FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                       ',' Register:Rc;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
        FCMPfau_pipe =  0b00111_0_000;
        FCMPxlu_pipe =  0b00111_0_000;
        FCMP =  0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;

      !Nenc83;
      ABC = 1;


 CLASS "Const1 FCMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test(GT):fcomp /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register:Rb
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FCMP"

    OPCODES
        FCMPfau_pipe =  0b00111_0_000;
        FCMPxlu_pipe =  0b00111_0_000;
        FCMP =  0b00111_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;

      FTZ1 = FTZ;
      FComp = Test;
      !Pipe2b;

      Sync=S;
      !nB1;

      !Nenc83;
      ABC = 2;


 CLASS "FSWZ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /SWZMode:swz /FTZ(noFTZ):ftz /Round1(RN):rnd /NDV(noNDV):ndv /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb
                    ',' PNWord:uImm;
    OPCODES
        FSWZfmaX_pipe =  0b01001_0_000;
        FSWZ =  0b01001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Rnd1 = Round1;
      FTZ1 = FTZ;
      NDV = NDV;
      SWZMode = SWZMode;
      PNWord = PNWord;

      Sync=S;
      !Nenc86;



 CLASS "FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb;

    CONDITIONS

    OPCODES
        FMULfau_pipe =  0b01011_0_000;
        FMULfmaliteW_pipe =  0b01011_0_000;
        FMULfmaX_pipe =  0b01011_0_000;
        FMUL =  0b01011_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;

      FMZ = FMZ;
      Scale = Scale;
      Rnd1 = Round1;
      Sat = SAT;
      Pipe2 = pipe2;
      nAB = PSignFFMA(Ra@negate,Rb@negate);

      Sync=S;
      !BFiller;
      !Nenc84;
      ABC=0;


 CLASS "Imm FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS

    OPCODES
        FMULfau_pipe =  0b01011_0_000;
        FMULfmaliteW_pipe =  0b01011_0_000;
        FMULfmaX_pipe =  0b01011_0_000;
        FMUL =  0b01011_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;

      FMZ = FMZ;
      Scale = Scale;
      Rnd1 = Round1;
      Sat = SAT;
      Pipe2 = pipe2;
      nAB = PSignFFMA(Ra@negate,UnaryNeg);

      Sync=S;

      !Nenc84;
      ABC = 3;


 CLASS "Const FMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /Scale(NONE):scale
                                  /Round1(RN):rnd /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        FMULfau_pipe =  0b01011_0_000;
        FMULfmaliteW_pipe =  0b01011_0_000;
        FMULfmaX_pipe =  0b01011_0_000;
        FMUL =  0b01011_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;

      FMZ = FMZ;
      Scale = Scale;
      Rnd1 = Round1;
      Sat = SAT;
      Pipe2 = pipe2;
      nAB = PSignFFMA(Ra@negate,srcConst@negate);

      Sync=S;

      !Nenc84;
      ABC = 1;


 CLASS "FMUL32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FMZ(noFTZ):fmz /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' F32Imm(64):fImm;

    OPCODES
        FMUL32Ifau_pipe =  0b00110_0_010;
        FMUL32IfmaliteW_pipe =  0b00110_0_010;
        FMUL32IfmaX_pipe =  0b00110_0_010;
        FMUL32I =  0b00110_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = fImm;
      WriteCCI = writeCC;
      FMZ = FMZ;
      Sat = SAT;
      Pipe2 = pipe2;
      Sync=S;


 CLASS "FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' [-][||]Register:Rb
                    ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        FMNMXfau_pipe =  0b00001_0_000;
        FMNMXfmaX_pipe =  0b00001_0_000;
        FMNMX =  0b00001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc24;
      ABC=0;


 CLASS "Imm FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Ra ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                    ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        FMNMXfau_pipe =  0b00001_0_000;
        FMNMXfmaX_pipe =  0b00001_0_000;
        FMNMX =  0b00001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc24;
      ABC = 3;


 CLASS "Const FMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]Register:Ra ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                    ',' [!]Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        FMNMXfau_pipe =  0b00001_0_000;
        FMNMXfmaX_pipe =  0b00001_0_000;
        FMNMX =  0b00001_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      SrcPred = Pa;
      SrcNot = Pa@not;
      FTZ1 = FTZ;
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc24;
      ABC = 1;


 CLASS "FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
             ',' Register:Ra ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    OPCODES
        FCCOfmaX_pipe =  0b01000_0_000;
        FCCO =  0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      ABC=0;
      !Nenc87;
      !BFiller;


 CLASS "Imm FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
             ',' Register:Ra ',' F32Imm(64):uImm ',' Register(RZ):Rc;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    OPCODES
        FCCOfmaX_pipe =  0b01000_0_000;
        FCCO =  0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      ABC = 3;
      !Nenc87;



 CLASS "Const FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register(RZ):Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    OPCODES
        FCCOfmaX_pipe =  0b01000_0_000;
        FCCO =  0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      CMode = CMode;

      Sync=S;
      ABC = 1;
      !Nenc87;



 CLASS "Const1 FCCO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CMode:cmode /S(noS):sync
             Predicate:Pd ',' Predicate(P0):nPd
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    OPCODES
        FCCOfmaX_pipe =  0b01000_0_000;
        FCCO =  0b01000_0_000;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      CMode = CMode;

      Sync=S;
      ABC = 2;
      !Nenc87;



CLASS "FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETfau_pipe =  0b0001_0_000;
        FSETfmaX_pipe =  0b0001_0_000;
        FSET =  0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      FTZ2 = FTZ;


      !BFiller;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETfau_pipe =  0b0001_0_000;
        FSETfmaX_pipe =  0b0001_0_000;
        FSET =  0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      FTZ2 = FTZ;


      !BFiller;
      Sync=S;
      ABC=0;


CLASS "Imm FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETfau_pipe =  0b0001_0_000;
        FSETfmaX_pipe =  0b0001_0_000;
        FSET =  0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETfau_pipe =  0b0001_0_000;
        FSETfmaX_pipe =  0b0001_0_000;
        FSET =  0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 3;


CLASS "Const FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETfau_pipe =  0b0001_0_000;
        FSETfmaX_pipe =  0b0001_0_000;
        FSET =  0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      BVal = BVal;
      Bop = bopopt;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const FSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETfau_pipe =  0b0001_0_000;
        FSETfmaX_pipe =  0b0001_0_000;
        FSET =  0b0001_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      BVal = BVal;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      Sync=S;
      ABC = 1;


CLASS "FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETPfau_pipe =  0b0010_0_000;
        FSETPfmaX_pipe =  0b0010_0_000;
        FSETP =  0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      FTZ2 = FTZ;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;


ALTERNATE CLASS "NoBop FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' [-][||]Register:Rb
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETPfau_pipe =  0b0010_0_000;
        FSETPfmaX_pipe =  0b0010_0_000;
        FSETP =  0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      nA1 = Ra@negate;
      nB1 = Rb@negate;
      aA1 = Ra@absolute;
      aB1 = Rb@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      FTZ2 = FTZ;


      !BFiller;
      !Nenc88;
      Sync=S;
      ABC=0;


CLASS "Imm FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ',' [!]Predicate:Pa;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETPfau_pipe =  0b0010_0_000;
        FSETPfmaX_pipe =  0b0010_0_000;
        FSETP =  0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 3;


ALTERNATE CLASS "NoBop Imm FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
                                    ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs
                                    ;
    CONDITIONS
         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETPfau_pipe =  0b0010_0_000;
        FSETPfmaX_pipe =  0b0010_0_000;
        FSETP =  0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Bconst=uImm;
      nA1 = Ra@negate;
      nB1 = UnaryNeg;
      aA1 = Ra@absolute;
      aB1 = UnaryAbs;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 3;


CLASS "Const FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ',' [!]Predicate:Pa;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETPfau_pipe =  0b0010_0_000;
        FSETPfmaX_pipe =  0b0010_0_000;
        FSETP =  0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop = bopopt;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 1;


ALTERNATE CLASS "NoBop Const FSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Test:fcomp /FTZ(noFTZ):ftz /S(noS):sync
                               Predicate:Pd
                                    ',' [-][||]Register:Ra
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]
                                    ;
    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           Test <= `Test@T :
             "Comparison operator is not allowed for FSET"

    OPCODES
        FSETPfau_pipe =  0b0010_0_000;
        FSETPfmaX_pipe =  0b0010_0_000;
        FSETP =  0b0010_0_000;

    ENCODING
      Opcode26 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nA1 = Ra@negate;
      nB1 = srcConst@negate;
      aA1 = Ra@absolute;
      aB1 = srcConst@absolute;
      FComp = Test;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop = `Bop@AND;
      FTZ2 = FTZ;



      !Nenc88;
      Sync=S;
      ABC = 1;


 CLASS "IPA 1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register:Rb ',' Register(RZ):Rc ;

    CONDITIONS
        ERROR
            ((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) -> (Rb == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (msi != `MSI@OFFSET) -> (Rc == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b11000_0_000;
        IPA =  0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      RegC = Rc;
      Imm11 = sImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc89;


 CLASS "I IPA 1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register:Rb ',' Register(RZ):Rc ;

    CONDITIONS
        ERROR
            ((ipaop == `IPAOp@PASS) || (ipaop == `IPAOp@CONSTANT)) -> (Rb == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (msi != `MSI@OFFSET) -> (Rc == `Register@RZ):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b11000_0_000;
        IPA =  0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      RegC = Rc;
      Imm10 = uImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc113;


 ALTERNATE CLASS "IPA 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm] ;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b11000_0_000;
        IPA =  0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      Imm11 = sImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc89;


 ALTERNATE CLASS "I IPA 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IPAOp(MUL):ipaop /MSI(CENTER):msi /SAT(noSAT):sat /S(noS):sync
             Register:Rd
             ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm] ;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register out of range"

    OPCODES
        IPAsu_pipe =  0b11000_0_000;
        IPA =  0b11000_0_000;

    ENCODING
      Opcode29 = Opcode;
      IPAOp = IPAOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = `Register@RZ;
      RegC = `Register@RZ;
      Imm10 = uImm;
      MSI = MSI;
      Sat = SAT;
      Sync=S;
      !Nenc113;


 CLASS "RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
             Register:Rd ',' [-][||]Register:Rb;

    CONDITIONS

    OPCODES
        RROfmaX_pipe =  0b01100_0_000;
        RRO =  0b01100_0_000;

    ENCODING
      Opcode29 = Opcode;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      !nA1;
      nB1 = Rb@negate;
      !aA1;
      aB1 = Rb@absolute;

      Sync=S;
      !BFiller;
      !Nenc90;
      ABC=0;


 CLASS "Imm RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
             Register:Rd ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs;

    CONDITIONS

    OPCODES
        RROfmaX_pipe =  0b01100_0_000;
        RRO =  0b01100_0_000;

    ENCODING
      Opcode29 = Opcode;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      !nA1;
      nB1 = UnaryNeg;
      !aA1;
      aB1 = UnaryAbs;

      Sync=S;

      !Nenc90;
      ABC = 3;


 CLASS "Const RRO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /RROOp:rroop /S(noS):sync
Register:Rd ',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        RROfmaX_pipe =  0b01100_0_000;
        RRO =  0b01100_0_000;

    ENCODING
      Opcode29 = Opcode;
      RROOp = RROOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !nA1;
      nB1 = srcConst@negate;
      !aA1;
      aB1 = srcConst@absolute;

      Sync=S;

      !Nenc90;
      ABC = 1;


 CLASS "MUFU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MufuOp:mufu /SAT(noSAT):sat /S(noS):sync
             Register:Rd ',' [-][||]Register:Ra;

    OPCODES
        MUFUfu_pipe =  0b11001_0_000;
        MUFU =  0b11001_0_000;

    ENCODING
      Opcode29 = Opcode;
      MufuOp = MufuOp;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      nA1 = Ra@negate;
      aA1 = Ra@absolute;
      Sat = SAT;

      Sync=S;
      !Nenc92;




CLASS "F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      RndIR = rnd;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      RndIR = rnd;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 1"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1("F32.F32"):fmts
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1:fmts
##ENDIF
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
            "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      RndIR = rnd;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"

         ERROR
           (ftz == `FTZ@FTZ) -> (fmts != `F2Ffmts2@"F64.F32"):
             ".FTZ cannot be used with F64 source"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))): "Register B is out of range"

         ERROR
            ((fmts != `F2Ffmts2@"F64.F32") && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
              "Register D is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      Rnd = rnd;
      !IR;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"

         ERROR
           (ftz == `FTZ@FTZ) -> (fmts != `F2Ffmts2@"F64.F32"):
             ".FTZ cannot be used with F64 source"


         ERROR
            ((fmts != `F2Ffmts2@"F64.F32") && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
              "Register D is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      Rnd = rnd;
      !IR;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

         ERROR
           ( fmts == `F2Ffmts2@"F64.F32" ) -> (sat == `SAT@noSAT):
             "F64 cannot be used with SAT"

         ERROR
           (ftz == `FTZ@FTZ) -> (fmts != `F2Ffmts2@"F64.F32"):
             ".FTZ cannot be used with F64 source"


         ERROR
            ((fmts != `F2Ffmts2@"F64.F32") && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
              "Register D is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      Rnd = rnd;
      !IR;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (ftz != `FTZ@FTZ):
             ".FTZ cannot be used with F16.F16"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      RndIR = rnd;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (ftz != `FTZ@FTZ):
             ".FTZ cannot be used with F16.F16"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      RndIR = rnd;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 1 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_16:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (ftz != `FTZ@FTZ):
             ".FTZ cannot be used with F16.F16"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      RndIR = rnd;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      Rnd = rnd;
      !IR;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;

CLASS "Imm F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      Rnd = rnd;
      !IR;
      ABC = 3;

      Sync=S;
      !Nenc7;

CLASS "Const F2F 2 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_16:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts != `F2Ffmts2_16@"F64.F16" ) :
             "F16 cannot be converted to F64"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      Rnd = rnd;
      !IR;
      ABC = 1;

      Sync=S;
      !Nenc7;

CLASS "F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rb)+((Rb)==63))) :
             "F64 as source format requires an even source register"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      RndIR = rnd;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      RndIR = rnd;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 1 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts1_64:fmts
                                /F2FRound1(PASS):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts == `F2Ffmts1_64@"F64.F64" ) -> IsEven(((Rd)+((Rd)==63))) :
             "F64 as destination format requires an even destination register"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      RndIR = rnd;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"
         ERROR
           ( fmts == `F2Ffmts2_64@"F32.F64" ) -> IsEven(((Rb)+((Rb)==63))) :
             "F64 as source format requires an even source register"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      Rnd = rnd;
      !IR;
      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc7;


CLASS "Imm F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs/H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      Rnd = rnd;
      !IR;
      ABC = 3;

      Sync=S;
      !Nenc7;


CLASS "Const F2F 2 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /F2Ffmts2_64:fmts
                                /F2FRound2(RN):rnd
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset]/H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           ( fmts != `F2Ffmts2_64@"F16.F64" ) :
             "F64 cannot be converted to F16"

         ERROR
           sat == `SAT@noSAT:
             "F64 cannot be used with SAT"

         ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
             :
              "Register is out of range"

    OPCODES
        F2FfmaX_pipe =  0b000100_0_100;
        F2F =  0b000100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      SrcDstFmt =* fmts;

      FTZ = FTZ;
      Sat = SAT;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      Rnd = rnd;
      !IR;
      ABC = 1;

      Sync=S;
      !Nenc7;


CLASS "F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /Integer(S32):dstfmt /Float32(F32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))): "Register B is out of range"

         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc8;

CLASS "Imm F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /Integer(S32):dstfmt /Float32(F32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F32Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc8;

CLASS "Const F2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz { /Integer(S32):dstfmt /Float32(F32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float32:srcfmt
##ENDIF
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"
         ERROR
           (halfsel == `H1H0@H0) :
             "H1 is only allowed for an F16 source"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc8;

CLASS "F2I 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

         ERROR
           ftz == `FTZ@noFTZ:
             "F16 cannot be used with FTZ"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))): "Register B is out of range"

         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc8;


CLASS "Imm F2I 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F16Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

         ERROR
           ftz == `FTZ@noFTZ:
             "F16 cannot be used with FTZ"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc8;


CLASS "Const F2I 16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float16:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) != `Integer@U64):
             "F16 cannot be converted to U64/S64"

         ERROR
           ftz == `FTZ@noFTZ:
             "F16 cannot be used with FTZ"


         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc8;


CLASS "F2I 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"

         ERROR
           (srcfmt == `Float64@F64) -> IsEven(((Rb)+((Rb)==63))) :
             "F64 as source format requires an even source register"

         ERROR (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))): "Register B is out of range"

         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

         ERROR
           ftz == `FTZ@noFTZ:
             "F64 cannot be used with FTZ"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc8;


CLASS "Imm F2I 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' F64Imm(64):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /H1H0(H0):halfsel;

    CONDITIONS
         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"



         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

         ERROR
           ftz == `FTZ@noFTZ:
             "F64 cannot be used with FTZ"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc8;


CLASS "Const F2I 64"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /FTZ(noFTZ):ftz /Integer:dstfmt /Float64:srcfmt
                                /Round3(ROUND):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /H1H0(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U16) -> (srcfmt != `Float64@F64) :
             "F64 cannot be converted to S16/U16"

         ERROR
           (((dstfmt)&0xfe) == `Integer@U64) -> IsEven(((Rd)+((Rd)==63))) :
             "U64/S64 as destination format requires an even destination register"



         ERROR
           ((((dstfmt)&0xfe) != `Integer@U64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2))):
             "Register D is out of range"

         ERROR
           (halfsel == `H1H0@H0) :
             "HI is only allowed for an F16 source"

         ERROR
           ftz == `FTZ@noFTZ:
             "F64 cannot be used with FTZ"

    OPCODES
        F2IfmaX_pipe =  0b000101_0_100;
        F2I =  0b000101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      SrcFmt =* srcfmt;

      FTZ = FTZ;
      Rnd = Round3;
      WriteCC = writeCC;
      H1H0 = H1H0;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc8;


CLASS "MOV32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             UImm(32)*:uImm ',' UImm(4/0xf):quadMask;

    CONDITIONS

        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        MOV32Ifau_pipe =  0b00011_0_010;
        MOV32IfmaliteW_pipe =  0b00011_0_010;
        MOV32IfmaX_pipe =  0b00011_0_010;
        MOV32Ifu_pipe =  0b00011_0_010;
        MOV32Ixlu_pipe =  0b00011_0_010;
        MOV32I =  0b00011_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Imm32 = uImm;
      QuadMask = quadMask;

      Sync=S;
      !Nenc12;


CLASS "MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW):pipe /S(noS):sync
             Register:Rd ','
             Register:Rb ',' UImm(4/0xf):quadMask;

    CONDITIONS

        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register is out of range"

    OPCODES
        MOVfau_pipe =  0b001010_0_100;
        MOVfmaliteW_pipe =  0b001010_0_100;
        MOVfmaX_pipe =  0b001010_0_100;
        MOVfu_pipe =  0b001010_0_100;
        MOVxlu_pipe =  0b001010_0_100;
        MOV =  0b001010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      QuadMask = quadMask;
      Pipe2a = Pipe2;

      Sync=S;
      !Nenc13;
      ABC=0;
      !BFiller;


CLASS "Imm MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW):pipe /S(noS):sync
             Register:Rd ','
             SImm(20):uImm ',' UImm(4/0xf):quadMask;

    CONDITIONS

        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
           :
                "Register is out of range"

    OPCODES
        MOVfau_pipe =  0b001010_0_100;
        MOVfmaliteW_pipe =  0b001010_0_100;
        MOVfmaX_pipe =  0b001010_0_100;
        MOVfu_pipe =  0b001010_0_100;
        MOVxlu_pipe =  0b001010_0_100;
        MOV =  0b001010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      QuadMask = quadMask;
      Pipe2a = Pipe2;

      Sync=S;
      !Nenc13;
      ABC = 3;



CLASS "Const MOV"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Pipe2(HW):pipe /S(noS):sync
             Register:Rd ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' UImm(4/0xf):quadMask;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


        ERROR
            (sync == `S@S) -> (quadMask == 0xf):
                "Illegal instruction encoding, PixMaskU04=0xf and .S used together"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
           :
                "Register is out of range"

    OPCODES
        MOVfau_pipe =  0b001010_0_100;
        MOVfmaliteW_pipe =  0b001010_0_100;
        MOVfmaX_pipe =  0b001010_0_100;
        MOVfu_pipe =  0b001010_0_100;
        MOVxlu_pipe =  0b001010_0_100;
        MOV =  0b001010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      QuadMask = quadMask;
      Pipe2a = Pipe2;

      Sync=S;
      !Nenc13;
      ABC = 1;



CLASS "SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             [!] Predicate:Pa;

    CONDITIONS

    OPCODES
        SELfau_pipe =  0b001000_0_100;
        SELxlu_pipe =  0b001000_0_100;
        SEL =  0b001000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !Nenc14;
      ABC=0;
      !BFiller;

CLASS "Imm SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             [!] Predicate:Pa;

    CONDITIONS

    OPCODES
        SELfau_pipe =  0b001000_0_100;
        SELxlu_pipe =  0b001000_0_100;
        SEL =  0b001000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !Nenc14;
      ABC = 3;


CLASS "Const SEL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             [!] Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        SELfau_pipe =  0b001000_0_100;
        SELxlu_pipe =  0b001000_0_100;
        SEL =  0b001000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;

      Sync=S;
      !Nenc14;
      ABC = 1;


CLASS "S2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             SpecialRegister:SR;

    CONDITIONS
        ERROR
            ((SR < 41) || (SR > 47)):
                "SR41 - SR47 are invalid on SM3"

    OPCODES
        S2Rfau_pipe =  0b001011_0_100;
        S2Rxlu_pipe =  0b001011_0_100;
        S2R =  0b001011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      SReg = SR;
      !Pipe2;
      Sync=S;
      !Nenc15;





  CLASS "B2R BAR imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdBAR(BAR):barmd /S(noS):sync
             Register:Rd ','
             UImm(4):barNum;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        B2Rfe_pipe =  0b001110_0_100;
        B2R =  0b001110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Barmd =* BarmdBAR;
      !DstPred;
      Dest = Rd;
      RegA = barNum;
      Sync=S;
      !Nenc116;
      AFix_BAR=0;


  CLASS "B2R BAR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdBAR(BAR):barmd /S(noS):sync
             Register:Rd ','
             Register:Ra;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        B2Rfe_pipe =  0b001110_0_100;
        B2R =  0b001110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Barmd =* BarmdBAR;
      !DstPred;
      Dest = Rd;
      RegA = Ra;
      Sync=S;
      !Nenc116;
      AFix_BAR=1;





 CLASS "B2R RESULT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdRESULT:barmd /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        B2Rfe_pipe =  0b001110_0_100;
        B2R =  0b001110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Barmd =* BarmdRESULT;
      DstPred = Pd;
      Dest = Rd;
      !RegA;
      Sync=S;
      !Nenc116;
      AFix_BAR=0;



 CLASS "B2R WARP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarmdWARP:barmd /S(noS):sync
             Register:Rd;

    CONDITIONS
        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
                "Register D is out of range"

    OPCODES
        B2Rfe_pipe =  0b001110_0_100;
        B2R =  0b001110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Barmd =* BarmdWARP;
      !DstPred;
      Dest = Rd;
      !RegA;
      Sync=S;
      !Nenc116;
      AFix_BAR=0;
CLASS "P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
        P2Rxlu_pipe =  0b001100_0_100;
        P2R =  0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC=0;
      !BFiller;

CLASS "Imm P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
        P2Rxlu_pipe =  0b001100_0_100;
        P2R =  0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC = 3;


CLASS "Const P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        P2Rxlu_pipe =  0b001100_0_100;
        P2R =  0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC = 1;


ALTERNATE CLASS "Simple P2R"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             Register:Rd ',' PR:Pr;

    CONDITIONS

    OPCODES
        P2Rxlu_pipe =  0b001100_0_100;
        P2R =  0b001100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = `Register@RZ;
      Bconst = 0xFFFF;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc17;
      ABC = 3;

 CLASS "R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             PR:Pr ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
        R2Pxlu_pipe =  0b001101_0_100;
        R2P =  0b001101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc18;
      !BFiller;
      ABC = 0;

 CLASS "Imm R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
             PR:Pr ',' Register:Ra ',' UImm(20/0xffff):uImm;

    CONDITIONS

    OPCODES
        R2Pxlu_pipe =  0b001101_0_100;
        R2P =  0b001101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Bconst = uImm;
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc18;
      ABC = 3;

 CLASS "Const R2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /H1H0(H0):halfsel /S(noS):sync
PR:Pr ',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
        ERROR constBank <= 17 :
              "Only constant banks 0..17 are legal"
        ERROR (immConstOffset & 0x3) == 0 :
              "Constant offsets must be aligned on a 4B boundary"

    OPCODES
        R2Pxlu_pipe =  0b001101_0_100;
        R2P =  0b001101_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      !Bgap;

BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      H1H0a = H1H0;
      Sync=S;
      !Nenc18;
      ABC = 1;

 CLASS "PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
             Register:Rb ',' Register:Rc;

    CONDITIONS

    OPCODES
        PRMTfau_pipe =  0b001001_0_100;
        PRMTxlu_pipe =  0b001001_0_100;
        PRMT =  0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      !Pipe2a;
      PMode = PMode;
      Sync=S;
      !BFiller;
      !Nenc19;
      ABC=0;




 CLASS "Imm PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
             SImm(20):uImm ',' Register:Rc;

    CONDITIONS

    OPCODES
        PRMTfau_pipe =  0b001001_0_100;
        PRMTxlu_pipe =  0b001001_0_100;
        PRMT =  0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      !Pipe2a;
      PMode = PMode;
      Sync=S;

      !Nenc19;
      ABC = 3;




 CLASS "Const PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        PRMTfau_pipe =  0b001001_0_100;
        PRMTxlu_pipe =  0b001001_0_100;
        PRMT =  0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      !Pipe2a;
      PMode = PMode;
      Sync=S;

      !Nenc19;
      ABC = 1;




 CLASS "Const1 PRMT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PMode(IDX):prmt /S(noS):sync
             Register:Rd ',' Register:Ra ','
Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        PRMTfau_pipe =  0b001001_0_100;
        PRMTxlu_pipe =  0b001001_0_100;
        PRMT =  0b001001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      !Pipe2a;
      PMode = PMode;
      Sync=S;

      !Nenc19;
      ABC = 2;




 CLASS "IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
            ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "It is illegal to negate both sources at the same time."

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    OPCODES
        IADDfau_pipe =  0b01001_0_011;
        IADDxlu_pipe =  0b01001_0_011;
        IADD =  0b01001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,Rb@negate);
      Xm = xmode;

      Sync=S;
      !BFiller;
      !Nenc20;
      ABC=0;

 CLASS "Imm IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
            ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    OPCODES
        IADDfau_pipe =  0b01001_0_011;
        IADDxlu_pipe =  0b01001_0_011;
        IADD =  0b01001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,UnaryNeg);
      Xm = xmode;

      Sync=S;

      !Nenc20;
      ABC = 3;

 CLASS "Const IADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
            ) ) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !srcConst@negate) :
             "It is illegal to negate both sources at the same time."

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    OPCODES
        IADDfau_pipe =  0b01001_0_011;
        IADDxlu_pipe =  0b01001_0_011;
        IADD =  0b01001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Sat = SAT;
      PSign = PSign(PO,Ra@negate,srcConst@negate);
      Xm = xmode;

      Sync=S;

      !Nenc20;
      ABC = 1;

##IF !DEFINED(ARCH_SEMANTICS)


 CLASS "ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), %%Register(Ra) , -%%Register(Rb)";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Imm ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), %%Register(Ra) , uImm .NEG";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Imm ISUB1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm ',' Register:Ra;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), -%%Register(Ra) , uImm";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Const ISUB"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), %%Register(Ra) , -C[constBank][immConstOffset]";

##ENDIF
##IF !DEFINED(ARCH_SEMANTICS)
 CLASS "Const ISUB1"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /Pipe2(HW)@:pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Ra;
    OPCODES
        ISUBfau_pipe =  0;
        ISUBxlu_pipe =  0;
        ISUB =  0;
    REMAP "@%%Predicate(Pg) IADD  .%%PO(po) .%%SAT(sat) .%%X(xmode) .%%Pipe2(pipe2) .%%S(sync) %%Register(Rd) .%%optCC(writeCC), -%%Register(Ra) , C[constBank][immConstOffset]";
##ENDIF


 CLASS "IADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(32):sImm;

    CONDITIONS
         ERROR
           (PO -> !X) && (X ->!PO) :
             ".PO and .X cannot be simultaneously specified"
         ERROR
           (PO -> !Ra@negate) :
             ".PO cannot be used with '-' on either input"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"

    OPCODES
        IADD32Ifau_pipe =  0b00001_0_010;
        IADD32Ixlu_pipe =  0b00001_0_010;
        IADD32I =  0b00001_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      Sat = SAT;
      PSign = PSign32(PO,Ra@negate);
      Xm = xmode;

      Sync=S;
      !Nenc21;


 CLASS "ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb ',' UImm(5):shift;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        ISCADDxlu_pipe =  0b01000_0_011;
        ISCADD =  0b01000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign2 = PSign(PO,Ra@negate,Rb@negate);

      Sync=S;
      !BFiller;
      !Nenc22;
      ABC=0;

 CLASS "Imm ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg ',' UImm(5):shift;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        ISCADDxlu_pipe =  0b01000_0_011;
        ISCADD =  0b01000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Imm5I = shift;
      PSign2 = PSign(PO,Ra@negate,UnaryNeg);

      Sync=S;

      !Nenc22;
      ABC = 3;

 CLASS "Const ISCADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' UImm(5):shift;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        ISCADDxlu_pipe =  0b01000_0_011;
        ISCADD =  0b01000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Imm5I = shift;
      PSign2 = PSign(PO,Ra@negate,srcConst@negate);

      Sync=S;

      !Nenc22;
      ABC = 1;

 CLASS "ISCADD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(32):sImm ',' UImm(5):shift;

    OPCODES
        ISCADD32Ixlu_pipe =  0b01000_0_010;
        ISCADD32I =  0b01000_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      Imm5I = shift;

      Sync=S;


 CLASS "ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS

    OPCODES
        ISADxlu_pipe =  0b00111_0_011;
        ISAD =  0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;
      !BFiller;
      !Nenc23;
      ABC=0;

 CLASS "Imm ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS

    OPCODES
        ISADxlu_pipe =  0b00111_0_011;
        ISAD =  0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc23;
      ABC = 3;

 CLASS "Const ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        ISADxlu_pipe =  0b00111_0_011;
        ISAD =  0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc23;
      ABC = 1;

 CLASS "Const1 ISAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        ISADxlu_pipe =  0b00111_0_011;
        ISAD =  0b00111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc23;
      ABC = 2;

 CLASS "IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        IMNMXfau_pipe =  0b00001_0_011;
        IMNMXxlu_pipe =  0b00001_0_011;
        IMNMX =  0b00001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;
      XMode = XMode;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;
      !BFiller;
      !Nenc24;
      ABC=0;


 CLASS "Imm IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        IMNMXfau_pipe =  0b00001_0_011;
        IMNMXxlu_pipe =  0b00001_0_011;
        IMNMX =  0b00001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;
      XMode = XMode;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc24;
      ABC = 3;


 CLASS "Const IMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /XMode(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [!]Predicate:Pa;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        IMNMXfau_pipe =  0b00001_0_011;
        IMNMXxlu_pipe =  0b00001_0_011;
        IMNMX =  0b00001_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      !Pipe2;
      SrcPred = Pa;
      SrcNot = Pa@not;
      XMode = XMode;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);

      Sync=S;

      !Nenc24;
      ABC = 1;


 CLASS "BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
        BFExlu_pipe =  0b01110_0_011;
        BFE =  0b01110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;

      Sync=S;
      !BFiller;
      !Nenc25;
      ABC=0;


 CLASS "Imm BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
        BFExlu_pipe =  0b01110_0_011;
        BFE =  0b01110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;

      Sync=S;

      !Nenc25;
      ABC = 3;


 CLASS "Const BFE"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        BFExlu_pipe =  0b01110_0_011;
        BFE =  0b01110_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;

      Sync=S;

      !Nenc25;
      ABC = 1;


 CLASS "BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS

    OPCODES
        BFIxlu_pipe =  0b00101_0_011;
        BFI =  0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;

      Sync=S;
      !BFiller;
      !Nenc26;
      ABC=0;


 CLASS "Imm BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS

    OPCODES
        BFIxlu_pipe =  0b00101_0_011;
        BFI =  0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;

      Sync=S;

      !Nenc26;
      ABC = 3;


 CLASS "Const BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        BFIxlu_pipe =  0b00101_0_011;
        BFI =  0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;

      Sync=S;

      !Nenc26;
      ABC = 1;


 CLASS "Const1 BFI"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        BFIxlu_pipe =  0b00101_0_011;
        BFI =  0b00101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;

      Sync=S;

      !Nenc26;
      ABC = 2;


 CLASS "SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
        SHRxlu_pipe =  0b01011_0_011;
        SHR =  0b01011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      XMode = XXHI;
      M = CWMode;

      Sync=S;
      !BFiller;
      !Nenc27;
      ABC=0;


 CLASS "Imm SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
        SHRxlu_pipe =  0b01011_0_011;
        SHR =  0b01011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      XMode = XXHI;
      M = CWMode;

      Sync=S;

      !Nenc27;
      ABC = 3;


 CLASS "Const SHR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /CWMode(C):wmode /XXHI(noX):xmode /BREV(noBREV):brev /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        SHRxlu_pipe =  0b01011_0_011;
        SHR =  0b01011_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      Brev = BREV;
      XMode = XXHI;
      M = CWMode;

      Sync=S;

      !Nenc27;
      ABC = 1;


 CLASS "SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
        SHLxlu_pipe =  0b01100_0_011;
        SHL =  0b01100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      M = CWMode;
      Xm = X;

      Sync=S;
      !BFiller;
      !Nenc28;
      ABC=0;


 CLASS "Imm SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
        SHLxlu_pipe =  0b01100_0_011;
        SHL =  0b01100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      M = CWMode;
      Xm = X;

      Sync=S;

      !Nenc28;
      ABC = 3;


 CLASS "Const SHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CWMode(C):wmode /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        SHLxlu_pipe =  0b01100_0_011;
        SHL =  0b01100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      M = CWMode;
      Xm = X;

      Sync=S;

      !Nenc28;
      ABC = 1;


 CLASS "LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Ra ',' [~]Register:Rb;

    CONDITIONS

    OPCODES
        LOPfau_pipe =  0b01101_0_011;
        LOPxlu_pipe =  0b01101_0_011;
        LOP =  0b01101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = Rb@invert;

      Sync=S;
      !BFiller;
      !Nenc22;
      ABC=0;


 CLASS "Imm LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Ra ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    CONDITIONS

    OPCODES
        LOPfau_pipe =  0b01101_0_011;
        LOPxlu_pipe =  0b01101_0_011;
        LOP =  0b01101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = UnaryInv;

      Sync=S;

      !Nenc22;
      ABC = 3;


 CLASS "Const LOP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /Pipe2(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [~]Register:Ra ',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        LOPfau_pipe =  0b01101_0_011;
        LOPxlu_pipe =  0b01101_0_011;
        LOP =  0b01101_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Pipe2a = Pipe2;
      WriteCC = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = srcConst@invert;

      Sync=S;

      !Nenc22;
      ABC = 1;


 CLASS "LOP32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LOP:lop /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Ra ',' UImm(32):uImm /UnaryInv(noINV):jinv ;

    OPCODES
        LOP32Ifau_pipe =  0b00111_0_010;
        LOP32Ixlu_pipe =  0b00111_0_010;
        LOP32I =  0b00111_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = uImm;
      WriteCCI = writeCC;
      Xm_I = X;
      LOP = LOP;
      nA_L = Ra@invert;
      nB_L = UnaryInv;
      Sync=S;


 CLASS "FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [~]Register:Rb;

    CONDITIONS

    OPCODES
        FLOxlu_pipe =  0b01111_0_011;
        FLO =  0b01111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegB = Rb;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      SH = SH;
      nB_L = Rb@invert;

      Sync=S;
      !BFiller;
      !Nenc30;
      ABC=0;


 CLASS "Imm FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryInv(noINV):jinv;

    CONDITIONS

    OPCODES
        FLOxlu_pipe =  0b01111_0_011;
        FLO =  0b01111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      Bconst=uImm;
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      SH = SH;
      nB_L = UnaryInv;

      Sync=S;

      !Nenc30;
      ABC = 3;


 CLASS "Const FLO"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer32(S32):us32 /SH(noSH):sh /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [~]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        FLOxlu_pipe =  0b01111_0_011;
        FLO =  0b01111_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      Signed = IsSigned(Integer32);
      SH = SH;
      nB_L = srcConst@invert;

      Sync=S;

      !Nenc30;
      ABC = 1;


 CLASS "IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb;

    CONDITIONS

    OPCODES
        IMULfmaX_pipe =  0b01010_0_011;
        IMUL =  0b01010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;
      !BFiller;
      !Nenc40;
      ABC=0;


 CLASS "Imm IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

    OPCODES
        IMULfmaX_pipe =  0b01010_0_011;
        IMUL =  0b01010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;

      !Nenc40;
      ABC = 3;


 CLASS "Const IMUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


    OPCODES
        IMULfmaX_pipe =  0b01010_0_011;
        IMUL =  0b01010_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;

      !Nenc40;
      ABC = 1;


 CLASS "IMUL32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(32):sImm;

    OPCODES
        IMUL32IfmaX_pipe =  0b00010_0_010;
        IMUL32I =  0b00010_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;

      Sync=S;
      !Nenc41;


 CLASS "IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' [-]Register:Rb ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"


    OPCODES
        IMADfmaX_pipe =  0b00100_0_011;
        IMAD =  0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);

      Sync=S;
      !BFiller;
      !Nenc42;
      ABC=0;


 CLASS "Imm IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(20):uImm /UnaryNeg(noNEG):jneg ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> ( !Ra@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"


    OPCODES
        IMADfmaX_pipe =  0b00100_0_011;
        IMAD =  0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,UnaryNeg,Rc@negate);

      Sync=S;

      !Nenc42;
      ABC = 3;


 CLASS "Const IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [-]Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !srcConst@negate
                 && !Rc@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"


    OPCODES
        IMADfmaX_pipe =  0b00100_0_011;
        IMAD =  0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,srcConst@negate,Rc@negate);

      Sync=S;

      !Nenc42;
      ABC = 1;


 CLASS "Const1 IMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po
                       /SAT(noSAT):sat /X(noX):xmode /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-]Register:Ra ',' [-]Register:Rb ',' [-]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (PO -> ( !Ra@negate
                 && !Rb@negate
                 && !srcConst@negate
           ) ) :
             ".PO cannot be used with '-' on either input"

         ERROR
           PO -> (xmode != `X@X):
             ".PO cannot be used with .X"

         ERROR
           (SAT -> (hib != `HILO@LO)):
             ".SAT cannot be used with .LO"

         ERROR
           (SAT -> (IsOdd(us32) && IsOdd(us32b))) :
             ".SAT is not allowed for unsigned inputs"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
            :
             "Register is out of range"


    OPCODES
        IMADfmaX_pipe =  0b00100_0_011;
        IMAD =  0b00100_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      Xm1 = X;
      Sat1 = SAT;
      PSign = PSignMAD(PO,Ra@negate,Rb@negate,srcConst@negate);

      Sync=S;

      !Nenc42;
      ABC = 2;


 CLASS "IMAD32I"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                            { /Integer32(S32):us32 /Integer32(S32):us32b } /HILO(LO):hib /PO(noPO):po /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra ',' SImm(32):sImm ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
            Rd == Rc :
             "Destination register must be the same as input register 3"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
        && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
        && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
             "Register is out of range"

    OPCODES
        IMAD32IfmaX_pipe =  0b00000_0_010;
        IMAD32I =  0b00000_0_010;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = IDENTICAL(Rd,Rc);
      RegA = Ra;
      Imm32 = sImm;
      WriteCCI = writeCC;
      ASigned = IsSigned(us32);
      BSigned = IsSigned(us32b);
      HILO = HILO;
      PSign = PSign(PO,Ra@negate,Rc@negate);

      Sync=S;


CLASS "IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;

      SABCExt =* GetSPExtract(scext, saext, sbext);

      Sync=S;
      !Nenc135;
      !BFiller;
      ABC=0;


CLASS "Imm IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS
         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;

      SABCExt =* GetSPExtract(scext, saext, sbext);

      Sync=S;
      !Nenc135;

      ABC = 3;


CLASS "Const IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;

      SABCExt =* GetSPExtract(scext, saext, sbext);

      Sync=S;
      !Nenc135;

      ABC = 1;


CLASS "Const1 IMADSP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IntegerSPA:saext /IntegerSPB:sbext /IntegerSPC:scext
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            !((IsSPASigned(saext) || IsSPBSigned(sbext)) && !IsSPCSigned(scext)):
               "IMADSP with either .saext and .sbext signed, as well as .scext unsigned is illegal. Either .saext signed or .sbext signed requires that .scext also be signed."

         ERROR
            !(!IsSPASigned(saext) && !IsSPBSigned(sbext) && IsSPCSigned(scext)):
               "IMADSP with both .saext and .sbext unsigned, as well as .scext signed is illegal. Both .saext unsigned and .sbext unsigned requires that .scext also be unsigned."

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;

      SABCExt =* GetSPExtract(scext, saext, sbext);

      Sync=S;
      !Nenc135;

      ABC = 2;


CLASS "IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      WriteCC = writeCC;

      !SAExt;
      !SBExt;
      SCExt =* sd;

      Sync=S;
      !Nenc135;
      !BFiller;
      ABC=0;
CLASS "Imm IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra ',' SImm(20):uImm ',' Register:Rc;

    CONDITIONS
         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      WriteCC = writeCC;

      !SAExt;
      !SBExt;
      SCExt =* sd;

      Sync=S;
      !Nenc135;

      ABC = 3;
CLASS "Const IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      WriteCC = writeCC;

      !SAExt;
      !SBExt;
      SCExt =* sd;

      Sync=S;
      !Nenc135;

      ABC = 1;
CLASS "Const1 IMADSP SD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /IMADSP_SD:sd
                       /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' Register:Ra ',' Register:Rb ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
               "Register is out of range"

    OPCODES
        IMADSPfmaX_pipe =  0b00000_0_011;
        IMADSP =  0b00000_0_011;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      WriteCC = writeCC;

      !SAExt;
      !SBExt;
      SCExt =* sd;

      Sync=S;
      !Nenc135;

      ABC = 2;
 CLASS "STP"
    FORMAT Opcode /STPMode(noWAIT):stpmode /TPhase(noPhase):phase /S(noS):sync UImm(8):uImm;

    OPCODES
        STPfe_pipe =  0b010011_0_100;
        STP =  0b010011_0_100;

    ENCODING
      Opcode18 = Opcode;
      STPMode = STPMode;
      Imm8 = Imm;
      Phase = TPhase;
      !Nenc33;
      Sync=S;



 CLASS "TEX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless /LOD(noLOD):lod /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
##IF DEFINED(ARCH_SEMANTICS)
             UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS







        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) == 2)) || (((tid <= 0x7) && (LOD == `LOD@LZ)) && (ParamA == `ParamA@"2D"))) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 2)) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2)) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2)) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"
        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

        ERROR
            (DC == `DC@DC) -> (ParamA != `ParamA@"_3D"):
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TEX (errata 36)"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )))):
                "Register A is out of range"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"





        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) - 4))):
                "Register B is out of range"

        ERROR
            (!((tid <= 0x7) && (LOD == `LOD@LZ))) -> (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"
    OPCODES
        TEXtex_pipe =  0b1000_0_110;
        TEX =  0b1000_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB = tid;
      Wmsk = wmsk;
      Bindless = bindless;
      LOD = LOD;
      TOFF2 = TOFF2;
      DC = DC;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc29;
      Sync=S;

 ALTERNATE CLASS "TEX Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless /LOD(noLOD):lod /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb ','
##IF DEFINED(ARCH_SEMANTICS)
             UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS







        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) == 2)) || (((tid <= 0x7) && (LOD == `LOD@LZ)) && (ParamA == `ParamA@"2D"))) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 2)) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2)) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2)) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"
        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported yet"

        ERROR
            (DC == `DC@DC) -> (ParamA != `ParamA@"_3D"):
                "Illegal instruction encoding: Depth Comparison filter is not supported by 3D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TEX (errata 36)"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) )))):
                "Register A is out of range"

        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"





        ERROR
            ((!((tid <= 0x7) && (LOD == `LOD@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) > 4)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (DC == `DC@DC) + (LOD == `LOD@LB || LOD == `LOD@LL || LOD == `LOD@LBA || LOD == `LOD@LLA) ) - 4))):
                "Register B is out of range"

        ERROR
            (!((tid <= 0x7) && (LOD == `LOD@LZ))) -> (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"
    OPCODES
        TEXtex_pipe =  0b1000_0_110;
        TEX =  0b1000_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      Bindless = bindless;
      LOD = LOD;
      TOFF2 = TOFF2;
      DC = DC;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc29;
      Sync=S;


 CLASS "TLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless /LOD1:lod /TOFF1(noTOFF):toff /MS(noMS):ms
             /CL(noCL):clamp /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) <= 4)) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 4)) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) == 2)) || (((tid <= 0x7) && (LOD1 == `LOD1@LZ)) && (ParamA == `ParamA@"2D"))) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 2)) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2)) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2)) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 2 if sz is 64"
        ERROR
            (ParamA != `ParamA@CUBE):
                "Illegal instruction encoding: CUBE is not supported"

        ERROR
            (ParamA != `ParamA@ARRAY_CUBE):
                "Illegal instruction encoding: ARRAY_CUBE is not supported"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (MS == `MS@noMS || CL == `CL@noCL):
                "Illegal instruction encoding: .MS cannot be combined with .CL"

        ERROR
            (MS == `MS@MS) -> (LOD1 == `LOD1@LZ):
                "Illegal instruction encoding: .MS can only be used with the .LZ LOD option"

        ERROR
            (MS == `MS@MS) -> (ParamA == `ParamA@"2D" || ParamA == `ParamA@ARRAY_2D):
                "Illegal instruction encoding: .MS can only be used with 2D/ARRAY_2D textures"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD (errata 36)"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) )))):
                "Register A is out of range"

        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 4)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"





        ERROR
            ((!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) > 4)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) + (MS == `MS@MS) + (LOD1 == `LOD1@LL) ) - 4))):
                "Register B is out of range"

        ERROR
            (!((tid <= 0x7) && (LOD1 == `LOD1@LZ))) -> (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"
    OPCODES
        TLDtex_pipe =  0b1001_0_110;
        TLD =  0b1001_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB = tid;
      Wmsk = wmsk;
      Bindless = bindless;
      LOD1 = LOD1;
      TOFF1 = TOFF1;
      MS = MS;
      CL = CL;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc130;
      Sync=S;



  CLASS "TLD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /B(noB):bindless /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS







        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 2) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 2) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: PTP is not supported with CubeMap textures"

        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            ((ParamA != `ParamA@"1D") && (ParamA != `ParamA@ARRAY_1D)):
                "Illegal instruction encoding: 1D is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD4 (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    OPCODES
        TLD4tex_pipe =  0b1010_0_110;
        TLD4 =  0b1010_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB = tid;
      Wmsk = wmsk;
      TexComp = TexComp;
      Bindless = bindless;
      TOFF2 = TOFF2;
      DC = DC;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc82;
      Sync=S;


  ALTERNATE CLASS "TLD4 Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /TexComp:tcomp /B(noB):bindless /TOFF2(noTOFF):toff
             /DC(noDC):dc /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd
             ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS







        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 2) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 2) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (TOFF2 == `TOFF2@PTP) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: PTP is not supported with CubeMap textures"

        ERROR
            (TOFF2 == `TOFF2@AOFFI) -> ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: AOFFI is not supported with CubeMap textures"

        ERROR
            ((ParamA != `ParamA@"1D") && (ParamA != `ParamA@ARRAY_1D)):
                "Illegal instruction encoding: 1D is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TLD4 (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) + (TOFF2 == `TOFF2@AOFFI) + (TOFF2 == `TOFF2@PTP) * 2 + (DC == `DC@DC) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

    OPCODES
        TLD4tex_pipe =  0b1010_0_110;
        TLD4 =  0b1010_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      TexComp = TexComp;
      Bindless = bindless;
      TOFF2 = TOFF2;
      DC = DC;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc82;
      Sync=S;


  CLASS "TMML"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless /LODLEN:lodlen
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 4) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) == 2) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 2) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TMML (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    OPCODES
        TMMLtex_pipe =  0b1011_0_110;
        TMML =  0b1011_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB = tid;
      Wmsk = wmsk;
      Bindless = bindless;
      LODLEN = LODLEN;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc85;
      Sync=S;


  ALTERNATE CLASS "TMML Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless /LODLEN:lodlen
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register(RZ):Rb
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 4) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) == 2) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 2) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            (ParamA != `ParamA@ARRAY_3D):
                "Illegal instruction encoding: ARRAY_3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TMML (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) <= 4) && (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") + (ParamA == `ParamA@RECT) * 2 + (ParamA == `ParamA@CUBE) * 3 + (ParamA == `ParamA@"_3D") * 3 + (ParamA == `ParamA@ARRAY_1D) * 2 + (ParamA == `ParamA@ARRAY_RECT) * 3 + (ParamA == `ParamA@ARRAY_3D) * 4 + (ParamA == `ParamA@ARRAY_CUBE) * 4 + (B == `B@B) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    OPCODES
        TMMLtex_pipe =  0b1011_0_110;
        TMML =  0b1011_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      Bindless = bindless;
      LODLEN = LODLEN;
      NDVa = NDV;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc85;
      Sync=S;






  CLASS "TXA"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
##IF DEFINED(ARCH_SEMANTICS)
             Register:Rd ',' Register:Ra ',' UImm(13)*:tid ',' UImm(4/15):wmsk ;
##ELSE
             Register:Rd ',' Register:Ra ',' UImm(13)*:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXA (errata 36)"

        ERROR
            ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-3))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D is not aligned"


    OPCODES
        TXAtex_pipe =  0b1101_0_110;
        TXA =  0b1101_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidB = tid;
      Wmsk = wmsk;
      NDVa = NDV;
      NODEP = NODEP;
      Phase = TPhase;
      !Nenc97;
      Sync=S;
  ALTERNATE CLASS "TXA Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /NDV(noNDV):ndv /NODEP(noNODEP):ndp
             /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ','
             UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXA (errata 36)"

        ERROR
            ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4"

        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-3))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D is not aligned"


    OPCODES
        TXAtex_pipe =  0b1101_0_110;
        TXA =  0b1101_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      NDVa = NDV;
      NODEP = NODEP;
      Phase = TPhase;
      !Nenc97;
      Sync=S;


  CLASS "TXD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(13)*:tid ',' ParamA:paramA
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) == 2) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 2) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: Cube is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXD (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) <= 4) && (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    OPCODES
        TXDtex_pipe =  0b1110_0_110;
        TXD =  0b1110_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidB = tid;
      Wmsk = wmsk;
      TOFF1 = TOFF1;
      Bindless = bindless;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc98;
      Sync=S;


  ALTERNATE CLASS "TXD Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless /TOFF1(noTOFF):toff
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb
             ',' UImm(8):tid ',' UImm(5):smp ',' ParamA:paramA
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) <= 4) -> (Rb == `Register@RZ):
                "Register B should be zero register if the number of coordinates is less than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> ((((Rb)+((Rb)==63)) & 0x3) == 0):
                "Register B should be aligned to 4 if the number of coordinates is greater than 4"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) == 2) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                "Register A should be aligned to 2 if the number of coordinates is 2"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 2) -> ((((Ra)+((Ra)==63)) & 0x3) == 0):
                "Register A should be aligned to 4 if the number of coordinates is greater than 2"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D should be aligned to 4 if sz is greater than 64"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D should be aligned to 4 if sz is 64"

        ERROR
            ((ParamA != `ParamA@CUBE) && (ParamA != `ParamA@ARRAY_CUBE)):
                "Illegal instruction encoding: Cube is not supported"

        ERROR
            ((ParamA != `ParamA@"3D") && (ParamA != `ParamA@ARRAY_3D)):
                "Illegal instruction encoding: 3D is not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXD (errata 36)"

        ERROR
            ((( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) <= 4) && (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 1)) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) == 1) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) )))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-4))):
                "Register A is out of range"

        ERROR
            (( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) > 4) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-( (ParamA == `ParamA@"_1D") * 3 + (ParamA == `ParamA@RECT) * 6 + (ParamA == `ParamA@ARRAY_1D) * 4 + (ParamA == `ParamA@ARRAY_RECT) * 7 + (B == `B@B) + (TOFF1 == `TOFF1@AOFFI) ) - 4))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"


    OPCODES
        TXDtex_pipe =  0b1110_0_110;
        TXD =  0b1110_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      TOFF1 = TOFF1;
      Bindless = bindless;
      NODEP = NODEP;
      ParamA = ParamA;
      Phase = TPhase;
      !Nenc98;
      Sync=S;






  CLASS "TXQ"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' TXQMode:query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D is not aligned"


    OPCODES
        TXQtex_pipe =  0b1100_0_110;
        TXQ =  0b1100_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidB = tid;
      Wmsk = wmsk;
      Bindless = bindless;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(TXQMode);
      !Nenc99;
      Sync=S;






  ALTERNATE CLASS "TXQ Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' TXQMode:query
             ',' UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            ((TXQMode == `TXQMode@TEX_HEADER_DIMENSION) || (TXQMode == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (TXQMode == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D is not aligned"


    OPCODES
        TXQtex_pipe =  0b1100_0_110;
        TXQ =  0b1100_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      Bindless = bindless;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(TXQMode);
      !Nenc99;
      Sync=S;






  ALTERNATE CLASS "TXQ Imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' UImm(5):query
##IF DEFINED(ARCH_SEMANTICS)
             ',' UImm(13)*:tid ',' UImm(4/15):wmsk ;
##ELSE
             ',' UImm(13)*:tid ',' UImm(4):wmsk ;
##ENDIF

    CONDITIONS

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D is not aligned"


    OPCODES
        TXQtex_pipe =  0b1100_0_110;
        TXQ =  0b1100_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidB = tid;
      Wmsk = wmsk;
      Bindless = bindless;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(query);
      !Nenc99;
      Sync=S;


  ALTERNATE CLASS "TXQ Imm Legacy Style"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
             /B(noB):bindless
             /NODEP(noNODEP):ndp /TPhase(noPhase):phase /S(noS):sync
             Register:Rd ',' Register:Ra ',' UImm(5):query
             ',' UImm(8):tid ',' UImm(5):smp ',' UImm(4):wmsk ;

    CONDITIONS

        ERROR
            ((query == `TXQMode@TEX_HEADER_DIMENSION) || (query == `TXQMode@TEX_HEADER_TEXTURE_TYPE) || (query == `TXQMode@TEX_HEADER_SAMPLER_POS)):
                "Illegal instruction encoding: Queue mode not supported"

        ERROR
            (S != `S@S):
                "Illegal instruction encoding: Sync modifier is not supported on TXQ (errata 36)"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-(((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0))))):
                "Register D is out of range"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) == 2) -> ((((Rd)+((Rd)==63)) & 0x1) == 0):
                "Register D is not aligned"

        ERROR
            ((((wmsk & 0x1) != 0) + ((wmsk & 0x2) != 0) + ((wmsk & 0x4) != 0) + ((wmsk & 0x8) != 0)) > 2) -> ((((Rd)+((Rd)==63)) & 0x3) == 0):
                "Register D is not aligned"


    OPCODES
        TXQtex_pipe =  0b1100_0_110;
        TXQ =  0b1100_0_110;

    ENCODING
      Opcode24 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      TidBTEX = tid;
      TidBSAMP = smp;
      Wmsk = wmsk;
      Bindless = bindless;
      NODEP = NODEP;
      Phase = TPhase;
      TexQuery = TXQModeDim(query);
      !Nenc99;
      Sync=S;


 CLASS "TEXDEPBAR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync UImm(6):uImm ;

    OPCODES
        TEXDEPBARbru_pipe =  0b111100_0_110;
        TEXDEPBAR =  0b111100_0_110;

    ENCODING
      Opcode18 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      RegB = uImm;
      !Nenc114;
      Sync=S;





CLASS "LDC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /AdMode(IA):ad /S(noS):sync
Register:Rd ',' C:srcConst[UImm(5/0*):constBank]* [NonZeroRegister:Ra + SImm(17/0)*:sImm];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    OPCODES
        LDCxlu_pipe =  0b000101_0_110;
        LDC =  0b000101_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      AdMode = AdMode;
      LSSize = CInteger;
      Dest = Rd;
      RegA =* Ra;

CBank,Imm16 =  ConstBankAddress0(constBank,sImm);

      !Nenc66;
      Sync=S;


CLASS "I LDC"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /AdMode(IA):ad /S(noS):sync
Register:Rd ',' C:srcConst[UImm(5/0*):constBank]* [ZeroRegister(RZ):Ra + SImm(17)*:immConstOffset];

    CONDITIONS





         ERROR
           (constBank <= 17) :
             "Only constant banks 0..17 are legal"

    OPCODES
        LDCxlu_pipe =  0b000101_0_110;
        LDC =  0b000101_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      AdMode = AdMode;
      LSSize = CInteger;
      Dest = Rd;
      RegA =* Ra;

CBank,Imm16 =  ConstBankAddress0(constBank,immConstOffset);

      !Nenc66;
      Sync=S;


CLASS "VILD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' V:srcVert[NonZeroRegister:Ra + SImm(16/0)*:sImm];

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"


    OPCODES
        VILDagu_pipe =  0b000000_0_110;
        VILD =  0b000000_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm16 = sImm;
      !BAddr;

      !Nenc67;
      Sync=S;



CLASS "I VILD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ',' V:srcVert[ZeroRegister(RZ):Ra + UImm(16/0)*:uImm];

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"


    OPCODES
        VILDagu_pipe =  0b000000_0_110;
        VILD =  0b000000_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm16 = uImm;
      !BAddr;

      !Nenc67;
      Sync=S;



CLASS "I ALD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /P(noP):p /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register(RZ):Rb;

    CONDITIONS

        ERROR
          (((Rd)+((Rd)==63)) % ARegAlignment(AInteger)) == 0 :
            "Output register improperly aligned for specified operation size"

        ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register D is out of range"

        ERROR
          (P == `P@P) -> (Rb == `Register@RZ):
            "Register B is ignored when using the .P modifier"

        ERROR
          (P == `P@P) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

        ERROR
          (P == `P@noP) -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))):
            "Register B is out of range"


    OPCODES
        ALDagu_pipe =  0b000001_0_110;
        ALD =  0b000001_0_110;

    ENCODING
      Opcode18 = Opcode;
      AIO = AIO;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      Imm10 = uImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc111;
      Sync=S;



CLASS "ALD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /POnly:p /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register(RZ):Rb;

    CONDITIONS

        ERROR
          (((Rd)+((Rd)==63)) % ARegAlignment(AInteger)) == 0 :
            "Output register improperly aligned for specified operation size"

        ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register D is out of range"

        ERROR
          (Rb == `Register@RZ):
            "Register B is ignored when using the .P modifier"

        ERROR
          ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

    OPCODES
        ALDagu_pipe =  0b000001_0_110;
        ALD =  0b000001_0_110;

    ENCODING
      Opcode18 = Opcode;
      AIO = AIO;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      Imm11 = sImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc68;
      Sync=S;


CLASS "ALD PHYS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /Phys:phys /AInteger("32"):size /S(noS):sync
             Register:Rd ',' A:srcAttr[NonZeroRegister:Ra]
             ',' Register(RZ):Rb;

   CONDITIONS

        ERROR
          (((Rd)+((Rd)==63)) % ARegAlignment(AInteger)) == 0 :
            "Output register improperly aligned for specified operation size"

        ERROR
          ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register D is out of range"


    OPCODES
        ALDagu_pipe =  0b000001_0_110;
        ALD =  0b000001_0_110;

    ENCODING
      Opcode18 = Opcode;
      AIO = AIO;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      RegB = Rb;
      Imm11 = 0;
      ALSize = AInteger;
      !BAddr;

      !Nenc68;
      Sync=S;




CLASS "I AST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /P(noP):p /AInteger("32"):size /S(noS):sync
             A:srcAttr[ZeroRegister(RZ):Ra + UImm(10/0)*:uImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS

        ERROR
          (((Rb)+((Rb)==63)) % ARegAlignment(AInteger)) == 0 :
            "Input register improperly aligned for specified operation size"

        ERROR
          ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register B is out of range"

   OPCODES
        ASTagu_pipe =  0b000010_0_110;
        AST =  0b000010_0_110;

    ENCODING
      Opcode2 = Opcode;
      P = P;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegB = Rb;
      Imm10 = uImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc112;
      Sync=S;



CLASS "AST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /AInteger("32"):size /S(noS):sync
             A:srcAttr[NonZeroRegister:Ra + SImm(11/0)*:sImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS

        ERROR
          (((Rb)+((Rb)==63)) % ARegAlignment(AInteger)) == 0 :
            "Input register improperly aligned for specified operation size"

        ERROR
          ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register B is out of range"

        ERROR
          ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

    OPCODES
        ASTagu_pipe =  0b000010_0_110;
        AST =  0b000010_0_110;

    ENCODING
      Opcode2 = Opcode;
      P = 1;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegB = Rb;
      Imm11 = sImm;
      ALSize = AInteger;
      !BAddr;

      !Nenc69;
      Sync=S;


CLASS "AST PHYS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Phys:phys /AInteger("32"):size /S(noS):sync
             A:srcAttr[NonZeroRegister:Ra] ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS

        ERROR
          (((Rb)+((Rb)==63)) % ARegAlignment(AInteger)) == 0 :
            "Input register improperly aligned for specified operation size"

        ERROR
          ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-AInteger+1)))):
            "Register B is out of range"

        ERROR
          ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
            "Register A is out of range"

    OPCODES
        ASTagu_pipe =  0b000010_0_110;
        AST =  0b000010_0_110;

    ENCODING
      Opcode2 = Opcode;
      P = 0;
      Pred = Pg;
      PredNot = Pg@not;
      RegC = Rc;
      RegA =* Ra;
      RegB = Rb;
      Imm11 = 0;
      ALSize = AInteger;
      !BAddr;

      !Nenc69;
      Sync=S;


CLASS "AL2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /AInteger("32"):size /S(noS):sync
             Register:Rd ',' NonZeroRegister:Ra ',' SImm(11/0):sImm;

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    OPCODES
        AL2Pxlu_pipe =  0b000011_0_110;
        AL2P =  0b000011_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      AIO = AIO;
      Dest = Rd;
      RegA =* Ra;
      Imm11 = sImm;
      ALSize = AInteger;

      !Nenc136;
      Sync=S;


CLASS "I AL2P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /AIO(I):io /AInteger("32"):size /S(noS):sync
             Register:Rd ',' ZeroRegister(RZ):Ra ',' UImm(10/0):uImm;

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    OPCODES
        AL2Pxlu_pipe =  0b000011_0_110;
        AL2P =  0b000011_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      AIO = AIO;
      Dest = Rd;
      RegA =* Ra;
      Imm10 = uImm;
      ALSize = AInteger;
      !Nenc137;
      Sync=S;


CLASS "OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
             Register:Rd ',' Register:Ra ',' Register:Rb;

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register is out of range"

    OPCODES
        OUTagu_pipe =  0b000111_0_110;
        OUT =  0b000111_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      OutType = OutType;

      !Nenc70;
      Sync=S;
      ABC=0;
      !BFiller;


CLASS "Imm OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
             Register:Rd ',' Register:Ra ',' SImm(20):uImm;

    CONDITIONS

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register is out of range"

    OPCODES
        OUTagu_pipe =  0b000111_0_110;
        OUT =  0b000111_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      OutType = OutType;

      !Nenc70;
      Sync=S;
      ABC = 3;



CLASS "Const OUT"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /OutType:out /S(noS):sync
Register:Rd ',' Register:Ra ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"


        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register is out of range"

    OPCODES
        OUTagu_pipe =  0b000111_0_110;
        OUT =  0b000111_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      OutType = OutType;

      !Nenc70;
      Sync=S;
      ABC = 1;



 CLASS "PIXLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd ','
             [NonZeroRegister:Ra + SImm(8/0)*:sImm];

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        PIXLDfe_pipe =  0b000100_0_110;
        PIXLD =  0b000100_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      PredDest = Pd;
      RegA =* Ra;
      PixMode = PixMode;
      Imm8 = sImm;

      Sync=S;
      !Nenc71;


 CLASS "I PIXLD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd ','
             [ZeroRegister(RZ):Ra + UImm(8/0)*:uImm];

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

        ERROR
            ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        PIXLDfe_pipe =  0b000100_0_110;
        PIXLD =  0b000100_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      PredDest = Pd;
      RegA =* Ra;
      PixMode = PixMode;
      Imm8 = uImm;

      Sync=S;
      !Nenc71;


 ALTERNATE CLASS "PIXLD simple"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /PixMode(MSCOUNT):pixmode /S(noS):sync
             Register:Rd
             ',' Predicate(PT):Pd;

    CONDITIONS

        ERROR
            ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

    OPCODES
        PIXLDfe_pipe =  0b000100_0_110;
        PIXLD =  0b000100_0_110;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      PredDest = Pd;
      RegA = `Register@RZ;
      PixMode = PixMode;
      Imm8 = 0;

      Sync=S;
      !Nenc71;


 CLASS "LD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(32/0)*:sImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    OPCODES
        LDagu_pipe =  0b10000_0_101;
        LD =  0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize =* LDInteger;
      E = E;
      COP = LoadCacheOp;

      Sync=S;
 CLASS "I LD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /LoadCacheOp(CA):cop /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm];

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    OPCODES
        LDagu_pipe =  0b10000_0_101;
        LD =  0b10000_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize =* LDInteger;
      E = E;
      COP = LoadCacheOp;

      Sync=S;
CLASS "SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             Register:Rc;

    CONDITIONS ERROR IsEven(Rb+(Rb==63)) && (Rc == (Rb+1)) : "Rb and Rc need to be vector-aligned"
 ERROR !(Rb==63): "Rb cannot be RZ"
 ERROR !(Rc==63): "Rc cannot be RZ"

    OPCODES
        SHFLagu_pipe =  0b10001_0_101;
        SHFL =  0b10001_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      Shflmd = shflmd;
      !SHFLFiller;
      CFix_SHFL=0;
      BFix_SHFL=0;
      LockPred = Pd;
      Sync=S;
      !Nenc138;
CLASS "b SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             UImm(5):uImm5 ','
             Register:Rc;



    OPCODES
        SHFLagu_pipe =  0b10001_0_101;
        SHFL =  0b10001_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      shfl_imm5 = uImm5;
!bit6_RegB;
      RegC = Rc;
      Shflmd = shflmd;
      !SHFLFiller;
      CFix_SHFL=0;
      BFix_SHFL=1;
      LockPred = Pd;
      Sync=S;
      !Nenc138;
CLASS "c b SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             UImm(5):uImm5 ','
             UImm(13):uImm13;



    OPCODES
        SHFLagu_pipe =  0b10001_0_101;
        SHFL =  0b10001_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      shfl_imm5 = uImm5;
!bit6_RegB;
      Imm13 = uImm13;
      Shflmd = shflmd;

      CFix_SHFL=1;
      BFix_SHFL=1;
      LockPred = Pd;
      Sync=S;
      !Nenc138;
CLASS "c SHFL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Shflmd:shflmd /S(noS):sync
             Predicate:Pd ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             UImm(13):uImm13;



    OPCODES
        SHFLagu_pipe =  0b10001_0_101;
        SHFL =  0b10001_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Imm13 = uImm13;
      Shflmd = shflmd;

      CFix_SHFL=1;
      BFix_SHFL=0;
      LockPred = Pd;
      Sync=S;
      !Nenc138;
 CLASS "ST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

    OPCODES
        STagu_pipe =  0b10010_0_101;
        ST =  0b10010_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = sImm;
      LSSize = CInteger;
      E = E;
      COP = StoreCacheOp;

      Sync=S;
 CLASS "I ST"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Operand register improperly aligned for specified operation size"

         ERROR
           (E & (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))) || ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
             "Register A is out of range"

    OPCODES
        STagu_pipe =  0b10010_0_101;
        ST =  0b10010_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = uImm;
      LSSize = CInteger;
      E = E;
      COP = StoreCacheOp;

      Sync=S;
 CLASS "ATOM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Comparison register improperly aligned for specified operation size"

        ERROR (atom == `AtomOp@MIN || atom == `AtomOp@MAX || atom == `AtomOp@AND || atom == `AtomOp@OR || atom == `AtomOp@XOR) -> (size != `SQInteger@U64):
            "ATOM.{MIN,MAX,AND,OR,XOR} do not accept 64bit ops"

        ERROR (atom == `AtomOp@MIN || atom == `AtomOp@MAX || atom == `AtomOp@AND || atom == `AtomOp@OR || atom == `AtomOp@XOR) -> (size != `SQInteger@S64):
            "ATOM.{MIN,MAX,AND,OR,XOR} do not accept 64bit ops"

         ERROR
           (size == `SQInteger@U64) -> ((atom == `AtomOp@EXCH) || (atom == `AtomOp@ADD) || (atom == `AtomOp@AND)
                                    || (atom == `AtomOp@OR) || (atom == `AtomOp@XOR) || (atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "This operation is not supported with U64"

         ERROR
           (size == `SQInteger@S64) -> ((atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "Only ATOM.MIN/MAX can be used with S64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

    OPCODES
        ATOMagu_pipe =  0b01_0_101;
        ATOM =  0b01_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegDa = Rd;
      RegA =* Ra;
      RegC = Rc;
      Imm20a = sImm;
      AtomSize = SQInteger;
      AtomOp =* AtomOp;
      E = E;
      Sync=S;


 CLASS "I ATOM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /AtomOp:atom /SQInteger("U32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb ',' Register(RZ):Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4))) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

         ERROR
           (((Rd)+((Rd)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Comparison register improperly aligned for specified operation size"

        ERROR (atom == `AtomOp@MIN || atom == `AtomOp@MAX || atom == `AtomOp@AND || atom == `AtomOp@OR || atom == `AtomOp@XOR) -> (size != `SQInteger@U64):
            "ATOM.{MIN,MAX,AND,OR,XOR} do not accept 64bit ops"

        ERROR (atom == `AtomOp@MIN || atom == `AtomOp@MAX || atom == `AtomOp@AND || atom == `AtomOp@OR || atom == `AtomOp@XOR) -> (size != `SQInteger@S64):
            "ATOM.{MIN,MAX,AND,OR,XOR} do not accept 64bit ops"

         ERROR
           (size == `SQInteger@U64) -> ((atom == `AtomOp@EXCH) || (atom == `AtomOp@ADD) || (atom == `AtomOp@AND)
                                    || (atom == `AtomOp@OR) || (atom == `AtomOp@XOR) || (atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "This operation is not supported with U64"

         ERROR
           (size == `SQInteger@S64) -> ((atom == `AtomOp@MIN) || (atom == `AtomOp@MAX)):
             "Only ATOM.MIN/MAX can be used with S64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (atom == `AtomOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

    OPCODES
        ATOMagu_pipe =  0b01_0_101;
        ATOM =  0b01_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegDa = Rd;
      RegA =* Ra;
      RegC = Rc;
      Imm20a = uImm;
      AtomSize = SQInteger;
      AtomOp =* AtomOp;
      E = E;
      Sync=S;


 CLASS "ATOM CAS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /SQInteger("U32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(20/0)*:sImm]
             ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Comparison register improperly aligned for specified operation size"

         ERROR (size == `SQInteger@U32 && Rb != `Register@RZ ) -> (IsEven(((Rb)+((Rb)==63))) && ( ((Rc)+((Rc)==63)) == (((Rb)+((Rb)==63)) + SQRegAlignment(SQInteger)) ) || (Rc == `Register@RZ)):
            "ATOM.CAS.32 requires Rb and Rc to be vector-aligned"

         ERROR (size == `SQInteger@U32 && Rc != `Register@RZ ) -> (( ((Rc)+((Rc)==63))%2 == SQRegAlignment(SQInteger)) && ( IsEven(((Rb)+((Rb)==63))) || (Rb == `Register@RZ))) :
            "ATOM.CAS.32 requires Rb and Rc to be vector-aligned"

         ERROR (size == `SQInteger@U64 && Rb != `Register@RZ ) -> ( (((Rb)+((Rb)==63))%4)==0 && ((((Rc)+((Rc)==63)) == ((Rb)+((Rb)==63)) + SQRegAlignment(SQInteger)) || (Rc == `Register@RZ)) ):
            "ATOM.CAS.U64 requires Rb to be R4n+0 or RZ and Rc must be Rb+2 or RZ"

         ERROR (size == `SQInteger@U64 && Rc != `Register@RZ ) -> ((((Rc)+((Rc)==63))%4)==SQRegAlignment(SQInteger) && (((((Rb)+((Rb)==63))%4)==0) || (Rb == `Register@RZ))) :
            "ATOM.CAS.U64 requires Rb to be R4n+0 or RZ and Rc must be Rb+2 or RZ"


    OPCODES
        ATOMagu_pipe =  0b01_0_101;
        ATOM =  0b01_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegDa = Rd;
      RegA =* Ra;
      RegC = Rc;
      Imm20a = sImm;
      AtomSize = SQInteger;
      AtomOp =* CAS;
      E = E;
      Sync=S;


 CLASS "I ATOM CAS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /CAS:cas /SQInteger("U32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(20/0)*:uImm]
             ',' Register:Rb ',' Register:Rc;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           (((Rd)+((Rd)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (((Rc)+((Rc)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Comparison register improperly aligned for specified operation size"

         ERROR (size == `SQInteger@U32 && Rb != `Register@RZ ) -> (IsEven(((Rb)+((Rb)==63))) && ( ((Rc)+((Rc)==63)) == (((Rb)+((Rb)==63)) + SQRegAlignment(SQInteger)) ) || (Rc == `Register@RZ)):
            "ATOM.CAS.32 requires Rb and Rc to be vector-aligned"

         ERROR (size == `SQInteger@U32 && Rc != `Register@RZ ) -> (( ((Rc)+((Rc)==63))%2 == SQRegAlignment(SQInteger)) && ( IsEven(((Rb)+((Rb)==63))) || (Rb == `Register@RZ))) :
            "ATOM.CAS.32 requires Rb and Rc to be vector-aligned"

         ERROR (size == `SQInteger@U64 && Rb != `Register@RZ ) -> ( (((Rb)+((Rb)==63))%4)==0 && ((((Rc)+((Rc)==63)) == ((Rb)+((Rb)==63)) + SQRegAlignment(SQInteger)) || (Rc == `Register@RZ)) ):
            "ATOM.CAS.U64 requires Rb to be R4n+0 or RZ and Rc must be Rb+2 or RZ"

         ERROR (size == `SQInteger@U64 && Rc != `Register@RZ ) -> ((((Rc)+((Rc)==63))%4)==SQRegAlignment(SQInteger) && (((((Rb)+((Rb)==63))%4)==0) || (Rb == `Register@RZ))) :
            "ATOM.CAS.U64 requires Rb to be R4n+0 or RZ and Rc must be Rb+2 or RZ"


    OPCODES
        ATOMagu_pipe =  0b01_0_101;
        ATOM =  0b01_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegDa = Rd;
      RegA =* Ra;
      RegC = Rc;
      Imm20a = uImm;
      AtomSize = SQInteger;
      AtomOp =* CAS;
      E = E;
      Sync=S;


 CLASS "RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0)*:sImm]
             ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (size == `SQInteger@S32) -> ((redop != `RedOp@INC) && (redop != `RedOp@DEC)):
             "INC/DEC cannot be applied to S32"

         ERROR
           (size == `SQInteger@U64) -> (redop == `RedOp@ADD):
             "Only Add can be applied to U64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (redop == `RedOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

    OPCODES
        REDagu_pipe =  0b00_0_101;
        RED =  0b00_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = sImm;
      AtomSize = SQInteger;
      AtomOp = RedOp;
      E = E;
      Sync=S;


 CLASS "I RED"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /RedOp:redop /SQInteger("U32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm]
             ',' Register:Rb;

    CONDITIONS
         ERROR
           E -> IsEven(((Ra)+((Ra)==63))) :
             "An even address register is required when '.E' is specified"

         ERROR
           E -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
             "Register A is out of range"

         ERROR
           (E == `E@noE) -> (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)+((Rb)==63)) % SQRegAlignment(SQInteger)) == 0 :
             "Input register improperly aligned for specified operation size"

         ERROR
           (size == `SQInteger@S32) -> ((redop != `RedOp@INC) && (redop != `RedOp@DEC)):
             "INC/DEC cannot be applied to S32"

         ERROR
           (size == `SQInteger@U64) -> (redop == `RedOp@ADD):
             "Only Add can be applied to U64"

         ERROR
           (size != `SQInteger@U128):
             "U128 is not supported"

         ERROR
           (size == `SQInteger@"F32.FTZ.RN") -> (redop == `RedOp@ADD):
             "Only Add can be applied to F32.FTZ.RN"

         ERROR
           (size == `SQInteger@"32") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"64") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2)))):
             "Register is out of range"

         ERROR
           (size == `SQInteger@"128") -> ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-4)))):
             "Register is out of range"

    OPCODES
        REDagu_pipe =  0b00_0_101;
        RED =  0b00_0_101;

    ENCODING
      Opcode21 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm32 = uImm;
      AtomSize = SQInteger;
      AtomOp = RedOp;
      E = E;
      Sync=S;


 CLASS "LDS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    OPCODES
        LDSagu_pipe =  0b110000_1_0_101;
        LDS =  0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize =* LDInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "I LDS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LDInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % LDRegAlignment(LDInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-LDRegAlignment(LDInteger)))):
             "Register D is out of range"

    OPCODES
        LDSagu_pipe =  0b110000_1_0_101;
        LDS =  0b110000_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize =* LDInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "LDSLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        LDSLKagu_pipe =  0b10101_0_101;
        LDSLK =  0b10101_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      LockPred = Pd;
      !Nenc74;
      Sync=S;


 CLASS "I LDSLK"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             Predicate:Pd ',' Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        LDSLKagu_pipe =  0b10101_0_101;
        LDSLK =  0b10101_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      LockPred = Pd;
      !Nenc74;
      Sync=S;


 CLASS "STS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
             "Register B is out of range"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

    OPCODES
        STSagu_pipe =  0b110010_1_0_101;
        STS =  0b110010_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "I STS"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           ((((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger))))):
             "Register B is out of range"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

    OPCODES
        STSagu_pipe =  0b110010_1_0_101;
        STS =  0b110010_1_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;

      !Nenc73;
      Sync=S;
      !COP;


 CLASS "STSCUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
            Predicate:Pd ',' [NonZeroRegister:Ra + SImm(24/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
        STSCULagu_pipe =  0b10111_0_101;
        STSCUL =  0b10111_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      LockPred = Pd;
      !Nenc74;
      Sync=S;



 CLASS "I STSCUL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /CInteger("32"):size /S(noS):sync
            Predicate:Pd ',' [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

    OPCODES
        STSCULagu_pipe =  0b10111_0_101;
        STSCUL =  0b10111_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      LockPred = Pd;
      !Nenc74;
      Sync=S;



 CLASS "CCTL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /CCTLOp:cctlop /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0)*:sImm] ;

    CONDITIONS
         ERROR
           (cctlop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                   "In CCTL.IVALL Register A should be zero register"

         ERROR
           (cctlop != `CCTLOp@WBALL) :
                   "WBALL is disallowed for CCTL"
         ERROR
           (cctlop != `CCTLOp@RSLB) :
                   "RSLB is disallowed for CCTL"

         ERROR
           (Cache != `Cache@D) -> ((cctlop != `CCTLOp@RS) && (cctlop != `CCTLOp@PF1) && (cctlop != `CCTLOp@PF1.5) && (cctlop != `CCTLOp@PF2)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (cctlop == `CCTLOp@IV) -> ((Cache != `Cache@C) && (Cache != `Cache@I)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (E == `E@E) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))):
                   "Register A is out of range"

         ERROR
           (E == `E@E) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                   "Register A is not properly aligned"

         ERROR
           (E == `E@noE) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                   "Register A is out of range"


    OPCODES
        CCTLagu_pipe =  0b10011_0_101;
        CCTL =  0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm30a = sImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* CCTLOp;

      Sync=S;


 CLASS "I CCTL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /CCTLOp:cctlop /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm] ;

    CONDITIONS
         ERROR
           (cctlop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                   "In CCTL.IVALL Register A should be zero register"

         ERROR
           (cctlop != `CCTLOp@WBALL) :
                   "WBALL is disallowed for CCTL"
         ERROR
           (cctlop != `CCTLOp@RSLB) :
                   "RSLB is disallowed for CCTL"

         ERROR
           (Cache != `Cache@D) -> ((cctlop != `CCTLOp@RS) && (cctlop != `CCTLOp@PF1) && (cctlop != `CCTLOp@PF1.5) && (cctlop != `CCTLOp@PF2)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (cctlop == `CCTLOp@IV) -> ((Cache != `Cache@C) && (Cache != `Cache@I)):
                   "Illegal instruction: unsupported combination"

         ERROR
           (E == `E@E) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2)))):
                   "Register A is out of range"

         ERROR
           (E == `E@E) -> ((((Ra)+((Ra)==63)) & 0x1) == 0):
                   "Register A is not properly aligned"

         ERROR
           (E == `E@noE) -> ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                   "Register A is out of range"


    OPCODES
        CCTLagu_pipe =  0b10011_0_101;
        CCTL =  0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm30a = uImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* CCTLOp;

      Sync=S;


 ALTERNATE CLASS "CCTL IVALL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyIvall:ivall /S(noS):sync
             ;

    OPCODES
        CCTLagu_pipe =  0b10011_0_101;
        CCTL =  0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA = `Register@RZ;
      Imm30a = 0;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyIvall;

      Sync=S;


 CLASS "CCTL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             Register:Rd ',' [NonZeroRegister:Ra + SImm(32/0)*:sImm] ;

    OPCODES
        CCTLagu_pipe =  0b10011_0_101;
        CCTL =  0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm30a = sImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;

 CLASS "I CCTL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             Register:Rd ',' [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm] ;

    OPCODES
        CCTLagu_pipe =  0b10011_0_101;
        CCTL =  0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm30a = uImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;

 ALTERNATE CLASS "CCTL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             [NonZeroRegister:Ra + SImm(32/0)*:sImm] ;

    OPCODES
        CCTLagu_pipe =  0b10011_0_101;
        CCTL =  0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm30a = sImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;
 ALTERNATE CLASS "I CCTL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /E(noE):e /Cache(D):cache /OnlyQry:op /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(32/0)*:uImm] ;

    OPCODES
        CCTLagu_pipe =  0b10011_0_101;
        CCTL =  0b10011_0_101;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm30a = uImm SCALE 4;
      E = E;
      Cache = Cache;
      CCTLOp =* OnlyQry;

      Sync=S;
  CLASS "SUSTGA.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp3:clamp /Ofmt:ofmt /S(noS):sync
             [Register:Ra] ',' Register:Rb ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
                "Register B is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register C is out of range"

        ERROR
            (((Rc)+((Rc)==63)) % CRegAlignment(CInteger)) == 0:
                "Register C is not properly aligned"

    OPCODES
        SUSTGAagu_pipe =  0b110111_0_101;
        SUSTGA =  0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      RGBAb =* RGBA_NONE;
      Bc = 0;
      SrcPred = Pcl;
      SrcNot = Pcl@not;
      Clamp = Clamp3;
      Ofmt = Ofmt;
      RegB = Rb;
      RegA = Ra;
      RegC2 = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      COP = StoreCacheOp;
      LSSize = CInteger;
      !Nenc132;
      Sync=S;

  CLASS "SUSTGA.B cimm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /StoreCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp3:clamp /Ofmt:ofmt /S(noS):sync
[Register:Ra] ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register C is out of range"

        ERROR
            (((Rc)+((Rc)==63)) % CRegAlignment(CInteger)) == 0:
                "Register C is not properly aligned"

    OPCODES
        SUSTGAagu_pipe =  0b110111_0_101;
        SUSTGA =  0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      RGBAb =* RGBA_NONE;
      Bc = 1;
      SrcPred = Pcl;
      SrcNot = Pcl@not;
      Clamp = Clamp3;
      Ofmt = Ofmt;

CBank2,Imm14 =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      RegC2 = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      COP = StoreCacheOp;
      LSSize = CInteger;
      Sync=S;



  CLASS "SUSTGA.P"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3B(SD):rf /Clamp3(SDCL):clamp /Ofmt(U32):ofmt /S(noS):sync
             [Register:Ra] ',' Register:Rb ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
                "Register B is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register C is out of range"

    OPCODES
        SUSTGAagu_pipe =  0b110111_0_101;
        SUSTGA =  0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      RGBAb =* RGBA;
      Bc = 0;
      SrcPred = Pcl;
      SrcNot = Pcl@not;
      Clamp = Clamp3;
      Ofmt = ofmt;
      RegB = Rb;
      RegA = Ra;
      RegC2 = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      COP = StoreCacheOp;
      Rf = rf;
      !Nenc133;
      Sync=S;

  CLASS "SUSTGA.P cimm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /POnly:p /StoreCacheOp(CG):cop /RGBA(RGBA):rgba /SD3B(SD):rf /Clamp3(SDCL):clamp /Ofmt(U32):ofmt /S(noS):sync
[Register:Ra] ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' Register:Rc ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
                "Register A is out of range"

        ERROR
            (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1))):
                "Register C is out of range"

    OPCODES
        SUSTGAagu_pipe =  0b110111_0_101;
        SUSTGA =  0b110111_0_101;

    ENCODING
      Opcode2 = Opcode;
      RGBAb =* RGBA;
      Bc = 1;
      SrcPred = Pcl;
      SrcNot = Pcl@not;
      Clamp = Clamp3;
      Ofmt = Ofmt;

CBank2,Imm14 =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      RegC2 = Rc;
      PredNot = Pg@not;
      Pred = Pg;
      COP = StoreCacheOp;
      Rf = rf;
      !Nenc134;
      Sync=S;





  CLASS "SULDGA.B"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp2:clamp /Ofmt:ofmt /S(noS):sync
             Register:Rd ',' [Register:Ra] ',' Register:Rb ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
                "Register B is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register D is out of range"

        ERROR
            ((Rd)+((Rd)==63)) % CRegAlignment(CInteger) == 0:
                "Register D is not properly aligned"

        ERROR
            (((Ra)+((Ra)==63)) & 0x1) == 0:
                "Register A is not properly aligned"

    OPCODES
        SULDGAagu_pipe =  0b110101_0_101;
        SULDGA =  0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      RGBAb =* RGBA_NONE;
      Bc = 0;
      SrcPred = Pcl;
      SrcNot = Pcl@not;
      Clamp = Clamp2;
      Ofmt = Ofmt;
      RegB = Rb;
      RegA = Ra;
      Dest = Rd;
      PredNot = Pg@not;
      Pred = Pg;
      COP = LoadCacheOp;
      LSSize = CInteger;
      !Nenc132;
      Sync=S;

  CLASS "SULDGA.B cimm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BOnly:b /LoadCacheOp(CG):cop /RGBA_NONE(noRGBA):rgba /CInteger:size /Clamp2:clamp /Ofmt:ofmt /S(noS):sync
Register:Rd ',' [Register:Ra] ',' C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ',' [!]Predicate:Pcl;

    CONDITIONS
        ERROR
            (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-2))):
                "Register A is out of range"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
                "Register D is out of range"

        ERROR
            ((Rd)+((Rd)==63)) % CRegAlignment(CInteger) == 0:
                "Register D is not properly aligned"

        ERROR
            (((Ra)+((Ra)==63)) & 0x1) == 0:
                "Register A is not properly aligned"

    OPCODES
        SULDGAagu_pipe =  0b110101_0_101;
        SULDGA =  0b110101_0_101;

    ENCODING
      Opcode2 = Opcode;
      RGBAb =* RGBA_NONE;
      Bc = 1;
      SrcPred = Pcl;
      SrcNot = Pcl@not;
      Clamp = Clamp2;
      Ofmt = Ofmt;

CBank2,Imm14 =  ConstBankAddress2(constBank,immConstOffset);
      RegA = Ra;
      Dest = Rd;
      PredNot = Pg@not;
      Pred = Pg;
      COP = LoadCacheOp;
      LSSize = CInteger;
      Sync=S;
CLASS "SUCLAMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BDim("MD"):dim /Integer32(S32):us32 /Smode("SD.R1"):smd /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             SImm(6):sImm;


    OPCODES
        SUCLAMPxlu_pipe =  0b010110_0_100;
        SUCLAMP =  0b010110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      Imm06 = sImm;
      SUPDest = Pcl;
      Sync=S;
      Signed32 = IsSigned(us32);
      BDim = dim;
      SMode = smd;
      ABC=0;
      !BFiller;
CLASS "Imm SUCLAMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BDim("MD"):dim /Integer32(S32):us32 /Smode("SD.R1"):smd /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             SImm(6):sImm;


    OPCODES
        SUCLAMPxlu_pipe =  0b010110_0_100;
        SUCLAMP =  0b010110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      Imm06 = sImm;
      SUPDest = Pcl;
      Sync=S;
      Signed32 = IsSigned(us32);
      BDim = dim;
      SMode = smd;
      ABC = 3;

CLASS "Const SUCLAMP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BDim("MD"):dim /Integer32(S32):us32 /Smode("SD.R1"):smd /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             SImm(6):sImm;


    OPCODES
        SUCLAMPxlu_pipe =  0b010110_0_100;
        SUCLAMP =  0b010110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Imm06 = sImm;
      SUPDest = Pcl;
      Sync=S;
      Signed32 = IsSigned(us32);
      BDim = dim;
      SMode = smd;
      ABC = 1;

CLASS "SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             Register:Rc;


    OPCODES
        SUBFMxlu_pipe =  0b010111_0_100;
        SUBFM =  0b010111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      SUPDest = Pcl;
      BDim = dim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC=0;
      !BFiller;
CLASS "Imm SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             Register:Rc;


    OPCODES
        SUBFMxlu_pipe =  0b010111_0_100;
        SUBFM =  0b010111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      SUPDest = Pcl;
      BDim = dim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC = 3;

CLASS "Const SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             Register:Rc;


    OPCODES
        SUBFMxlu_pipe =  0b010111_0_100;
        SUBFM =  0b010111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      SUPDest = Pcl;
      BDim = dim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC = 1;

CLASS "Const1 SUBFM"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ThreeD("2D"):dim /S(noS):sync
             Predicate:Pcl ','
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];


    OPCODES
        SUBFMxlu_pipe =  0b010111_0_100;
        SUBFM =  0b010111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      SUPDest = Pcl;
      BDim = dim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC = 2;

CLASS "SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
             Register:Rc;


    OPCODES
        SUEAUxlu_pipe =  0b011000_0_100;
        SUEAU =  0b011000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      !SUPDest;
      !BDim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC=0;
      !BFiller;

CLASS "Imm SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             SImm(20):uImm ','
             Register:Rc;


    OPCODES
        SUEAUxlu_pipe =  0b011000_0_100;
        SUEAU =  0b011000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Bconst=uImm;
      RegC = Rc;
      !SUPDest;
      !BDim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC = 3;


CLASS "Const SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] ','
             Register:Rc;


    OPCODES
        SUEAUxlu_pipe =  0b011000_0_100;
        SUEAU =  0b011000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rc;
      !SUPDest;
      !BDim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC = 1;


CLASS "Const1 SUEAU"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /S(noS):sync
             Register:Rd ','
             Register:Ra ','
             Register:Rb ','
C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset];


    OPCODES
        SUEAUxlu_pipe =  0b011000_0_100;
        SUEAU =  0b011000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      RegC = Rb;
      !SUPDest;
      !BDim;
      Sync=S;
      !Signed32;
      !SMode;
      ABC = 2;


CLASS "I2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer(S32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):bytesel;

    OPCODES
        I2Ixlu_pipe =  0b000111_0_100;
        I2I =  0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;
      By = B1B0;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc9;


CLASS "Imm I2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer(S32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):bytesel;

    OPCODES
        I2Ixlu_pipe =  0b000111_0_100;
        I2I =  0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;
      By = B1B0;

      ABC = 3;

      Sync=S;
      !Nenc9;


CLASS "Const I2I"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Integer(S32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):bytesel;

    OPCODES
        I2Ixlu_pipe =  0b000111_0_100;
        I2I =  0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;
      By = B1B0;

      ABC = 1;

      Sync=S;
      !Nenc9;


CLASS "I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel;

    OPCODES
        I2Ixlu_pipe =  0b000111_0_100;
        I2I =  0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );
      By = I2XH;

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc9;
CLASS "Imm I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel;

    OPCODES
        I2Ixlu_pipe =  0b000111_0_100;
        I2I =  0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );
      By = I2XH;

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc9;
CLASS "Const I2I16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Integer:dstfmt /Integer16:srcfmt
                                /SAT(noSAT):sat /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel;

    OPCODES
        I2Ixlu_pipe =  0b000111_0_100;
        I2I =  0b000111_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      IDstFmt = IntSize( dstfmt );
      ISrcFmt =* IntSize( srcfmt );
      By = I2XH;

      Sat = SAT;
      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc9;
CLASS "I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Float(F32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /B1B0(B0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"
         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (IsEven(((Rb)+((Rb)==63)))) :
             ".U64 requires an even source register"
         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

         ERROR
           ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
             ".U32/.S32 to .F16 is not supported"

         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
             ".U64/.S64 to .F16 is not supported"

         ERROR
           ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register D is out if range"

         ERROR
           ((srcfmt == `IntegerNo16@U64) || (srcfmt == `IntegerNo16@S64)) -> (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-2))):
             "Register B is out of range"

    OPCODES
        I2FfmaX_pipe =  0b000110_0_100;
        I2F =  0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );

      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      Rnd = Round1;
      nB = Rb@negate;
      aB = Rb@absolute;
      By = B1B0;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc10;


CLASS "Imm I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Float(F32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /B1B0(B0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"
         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

         ERROR
           ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
             ".U32/.S32 to .F16 is not supported"

         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
             ".U64/.S64 to .F16 is not supported"

         ERROR
           ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register D is out if range"


    OPCODES
        I2FfmaX_pipe =  0b000110_0_100;
        I2F =  0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );

      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      Rnd = Round1;
      nB = UnaryNeg;
      aB = UnaryAbs;
      By = B1B0;

      ABC = 3;

      Sync=S;
      !Nenc10;


CLASS "Const I2F"
##IF DEFINED(ARCH_SEMANTICS)
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode { /Float(F32):dstfmt /IntegerNo16(S32):srcfmt }
##ELSE
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /IntegerNo16:srcfmt
##ENDIF
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /B1B0(B0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"
         ERROR
           ((srcfmt == `Integer@U8) || (srcfmt == `Integer@S8)) -> (dstfmt != `Float@F64) :
             ".U8/.S8 to .F64 is not supported"

         ERROR
           ((srcfmt == `Integer@U32) || (srcfmt == `Integer@S32)) -> (dstfmt != `Float@F16) :
             ".U32/.S32 to .F16 is not supported"

         ERROR
           ((srcfmt == `Integer@U64) || (srcfmt == `Integer@S64)) -> (dstfmt != `Float@F16) :
             ".U64/.S64 to .F16 is not supported"

         ERROR
           ((dstfmt != `Float@F64) && (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))) || ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-2)))):
             "Register D is out if range"


    OPCODES
        I2FfmaX_pipe =  0b000110_0_100;
        I2F =  0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );

      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Rnd = Round1;
      nB = srcConst@negate;
      aB = srcConst@absolute;
      By = B1B0;

      ABC = 1;

      Sync=S;
      !Nenc10;


CLASS "I2F16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-][||]Register:Rb /I2XH(H0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
             "Register D is out if range"

         ERROR
           (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1))):
             "Register B is out of range"

    OPCODES
        I2FfmaX_pipe =  0b000110_0_100;
        I2F =  0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );
      By = I2XH;

      WriteCC = writeCC;
      Dest = Rd;
      RegB = Rb;
      Rnd = Round1;
      nB = Rb@negate;
      aB = Rb@absolute;

      ABC=0;
      !BFiller;
      Sync=S;
      !Nenc10;
CLASS "Imm I2F16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' SImm(20):uImm /UnaryNeg(noNEG):jneg /UnaryAbs(noABS):jabs /I2XH(H0):halfsel;

    CONDITIONS
         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
             "Register D is out if range"


    OPCODES
        I2FfmaX_pipe =  0b000110_0_100;
        I2F =  0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );
      By = I2XH;

      WriteCC = writeCC;
      Dest = Rd;
      Bconst=uImm;
      Rnd = Round1;
      nB = UnaryNeg;
      aB = UnaryAbs;

      ABC = 3;

      Sync=S;
      !Nenc10;
CLASS "Const I2F16"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Float:dstfmt /Integer16:srcfmt
                                  /Round1(RN):rnd /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
',' [-][||]C:srcConst[UImm(5/0*):constBank]* [SImm(17)*:immConstOffset] /I2XH(H0):halfsel;

    CONDITIONS
ERROR constBank <= 17 : "Only constant banks 0..17 are legal"

         ERROR
           (dstfmt == `Float@F64) -> (IsEven(((Rd)+((Rd)==63)))) :
             ".F64 requires an even destination register"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1))):
             "Register D is out if range"


    OPCODES
        I2FfmaX_pipe =  0b000110_0_100;
        I2F =  0b000110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;

      DstFmt = dstfmt;
      ISrcFmt =* IntSize ( srcfmt );
      By = I2XH;

      WriteCC = writeCC;
      Dest = Rd;
!Bgap;BcbankHi,BcbankLo,Bcaddr =  ConstBankAddress2(constBank,immConstOffset);
      Rnd = Round1;
      nB = srcConst@negate;
      aB = srcConst@absolute;

      ABC = 1;

      Sync=S;
      !Nenc10;
CLASS "BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            Register:Ra ',' Register:Rb;

    CONDITIONS ERROR ((Ra+(Ra==63)) == (Rb+(Rb==63))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      !Dest;
      !DstPred;
       SrcPred = `Predicate@PT;
       SrcNot = 0;
      !BarFiller;
      AFix_BAR=0;
      BFix_BAR=0;
      !BarRedOp;
      !Nenc62;
      !Sync;

CLASS "b BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            Register:Ra ',' UImm(12/0):uImm;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      !Dest;
      !DstPred;
       SrcPred = `Predicate@PT;
       SrcNot = 0;

      AFix_BAR=0;
      BFix_BAR=1;
      !BarRedOp;
      !Nenc62;
      !Sync;

CLASS "a b BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            UImm(4):barNum ',' UImm(12/0):uImm;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      !Dest;
      !DstPred;
       SrcPred = `Predicate@PT;
       SrcNot = 0;

      AFix_BAR=1;
      BFix_BAR=1;
      !BarRedOp;
      !Nenc62;
      !Sync;

CLASS "3f BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            UImm(4):barNum ',' UImm(12/0):uImm;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      !DstPred;
       SrcPred = `Predicate@PT;
       SrcNot = 0;

      AFix_BAR=1;
      BFix_BAR=1;
      !BarRedOp;
      !Nenc62;
      !Sync;

CLASS "a BAR Sync"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarSync:barmode
            UImm(4):barNum ',' Register:Rb;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarSync;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      !Dest;
      !DstPred;
       SrcPred = `Predicate@PT;
       SrcNot = 0;
      !BarFiller;
      AFix_BAR=1;
      BFix_BAR=0;
      !BarRedOp;
      !Nenc62;
      !Sync;

CLASS "BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            Register:Ra ',' Register:Rb;

    CONDITIONS ERROR ((Ra+(Ra==63)) == (Rb+(Rb==63))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      !Dest;
      !DstPred;
      !SrcPred;
      !SrcNot;
      !BarFiller;
      AFix_BAR=0;
       BFix_BAR=0;
      !BarRedOp;
      !Nenc62;
      !Sync;



CLASS "a BAR Arv"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            UImm(4):barNum ',' Register:Rb;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      !Dest;
      !DstPred;
      !SrcPred;
      !SrcNot;
      !BarFiller;
      AFix_BAR=1;
       BFix_BAR=0;
      !BarRedOp;
      !Nenc62;
      !Sync;



CLASS "BAR Arv imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            Register:Ra ',' UImm(12):uImm;

    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      !Dest;
      !DstPred;
      !SrcPred;
      !SrcNot;
      AFix_BAR=0;
       BFix_BAR=1;
      !BarRedOp;
      !Nenc62;
      !Sync;

CLASS "a BAR Arv imm"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarArv:barmode
            UImm(4):barNum ',' UImm(12):uImm;

    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarArv;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      !Dest;
      !DstPred;
      !SrcPred;
      !SrcNot;
      AFix_BAR=1;
       BFix_BAR=1;
      !BarRedOp;
      !Nenc62;
      !Sync;

CLASS "BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            Register:Ra ',' Register:Rb ',' [!]Predicate:Pa;

    CONDITIONS ERROR ((Ra+(Ra==63)) == (Rb+(Rb==63))) : "Ra needs to be equal to Rb when specifying registers for SaName and SbarCnt"

    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;
      !DstPred;
      !BarFiller;
      AFix_BAR=0;
      BFix_BAR=0;
      !Nenc62;
      !Sync;
CLASS "b BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            Register:Ra ',' UImm(12/0):uImm ',' [!]Predicate:Pa;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = Ra;
      Imm12 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;
      !DstPred;

      AFix_BAR=0;
      BFix_BAR=1;
      !Nenc62;
      !Sync;
CLASS "a b BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            UImm(4):barNum ',' UImm(12/0):uImm ',' [!]Predicate:Pa;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      Imm12 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;
      !DstPred;

      AFix_BAR=1;
      BFix_BAR=1;
      !Nenc62;
      !Sync;
CLASS "a BAR Red"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BarRED:barmode /Red:redmode
            UImm(4):barNum ',' Register:Rb ',' [!]Predicate:Pa;



    OPCODES
        BARfe_pipe =  0b010100_0_100;
        BAR =  0b010100_0_100;

    ENCODING
      Opcode18 = Opcode;
      BarOp =* BarRED;
      BarRedOp = Red;
      Pred = Pg;
      PredNot = Pg@not;
      RegA = barNum;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      !Dest;
      !DstPred;
      !BarFiller;
      AFix_BAR=1;
      BFix_BAR=0;
      !Nenc62;
      !Sync;
 CLASS "VADD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/ASel4("3210"):asel
             ',' [-]Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

         ERROR
           (AVRG -> (!Ra@negate && !Rb@negate)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD4xlu_pipe =  0b100000_0_100;
        VADD4 =  0b100000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      AVGMode = VMode(AVRG,Ra@negate,Rb@negate);
      BVideo=1;
      !BFiller1;
      Sync=S;



 CLASS "Imm VADD4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/ASel4("3210"):asel
             ',' SSImm(9):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

         ERROR
           (AVRG -> (!Ra@negate && !uImm@sign)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rc)==`Register@RZ)||((Rc)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD4xlu_pipe =  0b100000_0_100;
        VADD4 =  0b100000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      AVGMode = VMode(AVRG,Ra@negate,uImm@sign);
      BVideo=0;

      Sync=S;



 CLASS "VABSDIFF4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF4fau_pipe =  0b100010_0_100;
        VABSDIFF4xlu_pipe =  0b100010_0_100;
        VABSDIFF4 =  0b100010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      !Nenc59;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VABSDIFF4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF4fau_pipe =  0b100010_0_100;
        VABSDIFF4xlu_pipe =  0b100010_0_100;
        VABSDIFF4 =  0b100010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      !Nenc59;
      BVideo=0;

      Sync=S;


 CLASS "VMNMX4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX4xlu_pipe =  0b100001_0_100;
        VMNMX4 =  0b100001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      MN = MN;

      !Nenc100;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VMNMX4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX4xlu_pipe =  0b100001_0_100;
        VMNMX4 =  0b100001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      MN = MN;

      !Nenc100;
      BVideo=0;

      Sync=S;


 CLASS "VSET4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' Register:Rc;

    CONDITIONS



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSET4xlu_pipe =  0b100011_0_100;
        VSET4 =  0b100011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      VComp = ICmpAll;

      !DFormat;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VSET4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSET4xlu_pipe =  0b100011_0_100;
        VSET4 =  0b100011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      VComp = ICmpAll;

      !DFormat;
      BVideo=0;

      Sync=S;


 CLASS "VSHL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8(S8):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("4444"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSHL4xlu_pipe =  0b100101_0_100;
        VSHL4 =  0b100101_0_100;
        VSHR4xlu_pipe =  0b100100_0_100;
        VSHR4 =  0b100100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;
      MV = CWMode;

      !Nenc101;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VSHL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8(S8):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' Register:Rc;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

    OPCODES
        VSHL4xlu_pipe =  0b100101_0_100;
        VSHL4 =  0b100101_0_100;
        VSHR4xlu_pipe =  0b100100_0_100;
        VSHR4 =  0b100100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;
      MV = CWMode;

      !Nenc101;
      BVideo=0;

      Sync=S;


 CLASS "VSEL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' Register:Rb/BSel4("7654"):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL4xlu_pipe =  0b100110_0_100;
        VSEL4 =  0b100110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      bsel4 = bsel;

      !Nenc102;
      BVideo=1;
      !BFiller1;
      Sync=S;


 CLASS "Imm VSEL4"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer8(S8):safmt /Integer8(S8):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask4(XYZW):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/ASel4("3210"):asel
             ',' UImm(8):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS ERROR Video4ImmSel(asel) : "Specified input selection is not allowed for the immediate mode of this operation"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"



        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL4xlu_pipe =  0b100110_0_100;
        VSEL4 =  0b100110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm8 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer8Signed(safmt);
      sbfmt = Integer8Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask4 = LaneMask4;
      WriteCC = writeCC;
      asel4 = asel;
      !bsel4;

      !Nenc102;
      BVideo=0;

      Sync=S;


 CLASS "VADD2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/Sel2("10"):asel
             ',' [-]Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (AVRG -> (!Ra@negate && !Rb@negate)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD2xlu_pipe =  0b101000_0_100;
        VADD2 =  0b101000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      AVGMode = VMode(AVRG,Ra@negate,Rb@negate);
      BVideo=1;
      !BFiller2;
      Sync=S;



 CLASS "Imm VADD2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /AVRG(noAVRG):avg /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/Sel2hi("10"):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (AVRG -> (!Ra@negate && !uImm@sign)) :
             ".AVRG cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VADD2xlu_pipe =  0b101000_0_100;
        VADD2 =  0b101000_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      AVGMode = VMode(AVRG,Ra@negate,uImm@sign);
      BVideo=0;

      Sync=S;



 CLASS "VABSDIFF2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF2xlu_pipe =  0b101010_0_100;
        VABSDIFF2 =  0b101010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      !Nenc59;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VABSDIFF2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VABSDIFF2xlu_pipe =  0b101010_0_100;
        VABSDIFF2 =  0b101010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      !Nenc59;
      BVideo=0;

      Sync=S;


 CLASS "VMNMX2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX2xlu_pipe =  0b101001_0_100;
        VMNMX2 =  0b101001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      MN = MN;

      !Nenc100;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VMNMX2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VMNMX2xlu_pipe =  0b101001_0_100;
        VMNMX2 =  0b101001_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      MN = MN;

      !Nenc100;
      BVideo=0;

      Sync=S;


 CLASS "VSET2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSET2xlu_pipe =  0b101011_0_100;
        VSET2 =  0b101011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      VComp = ICmpAll;

      !DFormat;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VSET2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSET2xlu_pipe =  0b101011_0_100;
        VSET2 =  0b101011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      VComp = ICmpAll;

      !DFormat;
      BVideo=0;

      Sync=S;


 CLASS "VSHL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16(S16):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("22"):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSHL2xlu_pipe =  0b101101_0_100;
        VSHL2 =  0b101101_0_100;
        VSHR2xlu_pipe =  0b101100_0_100;
        VSHR2 =  0b101100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;
      MV = CWMode;

      !Nenc101;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VSHL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16(S16):safmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSHL2xlu_pipe =  0b101101_0_100;
        VSHL2 =  0b101101_0_100;
        VSHR2xlu_pipe =  0b101100_0_100;
        VSHR2 =  0b101100_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;

      MV = CWMode;

      !Nenc101;
      BVideo=0;

      Sync=S;


 CLASS "VSEL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2("10"):asel
             ',' Register:Rb/Sel2("32"):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
         && (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL2xlu_pipe =  0b101110_0_100;
        VSEL2 =  0b101110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2 = asel;
      bsel2 = bsel;

      !Nenc102;
      BVideo=1;
      !BFiller2;
      Sync=S;


 CLASS "Imm VSEL2"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /Integer16(S16):safmt /Integer16(S16):sbfmt }
                  /SAT(noSAT):sat /VRed(SIMD_MRG):vred /LaneMask2(XY):laneMsk /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/Sel2hi("10"):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

        ERROR
            (sat == `SAT@SAT) -> (vred != `VRed@ACC):
                "Illegal instruction encoding"

        ERROR
            (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))
         && (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))
           :
                "Register out of range"

    OPCODES
        VSEL2xlu_pipe =  0b101110_0_100;
        VSEL2 =  0b101110_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      DFormat = DFormat;
      safmt = Integer16Signed(safmt);
      sbfmt = Integer16Signed(sbfmt);
      Sat3 = SAT;
      VRed = VRed;
      LaneMask2 = LaneMask2;
      WriteCC = writeCC;
      asel2hi = asel;


      !Nenc102;
      BVideo=0;

      Sync=S;


 CLASS "VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a8 b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a32 b8 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a8 b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "a32 b32 VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !Rb@negate) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,Rb@negate);
      !Nenc103;
      BVideo=1;
      !BFiller3;
      Sync=S;

 CLASS "Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,uImm@sign);
      !Nenc103;
      BVideo=0;

      Sync=S;

 CLASS "a8 Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,uImm@sign);
      !Nenc103;
      BVideo=0;

      Sync=S;

 CLASS "a32 Imm VADD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /PO(noPO):po /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(17):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign)) :
             ".PO cannot be used with '-' on either input"
         ERROR
           (!Ra@negate || !uImm@sign) :
             "Cannot use '-' on both of the inputs"

    OPCODES
        VADDxlu_pipe =  0b11000_0_100;
        VADD =  0b11000_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      AVGMode = PSign(PO,Ra@negate,uImm@sign);
      !Nenc103;
      BVideo=0;

      Sync=S;

 CLASS "VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer16:safmt /Integer:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt /Integer8:safmt /Integer:sbfmt
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VABSDIFF"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(UD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VABSDIFFxlu_pipe =  0b11010_0_100;
        VABSDIFF =  0b11010_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      !Nenc104;
      BVideo=0;

      Sync=S;


 CLASS "VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VMNMX"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /MN(MN):mnmx /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VMNMXxlu_pipe =  0b11001_0_100;
        VMNMX =  0b11001_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MN = MN;

      !Nenc105;
      BVideo=0;

      Sync=S;


 CLASS "VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt } /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt } /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS

    OPCODES
        VSETxlu_pipe =  0b11011_0_100;
        VSET =  0b11011_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      VOP = VOP;
      WriteCC = writeCC;
      VComp = ICmpAll;

      !Nenc106;
      BVideo=0;

      Sync=S;


 CLASS "VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer16:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /VInteger32:safmt /Integer8:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /VInteger32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /VInteger32:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /VInteger32(S32):sbfmt } /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' Register:Rb
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer16:safmt /Integer:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt /Integer8:safmt /Integer:sbfmt /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VSHL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /DFormat(SD):dfmt { /VInteger32(S32):safmt /Integer(S32):sbfmt } /CWMode(C):wrap
                  /SAT(noSAT):sat /VOP(PASS):vop /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' Register:Rc;

    CONDITIONS
         ERROR
           !IsOdd(sbfmt) :
             "No signed integer format allowed for shift count"

    OPCODES
        VSHLxlu_pipe =  0b11101_0_100;
        VSHL =  0b11101_0_100;
        VSHRxlu_pipe =  0b11100_0_100;
        VSHR =  0b11100_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      DFormat2 = DFormat;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      VOP = VOP;
      WriteCC = writeCC;
      MV = CWMode;

      !Nenc107;
      BVideo=0;

      Sync=S;


 CLASS "VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/H1H0(H0):bsel
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer16:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb/H1H0(H0):bsel
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a8 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb/B1B0(B0):bsel
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a32 b8 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /VInteger32:safmt /Integer8:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb/B1B0(B0):bsel
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /VInteger32:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' Register:Rb
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a8 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a8 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /VInteger32:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' Register:Rb
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "a32 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' Register:Rb
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      RegB = Rb;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 ALTERNATE CLASS "NoBop a32 b32 VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' Register:Rb
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      RegB = Rb;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=1;
      !BFiller3;
      Sync=S;


 CLASS "Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 ALTERNATE CLASS "NoBop Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer16:safmt /Integer:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/H1H0(H0):asel
             ',' UImm(16):uImm
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 CLASS "a8 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 ALTERNATE CLASS "NoBop a8 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  /Integer8:safmt /Integer:sbfmt
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra/B1B0(B0):asel
             ',' UImm(16):uImm
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 CLASS "a32 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                   /Bop:bopopt /S(noS):sync
             Predicate:Pd ',' Predicate:nPd
             ',' Register:Ra
             ',' UImm(16):uImm
             ',' [!]Predicate:Pa;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = Pa;
      SrcNot = Pa@not;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Bop = bopopt;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 ALTERNATE CLASS "NoBop a32 Imm VSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /ICmpAll:icomp
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                    /S(noS):sync
             Predicate:Pd
             ',' Register:Ra
             ',' UImm(16):uImm
             ;

    CONDITIONS

    OPCODES
        VSETPxlu_pipe =  0b11111_0_100;
        VSETP =  0b11111_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      RegA = Ra;
      Imm16 = uImm;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Bop = `Bop@AND;
      VComp = ICmpAll;


      !Nenc108;
      BVideo=0;

      Sync=S;


 CLASS "VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer16:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/H1H0(H0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat16(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a8 b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a32 b8 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /VInteger32:safmt /Integer8:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb/B1B0(B0):bsel
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat8(sbfmt,bsel);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a8 b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /VInteger32:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "a32 b32 VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  { /VInteger32(S32):safmt /VInteger32(S32):sbfmt }
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' [-]Register:Rb
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !Rb@negate && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      RegB = Rb;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      bSelect =* VFormat32(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,Rb@negate,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=1;
      !BFiller3;
      Sync=S;




 CLASS "Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer16:safmt /Integer:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/H1H0(H0):asel
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat16(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=0;

      Sync=S;




 CLASS "a8 Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  /Integer8:safmt /Integer:sbfmt
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra/B1B0(B0):asel
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat8(safmt,asel);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=0;

      Sync=S;




 CLASS "a32 Imm VMAD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode
                  { /VInteger32(S32):safmt /Integer(S32):sbfmt }
                  /PO(noPO):po /VMadScale(PASS):vscale /SAT(noSAT):sat /Pipe2FMALite(HW):pipe2 /S(noS):sync
             Register:Rd /optCC(noCC):writeCC
             ',' [-]Register:Ra
             ',' SSImm(17):uImm
             ',' [-]Register:Rc;

    CONDITIONS
         ERROR
           (PO -> (!Ra@negate && !uImm@sign && !Rc@negate)) :
             ".PO cannot be used with '-' on either input"

    OPCODES
        VMADfmaX_pipe =  0b11110_0_100;
        VMAD =  0b11110_0_100;

    ENCODING
      Opcode3 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA = Ra;
      Imm16 = uImm;
      RegC = Rc;
      aSelect =* VFormat32(safmt);
      sbfmt = IntegerSigned(sbfmt);
      Sat3 = SAT;
      WriteCC = writeCC;
      AVGMode = PSignMAD(PO,Ra@negate,uImm@sign,Rc@negate);
      Pipe2c = pipe2;
      VScale = VMadScale;
      !Nenc109;
      BVideo=0;

      Sync=S;




CLASS "PSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0 /Bop:bopopt /S(noS):sync
                               Predicate:Pd ',' Predicate:nPd
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ',' [!]Predicate:Pa;

    OPCODES
        PSETPfau_pipe =  0b000011_0_100;
        PSETPxlu_pipe =  0b000011_0_100;
        PSETP =  0b000011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = nPd;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop0 = bop0;
      Bop = bopopt;


      !Nenc5;
      Sync=S;


ALTERNATE CLASS "NoBop PSETP"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /Bop:bop0 /S(noS):sync
                               Predicate:Pd
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ;

    OPCODES
        PSETPfau_pipe =  0b000011_0_100;
        PSETPxlu_pipe =  0b000011_0_100;
        PSETP =  0b000011_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      PDest = Pd;
      PNDest = `Predicate@PT;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop0 = bop0;
      Bop = `Bop@AND;


      !Nenc5;
      Sync=S;


CLASS "PSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0 /Bop:bopopt /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ',' [!]Predicate:Pa;

    OPCODES
        PSETfau_pipe =  0b000010_0_100;
        PSETxlu_pipe =  0b000010_0_100;
        PSET =  0b000010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = Pa;
      SrcNot = Pa@not;
      Bop0 = bop0;
      Bop = bopopt;
      BVal = BVal;


      !Nenc6;
      Sync=S;
ALTERNATE CLASS "NoBop PSET"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /BVal(BM):bval /Bop:bop0 /S(noS):sync
                               Register:Rd /optCC(noCC):writeCC
                                    ',' [!]Predicate:Pc
                                    ',' [!]Predicate:Pb
                                    ;

    OPCODES
        PSETfau_pipe =  0b000010_0_100;
        PSETxlu_pipe =  0b000010_0_100;
        PSET =  0b000010_0_100;

    ENCODING
      Opcode2 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      WriteCC = writeCC;
      !Pipe2;
      Src2Pred = Pc;
      Src2Not = Pc@not;
      Src1Pred = Pb;
      Src1Not = Pb@not;
      SrcPred = `Predicate@PT;
      SrcNot = 0;
      Bop0 = bop0;
      Bop = `Bop@AND;
      BVal = BVal;


      !Nenc6;
      Sync=S;
 CLASS "MEMBAR"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /MemBarLevel:lvl /S(noS):sync;

    OPCODES
        MEMBARagu_pipe =  0b111000_0_101;
        MEMBAR =  0b111000_0_101;

    ENCODING
      Opcode2 = Opcode;
      MembarL = MemBarLevel;
      Pred = Pg;
      PredNot = Pg@not;
      Sync=S;
      !Nenc110;
 CLASS "LDL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [NonZeroRegister:Ra + SImm(24/0)*:sImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        LDLagu_pipe =  0b110000_0_0_101;
        LDL =  0b110000_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      COP = LLoadCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "I LDL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LLoadCacheOp(CA):cop /CInteger("32"):size /S(noS):sync
             Register:Rd ','
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm];

    CONDITIONS
         ERROR
           (((Rd)+((Rd)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        LDLagu_pipe =  0b110000_0_0_101;
        LDL =  0b110000_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      COP = LLoadCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "STL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0)*:sImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        STLagu_pipe =  0b110010_0_0_101;
        STL =  0b110010_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = sImm;
      LSSize = CInteger;
      COP = StoreCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "I STL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /StoreCacheOp(WB):cop /CInteger("32"):size /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ',' Register:Rb;

    CONDITIONS
         ERROR
           (((Rb)+((Rb)==63)) % CRegAlignment(CInteger)) == 0 :
             "Output register improperly aligned for specified operation size"

         ERROR
           (((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1))):
             "Register A is out of range"

         ERROR
           (((Rb)==`Register@RZ)||((Rb)<=(%MAX_REG_COUNT-CRegAlignment(CInteger)))):
             "Register D is out of range"

    OPCODES
        STLagu_pipe =  0b110010_0_0_101;
        STL =  0b110010_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rb;
      RegA =* Ra;
      Imm24 = uImm;
      LSSize = CInteger;
      COP = StoreCacheOp;

      !Nenc73;
      Sync=S;


 CLASS "CCTLL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLOp:cctllop /S(noS):sync
             [NonZeroRegister:Ra + SImm(24/0)*:sImm] ;

    CONDITIONS
         ERROR
           !(cctllop != `CCTLOp@WBALL && cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache != `LCache@CRS) :
                "WBALL is disallowed without CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache == `LCache@CRS && (Ra != `Register@RZ || sImm != 0)) :
                "Address operand must be [0] for CCTLL.CRS.WBALL"
         ERROR
           !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

         ERROR
           (cctllop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                "In CCTLL.IVALL Register A should be zero register"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b110100_0_0_101;
        CCTLL =  0b110100_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm22a = sImm SCALE 4;
      CCTLOp =* cctllop;
      Cache = cache;

      !Nenc73;
      Sync=S;


 CLASS "I CCTLL"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLOp:cctllop /S(noS):sync
             [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ;

    CONDITIONS
         ERROR
           !(cctllop != `CCTLOp@WBALL && cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache != `LCache@CRS) :
                "WBALL is disallowed without CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache == `LCache@CRS && (Ra != `Register@RZ || uImm != 0)) :
                "Address operand must be [0] for CCTLL.CRS.WBALL"
         ERROR
           !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

         ERROR
           (cctllop == `CCTLOp@IVALL) -> (Ra == `Register@RZ):
                "In CCTLL.IVALL Register A should be zero register"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b110100_0_0_101;
        CCTLL =  0b110100_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA =* Ra;
      Imm22a = uImm SCALE 4;
      CCTLOp =* cctllop;
      Cache = cache;

      !Nenc73;
      Sync=S;


 ALTERNATE CLASS "CCTLL NoOperands"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /CCTLLOp2:cctllop /S(noS):sync
             ;

    CONDITIONS
         ERROR
           !(cctllop != `CCTLOp@WBALL && cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@WBALL && cache != `LCache@CRS) :
                "WBALL is disallowed without CCTLL.CRS"
         ERROR
           !(cctllop == `CCTLOp@RSLB) :
                "RSLB is disallowed for CCTLL"

    OPCODES
        CCTLLagu_pipe =  0b110100_0_0_101;
        CCTLL =  0b110100_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      !Dest;
      RegA = `Register@RZ;
      Imm22a = 0;
      CCTLOp =* cctllop;
      Cache = cache;

      !Nenc73;
      Sync=S;




 CLASS "CCTLL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /OnlyQry:op /S(noS):sync
              Register:Rd ',' [NonZeroRegister:Ra + SImm(24/0)*:sImm] ;

    CONDITIONS
         ERROR
           !(cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"

         ERROR
           ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b110100_0_0_101;
        CCTLL =  0b110100_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm22a = sImm SCALE 4;
      CCTLOp =* OnlyQry;
      Cache = cache;

      !Nenc73;
      Sync=S;


 CLASS "I CCTLL QRY"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /OnlyQry:op /S(noS):sync
              Register:Rd ',' [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ;

    CONDITIONS
         ERROR
           !(cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"

         ERROR
           ((((Rd)==`Register@RZ)||((Rd)<=(%MAX_REG_COUNT-1)))):
                "Register D is out of range"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b110100_0_0_101;
        CCTLL =  0b110100_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = Rd;
      RegA =* Ra;
      Imm22a = uImm SCALE 4;
      CCTLOp =* OnlyQry;
      Cache = cache;

      !Nenc73;
      Sync=S;


 ALTERNATE CLASS "CCTLL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /OnlyQry:op /S(noS):sync
              [NonZeroRegister:Ra + SImm(24/0)*:sImm] ;

    CONDITIONS
         ERROR
           !(cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b110100_0_0_101;
        CCTLL =  0b110100_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm22a = sImm SCALE 4;
      CCTLOp =* OnlyQry;
      Cache = cache;

      !Nenc73;
      Sync=S;
 ALTERNATE CLASS "I CCTLL QRY NoRD"
    FORMAT PREDICATE @[!]Predicate(PT):Pg Opcode /LCache(D):cache /OnlyQry:op /S(noS):sync
              [ZeroRegister(RZ):Ra + UImm(24/0)*:uImm] ;

    CONDITIONS
         ERROR
           !(cache == `LCache@CRS) :
                "Cache Operation is disallowed for CCTLL.CRS"

         ERROR
           ((((Ra)==`Register@RZ)||((Ra)<=(%MAX_REG_COUNT-1)))):
                "Register A is out of range"

    OPCODES
        CCTLLagu_pipe =  0b110100_0_0_101;
        CCTLL =  0b110100_0_0_101;

    ENCODING
      Opcode22 = Opcode;
      Pred = Pg;
      PredNot = Pg@not;
      Dest = `Register@RZ;
      RegA =* Ra;
      Imm22a = uImm SCALE 4;
      CCTLOp =* OnlyQry;
      Cache = cache;

      !Nenc73;
      Sync=S;
