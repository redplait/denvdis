ARCHITECTURE "NVIDIA Tesla GPU"

   PROCESSOR_ID Tesla;
   ISSUE_SLOTS 1;
   WORD_SIZE 64;
   BRANCH_DELAY 0;
   ELF_ID 190;
   ELF_ABI 0x33;
   ELF_ABI_VERSION 7;


   ELF_VERSION 75;

   RELOCATORS
  { "R_CUDA_NONE", 0, False, False, 0,0, { { 0, 0} } }
  { "R_CUDA_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_G32", "R_CUDA_G32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_G64", "R_CUDA_G64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_ABS32_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_TEX_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_SAMP_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 20, 12} } }
  { "R_CUDA_SURF_HW_DESC", "R_CUDA_SURF_HW_DESC", 32 }
  { "R_CUDA_SURF_HW_SW_DESC", "R_CUDA_SURF_HW_SW_DESC", 32 }
  { "R_CUDA_ABS32_LO_26", 0x00000000ffffffff, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_HI_26", 0xffffffff00000000, False, False, 0,0, { { 26, 32} } }
  { "R_CUDA_ABS32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_ABS24_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 24} } }
  { "R_CUDA_ABS24_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS16_26", 0xffffffffffffffff, False, False, 0,0, { { 26, 16} } }
  { "R_CUDA_ABS16_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 16} } }
  { "R_CUDA_TEX_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 32, 8} } }
  { "R_CUDA_SAMP_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 40, 5} } }
  { "R_CUDA_SURF_SLOT", 0xffffffffffffffff, False, False, 0,0, { { 26, 6} } }
  { "R_CUDA_TEX_BINDLESSOFF13_32", 0xffffffffffffffff, False, False, 0,2, { { 32, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_47", 0xffffffffffffffff, False, False, 0,2, { { 47, 13} } }
  { "R_CUDA_CONST_FIELD19_28", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 28, 18},
  { 26, 1} } }
  { "R_CUDA_CONST_FIELD19_23", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 23, 19} } }
  { "R_CUDA_TEX_SLOT9_49", 0xffffffffffffffff, False, False, 0,0, { { 49, 9} } }
  { "R_CUDA_6_31", 0xffffffffffffffff, False, False, 0,0, { { 31, 6} } }
  { "R_CUDA_2_47", 0xffffffffffffffff, False, False, 0,0, { { 47, 2} } }
  { "R_CUDA_TEX_BINDLESSOFF13_41", 0xffffffffffffffff, False, False, 0,2, { { 41, 13} } }
  { "R_CUDA_TEX_BINDLESSOFF13_45", 0xffffffffffffffff, False, False, 0,2, { { 45, 13} } }
  { "R_CUDA_FUNC_DESC32_23", 0xffffffffffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_23", 0x00000000ffffffff, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_23", 0xffffffff00000000, False, False, 0,0, { { 23, 32} } }
  { "R_CUDA_FUNC_DESC_32", "R_CUDA_FUNC_DESC_32", 0xffffffffffffffff, False, False, 0,0, { { 0, 32} } }
  { "R_CUDA_FUNC_DESC_64", "R_CUDA_FUNC_DESC_64", 0xffffffffffffffff, False, False, 0,0, { { 0, 64} } }
  { "R_CUDA_CONST_FIELD21_26", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 26, 21} } }
  { "R_CUDA_QUERY_DESC21_37", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 37, 21} } }
  { "R_CUDA_CONST_FIELD19_26", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 26, 19} } }
  { "R_CUDA_CONST_FIELD21_23", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 23, 21} } }
  { "R_CUDA_PCREL_IMM24_26", 0xffffffffffffffff, True, False, 0,0, { { 26, 24} } }
  { "R_CUDA_PCREL_IMM24_23", 0xffffffffffffffff, True, False, 0,0, { { 23, 24} } }
  { "R_CUDA_ABS32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_ABS24_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 24} } }
  { "R_CUDA_ABS16_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 16} } }
  { "R_CUDA_FUNC_DESC32_20", 0xffffffffffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_LO_20", 0x00000000ffffffff, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_FUNC_DESC32_HI_20", 0xffffffff00000000, False, False, 0,0, { { 20, 32} } }
  { "R_CUDA_CONST_FIELD19_20", 0xffffffffffffffff, "ConstBankAddress2", False, False, 0,0, { { 20, 19} } }
  { "R_CUDA_BINDLESSOFF13_36", 0xffffffffffffffff, False, False, 0,2, { { 36, 13} } }
  { "R_CUDA_SURF_HEADER_INDEX", 0xffffffffffffffff, False, False, False, 0,0, { { 0, 20} } }
  { "R_CUDA_INSTRUCTION8", "R_CUDA_INSTRUCTION8", 8 }
  { "R_CUDA_CONST_FIELD21_20", 0xffffffffffffffff, "ConstBankAddress0", False, False, 0,0, { { 20, 21} } }
      ;


   OPTIONS NOCHECK_OPCLASS_AMBIGUITY,
           CASE_INSENSITIVE_SYNTAX;

   EMPTY_INSTRUCTION = "NOP;";


CONSTANTS
    ITYPE_OTHER = 0
    ITYPE_BRANCH = 1 << 0
    ITYPE_TEX_S = 1 << 1
    ITYPE_TEX_T = 1 << 2
    ITYPE_IMMEDIATE_BRANCH = 1 << 3

REGISTERS

    Register R(0 .. 127);

    Register16 R(0 .. 63)L = (0 .. 126 /2),
                       R(0 .. 63)H = (1 .. 127 /2);

    Address A(0 .. 7);
    Condition C(0 .. 3);
    noCondition noCond = 4 ;

    SpecialRegister TID = 0, SR0 = 0,
                       Clock = 1, SR1 = 1,
                       Coop = 2, SR2 = 2,
                       GBC = 3, SR3 = 3,
                       Perf0 = 4, SR4 = 4,
                       Perf1 = 5, SR5 = 5,
                       Perf2 = 6, SR6 = 6,
                       Perf3 = 7, SR7 = 7,
                       Sample = 8, SR8 = 8;

KEYWORDS

    Float F16=2, F32=4, F64=5;
    Integer16 U16=2, S16=3;
    IntegerNon16 U8=0, S8= 1, U32=4, S32=5, U64=6, S64=7;

    Integer24 U24=100, S24=101;
    Integer128 U128=8, S128=9;

    Barrier b (0..15);
    C c ;
    V v ;
    O o ;
    G g ;
    GRF GRF ;
    Local local ;
    GLOB global (0..15);
    PHASE P (0.. 7);
    CARRY CARRY (0.. 3);

    noCARRY noCARRY = 4 ;

    Rounding RN=0, ROUND=0,
                    RM=1, FLOOR=1,
                    RP=2, CEIL =2,
                    RZ=3, TRUNC=3;

    LogicalOp AND, OR, XOR, PASS_B;

    RROmode SINCOS=0, COS=0, SIN=0, EX2=1;


    HILO LO, HI;
    IR noIR, IR;
    SAT noSAT, SAT;
    BSAT noBSAT, BSAT;
    BEXT noBEXT, BEXT;
    PIPE noPIPE, MAD,SFU;
    UNL noUNL, UNL;
    CUBE noCUBE, CUBE;
    NODEP noNODEP, NODEP;
    ND noND, ND;
    UN noUN, UN;
    S noS, S;


    MEMOP2
                    IADD = 0,
                    EXCH = 1,
                    FADD = 3,
                    INC = 4,
                    DEC = 5,
                    IMAX = 6,
                    IMIN = 7,
                    FMAX = 8,
                    FMIN = 9,
                    IAND = 10,
                    IOR = 11,
                    IXOR = 12,
                    IMUL = 13,
                    FMUL = 14;

    MEMOP3 CAS = 2;


    CC
        FALSE = 0,
        LT = 1,
        EQ = 2,
        LE = 3,
        GT = 4,
        NE = 5,
        GE = 6,
        LEG = 7,
        U = 8,
        LTU = 9,
        EQU = 10,
        LEU = 11,
        GTU = 12,
        NEU = 13,
        GEU = 14,
        TRUE = 15,
        OVERFLOW = 16,
        CARRY = 17,
        ABOVE = 18,
        SIGN = 19,
        NOT_SIGN = 28,
        BELOW_OR_EQUAL = 29,
        NOT_CARRY = 30,
        NOT_OVERFLOW = 31;







    Swizzle
        "0000" = 0,
        "1111" = 1,
        "2222" = 2,
        "3333" = 3,
        "1032" = 4,
        "2301" = 5;

    TMask
        XXXX, RXXX, XGXX, RGXX,
        XXBX, RXBX, XGBX, RGBX,
        XXXA, RXXA, XGXA, RGXA,
        XXBA, RXBA, XGBA, RGBA;


    PNWord
        PPPPPPPP,PPPPPPNP,PPPPPPPN,PPPPPPZP,PPPPNPPP,PPPPNPNP,PPPPNPPN,PPPPNPZP,
        PPPPPNPP,PPPPPNNP,PPPPPNPN,PPPPPNZP,PPPPZPPP,PPPPZPNP,PPPPZPPN,PPPPZPZP,
        PPNPPPPP,PPNPPPNP,PPNPPPPN,PPNPPPZP,PPNPNPPP,PPNPNPNP,PPNPNPPN,PPNPNPZP,
        PPNPPNPP,PPNPPNNP,PPNPPNPN,PPNPPNZP,PPNPZPPP,PPNPZPNP,PPNPZPPN,PPNPZPZP,
        PPPNPPPP,PPPNPPNP,PPPNPPPN,PPPNPPZP,PPPNNPPP,PPPNNPNP,PPPNNPPN,PPPNNPZP,
        PPPNPNPP,PPPNPNNP,PPPNPNPN,PPPNPNZP,PPPNZPPP,PPPNZPNP,PPPNZPPN,PPPNZPZP,
        PPZPPPPP,PPZPPPNP,PPZPPPPN,PPZPPPZP,PPZPNPPP,PPZPNPNP,PPZPNPPN,PPZPNPZP,
        PPZPPNPP,PPZPPNNP,PPZPPNPN,PPZPPNZP,PPZPZPPP,PPZPZPNP,PPZPZPPN,PPZPZPZP,
        NPPPPPPP,NPPPPPNP,NPPPPPPN,NPPPPPZP,NPPPNPPP,NPPPNPNP,NPPPNPPN,NPPPNPZP,
        NPPPPNPP,NPPPPNNP,NPPPPNPN,NPPPPNZP,NPPPZPPP,NPPPZPNP,NPPPZPPN,NPPPZPZP,
        NPNPPPPP,NPNPPPNP,NPNPPPPN,NPNPPPZP,NPNPNPPP,NPNPNPNP,NPNPNPPN,NPNPNPZP,
        NPNPPNPP,NPNPPNNP,NPNPPNPN,NPNPPNZP,NPNPZPPP,NPNPZPNP,NPNPZPPN,NPNPZPZP,
        NPPNPPPP,NPPNPPNP,NPPNPPPN,NPPNPPZP,NPPNNPPP,NPPNNPNP,NPPNNPPN,NPPNNPZP,
        NPPNPNPP,NPPNPNNP,NPPNPNPN,NPPNPNZP,NPPNZPPP,NPPNZPNP,NPPNZPPN,NPPNZPZP,
        NPZPPPPP,NPZPPPNP,NPZPPPPN,NPZPPPZP,NPZPNPPP,NPZPNPNP,NPZPNPPN,NPZPNPZP,
        NPZPPNPP,NPZPPNNP,NPZPPNPN,NPZPPNZP,NPZPZPPP,NPZPZPNP,NPZPZPPN,NPZPZPZP,
        PNPPPPPP,PNPPPPNP,PNPPPPPN,PNPPPPZP,PNPPNPPP,PNPPNPNP,PNPPNPPN,PNPPNPZP,
        PNPPPNPP,PNPPPNNP,PNPPPNPN,PNPPPNZP,PNPPZPPP,PNPPZPNP,PNPPZPPN,PNPPZPZP,
        PNNPPPPP,PNNPPPNP,PNNPPPPN,PNNPPPZP,PNNPNPPP,PNNPNPNP,PNNPNPPN,PNNPNPZP,
        PNNPPNPP,PNNPPNNP,PNNPPNPN,PNNPPNZP,PNNPZPPP,PNNPZPNP,PNNPZPPN,PNNPZPZP,
        PNPNPPPP,PNPNPPNP,PNPNPPPN,PNPNPPZP,PNPNNPPP,PNPNNPNP,PNPNNPPN,PNPNNPZP,
        PNPNPNPP,PNPNPNNP,PNPNPNPN,PNPNPNZP,PNPNZPPP,PNPNZPNP,PNPNZPPN,PNPNZPZP,
        PNZPPPPP,PNZPPPNP,PNZPPPPN,PNZPPPZP,PNZPNPPP,PNZPNPNP,PNZPNPPN,PNZPNPZP,
        PNZPPNPP,PNZPPNNP,PNZPPNPN,PNZPPNZP,PNZPZPPP,PNZPZPNP,PNZPZPPN,PNZPZPZP,
        ZPPPPPPP,ZPPPPPNP,ZPPPPPPN,ZPPPPPZP,ZPPPNPPP,ZPPPNPNP,ZPPPNPPN,ZPPPNPZP,
        ZPPPPNPP,ZPPPPNNP,ZPPPPNPN,ZPPPPNZP,ZPPPZPPP,ZPPPZPNP,ZPPPZPPN,ZPPPZPZP,
        ZPNPPPPP,ZPNPPPNP,ZPNPPPPN,ZPNPPPZP,ZPNPNPPP,ZPNPNPNP,ZPNPNPPN,ZPNPNPZP,
        ZPNPPNPP,ZPNPPNNP,ZPNPPNPN,ZPNPPNZP,ZPNPZPPP,ZPNPZPNP,ZPNPZPPN,ZPNPZPZP,
        ZPPNPPPP,ZPPNPPNP,ZPPNPPPN,ZPPNPPZP,ZPPNNPPP,ZPPNNPNP,ZPPNNPPN,ZPPNNPZP,
        ZPPNPNPP,ZPPNPNNP,ZPPNPNPN,ZPPNPNZP,ZPPNZPPP,ZPPNZPNP,ZPPNZPPN,ZPPNZPZP,
        ZPZPPPPP,ZPZPPPNP,ZPZPPPPN,ZPZPPPZP,ZPZPNPPP,ZPZPNPNP,ZPZPNPPN,ZPZPNPZP,
        ZPZPPNPP,ZPZPPNNP,ZPZPPNPN,ZPZPPNZP,ZPZPZPPP,ZPZPZPNP,ZPZPZPPN,ZPZPZPZP;


    OptCondition = Condition + noCondition;
    OptCARRY = CARRY + noCARRY;
    Integer = Integer16 + IntegerNon16;
    MulInteger = Integer16 + IntegerNon16 + Integer24;
    AllInts = Integer16 + IntegerNon16 + Integer24 + Integer128;

    MulInteger16 = Integer16;
    MemSize16 = Integer16;

    MulIntegerNon16 = IntegerNon16 + Integer24;
    MemSizeNon16 = IntegerNon16 + Integer128;
    MemSize
          U8 = 0,
          S8 = 1,
          U16 = 2,
          S16 = 3,
          U64 = 4,
          U128 = 5,
          U32 = 6,
          S32 = 7,

          S64 = 4,
          S128 = 5
          ;
TABLES




    F2FSizes
          F32 F32 -> 0b101
          F16 F16 -> 0b000
          F32 F16 -> 0b100
          F32 F32 -> 0b010
          F64 F32 -> 0b110
          F16 F32 -> 0b001
          F32 F64 -> 0b011
          F64 F64 -> 0b111
          ;

    F2ISizes
          AllInts@U64 F32 -> 0b0110
          AllInts@U64 F64 -> 0b0111
          AllInts@U32 F64 -> 0b0011
          AllInts@U32 F32 -> 0b0101
          AllInts@U16 F32 -> 0b0001
          AllInts@U16 F16 -> 0b0000
          AllInts@S64 F64 -> 0b1111
          AllInts@S64 F32 -> 0b1110
          AllInts@S32 F64 -> 0b1011
          AllInts@S32 F32 -> 0b1101
          AllInts@S16 F32 -> 0b1001
          AllInts@S16 F16 -> 0b1000

          ;

    I2FSizes
          F32 AllInts@U64 -> 0b0101
          F64 AllInts@U64 -> 0b1101
          F64 AllInts@U32 -> 0b1100
          F32 AllInts@U32 -> 0b1001
          F32 AllInts@U16 -> 0b1000
          F16 AllInts@U16 -> 0b0000
          F64 AllInts@S64 -> 0b1111
          F32 AllInts@S64 -> 0b0111
          F64 AllInts@S32 -> 0b1110
          F32 AllInts@S32 -> 0b1011
          F32 AllInts@S16 -> 0b1010
          F16 AllInts@S16 -> 0b0010

          ;

    I2ISizes
          AllInts@U16 AllInts@U16 -> 0b0000
          AllInts@U32 AllInts@U16 -> 0b0100
          AllInts@S16 AllInts@U16 -> 0b1000
          AllInts@S32 AllInts@U16 -> 0b1100
          AllInts@U16 AllInts@S16 -> 0b0010
          AllInts@U32 AllInts@S16 -> 0b0110
          AllInts@S16 AllInts@S16 -> 0b1010
          AllInts@S32 AllInts@S16 -> 0b1110
          AllInts@U16 AllInts@U32 -> 0b0001
          AllInts@U32 AllInts@U32 -> 0b0101
          AllInts@S16 AllInts@U32 -> 0b1001
          AllInts@S32 AllInts@U32 -> 0b1101
          AllInts@U16 AllInts@S32 -> 0b0011
          AllInts@U32 AllInts@S32 -> 0b0111
          AllInts@S16 AllInts@S32 -> 0b1011
          AllInts@S32 AllInts@S32 -> 0b1111
          ;

    R2GDSize
          AllInts@U8 -> 0b01
          AllInts@U8 -> 0b11
          AllInts@U16 -> 0b00
          AllInts@U32 -> 0b10
          ;

    GRFSize
          AllInts@U8 -> 0b00
          AllInts@U16 -> 0b01
          AllInts@S16 -> 0b10
          AllInts@U32 -> 0b11
          AllInts@S32 -> 0b11
          ;

    IndexScale
          AllInts@U8 -> 1
          AllInts@S8 -> 1
          AllInts@U16 -> 2
          AllInts@S16 -> 2
          AllInts@U32 -> 4
          AllInts@S32 -> 4
          AllInts@U64 -> 8
          AllInts@S64 -> 8
          AllInts@U128 -> 16
          AllInts@S128 -> 16
          ;




    U32 AllInts@U16 -> 0
          AllInts@U32 -> 1
          ;







    IADDCombine

          C1 C0 0 0 -> 0b01_11
          C2 C0 0 0 -> 0b10_11
          C3 C0 0 0 -> 0b11_11

          C0 C0 0 0 -> 0b00_11
          C1 C1 0 0 -> 0b01_11
          C2 C2 0 0 -> 0b10_11
          C3 C3 0 0 -> 0b11_11

          noCond C0 0 0 -> 0b00_00
          noCond C1 0 0 -> 0b01_00
          noCond C2 0 0 -> 0b10_00
          noCond C3 0 0 -> 0b11_00

          noCond C0 0 1 -> 0b00_01
          noCond C1 0 1 -> 0b01_01
          noCond C2 0 1 -> 0b10_01
          noCond C3 0 1 -> 0b11_01

          noCond C0 1 0 -> 0b00_10
          noCond C1 1 0 -> 0b01_10
          noCond C2 1 0 -> 0b10_10
          noCond C3 1 0 -> 0b11_10
          ;

    IMADCombine

          C1 C0 0 0 -> 0b11_01
          C2 C0 0 0 -> 0b11_10
          C3 C0 0 0 -> 0b11_11

          C0 C0 0 0 -> 0b11_00
          C1 C1 0 0 -> 0b11_01
          C2 C2 0 0 -> 0b11_10
          C3 C3 0 0 -> 0b11_11

          noCond C0 0 0 -> 0b00_00
          noCond C1 0 0 -> 0b00_01
          noCond C2 0 0 -> 0b00_10
          noCond C3 0 0 -> 0b00_11

          noCond C0 0 1 -> 0b01_00
          noCond C1 0 1 -> 0b01_01
          noCond C2 0 1 -> 0b01_10
          noCond C3 0 1 -> 0b01_11

          noCond C0 1 0 -> 0b10_00
          noCond C1 1 0 -> 0b10_01
          noCond C2 1 0 -> 0b10_10
          noCond C3 1 0 -> 0b10_11
          ;

    IADD32Combine

          C0 0 0 -> 0b11
          noCond 0 0 -> 0b00
          noCond 0 1 -> 0b01
          noCond 1 0 -> 0b10
          ;

    IADD32ICombine

          C0 0 -> 0b11
          noCond 0 -> 0b00
          noCond 1 -> 0b10
          ;

    CombineSATAndInteger
          0 AllInts@U16 -> 0b00
          0 AllInts@U32 -> 0b01
          0 AllInts@S16 -> 0b00
          0 AllInts@S32 -> 0b01
          1 AllInts@S16 -> 0b10
          1 AllInts@S32 -> 0b11
          ;

    CombineSATAndInteger32
          0 AllInts@U16 -> 0b00
          0 AllInts@U32 -> 0b10
          0 AllInts@S16 -> 0b00
          0 AllInts@S32 -> 0b10
          1 AllInts@S16 -> 0b01
          1 AllInts@S32 -> 0b11
          ;

    IFormat
          AllInts@U16 -> 0b00
          AllInts@U32 -> 0b01
          AllInts@S16 -> 0b10
          AllInts@S32 -> 0b11
          ;

    IFormat_LOP
          AllInts@U16 -> 0b0
          AllInts@U32 -> 0b1
          AllInts@S16 -> 0b0
          AllInts@S32 -> 0b1
          ;

    IFormat32
          AllInts@U16 -> 0b00
          AllInts@U32 -> 0b10
          AllInts@S16 -> 0b01
          AllInts@S32 -> 0b11
          ;

    CSize
          AllInts@U8 -> 0b00
          AllInts@U16 -> 0b01
          AllInts@S16 -> 0b10
          AllInts@U32 -> 0b11
          AllInts@S32 -> 0b11
          ;

    IMul
          LO AllInts@U16 AllInts@U16 -> 0
          LO AllInts@U16 AllInts@S16 -> 1
          LO AllInts@S16 AllInts@U16 -> 2
          LO AllInts@S16 AllInts@S16 -> 3

          LO AllInts@U24 AllInts@U24 -> 4
          HI AllInts@U24 AllInts@U24 -> 5
          LO AllInts@S24 AllInts@S24 -> 6
          HI AllInts@S24 AllInts@S24 -> 7
    ;

    IMad
          AllInts@S24 SAT HI -> 0b0001
          AllInts@U16 noSAT LO -> 0b0000
          AllInts@S16 noSAT LO -> 0b0010
          AllInts@S16 SAT LO -> 0b0100
          AllInts@U24 noSAT LO -> 0b0110
          AllInts@S24 noSAT LO -> 0b1000
          AllInts@S24 SAT LO -> 0b1010
          AllInts@U24 noSAT HI -> 0b1100
          AllInts@S24 noSAT HI -> 0b1110
    ;

    IMad32
          AllInts@U16 noSAT -> 0b00
          AllInts@S16 noSAT -> 0b01
          AllInts@S16 SAT -> 0b10
    ;


    OptCondition
          C0 -> 0b100
          C1 -> 0b101
          C2 -> 0b110
          C3 -> 0b111
          noCond -> 0b000
          noCond -> 0b001
          noCond -> 0b010
          noCond -> 0b011
    ;

OPERATION PROPERTIES
    IWIDTH
    ITYPE
    SPA
    ;

FUNIT uC
   ISSUE_SLOTS 0;
   ENCODING WIDTH 64;




  Canvas0 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX................................'
  Canvas1 '...............................X................................'
  Canvas2 '................................................................'
  Canvas3 '...X............................................................'
  Sync '..............................X.................................'

  Opcode0 '................................XXXX..........................XX'
  Opcode1 'XXX.............................XXXX..........................XX'
  Opcode2 'XX..............................XXXX..........................XX'
  Opcode3 'XXX...........................XXXXXX..........................XX'
  Opcode4 'XXX.............................XXX...........................XX'
  Opcode5 '...............................XXXX...........................XX'
  Opcode6 '................................XXX...........................XX'
  Opcode7 'XXX...........................XXXXX...........................XX'
  Opcode8 'XXX............................XXXXX..........................XX'
  Opcode9 'XXX............................XXXX...........................XX'
  Opcode10 'XX.............................XXXXX..........................XX'
  Opcode11 'XXX............................XXXXX..........................XX'
  ShOpcode 'XXX........X....................XXXX..........................XX'
  VotOpcode 'XXX.............................XXXX.................XX.......XX'
  NOpcode 'XXX..........................X..XXXX..........................XX'
  BarOpcode 'XXX..............X............XXXXXX.XX.......................XX'
  BraOpcode1 'XXX......................X....XXXXXX..........................XX'
  B32Opcode '................................XXXX..........................XX'
  SCOpcode 'XXX.X...........................XXXX..........................XX'
  STPOpcode 'XXX........X....................XXXX...X......................XX'




  Nenc0 '...XXXXXXXXXXXXXXXXXXXXXXXXXX.......XXXXXXXXXXXXXXXXXXXXXXXXXX..'
  Nenc1 '...X..............XXXXXXXXXXX.........................XXXXXXXX..'
  Nenc2 '...XXXXXXXXXXXXXXX.......XXXX.........XXXXXXXXXXXXXXXXX.........'
  Nenc3 '...XXXXXXX.XXXXXXX.......XXXX............XXX...........XXXX.....'
  Nenc5 '...XXXXXXXXXXXXXXX.......XXXX.........X................XXXX.....'
  Nenc6 '...XXXXXXXXXXXXXX.XXXXXXXXXXXX......X..................XXXXXXX..'
  Nenc7 '...XXXXXXXXX.............XXXXX......X..................XXXXXXX..'
  Nenc8 '...XXXXXXXXX......XXXXXXX.XXXX......X..................XXXXXXX..'
  Nenc9 '...XXXXXXXXXXXXXXX.......XXXXX......XXXXXXXXXXXXXXXXXXXXXXXXXX..'
  Nenc10 '...XXXXXXXXXXXXXXXXXXXXXXXXXXX......XXXXXXXXXXXXXXXXXXXXXXXXXX..'
  Nenc11 '....................................XXXXXXXXXXXXXXXXXXXXXXXXXX..'
  Nenc12 '...XXX....XXXXXXXXXXXXXXX.XXX..........................XXXXXXX..'
  Nenc13 '...XXXXXXXXXXXXXXX.......XXXXX......XXXXXXXXXXXXXXXXXXX.........'
  Nenc14 '...X.XXXXX.XXXXXXX.......XXX.............XXXXXXX................'
  Nenc15 '...X.....................................XXXXX..................'
  Nenc17 '...X.........XXXXX..............................................'
  Nenc19 '...X........XX..................................................'
  Nenc20 '...X..XXX......XX........................XXXXXXX................'
  Nenc21 '...X..XXX...X..XX........................XXXXXXX................'
  Nenc22 '...XX.XXX................................XXXXXXX................'
  Nenc23 '...X..XXXX...XX..........................XXXXXXX................'
  Nenc24 '...X............................................................'
  Nenc26 '...XXX...................XXX....................................'
  Nenc29 '..........................................XXXXXX.......X........'
  Nenc30 '...XX.XXXX..XXXXXX.......XXX.............XXXXXXX................'
  Nenc31 '.........................................XXXXX.........X........'
  Nenc32 '...XX...XX.XXX...........XXX.............XXXXXXX................'
  Nenc33 '...X................................XXXXXX.......XXXXXX.........'
  Nenc34 '...XXXXXXXXXXXXXXXXXXXXXXXXXXX......XXXXXXXXXXXXXXXXX..XXXXXXX..'
  Nenc35 '...XXXXXXXXXXXXXXX..........XX......XXXXXXXXXXXXXXXXX..XXXXXXX..'
  Nenc36 '...X......................................XXXXXX................'
  Nenc38 '...XXX.....XXX..................................................'
  Nenc40 '...X.......XXXXXXX..............................................'
  Nenc41 '...X.......XXXX.................................................'
  Nenc44 '...XX......XXX..................................................'
  Nenc45 '...X..XXXX..XXXXXX..............................................'
  Nenc46 '...XX.....XXXXXX.........XXX....................................'
  Nenc47 '...XXXXXXXXXXXXXXX.......XXX....................................'
  Nenc49 '...XXXXXXXXXXXXXXX..........XX......XXXXXXXXXXXX.......XXXXXXX..'
  Nenc51 '...XX.XX....................X..........................XXXXXXX..'
  Nenc52 '...XX....XXXXXXX................................................'
  Nenc53 '...XX.XXXX..XXXXX........XXX.............XXXXXXX................'
  Nenc54 '...X......X..................X......XXXXXX..X...................'
  Nenc56 '...XXXXXXXXXXXXX............X.......X...........................'
  Nenc57 '...X........................X...................................'
  Nenc58 '...XXXXXXXXXXXXX.........XXXX.......X..X........................'
  Nenc59 '...XXXXXXXX.XXXXXXXXXXXXX...XX......XXX.XXXXXXXXXXXXXXXXXXXXXX..'
  Nenc60 '...XXXXX.................X..........X...........................'
  Nenc61 '...XXXXX...XXXXXXX.......XXXXX......XXXXXXXX....................'
  Nenc62 '...XXXXX...XXXXXXX.......XXXX...................................'
  Nenc63 '...XXXXXXXX..............XXXXX......XXXXXXXXXXXXXXXXXXX.........'
  Nenc64 '...XXXXXXXX..............XXXX..........................XXXXXXX..'
  Nenc65 '...X..XXXXX..................X......XXXXXXXXXX..................'
  Nenc66 '...X..XX..X..................X......XXXXX.......................'
  Nenc67 '...X..XXXXX..XXXXX...........X......XXXXX.......................'
  Nenc68 '...X..XXXXXXX..XXX...........X......XXXXX.......................'
  Nenc69 '...X..XXXXX..X...............X......XXXXX.......................'
  Nenc70 '...X........XXXXXX..............................................'
  Nenc71 '...X.........X..................................................'




  Imm321 '....XXXXXXXXXXXXXXXXXXXXXXXXXX............XXXXXX................'
  Imm32 '....XXXXXXXXXXXXXX..................XXXXXXXXXXXXXXXXXX..........'
  Imm24 '............XXXXXX...................XXXXXXXXXXXXXXXXXX.........'
  Imm16 '.......................................XXXXXXXXXXXXXXXX.........'
  Imm12 '...........................................XXXXXXXXXXXX.........'
  Imm4 '............................................XXXX................'
  BarName '.......................................XXXX.....................'

  Constant '......XXXX......................................................'
  IMul '..............XXXX..............................................'
  IMad 'XXX................................X............................'
  IMul32 '.........................................X......X......X........'

  Condition '..................XX............................................'
  CC '....................XXXXX.......................................'
  CondDest '.........................XXX....................................'
  SetCC4 '..............XXXX..............................................'
  SetCC3 '...............XXX..............................................'

  DAReg '...........................................................XXX..'
  DReg '.......................................................XXXXXXX..'
  DReg6 '........................................................XXXXXX..'
  AReg '................................................XXXXXXX.........'
  AReg6 '.................................................XXXXXX.........'
  BReg '.........................................XXXXXXX................'
  BReg1 '.....................................XXXXXXX....................'
  BReg6 '..........................................XXXXXX................'
  CReg '...........XXXXXXX..............................................'

  GRFIndex '..................................................XXXXX.........'
  GRFSize '................................................XX..............'

  GRFIndex6 '...................................................XXXX.........'
  GRFSize6 '.................................................XX.............'
  ConstOffs6 '...........................................XXXXX................'
  CBank6 '..........................................X.....................'

  Rnd0 '..............................................XX................'
  Rnd1 '.............XX.................................................'
  Rnd2 '........XX......................................................'
  Rnd3 '................XX..............................................'




  ANeg '.....X..........................................................'
  ANeg1 '..X.............................................................'
  ANeg2 '................................................X...............'
  CNeg '....X...........................................................'
  CNeg1 '..X.............................................................'
   Neg2 '.........................................X......................'
   Abs2 '................................................X...............'
  BNeg2 '.........................................X......................'
  CNeg2 '.........................................X......................'
  AAbs '...........X....................................................'
  CAbs '............X...................................................'
  AInv '...............X................................................'
  BInv '..............X.................................................'
  AInv32 '.........................................X......................'
  Lop '................XX..............................................'
  Lop32 '................................................X......X........'

  Ir '....X...........................................................'
  Sat '............X...................................................'
  Sat1 '..X.............................................................'
  Sat2 '...........X....................................................'
  Sat3 '.......................................................X........'
  QuadMask '..............XXXX..............................................'
  Token '.....................................................XX.........'
  Pipe '..............XX................................................'
  Pipe1 '......XX........................................................'
  Pipe2 '..............................................XX................'
  U321 '.....X..........................................................'
  U322 '................................................X...............'
  Bext '................X...............................................'
  RROmode '.................X..............................................'
  Swizzle '.............................................XXX................'
  PNWord '....XXXXXX................................XX....................'

  F2FSizes '.....X...X.......X..............................................'
  F2ISizes '....XX...X.......X..............................................'
  I2FSizes '.....X...X.....X.X..............................................'
  I2ISizes '....XX.........X.X..............................................'
  IFormat '....XX..........................................................'
  IFormat_LOP'.....X..........................................................'
  IFormat32 '................................................X......X........'
  G2RDSize '.....X..........................................................'
  R2GDSize '.....X...X......................................................'
  R2GSSize '..........X.....................................................'
  Size '................XX..............................................'
  L '........X.......................................................'




  O1c_ADD '...................................X.....X......................'
  O1c_MAD '....XX..........................................................'

  Output '............................X...................................'
  Increment '......................................X.........................'
  Address '.............................X......XX..........................'
  Address2 '....................................XX..........................'
  CBank '......XXXX......................................................'

  ABC '..........X............................XX.......................'
  ABCFix_A '.............................X......XXX.........................'
  ABCFix_AB '......XXXX...................X......XXX.........................'
  ABCFix_ABC '......XXXX...................X......XXX.........................'
  ABCFix_AC '......XXXX...................X......XXX.........................'

  AB '.......................................XX.......................'
  ABFix_AB '....................................XXX.........................'
  ABFix_A '....................................XXX.........................'

  TexId '...............................................XXXXXXXX.........'
  Sampler '..........................................XXXXX.................'
  NrofCoords '........................................XX......................'
  Offset '....XXXXXXXXXXXX................................................'
  TMask '................XX...................XX.........................'
  Un '.......................................X........................'
  NoDep '.............................X..................................'
  Nd '............................X...................................'
  Phase '.........................XXX....................................'
  Cube '....................................X...........................'
  Phase32 '....................................XXX.........................'
  NoDep32 '.......................................................X........'

  MemSize '........XXX.....................................................'
  MemOp '..........................XXXX..................................'
  MemId1 '.....................................XXXX.......................'
  MemId '............................................XXXX................'


ALL 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'

NOP_ENCODING
  ALL = 0xe0000000f0000001;


CLASS "NOP"
    FORMAT Opcode/S(noS);

    OPCODES
         NOP = 0b111_0_1111_01;

    ENCODING
      NOpcode = Opcode;
      Sync=S;!Canvas1;
      !Nenc0;

CLASS "NOPTRIG"
    FORMAT Opcode/S(noS) SImm(4);

    OPCODES
         NOP.TRIGGER = 0b111_1_1111_01;

    ENCODING
      NOpcode = Opcode;
      Imm32 = Imm;
      Sync=S;!Canvas1;
      !Nenc1;

CLASS "OUT"
    FORMAT Opcode/S(noS) SImm(2);

    OPCODES
         OUT = 0b110_1111_01;

    ENCODING
      Opcode1 = Opcode;
      Token = Imm;
      Sync=S;!Canvas1;
      !Nenc34;

CLASS "VOTE"
    FORMAT Opcode/S(noS) Condition ',' Condition/CC;

    OPCODES
         VOTE.ALL = 0b011_0001_10_01;
         VOTE.ANY = 0b011_0001_01_01;

    ENCODING
      VotOpcode = Opcode;
      Condition = Condition[2];
      CC = CC;
      CondDest = OptCondition(Condition[1]);
      Sync=S;!Canvas1;
      !Nenc35;

CLASS "SWZ"
    FORMAT Opcode/S(noS) /Swizzle /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ','
             PNWord;

    OPCODES
         SWZ = 0b100_1100_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      CReg = InputReg2;
      Swizzle = Swizzle;
      PNWord = PNWord;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc54;



CLASS "Output SWZ"
    FORMAT Opcode/S(noS) /Swizzle /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ','
             PNWord;

    OPCODES
         SWZ = 0b100_1100_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg = InputReg2;
      Swizzle = Swizzle;
      PNWord = PNWord;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc54;



CLASS "A2R"
    FORMAT Opcode/S(noS)
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Address;

    OPCODES
         A2R = 0b010_0000_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      Address = Address;
      DReg = Register;
      Sync=S;!Canvas1;
      !Nenc2;

CLASS "R2A"
    FORMAT Opcode/S(noS)
             Address:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ','
             UImm(4/0):ShiftAmount;

    OPCODES
         R2A = 0b110_0000_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DAReg = OutputReg;
      AReg = InputReg1;
      Imm4 = ShiftAmount;
      ABC=0;!ABCFix_A;
      Sync=S;!Canvas1;
      !Nenc3;

CLASS "A R2A"
    FORMAT Opcode/S(noS)
             Address:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
             UImm(4/0):ShiftAmount;

    OPCODES
         R2A = 0b110_0000_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DAReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      Imm4 = ShiftAmount;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Sync=S;!Canvas1;
      !Nenc3;

CLASS "ADA"
    FORMAT Opcode/S(noS)
             Address
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Address ','
             UImm(16);

    OPCODES
         ADA = 0b001_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      Address = Address[2];
      DAReg = Address[1];
      Imm16 = Imm;
      Sync=S;!Canvas1;
      !Nenc5;




CLASS "BAR"
    FORMAT Opcode
             Barrier ','
             UImm(12);
    OPCODES
         BAR.ARV = 0b000_0_001000_01_11;
         BAR.ARV.WAIT = 0b000_0_001000_11_11;

    ENCODING
      BarOpcode = Opcode;
      BarName = Barrier;
      Imm12 = Imm;
      !Nenc6;

CLASS "BAR.ALL"
    FORMAT Opcode
             Barrier;
    OPCODES
         BAR.ARV.WAIT.ALL = 0b000_1_001000_11_11;

    ENCODING
      BarOpcode = Opcode;
      BarName = Barrier;
      !Nenc6;!Imm12;

CLASS "BRA"
    FORMAT Opcode
             Condition(C0) / CC(TRUE) ','
             UImm(24)*;

    PROPERTIES
          ITYPE = ITYPE_IMMEDIATE_BRANCH;

    OPCODES
         BRA = 0b000_00_0001_11;

    ENCODING
      Opcode3 = Opcode;
      Condition = Condition;
      CC = CC;
      Imm24 = Imm;
      !Nenc7;

CLASS "CALL"
    FORMAT Opcode
             UImm(24)*;

    PROPERTIES
          ITYPE = ITYPE_IMMEDIATE_BRANCH;

    OPCODES
         PBK = 0b000_0_000100_11;
         SSY = 0b000_0_001010_11;
         PRET = 0b000_0_001101_11;
         CAL = 0b000_1_000010_11;
         CAL.NOINC = 0b000_0_000010_11;

    ENCODING
      BraOpcode1 = Opcode;
      Imm24 = Imm;
      !Nenc8;

CLASS "BRK"
    FORMAT Opcode
             Condition(C0) / CC(TRUE);

    OPCODES
         BRK = 0b000_00_0101_11;
         RET = 0b000_00_0011_11;
         KIL = 0b000_00_0000_11;
         BRKPT = 0b000_00_1011_11;

    ENCODING
      Opcode3 = Opcode;
      Condition = Condition;
      CC = CC;
      !Nenc9;

CLASS "TRAP"
    FORMAT Opcode;

    OPCODES
         TRAP = 0b000_00_1001_11;
         RAM = 0b000_00_0111_11;
         SAM = 0b000_00_0110_11;

    ENCODING
      Opcode3 = Opcode;
      !Nenc10;

CLASS "BRKPT32"
    FORMAT Opcode;

    OPCODES
         BRKPT32 = 0b1011_10;
         TRAP32 = 0b1001_10;

    ENCODING
      B32Opcode = Opcode;
      !Canvas0;
      !Nenc11;

CLASS "BRX"
    FORMAT Opcode C[UImm(4)*:constantIndex][Address+UImm(16)*];

    OPCODES
         BRX = 0b000_0_00_1100_11;
         BRX.LMT = 0b000_1_00_1100_11;

    ENCODING
      BraOpcode1 = Opcode;
      Constant = constantIndex;
      Address = Address;
      Imm16 = Imm[2];
      !Nenc12;
      !Increment;




CLASS "RRO"
    FORMAT Opcode/S(noS) Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-] [||] Register:InputReg1 ','
             RROmode;

    OPCODES
         RRO = 0b110_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      RROmode = RROmode;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc53;




CLASS "A RRO"
    FORMAT Opcode/S(noS) Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-] [||] G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
             RROmode;

    OPCODES
         RRO = 0b110_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      RROmode = RROmode;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc53;




CLASS "Output RRO"
    FORMAT Opcode/S(noS) O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-] [||] Register:InputReg1 ','
             RROmode;

    OPCODES
         RRO = 0b110_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      RROmode = RROmode;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc53;




CLASS "A Output RRO"
    FORMAT Opcode/S(noS) O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-] [||] G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
             RROmode;

    OPCODES
         RRO = 0b110_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      RROmode = RROmode;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc53;




CLASS "SINCOS"
    FORMAT Opcode/S(noS) Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1;

    OPCODES
         SIN = 0b100_0_1001_01;
         COS = 0b101_0_1001_01;
         EX2 = 0b110_0_1001_01;
         EX2.SAT = 0b110_1_1001_01;

    ENCODING
      SCOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc14;






CLASS "A SINCOS"
    FORMAT Opcode/S(noS) Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    OPCODES
         SIN = 0b100_0_1001_01;
         COS = 0b101_0_1001_01;
         EX2 = 0b110_0_1001_01;
         EX2.SAT = 0b110_1_1001_01;

    ENCODING
      SCOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc14;






CLASS "Output SINCOS"
    FORMAT Opcode/S(noS) O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1;

    OPCODES
         SIN = 0b100_0_1001_01;
         COS = 0b101_0_1001_01;
         EX2 = 0b110_0_1001_01;
         EX2.SAT = 0b110_1_1001_01;

    ENCODING
      SCOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc14;






CLASS "A Output SINCOS"
    FORMAT Opcode/S(noS) O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    OPCODES
         SIN = 0b100_0_1001_01;
         COS = 0b101_0_1001_01;
         EX2 = 0b110_0_1001_01;
         EX2.SAT = 0b110_1_1001_01;

    ENCODING
      SCOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc14;






CLASS "DADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         DADD = 0b011_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      CReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      Output=0;
      Sync=S;!Canvas1;
      !Nenc65;

CLASS "Output DADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         DADD = 0b011_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc65;

CLASS "DFMA"
    FORMAT Opcode/S(noS) /Rounding(RN) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]Register:InputReg3;

    OPCODES
         DFMA = 0b010_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Rnd2 = Rounding;
      CondDest = OptCondition(OptCondition);
      Output=0;
      Sync=S;!Canvas1;
      !Nenc66;

CLASS "Output DFMA"
    FORMAT Opcode/S(noS) /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]Register:InputReg3;

    OPCODES
         DFMA = 0b010_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Rnd2 = Rounding;
      CondDest = OptCondition(OptCondition);
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc66;

CLASS "DMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ',' [-][||]Register:InputReg2;

    OPCODES
         DMIN = 0b101_1110_01;
         DMAX = 0b110_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      Output=0;
      Sync=S;!Canvas1;
      !Nenc67;

CLASS "Output DMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ',' [-][||]Register:InputReg2;

    OPCODES
         DMIN = 0b101_1110_01;
         DMAX = 0b110_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc67;

CLASS "DMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         DMUL = 0b100_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      Output=0;
      Sync=S;!Canvas1;
      !Nenc68;

CLASS "Output DMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         DMUL = 0b100_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc68;

CLASS "DSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ','
             [-][||]Register:InputReg2 ','
             CC ;

    OPCODES
         DSET = 0b111_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      Output=0;
      Sync=S;!Canvas1;
      !Nenc69;




CLASS "Output DSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ','
             [-][||]Register:InputReg2 ','
             CC ;

    OPCODES
         DSET = 0b111_1110_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc69;




CLASS "FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      CReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AC;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "A FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "C FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "AC FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "Output FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AC;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "A Output FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "C Output FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "AC Output FADD"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FADD = 0b00_01011_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      Sat1 = SAT;
      Rnd0 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc15;

CLASS "FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "A FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "B FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "AB FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "Output FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "A Output FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "B Output FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "AB Output FMUL"
    FORMAT Opcode/S(noS) /Rounding(RN) /SAT(noSAT) /OptCondition(noCond) /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FMUL = 0b000_1100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;

      Sat2 = SAT;
      Pipe = PIPE;
      Rnd3 = Rounding;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc19;

CLASS "FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_ABC;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AC FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2',' [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "A FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "B FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex]',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AB FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex]',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "C FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2',' [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "Output FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_ABC;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AC Output FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2',' [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "A Output FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "B Output FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex]',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AB Output FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex]',' [-]Register:InputReg3;

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "C Output FMAD"
    FORMAT Opcode/S(noS) /SAT(noSAT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2',' [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FMAD = 0b00_1110_01;

    ENCODING
      Opcode10 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg3@negate;
      Sat1 = SAT;
      CondDest = OptCondition(OptCondition);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ',' [-][||]Register:InputReg2;

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "A FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-][||]Register:InputReg2;

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "B FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ',' [-][||]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "AB FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-][||]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "Output FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ',' [-][||]Register:InputReg2;

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "A Output FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-][||]Register:InputReg2;

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "B Output FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ',' [-][||]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "AB Output FMAX"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-][||]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    OPCODES
         FMIN = 0b101_1011_01;
         FMAX = 0b100_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc17;

CLASS "FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ','
             [-][||]Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "A FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
             [-][||]Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "B FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ','
             [-][||]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "AB FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
             [-][||]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "Output FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ','
             [-][||]Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "A Output FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
             [-][||]Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "B Output FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1 ','
             [-][||]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "AB Output FSET"
    FORMAT Opcode/S(noS) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
             [-][||]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           CC[2] < 16 :
             "Comparison is not allowed for FSET"

    OPCODES
         FSET = 0b011_1011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      ANeg = InputReg1@negate;
      CNeg = InputReg2@negate;
      AAbs = InputReg1@absolute;
      CAbs = InputReg2@absolute;
      SetCC4 = CC[2];
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc71;

CLASS "FCMP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    Register:InputReg1 ','
                    Register:InputReg2 ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC=0;!ABCFix_ABC;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "AC FCMP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
                    Register:InputReg2 ','
                 [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex] ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      CNeg1 = InputReg3@negate;
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "A FCMP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
                    Register:InputReg2 ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "B FCMP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    Register:InputReg1 ','
                    C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "AB FCMP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
                    C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "C FCMP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    Register:InputReg1 ','
                    Register:InputReg2 ','
                 [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      CNeg1 = InputReg3@negate;
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "Output FCMP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    Register:InputReg1 ','
                    Register:InputReg2 ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC=0;!ABCFix_ABC;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "AC Output FCMP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
                    Register:InputReg2 ','
                 [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex] ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      CNeg1 = InputReg3@negate;
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "A Output FCMP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
                    Register:InputReg2 ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "B Output FCMP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    Register:InputReg1 ','
                    C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "AB Output FCMP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ','
                    C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
                 [-]Register:InputReg3 ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      CNeg1 = InputReg3@negate;
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "C Output FCMP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
                    Register:InputReg1 ','
                    Register:InputReg2 ','
                 [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ;

    OPCODES
         FCMP = 0b01_1100_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      CNeg1 = InputReg3@negate;
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc26;


CLASS "FADD32I"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' SImm(32):Addend;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"

    OPCODES
         FADD32I = 0b000_11_1011_01;
         FMUL32I = 0b000_11_1100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ANeg2 = InputReg1@negate;
      Sat3 = SAT;
      Imm321 = Addend;
      AB=0;!ABFix_A;
      !BNeg2;
      !Nenc24;

CLASS "A FADD32I"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' SImm(32):Addend;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"

    OPCODES
         FADD32I = 0b000_11_1011_01;
         FMUL32I = 0b000_11_1100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      ANeg2 = InputReg1@negate;
      Sat3 = SAT;
      Imm321 = Addend;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !BNeg2;
      !Nenc24;

CLASS "FMAD32I"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' SImm(32):Addend ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"

    OPCODES
         FMAD32I = 0b000_11_1110_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      ANeg2 = InputReg1@negate;
      BNeg2 = InputReg3@negate;
      Sat3 = SAT;
      Imm321 = Addend;
      AB=0;!ABFix_A;
      !Nenc24;


CLASS "A FMAD32I"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' SImm(32):Addend ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"

    OPCODES
         FMAD32I = 0b000_11_1110_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      ANeg2 = InputReg1@negate;
      BNeg2 = InputReg3@negate;
      Sat3 = SAT;
      Imm321 = Addend;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Nenc24;


CLASS "FADD32"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         FADD32 = 0b1011_00;
         FMUL32 = 0b1100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      ANeg2 = InputReg1@negate;
      BNeg2 = InputReg2@negate;
      Sat3 = SAT;
      AB=0;!ABFix_AB;
      !Canvas0;

CLASS "A FADD32"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         FADD32 = 0b1011_00;
         FMUL32 = 0b1100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      ANeg2 = InputReg1@negate;
      BNeg2 = InputReg2@negate;
      Sat3 = SAT;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "B FADD32"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex];

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         FADD32 = 0b1011_00;
         FMUL32 = 0b1100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      ANeg2 = InputReg1@negate;
      BNeg2 = InputReg2@negate;
      Sat3 = SAT;
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "FMAD32"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         FMAD32 = 0b1110_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      ANeg2 = InputReg1@negate;
      CNeg2 = InputReg3@negate;
      Sat3 = SAT;
      AB=0;!ABFix_AB;
      !Canvas0;

CLASS "A FMAD32"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         FMAD32 = 0b1110_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      ANeg2 = InputReg1@negate;
      CNeg2 = InputReg3@negate;
      Sat3 = SAT;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "B FMAD32"
    FORMAT Opcode /SAT(noSAT)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         FMAD32 = 0b1110_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      ANeg2 = InputReg1@negate;
      CNeg2 = InputReg3@negate;
      Sat3 = SAT;
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "RCP32"
    FORMAT Opcode
             Register:OutputReg ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         RCP32 = 0b1001_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      Neg2 = InputReg1@negate;
      Abs2 = InputReg1@absolute;
      AB=0;!ABFix_A;
      !Canvas0;
      !Nenc29;

CLASS "A RCP32"
    FORMAT Opcode
             Register:OutputReg ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         RCP32 = 0b1001_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      Neg2 = InputReg1@negate;
      Abs2 = InputReg1@absolute;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
      !Nenc29;

CLASS "RCP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    OPCODES
         RCP = 0b000_1001_01;
         RSQ = 0b010_1001_01;
         LG2 = 0b011_1001_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc30;




CLASS "A RCP"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    OPCODES
         RCP = 0b000_1001_01;
         RSQ = 0b010_1001_01;
         LG2 = 0b011_1001_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc30;




CLASS "Output RCP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    OPCODES
         RCP = 0b000_1001_01;
         RSQ = 0b010_1001_01;
         LG2 = 0b011_1001_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc30;




CLASS "A Output RCP"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    OPCODES
         RCP = 0b000_1001_01;
         RSQ = 0b010_1001_01;
         LG2 = 0b011_1001_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg = InputReg1@negate;
      AAbs = InputReg1@absolute;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc30;




CLASS "F2F"
    FORMAT Opcode/S(noS) /Float /Float
             /SAT(noSAT) /IR(noIR) /Rounding(RN) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           (Float[1] == `F64) -> (Float[2] != `F16) :
             "F16 cannot be converted to F64"
         ERROR
           (Float[1] == `F16) -> (Float[2] != `F64) :
             "F64 cannot be converted to F16"
         ERROR
           (Float[1] == `F64) -> IsEven(OutputReg) :
             "F64 as destination format requires an even destination register"
         ERROR
           (Float[2] == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"

    OPCODES
         F2F = 0b11_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2FSizes = F2FSizes(Float[1],Float[2]);
      Sat = SAT;
      Ir = IR;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc20;

CLASS "A F2F"
    FORMAT Opcode/S(noS) /Float /Float
             /SAT(noSAT) /IR(noIR) /Rounding(RN) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (Float[1] == `F64) -> (Float[2] != `F16) :
             "F16 cannot be converted to F64"
         ERROR
           (Float[1] == `F16) -> (Float[2] != `F64) :
             "F64 cannot be converted to F16"
         ERROR
           (Float[1] == `F64) -> IsEven(OutputReg) :
             "F64 as destination format requires an even destination register"
         ERROR
           (Float[2] == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"

    OPCODES
         F2F = 0b11_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2FSizes = F2FSizes(Float[1],Float[2]);
      Sat = SAT;
      Ir = IR;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc20;

CLASS "Output F2F"
    FORMAT Opcode/S(noS) /Float /Float
             /SAT(noSAT) /IR(noIR) /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           (Float[1] == `F64) -> (Float[2] != `F16) :
             "F16 cannot be converted to F64"
         ERROR
           (Float[1] == `F16) -> (Float[2] != `F64) :
             "F64 cannot be converted to F16"
         ERROR
           (Float[2] == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"

    OPCODES
         F2F = 0b11_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2FSizes = F2FSizes(Float[1],Float[2]);
      Sat = SAT;
      Ir = IR;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc20;

CLASS "A Output F2F"
    FORMAT Opcode/S(noS) /Float /Float
             /SAT(noSAT) /IR(noIR) /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (Float[1] == `F64) -> (Float[2] != `F16) :
             "F16 cannot be converted to F64"
         ERROR
           (Float[1] == `F16) -> (Float[2] != `F64) :
             "F64 cannot be converted to F16"
         ERROR
           (Float[2] == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"

    OPCODES
         F2F = 0b11_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2FSizes = F2FSizes(Float[1],Float[2]);
      Sat = SAT;
      Ir = IR;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc20;

CLASS "IntegerNon16 F2I"
    FORMAT Opcode/S(noS) /IntegerNon16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
             ((IntegerSize&~1) == `F64) -> IsEven(OutputReg) :
               "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "A IntegerNon16 F2I"
    FORMAT Opcode/S(noS) /IntegerNon16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
             ((IntegerSize&~1) == `F64) -> IsEven(OutputReg) :
               "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "Output IntegerNon16 F2I"
    FORMAT Opcode/S(noS) /IntegerNon16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "A Output IntegerNon16 F2I"
    FORMAT Opcode/S(noS) /IntegerNon16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "Integer16 F2I"
    FORMAT Opcode/S(noS) /Integer16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
             ((IntegerSize&~1) == `F64) -> IsEven(OutputReg) :
               "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "A Integer16 F2I"
    FORMAT Opcode/S(noS) /Integer16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
             ((IntegerSize&~1) == `F64) -> IsEven(OutputReg) :
               "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "Output Integer16 F2I"
    FORMAT Opcode/S(noS) /Integer16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "A Output Integer16 F2I"
    FORMAT Opcode/S(noS) /Integer16:IntegerSize /Float:FloatSize
             /Rounding(RN) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(InputReg1) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported float to integer conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported float to integer conversion"

    OPCODES
         F2I = 0b10_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      F2ISizes =* F2ISizes(IntegerSize,FloatSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc21;

CLASS "IntegerNon16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /IntegerNon16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(OutputReg) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "A IntegerNon16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /IntegerNon16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(OutputReg) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "Output IntegerNon16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /IntegerNon16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "A Output IntegerNon16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /IntegerNon16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "Integer16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /Integer16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register16:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(OutputReg) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "A Integer16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /Integer16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (FloatSize == `F64) -> IsEven(OutputReg) :
             "F64 as source format requires an even source register"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "Output Integer16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /Integer16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register16:InputReg1;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "A Output Integer16 I2F"
    FORMAT Opcode/S(noS) /Float:FloatSize /Integer16:IntegerSize /SAT(noSAT)
             /Rounding(RN) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           ((IntegerSize&~1) != `AllInts@U8) :
             "No 8 bit mode allowed for this operation"
         ERROR
           (IntegerSize >= `AllInts@U64) -> IsEven(InputReg1) :
             "U64 or S64 as destination format requires an even destination register"
         ERROR
           (IntegerSize&~1) <= FloatSize+2 :
             "Unsupported integer to float conversion"
         ERROR
           (IntegerSize&~1)+2 >= FloatSize :
             "Unsupported integer to float conversion"
         ERROR
           (FloatSize == `F64) -> !SAT :
             "F64 as source format does not allow SAT"
         ERROR
           ((IntegerSize&~1) == 6) -> !BEXT :
             "U64 or S64 as destination format does not allow BEXT"

    OPCODES
         I2F = 0b01_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      Rnd1 = Rounding;
      CondDest = OptCondition(OptCondition);
      I2FSizes =* I2FSizes(FloatSize,IntegerSize);
      Sat = SAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc22;

CLASS "Integer1616 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register16:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A Integer1616 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "Output Integer1616 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register16:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A Output Integer1616 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "IntegerNon1616 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register16:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A IntegerNon1616 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "Output IntegerNon1616 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register16:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A Output IntegerNon1616 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /Integer16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "Integer16Non16 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A Integer16Non16 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "Output Integer16Non16 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A Output Integer16Non16 I2I"
    FORMAT Opcode/S(noS) /Integer16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "IntegerNon16Non16 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A IntegerNon16Non16 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "Output IntegerNon16Non16 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]Register:InputReg1;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "A Output IntegerNon16Non16 I2I"
    FORMAT Opcode/S(noS) /IntegerNon16:OutputSize /IntegerNon16:SourceSize
             /BSAT(noBSAT) /BEXT(noBEXT) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-][||]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputSize < `AllInts@U64) && (SourceSize < `AllInts@U64) :
             "U64 or S64 is not supported for I2I"
         ERROR
           (OutputSize > `AllInts@S8) && (SourceSize > `AllInts@S8) :
             "U8 or S8 is not supported for I2I"

    OPCODES
         I2I = 0b00_1010_01;

    ENCODING
      Opcode2 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      ANeg1 = InputReg1@negate;
      AAbs = InputReg1@absolute;
      CondDest = OptCondition(OptCondition);
      I2ISizes =* I2ISizes(OutputSize,SourceSize);
      Sat = BSAT;
      Bext = BEXT;
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc23;






CLASS "C2R"
    FORMAT Opcode/S(noS) Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Condition;

    CONDITIONS
         ERROR
           Condition[1] == Condition[2] :
             "Predicate condition register must be the same as the moved condition register"

    OPCODES
         C2R = 0b001_0000_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = Register;
      Condition = IDENTICAL(Condition[1],Condition[2]);
      CC = CC;
      Sync=S;!Canvas1;
      !Nenc13;

CLASS "R2C"
    FORMAT Opcode/S(noS) Condition
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register;

    OPCODES
         R2C = 0b101_0000_01;

    ENCODING
      Opcode1 = Opcode;
      AReg = Register;
      Condition = Condition[2];
      CC = CC;
      CondDest = Condition[1] BIAS 4;
      Sync=S;!Canvas1;
      !Nenc49;


CLASS "IntegerNon16 MOV32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize /PIPE(noPIPE)
             Register:OutputReg ',' Register:InputReg1;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         MOV32 = 0b0001_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      Pipe2 = PIPE;
      U322 =* U32(OperationSize);
      AB=0;!ABFix_A;
      !Canvas0;
      !Nenc31;

CLASS "A IntegerNon16 MOV32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize /PIPE(noPIPE)
             Register:OutputReg ',' G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         MOV32 = 0b0001_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      Pipe2 = PIPE;
      U322 =* U32(OperationSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
      !Nenc31;

CLASS "Integer16 MOV32"
    FORMAT Opcode /Integer16:OperationSize /PIPE(noPIPE)
             Register16:OutputReg ',' Register16:InputReg1;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         MOV32 = 0b0001_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      Pipe2 = PIPE;
      U322 =* U32(OperationSize);
      AB=0;!ABFix_A;
      !Canvas0;
      !Nenc31;

CLASS "A Integer16 MOV32"
    FORMAT Opcode /Integer16:OperationSize /PIPE(noPIPE)
             Register16:OutputReg ',' G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         MOV32 = 0b0001_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      Pipe2 = PIPE;
      U322 =* U32(OperationSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
      !Nenc31;

CLASS "IntegerNon16 MOV"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /PIPE(noPIPE)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "A IntegerNon16 MOV"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /PIPE(noPIPE)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "Output IntegerNon16 MOV"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "A Output IntegerNon16 MOV"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "Integer16 MOV"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /PIPE(noPIPE)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "A Integer16 MOV"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /PIPE(noPIPE)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "Output Integer16 MOV"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "A Output Integer16 MOV"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /PIPE(noPIPE)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(4/0xf):CondNr;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MOV = 0b000_00001_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      Pipe1 = PIPE;
      QuadMask = CondNr;
      U321 =* U32(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc32;

CLASS "IntegerNon16 MVI"
    FORMAT Opcode /IntegerNon16(U32):OperationSize
             Register:OutputReg ',' SImm(32)*;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MVI = 0b000_11_0001_01;

    ENCODING
      Opcode3 = Opcode;
      DReg = OutputReg;
      Imm321 = Imm;
      U322 =* U32(OperationSize);
      !Nenc33;

CLASS "Integer16 MVI"
    FORMAT Opcode /Integer16:OperationSize
             Register16:OutputReg ',' SImm(32)*;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"

    OPCODES
         MVI = 0b000_11_0001_01;

    ENCODING
      Opcode3 = Opcode;
      DReg = OutputReg;
      Imm321 = Imm;
      U322 =* U32(OperationSize);
      !Nenc33;

CLASS "IntegerNon16 MVC"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             C[UImm(4)*:constantIndex][Address(A0)++ + SImm(16)*:addrDisplacement]/Integer(U32):ConstantSize;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"
         ERROR
           (ConstantSize < `AllInts@U64) :
             "64 bit constant fetch is not supported by MVC"
         ERROR
           (ConstantSize != `AllInts@S8) :
             "S8 constant fetch is not supported by MVC"

    OPCODES
         MVC = 0b001_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputReg;
      Condition = Condition;
      CC = CC;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Constant = constantIndex;
      Imm16 = addrDisplacement;
      Address = Address;
      Increment = Address@postincr;
      Size = CSize(ConstantSize);

      Output=0;
      Sync=S;!Canvas1;
      !Nenc46;

CLASS "Output IntegerNon16 MVC"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             C[UImm(4)*:constantIndex][Address(A0)++ + SImm(16)*:addrDisplacement]/Integer(U32):ConstantSize;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"
         ERROR
           (ConstantSize < `AllInts@U64) :
             "64 bit constant fetch is not supported by MVC"
         ERROR
           (ConstantSize != `AllInts@S8) :
             "S8 constant fetch is not supported by MVC"

    OPCODES
         MVC = 0b001_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputIndex;
      Condition = Condition;
      CC = CC;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Constant = constantIndex;
      Imm16 = addrDisplacement;
      Address = Address;
      Increment = Address@postincr;
      Size = CSize(ConstantSize);

      Output = 1;
      Sync=S;!Canvas1;
      !Nenc46;

CLASS "Integer16 MVC"
    FORMAT Opcode/S(noS) /Integer16:OperationSize
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             C[UImm(4)*:constantIndex][Address(A0)++ + SImm(16)*:addrDisplacement]/Integer(U32):ConstantSize;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"
         ERROR
           (ConstantSize < `AllInts@U64) :
             "64 bit constant fetch is not supported by MVC"
         ERROR
           (ConstantSize != `AllInts@S8) :
             "S8 constant fetch is not supported by MVC"

    OPCODES
         MVC = 0b001_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputReg;
      Condition = Condition;
      CC = CC;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Constant = constantIndex;
      Imm16 = addrDisplacement;
      Address = Address;
      Increment = Address@postincr;
      Size = CSize(ConstantSize);

      Output=0;
      Sync=S;!Canvas1;
      !Nenc46;

CLASS "Output Integer16 MVC"
    FORMAT Opcode/S(noS) /Integer16:OperationSize
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             C[UImm(4)*:constantIndex][Address(A0)++ + SImm(16)*:addrDisplacement]/Integer(U32):ConstantSize;

    CONDITIONS
         ERROR
           (OperationSize == `AllInts@U16) || (OperationSize == `AllInts@U32) :
             "Only U16 or U32 allowed for this operation"
         ERROR
           (ConstantSize < `AllInts@U64) :
             "64 bit constant fetch is not supported by MVC"
         ERROR
           (ConstantSize != `AllInts@S8) :
             "S8 constant fetch is not supported by MVC"

    OPCODES
         MVC = 0b001_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputIndex;
      Condition = Condition;
      CC = CC;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Constant = constantIndex;
      Imm16 = addrDisplacement;
      Address = Address;
      Increment = Address@postincr;
      Size = CSize(ConstantSize);

      Output = 1;
      Sync=S;!Canvas1;
      !Nenc46;

CLASS "I2R"
    FORMAT Opcode/S(noS)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             V[Address(A0)++ + UImm(16):VIndex];

    OPCODES
         I2R = 0b000_0000_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputReg;
      Condition = Condition;
      CC = CC;
      Imm16 = VIndex;
      Address = Address;
      Increment = Address@postincr;

      Output=0;
      Sync=S;!Canvas1;
      !Nenc47;

CLASS "Output I2R"
    FORMAT Opcode/S(noS)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             V[Address(A0)++ + UImm(16):VIndex];

    OPCODES
         I2R = 0b000_0000_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputIndex;
      Condition = Condition;
      CC = CC;
      Imm16 = VIndex;
      Address = Address;
      Increment = Address@postincr;

      Output = 1;
      Sync=S;!Canvas1;
      !Nenc47;

CLASS "R2O"
    FORMAT Opcode/S(noS)
             O[Address(A0)++ + UImm(16)]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register;

    OPCODES
         R2O = 0b100_0000_01;

    ENCODING
      Opcode1 = Opcode;
      CReg = Register;
      Condition = Condition;
      CC = CC;
      Imm16 = Imm;
      Address = Address;
      Increment = Address@postincr;

      Sync=S;!Canvas1;
      !Nenc64;

CLASS "S2R"
    FORMAT Opcode/S(noS)
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             SpecialRegister;

    OPCODES
         S2R = 0b011_0000_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = Register;
      Condition = Condition;
      CC = CC;
      CReg = SpecialRegister;

      Sync=S;!Canvas1;
      !Nenc63;

CLASS "IntegerNon16 R2G"
    FORMAT Opcode/S(noS) /Integer:GlobalSize /IntegerNon16:RegisterSize /UNL(noUNL) /OptCondition(noCond)
             G[Address(A0)++ + UImm(16)*:GlobalIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1;

    CONDITIONS
         ERROR
           (GlobalSize == `AllInts@U16) || (GlobalSize == `AllInts@U32) :
             "Only U16 or U32 destination operation"
         ERROR
           (RegisterSize < `AllInts@U64) :
             "64 bit source format is not supported by R2G"
         ERROR
           !(RegisterSize&1) :
             "No signed source format supported by R2G"

    OPCODES
         R2G = 0b111_0000_01;

    ENCODING
      Opcode1 = Opcode;
      CReg = InputReg1;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      Imm16 = GlobalIndex;
      Address = Address;
      Increment = Address@postincr;
      L = UNL;
      R2GDSize =* R2GDSize (RegisterSize);
      R2GSSize = U32 (GlobalSize);

      Sync=S;!Canvas1;
      !Nenc51;

CLASS "Integer16 R2G"
    FORMAT Opcode/S(noS) /Integer:GlobalSize /Integer16:RegisterSize /UNL(noUNL) /OptCondition(noCond)
             G[Address(A0)++ + UImm(16)*:GlobalIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1;

    CONDITIONS
         ERROR
           (GlobalSize == `AllInts@U16) || (GlobalSize == `AllInts@U32) :
             "Only U16 or U32 destination operation"
         ERROR
           (RegisterSize < `AllInts@U64) :
             "64 bit source format is not supported by R2G"
         ERROR
           !(RegisterSize&1) :
             "No signed source format supported by R2G"

    OPCODES
         R2G = 0b111_0000_01;

    ENCODING
      Opcode1 = Opcode;
      CReg = InputReg1;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      Imm16 = GlobalIndex;
      Address = Address;
      Increment = Address@postincr;
      L = UNL;
      R2GDSize =* R2GDSize (RegisterSize);
      R2GSSize = U32 (GlobalSize);

      Sync=S;!Canvas1;
      !Nenc51;

CLASS "IntegerNon16 G2R"
    FORMAT Opcode/S(noS) /IntegerNon16:RegisterSize /PIPE(noPIPE) /UNL(noUNL) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G[Address(A0)++ + UImm(16)*:GlobalIndex]/Integer:GlobalSize;

    CONDITIONS
         ERROR
           (GlobalSize == `AllInts@U16) || (GlobalSize == `AllInts@U32) :
             "Only U16 or U32 destination operation"
         ERROR
           (GlobalSize < `AllInts@U64) :
             "64 bit source format is not supported by R2G"
         ERROR
           !(GlobalSize&1) :
             "No signed source format supported by R2G"

    OPCODES
         G2R = 0b010_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputReg;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      Imm16 = GlobalIndex;
      Address = Address;
      Increment = Address@postincr;
      L = UNL;
      Pipe1 = PIPE;
      Size =* CSize(RegisterSize);
      G2RDSize = U32 (GlobalSize);

      Output=0;
      Sync=S;!Canvas1;
      !Nenc52;




CLASS "Output IntegerNon16 G2R"
    FORMAT Opcode/S(noS) /IntegerNon16:RegisterSize /PIPE(noPIPE) /UNL(noUNL) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G[Address(A0)++ + UImm(16)*:GlobalIndex]/Integer:GlobalSize;

    CONDITIONS
         ERROR
           (GlobalSize == `AllInts@U16) || (GlobalSize == `AllInts@U32) :
             "Only U16 or U32 destination operation"
         ERROR
           (GlobalSize < `AllInts@U64) :
             "64 bit source format is not supported by R2G"
         ERROR
           !(GlobalSize&1) :
             "No signed source format supported by R2G"

    OPCODES
         G2R = 0b010_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputIndex;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      Imm16 = GlobalIndex;
      Address = Address;
      Increment = Address@postincr;
      L = UNL;
      Pipe1 = PIPE;
      Size =* CSize(RegisterSize);
      G2RDSize = U32 (GlobalSize);

      Output = 1;
      Sync=S;!Canvas1;
      !Nenc52;




CLASS "Integer16 G2R"
    FORMAT Opcode/S(noS) /Integer16:RegisterSize /PIPE(noPIPE) /UNL(noUNL) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G[Address(A0)++ + UImm(16)*:GlobalIndex]/Integer:GlobalSize;

    CONDITIONS
         ERROR
           (GlobalSize == `AllInts@U16) || (GlobalSize == `AllInts@U32) :
             "Only U16 or U32 destination operation"
         ERROR
           (GlobalSize < `AllInts@U64) :
             "64 bit source format is not supported by R2G"
         ERROR
           !(GlobalSize&1) :
             "No signed source format supported by R2G"

    OPCODES
         G2R = 0b010_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputReg;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      Imm16 = GlobalIndex;
      Address = Address;
      Increment = Address@postincr;
      L = UNL;
      Pipe1 = PIPE;
      Size =* CSize(RegisterSize);
      G2RDSize = U32 (GlobalSize);

      Output=0;
      Sync=S;!Canvas1;
      !Nenc52;




CLASS "Output Integer16 G2R"
    FORMAT Opcode/S(noS) /Integer16:RegisterSize /PIPE(noPIPE) /UNL(noUNL) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G[Address(A0)++ + UImm(16)*:GlobalIndex]/Integer:GlobalSize;

    CONDITIONS
         ERROR
           (GlobalSize == `AllInts@U16) || (GlobalSize == `AllInts@U32) :
             "Only U16 or U32 destination operation"
         ERROR
           (GlobalSize < `AllInts@U64) :
             "64 bit source format is not supported by R2G"
         ERROR
           !(GlobalSize&1) :
             "No signed source format supported by R2G"

    OPCODES
         G2R = 0b010_0001_01;

    ENCODING
      Opcode1 = Opcode;
      DReg = OutputIndex;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      Imm16 = GlobalIndex;
      Address = Address;
      Increment = Address@postincr;
      L = UNL;
      Pipe1 = PIPE;
      Size =* CSize(RegisterSize);
      G2RDSize = U32 (GlobalSize);

      Output = 1;
      Sync=S;!Canvas1;
      !Nenc52;




CLASS "IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC=0;!ABCFix_AC;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "A IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "C IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "AC IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "Output IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC=0;!ABCFix_AC;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "A Output IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "C Output IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "AC Output IntegerNon16 IADD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' [-]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC=0;!ABCFix_AC;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "A Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "C Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "AC Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "Output Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' [-]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC=0;!ABCFix_AC;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "A Output Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg = InputReg2;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "C Output Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' [-]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "AC Output Integer16 IADD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [-]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD = 0b000_0001_01;

    ENCODING
      Opcode9 = Opcode;
      Condition, O1c_ADD = IADDCombine( OptCARRY, Condition, InputReg1@negate, InputReg2@negate );
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      CReg=CIndex;
      IFormat =* CombineSATAndInteger(SAT,OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc36;

CLASS "IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC=0;!ABCFix_ABC;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AC IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "A IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "B IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AB IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "C IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "Output IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC=0;!ABCFix_ABC;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AC Output IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "A Output IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "B Output IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AB Output IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "C Output IntegerNon16 ISAD"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC=0;!ABCFix_ABC;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AC Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "A Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "B Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AB Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "C Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "Output Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC=0;!ABCFix_ABC;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AC Output Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "A Output Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "B Output Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "AB Output Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      IFormat =* IFormat(OperationSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "C Output Integer16 ISAD"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2 ',' C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         ISAD = 0b000_0101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      IFormat =* IFormat(OperationSize);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "Output Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A Output Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B Output Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB Output Integer1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "Output IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A Output IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B Output IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB Output IntegerNon1616 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "Output Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A Output Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B Output Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB Output Integer16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "Output IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "A Output IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "B Output IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "AB Output IntegerNon16Non16 IMUL"
    FORMAT Opcode/S(noS) /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL = 0b000_00100_01;

    ENCODING
      Opcode11 = Opcode;
      Condition = Condition;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IMul =* IMul(HILO,LeftSize,RightSize);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc38;

CLASS "IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC=0;!ABCFix_ABC;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AC IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "A IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "B IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AB IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "C IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "Output IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC=0;!ABCFix_ABC;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AC Output IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "A Output IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "B Output IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AB Output IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "C Output IntegerNon16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulIntegerNon16(U32):OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' Register16:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC=0;!ABCFix_ABC;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AC Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "A Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "B Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AB Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "C Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' Register16:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "Output Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' Register16:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC=0;!ABCFix_ABC;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AC Output Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b110;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "A Output Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "B Output Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "AB Output Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      CReg = InputReg3;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "C Output Integer16 IMAD"
    FORMAT Opcode/S(noS) /HILO(LO) /SAT(noSAT) /MulInteger16:OperationSize /OptCARRY(noCARRY) /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [-]Register16:InputReg1 ',' Register16:InputReg2 ',' [-]C:InputReg3[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           ((OperationSize < `AllInts@U32) && (OperationSize > `AllInts@S8)) || (OperationSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((OperationSize&~1) == `AllInts@U24):
             "IMAD.HI only allowed for 24 bit multiplication"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"
         ERROR
           (OptCARRY != `noCARRY)
                     -> (!InputReg1@negate && !InputReg3@negate) :
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY && CC != `TRUE) -> (OptCARRY == Condition):
             "Carry CC# must be the same as the predicate CC#"

    OPCODES
         IMAD = 0b0011_01;

    ENCODING
      Opcode5 = Opcode;
      CC = CC;
      CondDest = OptCondition(OptCondition);
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      CReg=CIndex;
      Condition, O1c_MAD = IMADCombine( OptCARRY, Condition, InputReg1@negate, InputReg3@negate );
      IMad =* IMad(OperationSize,SAT,HILO);
      ABC = 0b010;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc24;

CLASS "IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "A IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "B IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "AB IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "Output IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "A Output IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "B Output IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "AB Output IntegerNon16 IMAX"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "A Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "B Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "AB Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "Output Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "A Output Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "B Output Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "AB Output Integer16 IMAX"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         IMIN = 0b101_0011_01;
         IMAX = 0b100_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc40;

CLASS "IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "A IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "B IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "AB IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "Output IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "A Output IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "B Output IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "AB Output IntegerNon16 ISHIFT"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "A Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "B Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "AB Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "Output Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "A Output Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "B Output Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "AB Output Integer16 ISHIFT"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_0_0011_01;
         SHL = 0b110_0_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc70;

CLASS "IntegerNon16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "A IntegerNon16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "Output IntegerNon16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "A Output IntegerNon16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "Integer16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_A;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "A Integer16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "Output Integer16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_A;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "A Output Integer16 ISHIFT Imm"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' UImm(5):ShiftAmount;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         SHR = 0b111_1_0011_01;
         SHL = 0b110_1_0011_01;

    ENCODING
      ShOpcode = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = ShiftAmount;
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc45;

CLASS "IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register:InputReg1 ',' [~]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "A IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "B IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register:InputReg1 ',' [~]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "AB IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "Output IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register:InputReg1 ',' [~]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "A Output IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "B Output IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register:InputReg1 ',' [~]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "AB Output IntegerNon16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register16:InputReg1 ',' [~]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "A Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "B Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register16:InputReg1 ',' [~]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "AB Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "Output Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register16:InputReg1 ',' [~]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "A Output Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "B Output Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]Register16:InputReg1 ',' [~]C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "AB Output Integer16 LOP"
    FORMAT Opcode/S(noS) /LogicalOp /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' [~]C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"

    OPCODES
         LOP = 0b000_0_1101_01;

    ENCODING
      Opcode8 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      AInv = InputReg1@invert;
      BInv = InputReg2@invert;
      IFormat_LOP =* IFormat_LOP(OperationSize);
      Lop = LogicalOp;
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas2;
      !Nenc44;

CLASS "IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "A IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "B IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "AB IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             Register:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "Output IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "A Output IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "B Output IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "AB Output IntegerNon16 ISET"
    FORMAT Opcode/S(noS) /IntegerNon16(U32):OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      AReg = InputReg1;
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "A Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "B Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      AReg = InputReg1;
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "AB Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             Register16:OutputReg
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputReg;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output=0;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "Output Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' Register16:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC=0;!ABCFix_AB;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "A Output Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg = InputReg2;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b100;Address=IndexReg;Increment=IndexReg@postincr;!CBank;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "B Output Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register16:InputReg1 ',' C:InputReg2[UImm(4)*:CBank][Address(A0):IndexReg+++UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      AReg = InputReg1;
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b001;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "AB Output Integer16 ISET"
    FORMAT Opcode/S(noS) /Integer16:OperationSize /OptCondition(noCond)
             O[UImm(7):OutputIndex]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             G:InputReg1[Address(A0):IndexReg+++UImm(5)*:GRFIndex]/Integer(U32):GRFSize ',' C:InputReg2[UImm(4)*:CBank][UImm(7)*:CIndex] ','
             CC ;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           CC[2] < 8 :
             "Comparison is not allowed for ISET"

    OPCODES
         ISET = 0b011_0011_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC[1];
      DReg = OutputIndex;
      GRFIndex=GRFIndex;GRFSize=GRFSize(GRFSize);
      BReg=CIndex;
      SetCC3 = CC[2];
      IFormat =* IFormat(OperationSize);
      CondDest = OptCondition(OptCondition);
      ABC = 0b101;CBank=CBank;Address=IndexReg;Increment=IndexReg@postincr;
      Output = 1;
      Sync=S;!Canvas1;
      !Nenc41;
CLASS "IntegerNon16 IADD32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IADD32 = 0b001_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg2@negate );
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      AB=0;!ABFix_AB;
      !Canvas0;

CLASS "A IntegerNon16 IADD32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' [-]Register:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IADD32 = 0b001_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg2@negate );
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "B IntegerNon16 IADD32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' [-]C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IADD32 = 0b001_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg2@negate );
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "Integer16 IADD32"
    FORMAT Opcode /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register16:OutputReg ','
             [-]Register16:InputReg1 ',' [-]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IADD32 = 0b001_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg2@negate );
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      AB=0;!ABFix_AB;
      !Canvas0;

CLASS "A Integer16 IADD32"
    FORMAT Opcode /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register16:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' [-]Register16:InputReg2;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IADD32 = 0b001_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg2@negate );
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "B Integer16 IADD32"
    FORMAT Opcode /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register16:OutputReg ','
             [-]Register16:InputReg1 ',' [-]C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex];

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (!InputReg1@negate || !InputReg2@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg2@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IADD32 = 0b001_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg2@negate );
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "IMAD32"
    FORMAT Opcode /SAT(noSAT) /Integer:OperationSize /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize&~1) == `AllInts@U16) :
             "Only 16 mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"
         ERROR
           (!InputReg1@negate || !InputReg3@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg3@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMAD32 = 0b011_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg3@negate );
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IFormat32 = IMad32(OperationSize,SAT);
      AB=0;!ABFix_AB;
      !Canvas0;

CLASS "A IMAD32"
    FORMAT Opcode /SAT(noSAT) /Integer:OperationSize /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize&~1) == `AllInts@U16) :
             "Only 16 mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"
         ERROR
           (!InputReg1@negate || !InputReg3@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg3@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMAD32 = 0b011_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg3@negate );
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IFormat32 = IMad32(OperationSize,SAT);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "B IMAD32"
    FORMAT Opcode /SAT(noSAT) /Integer:OperationSize /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex] ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize&~1) == `AllInts@U16) :
             "Only 16 mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"
         ERROR
           (!InputReg1@negate || !InputReg3@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg3@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMAD32 = 0b011_00;

    ENCODING
      Opcode6 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg3@negate );
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IFormat32 = IMad32(OperationSize,SAT);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;

CLASS "IntegerNon16 ISAD32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize
             Register:OutputReg ','
             Register:InputReg1 ',' Register:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (InputReg1 == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         ISAD32 = 0b0101_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IFormat32 =* IFormat32(OperationSize);
      AB=0;!ABFix_AB;
      !Canvas0;
      !CNeg2;

CLASS "A IntegerNon16 ISAD32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (InputReg1 == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         ISAD32 = 0b0101_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IFormat32 =* IFormat32(OperationSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
      !CNeg2;

CLASS "B IntegerNon16 ISAD32"
    FORMAT Opcode /IntegerNon16(U32):OperationSize
             Register:OutputReg ','
             Register:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (InputReg1 == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         ISAD32 = 0b0101_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IFormat32 =* IFormat32(OperationSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
      !CNeg2;

CLASS "Integer16 ISAD32"
    FORMAT Opcode /Integer16:OperationSize
             Register16:OutputReg ','
             Register16:InputReg1 ',' Register16:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (InputReg1 == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         ISAD32 = 0b0101_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IFormat32 =* IFormat32(OperationSize);
      AB=0;!ABFix_AB;
      !Canvas0;
      !CNeg2;

CLASS "A Integer16 ISAD32"
    FORMAT Opcode /Integer16:OperationSize
             Register16:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2 ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (InputReg1 == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         ISAD32 = 0b0101_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IFormat32 =* IFormat32(OperationSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
      !CNeg2;

CLASS "B Integer16 ISAD32"
    FORMAT Opcode /Integer16:OperationSize
             Register16:OutputReg ','
             Register16:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex] ',' Register:InputReg3;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (InputReg1 == InputReg3) :
             "Input register must be the same as the output register"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         ISAD32 = 0b0101_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IFormat32 =* IFormat32(OperationSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
      !CNeg2;

CLASS "Integer1616 IMUL32"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             Register16:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_AB;
      !Canvas0;
CLASS "A Integer1616 IMUL32"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "B Integer1616 IMUL32"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             Register16:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex];

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "IntegerNon1616 IMUL32"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             Register:InputReg1 ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_AB;
      !Canvas0;
CLASS "A IntegerNon1616 IMUL32"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register16:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "B IntegerNon1616 IMUL32"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             Register:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex];

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "Integer16Non16 IMUL32"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             Register16:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_AB;
      !Canvas0;
CLASS "A Integer16Non16 IMUL32"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "B Integer16Non16 IMUL32"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             Register16:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex];

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "IntegerNon16Non16 IMUL32"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             Register:InputReg1 ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_AB;
      !Canvas0;
CLASS "A IntegerNon16Non16 IMUL32"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' Register:InputReg2;

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      BReg6 = InputReg2;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "B IntegerNon16Non16 IMUL32"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             Register:InputReg1 ',' C:InputReg2[UImm(1)*:CBank][Address(A0):IndexReg+++UImm(5)*:CIndex];

    CONDITIONS
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg2<64) :
             "Registers must be <64 for this operation"
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    PROPERTIES
          IWIDTH = 4;

    OPCODES
         IMUL32 = 0b0100_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      ConstOffs6=CIndex;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b01;CBank6=CBank;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas0;
CLASS "IntegerNon16 IADD32I"
    FORMAT Opcode /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]Register:InputReg1 ',' UImm(32):Addend;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD32I = 0b000_11_001_01;

    ENCODING
      Opcode7 = Opcode;
      O1c_ADD = IADD32ICombine( OptCARRY, InputReg1@negate );
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      Imm321 = Addend;
      AB=0;!ABFix_A;
      !Canvas3;

CLASS "A IntegerNon16 IADD32I"
    FORMAT Opcode /IntegerNon16(U32):OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):Addend;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD32I = 0b000_11_001_01;

    ENCODING
      Opcode7 = Opcode;
      O1c_ADD = IADD32ICombine( OptCARRY, InputReg1@negate );
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      Imm321 = Addend;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;

CLASS "Integer16 IADD32I"
    FORMAT Opcode /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register16:OutputReg ','
             [-]Register16:InputReg1 ',' UImm(32):Addend;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD32I = 0b000_11_001_01;

    ENCODING
      Opcode7 = Opcode;
      O1c_ADD = IADD32ICombine( OptCARRY, InputReg1@negate );
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      Imm321 = Addend;
      AB=0;!ABFix_A;
      !Canvas3;

CLASS "A Integer16 IADD32I"
    FORMAT Opcode /Integer16:OperationSize /SAT(noSAT) /OptCARRY(noCARRY)
             Register16:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):Addend;

    CONDITIONS
         ERROR
           (OperationSize < `AllInts@U64) && (OperationSize > `AllInts@S8) :
             "Only 16 or 32 bit mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IADD32I = 0b000_11_001_01;

    ENCODING
      Opcode7 = Opcode;
      O1c_ADD = IADD32ICombine( OptCARRY, InputReg1@negate );
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      IFormat32 =* CombineSATAndInteger32(SAT,OperationSize);
      Imm321 = Addend;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;

CLASS "IMAD32I"
    FORMAT Opcode /SAT(noSAT) /Integer:OperationSize /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]Register16:InputReg1 ',' UImm(32):Factor ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize&~1) == `AllInts@U16) :
             "Only 16 mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg3<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"
         ERROR
           (!InputReg1@negate || !InputReg3@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg3@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IMAD32I = 0b000_11_011_01;

    ENCODING
      Opcode7 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg3@negate );
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      AReg6 = InputReg1;
      IFormat32 = IMad32(OperationSize,SAT);
      Imm321 = Factor;
      AB=0;!ABFix_A;
      !Canvas3;

CLASS "A IMAD32I"
    FORMAT Opcode /SAT(noSAT) /Integer:OperationSize /OptCARRY(noCARRY)
             Register:OutputReg ','
             [-]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):Factor ',' [-]Register:InputReg3;

    CONDITIONS
         ERROR
           ((OperationSize&~1) == `AllInts@U16) :
             "Only 16 mode allowed for this operation"
         ERROR
           (OutputReg<64) && (InputReg1<64) && (InputReg3<64) :
             "Registers must be <64 for this operation"
         ERROR
           (OutputReg == InputReg3) :
             "Input register must be the same as the output register"
         ERROR
           (!InputReg1@negate || !InputReg3@negate) :
             "At most one '-' operation is allowed for this operation"
         ERROR
           (OptCARRY != `noCARRY) -> (!InputReg1@negate && !InputReg3@negate):
             "Carry mode cannot be used in combination with '-' operations"
         ERROR
           (OptCARRY != `noCARRY) -> (OptCARRY == `CARRY0):
             "Only .C0 allowed for this operation"
         ERROR
           SAT -> ((OperationSize&1)==1) :
             "SAT is only allowed in signed integer mode"

    OPCODES
         IMAD32I = 0b000_11_011_01;

    ENCODING
      Opcode7 = Opcode;
      O1c_ADD = IADD32Combine( OptCARRY, InputReg1@negate, InputReg3@negate );
      DReg6 = IDENTICAL(OutputReg,InputReg3);
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      IFormat32 = IMad32(OperationSize,SAT);
      Imm321 = Factor;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;

CLASS "Integer1616 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             Register16:InputReg1 ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_A;
      !Canvas3;

CLASS "A Integer1616 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;

CLASS "IntegerNon1616 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             Register:InputReg1 ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_A;
      !Canvas3;

CLASS "A IntegerNon1616 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulInteger16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;

CLASS "Integer16Non16 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             Register16:InputReg1 ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_A;
      !Canvas3;

CLASS "A Integer16Non16 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulInteger16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;

CLASS "IntegerNon16Non16 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             Register:InputReg1 ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB=0;!ABFix_A;
      !Canvas3;

CLASS "A IntegerNon16Non16 IMUL32I"
    FORMAT Opcode /HILO(LO) /MulIntegerNon16:LeftSize /MulIntegerNon16:RightSize
             Register:OutputReg ','
             G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):Factor;

    CONDITIONS
         ERROR
           (LeftSize&~1) == (RightSize&~1) :
             "No mixed size multiplication allowed"
         ERROR
           ((LeftSize < `AllInts@U32) && (LeftSize > `AllInts@S8)) || (LeftSize >= `AllInts@U24) :
             "Only 16 or 24 bit mode allowed for this operation"
         ERROR
           (HILO == `HI) -> ((LeftSize&~1) == `AllInts@U24):
             "MUL.HI only allowed for 24 bit multiplication"

    OPCODES
         IMUL32I = 0b000_11_0100_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      Imm321 = Factor;
      IMul32 =* IMul(HILO,LeftSize,RightSize);
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;

CLASS "LOP32I"
    FORMAT Opcode /LogicalOp
             Register:OutputReg ','
             [~]Register:InputReg1 ',' UImm(32):LopConst;

    OPCODES
         LOP32I = 0b000_11_1101_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      AReg6 = InputReg1;
      AInv32 = InputReg1@invert;
      Imm321 = LopConst;
      Lop32 = LogicalOp;
      AB=0;!ABFix_A;
      !Canvas3;




CLASS "A LOP32I"
    FORMAT Opcode /LogicalOp
             Register:OutputReg ','
             [~]G:InputReg1[Address(A0):IndexReg+++UImm(4):GRFIndex]/Integer(U32):GRFSize ',' UImm(32):LopConst;

    OPCODES
         LOP32I = 0b000_11_1101_01;

    ENCODING
      Opcode3 = Opcode;
      DReg6 = OutputReg;
      GRFIndex6=GRFIndex;GRFSize6=GRFSize(GRFSize);
      AInv32 = InputReg1@invert;
      Imm321 = LopConst;
      Lop32 = LogicalOp;
      AB = 0b10;Address2=IndexReg;Increment=IndexReg@postincr;
      !Canvas3;




CLASS "TEX32"
    FORMAT Opcode /UN(noUN) /NODEP(noNODEP) /PHASE(P0)
             Register ','
             UImm(8)*:tid ','
             UImm(5)*:smp ','
             UImm(2);

    CONDITIONS
         ERROR
           Register<64 :
             "Register must be <64 for this operation"

    PROPERTIES
          IWIDTH = 4;
          ITYPE = ITYPE_TEX_T | ITYPE_TEX_S;

    OPCODES
         TEX32 = 0b1111_00;

    ENCODING
      Opcode0 = Opcode;
      DReg6 = Register;
      TexId = tid;
      Sampler = smp;
      NrofCoords = Imm[3];
      Un = UN;
      NoDep32 = NODEP;
      Phase32 = PHASE;
      !Canvas0;

CLASS "TEX"
    FORMAT Opcode/S(noS) /UN(noUN) /NODEP(noNODEP) /ND(noND) /PHASE(P0) /CUBE(noCUBE)
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             UImm(8)*:tid ','
             UImm(5)*:smp ','
             UImm(2) ','
             TMask ','
             UImm(12);

    PROPERTIES
          ITYPE = ITYPE_TEX_T | ITYPE_TEX_S;

    OPCODES
         TEX = 0b000_1111_01;
         TXB = 0b001_1111_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = Register;
      TexId = tid;
      Sampler = smp;
      NrofCoords = Imm[3];
      Offset = Imm[4];
      TMask = TMask;
      Un = UN;
      Nd = ND;
      NoDep = NODEP;
      Phase = PHASE;
      Cube = CUBE;
      Sync=S;!Canvas1;
      !Nenc24;

CLASS "TXA"
    FORMAT Opcode/S(noS) /UN(noUN) /NODEP(noNODEP) /PHASE(P0)
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             UImm(8)*:tid ','
             UImm(5)*:smp ','
             UImm(2) ','
             TMask;

    PROPERTIES
          ITYPE = ITYPE_TEX_T | ITYPE_TEX_S;

    OPCODES
         TXA = 0b100_1111_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = Register;
      TexId = tid;
      Sampler = smp;
      NrofCoords = Imm[3];
      TMask = TMask;
      Un = UN;
      NoDep = NODEP;
      Phase = PHASE;
      Sync=S;!Canvas1;
      !Nenc56;

CLASS "TXL"
    FORMAT Opcode/S(noS) /UN(noUN) /NODEP(noNODEP) /PHASE(P0) /CUBE(noCUBE)
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             UImm(8)*:tid ','
             UImm(5)*:smp ','
             UImm(2) ','
             TMask ','
             UImm(12);

    PROPERTIES
          ITYPE = ITYPE_TEX_T | ITYPE_TEX_S;

    OPCODES
         TXL = 0b010_1111_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = Register;
      TexId = tid;
      Sampler = smp;
      NrofCoords = Imm[3];
      Offset = Imm[4];
      TMask = TMask;
      Un = UN;
      NoDep = NODEP;
      Phase = PHASE;
      Cube = CUBE;
      Sync=S;!Canvas1;
      !Nenc57;

CLASS "TXQ"
    FORMAT Opcode/S(noS) /NODEP(noNODEP)
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             UImm(8)*:tid ','
             UImm(5)*:smp ','
             UImm(2) ','
             TMask;

    PROPERTIES
          ITYPE = ITYPE_TEX_T | ITYPE_TEX_S;

    OPCODES
         TXQ = 0b011_1111_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      DReg = Register;
      TexId = tid;
      Sampler = smp;
      NrofCoords = Imm[3];
      TMask = TMask;
      NoDep = NODEP;
      Sync=S;!Canvas1;
      !Nenc58;

CLASS "STP"
    FORMAT Opcode/S(noS) PHASE;

    OPCODES
         STP = 0b101_1111_0_01;
         STP.WAIT = 0b101_1111_1_01;

    ENCODING
      STPOpcode = Opcode;
      Phase = PHASE;
      Sync=S;!Canvas1;
      !Nenc59;





CLASS "GATOM2"
    FORMAT Opcode/S(noS) /MEMOP2 /MemSize
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             GLOB[Register] ','
             Register;

    CONDITIONS
         ERROR
           MemSize > `S8 :
             "Byte size memory operations are not supported"

    OPCODES
         GATOM = 0b111_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemId1 = GLOB;
      MemOp =* MEMOP2;
      MemSize = MemSize;
      DReg = Register[1];
      AReg = Register[2];
      BReg = Register[3];
      !Nenc60;
      Sync=S;!Canvas1;
      !CReg;

CLASS "GRED2"
    FORMAT Opcode/S(noS) /MEMOP2 /MemSize
             GLOB[Register]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register;

    CONDITIONS
         ERROR
           MemSize > `S8 :
             "Byte size memory operations are not supported"

    OPCODES
         GRED = 0b110_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemId = GLOB;
      MemOp =* MEMOP2;
      MemSize = MemSize;
      AReg = Register[1];
      DReg = Register[2];
      !Nenc60;
      Sync=S;!Canvas1;
      !BReg1;
      !CReg;

CLASS "GATOM3"
    FORMAT Opcode/S(noS) /MEMOP3 /MemSize
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             GLOB[Register] ','
             Register ',' Register;

    CONDITIONS
         ERROR
           MemSize > `S8 :
             "Byte size memory operations are not supported"

    OPCODES
         GATOM = 0b111_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemId1 = GLOB;
      MemOp =* MEMOP3;
      MemSize = MemSize;
      DReg = Register[1];
      AReg = Register[2];
      BReg = Register[3];
      CReg = Register[4];
      !Nenc60;
      Sync=S;!Canvas1;

CLASS "GRED3"
    FORMAT Opcode/S(noS) /MEMOP3 /MemSize
             GLOB[Register]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register',' Register;

    CONDITIONS
         ERROR
           MemSize > `S8 :
             "Byte size memory operations are not supported"

    OPCODES
         GRED = 0b110_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemId = GLOB;
      MemOp =* MEMOP3;
      MemSize = MemSize;
      AReg = Register[1];
      DReg = Register[2];
      BReg1 = Register[3];
      !Nenc60;
      Sync=S;!Canvas1;
      !CReg;


CLASS "GLD"
    FORMAT Opcode/S(noS) /MemSize
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             GLOB[Register];

    OPCODES
         GLD = 0b100_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemId = GLOB;
      MemSize = MemSize;
      DReg = Register[1];
      AReg = Register[2];
      !Nenc61;
      Sync=S;!Canvas1;

CLASS "GST"
    FORMAT Opcode/S(noS) /MemSize
             GLOB[Register]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register;

    OPCODES
         GST = 0b101_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemId = GLOB;
      MemSize = MemSize;
      DReg = Register[2];
      AReg = Register[1];
      !Nenc61;
      Sync=S;!Canvas1;

CLASS "LLD"
    FORMAT Opcode/S(noS) /MemSize
             Register
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Local[Address(A0)++ + UImm(16)*];

    OPCODES
         LLD = 0b010_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemSize = MemSize;
      DReg = Register;
      Address = Address;
      Increment = Address@postincr;
      Imm16 = Imm;
      !Nenc62;
      Sync=S;!Canvas1;

CLASS "LST"
    FORMAT Opcode/S(noS) /MemSize
             Local[Address(A0)++ + UImm(16)*]
             PREDICATE(Condition(C0)/CC(TRUE)) ','
             Register;

    OPCODES
         LST = 0b011_1101_01;

    ENCODING
      Opcode1 = Opcode;
      Condition = Condition;
      CC = CC;
      MemSize = MemSize;
      DReg = Register;
      Address = Address;
      Increment = Address@postincr;
      Imm16 = Imm;
      !Nenc62;
      Sync=S;!Canvas1;
