0	unknown error
1	last line of file ends without a newline
2	last line of file ends with a backslash
3	#include file %sq includes itself
4	out of memory
5	
6	comment unclosed at end of file
7	unrecognized token
8	missing closing quote
9	nested comment is not allowed
A	"#" not expected here
B	unrecognized preprocessing directive
C	parsing restarts here after previous syntax error
D	expected a file name
E	extra text after expected end of preprocessing directive
F	
10	
11	expected a "]"
12	expected a ")"
13	extra text after expected end of number
14	identifier %sq is undefined
15	type qualifiers are meaningless in this declaration
16	invalid hexadecimal number
17	integer constant is too large
18	invalid octal digit
19	quoted string should contain at least one character
1A	too many characters in character constant
1B	character value is out of range
1C	expression must have a constant value
1D	expected an expression
1E	floating constant is out of range
1F	expression must have integral type
20	expression must have arithmetic type
21	expected a line number
22	invalid line number
23	#error directive: %s
24	the #if for this directive is missing
25	the #endif for this directive is missing
26	directive is not allowed -- an #else has already appeared
27	division by zero
28	expected an identifier
29	expression must have arithmetic or pointer type
2A	operand types are incompatible (%t1 and %t2)
2B	
2C	expression must have pointer type
2D	#undef may not be used on this predefined name
2E	%no is predefined; attempted redefinition ignored
2F	incompatible redefinition of macro %nod
30	
31	duplicate macro parameter name
32	"##" may not be first in a macro definition
33	"##" may not be last in a macro definition
34	expected a macro parameter name
35	expected a ":"
36	too few arguments in invocation of %n
37	too many arguments in invocation of %n
38	operand of sizeof may not be a function
39	this operator is not allowed in a constant expression
3A	this operator is not allowed in a preprocessing expression
3B	function call is not allowed in a constant expression
3C	this operator is not allowed in an integral constant expression
3D	integer operation result is out of range
3E	shift count is negative
3F	shift count is too large
40	declaration does not declare anything
41	expected a ";"
42	enumeration value is out of "int" range
43	expected a "}"
44	integer conversion resulted in a change of sign
45	integer conversion resulted in truncation
46	incomplete type %t is not allowed
47	operand of sizeof may not be a bit field
48	
49	
4A	
4B	operand of "*" must be a pointer but has type %t
4C	argument to macro is empty
4D	this declaration has no storage class or type specifier
4E	a parameter declaration may not have an initializer
4F	expected a type specifier
50	a storage class may not be specified here
51	more than one storage class may not be specified
52	storage class is not first
53	type qualifier specified more than once
54	invalid combination of type specifiers
55	invalid storage class for a parameter
56	invalid storage class for a function
57	a type specifier may not be used here
58	array of functions is not allowed
59	array of void is not allowed
5A	function returning function is not allowed
5B	function returning array is not allowed
5C	identifier-list parameters may only be used in a function definition
5D	function type may not come from a typedef
5E	the size of an array must be greater than zero
5F	array is too large
60	a translation unit must contain at least one declaration
61	a function may not return a value of this type
62	an array may not have elements of this type
63	a declaration here must declare a parameter
64	duplicate parameter name
65	%sq has already been declared in the current scope
66	forward declaration of enum type is nonstandard
67	class is too large
68	struct or union is too large
69	invalid size for bit field
6A	invalid type for a bit field
6B	zero-length bit field must be unnamed
6C	signed bit field of length 1
6D	expression preceding parentheses of apparent call must have (pointer-to-) function type
6E	expected either a definition or a tag name
6F	statement is unreachable
70	expected "while"
71	
72	%n was referenced but not defined
73	a continue statement may only be used within a loop
74	a break statement may only be used within a loop or switch
75	non-void %n should return a value
76	a void function may not return a value
77	cast to type %t is not allowed
78	return value type does not match the function type
79	a case label may only be used within a switch
7A	a default label may only be used within a switch
7B	
7C	default label has already appeared in this switch
7D	expected a "("
7E	expression must be an lvalue
7F	expected a statement
80	loop is not reachable
81	a block-scope function may only have extern storage class
82	expected a "{"
83	expression must have pointer-to-class type but it has type %t
84	expression must have pointer-to-struct-or-union type but it has type %t
85	expected a member name
86	expected a field name
87	%n has no member %sq
88	%n has no field %sq
89	expression must be a modifiable lvalue
8A	taking the address of a register variable is not allowed
8B	taking the address of a bit field is not allowed
8C	too many arguments in function call
8D	unnamed prototyped parameters not allowed when body is present
8E	expression must have pointer-to-object type but it has type %t
8F	program too large or complicated to compile
90	a value of type %t1 cannot be used to initialize an entity of type %t2
91	%n may not be initialized
92	too many initializer values
93	declaration is incompatible with %nfd
94	%n has already been initialized
95	a global-scope declaration may not have this storage class
96	a type name may not be redeclared as a parameter
97	a typedef name may not be redeclared as a parameter
98	conversion of nonzero integer to pointer
99	expression must have class type but it has type %t
9A	expression must have struct or union type but it has type %t
9B	old-fashioned assignment operator
9C	old-fashioned initializer
9D	expression must be an integral constant expression
9E	expression must be an lvalue or a function designator
9F	declaration is incompatible with previous %nod
A0	external name conflicts with external name of %nd
A1	unrecognized #pragma
A2	
A3	could not open temporary file %sq: %s2
A4	name of directory for temporary files is too long (%sq)
A5	too few arguments in function call
A6	invalid floating constant
A7	argument of type %t1 is incompatible with parameter of type %t2
A8	a function type is not allowed here
A9	expected a declaration
AA	pointer points outside of underlying object
AB	invalid type conversion
AC	external/internal linkage conflict with previous declaration %p
AD	floating-point value does not fit in required integral type
AE	expression has no effect
AF	subscript out of range
B0	
B1	%n was declared but never referenced
B2	"&" applied to an array has no effect
B3	right operand of "%%" is zero
B4	argument is incompatible with formal parameter
B5	argument is incompatible with corresponding format string conversion (expected type %t1 but argument has type %t2)
B6	could not open source file %sq (no directories in search list)
B7	type of cast must be integral
B8	type of cast must be arithmetic or pointer
B9	dynamic initialization in unreachable code
BA	pointless comparison of unsigned integer with zero
BB	use of "=" where "==" may have been intended
BC	enumerated type mixed with another type
BD	error while writing %s file
BE	invalid intermediate language file
BF	type qualifier is meaningless on cast type
C0	unrecognized character escape sequence
C1	zero used for undefined preprocessing identifier %sq
C2	expected an asm string
C3	an asm function must be prototyped
C4	an asm function may not have an ellipsis
C5	
C6	
C7	
C8	
C9	
CA	
CB	
CC	
CD	
CE	
CF	
D0	
D1	
D2	
D3	
D4	
D5	
D6	
D7	
D8	
D9	
DA	
DB	error while deleting file %sq: %s2
DC	integral value does not fit in required floating-point type
DD	floating-point value does not fit in required floating-point type
DE	floating-point operation result is out of range
DF	function %sq declared implicitly
E0	the format string requires additional arguments
E1	the format string ends before this argument
E2	invalid format string conversion
E3	macro recursion
E4	trailing comma is nonstandard
E5	bit field cannot contain all values of the enumerated type
E6	nonstandard type for a bit field
E7	declaration is not visible outside of function
E8	old-fashioned typedef of "void" ignored
E9	left operand is not a struct or union containing this field
EA	pointer does not point to struct or union containing this field
EB	variable %sq was declared with a never-completed type
EC	controlling expression is constant
ED	selector expression is constant
EE	invalid specifier on a parameter
EF	invalid specifier outside a class declaration
F0	duplicate specifier in declaration
F1	a union is not allowed to have a base class
F2	multiple access control specifiers are not allowed
F3	class or struct definition is missing
F4	qualified name is not a member of class %t or its base classes
F5	a nonstatic member reference must be relative to a specific object
F6	a nonstatic data member may not be defined outside its class
F7	%n has already been defined
F8	pointer to reference is not allowed
F9	reference to reference is not allowed
FA	reference to void is not allowed
FB	array of reference is not allowed
FC	reference %n requires an initializer
FD	expected a ","
FE	type name is not allowed
FF	type definition is not allowed
100	invalid redeclaration of type name %nod
101	const %n requires an initializer
102	"this" may only be used inside a nonstatic member function
103	constant value is not known
104	explicit type is missing ("int" assumed)
105	access control not specified (%sq by default)
106	not a class or struct name
107	duplicate base class name
108	invalid base class
109	%nd is inaccessible
10A	%no is ambiguous
10B	old-style parameter list (anachronism)
10C	declaration may not appear after executable statement in block
10D	conversion to inaccessible base class %t is not allowed
10E	
10F	
110	
111	
112	improperly terminated macro invocation
113	
114	name followed by "::" must be a class or namespace name
115	invalid friend declaration
116	a constructor or destructor may not return a value
117	invalid destructor declaration
118	declaration of a member with the same name as its class
119	global-scope qualifier (leading "::") is not allowed
11A	the global scope has no %sq
11B	qualified name is not allowed
11C	NULL reference is not allowed
11D	initialization with "{...}" is not allowed for object of type %t
11E	base class %t is ambiguous
11F	derived class %t1 contains more than one instance of class %t2
120	cannot convert pointer to base class %t2 to pointer to derived class %t1 -- base class is virtual
121	no instance of constructor %no matches the argument list
122	copy constructor for class %t is ambiguous
123	no default constructor exists for class %t
124	%sq is not a nonstatic data member or base class of class %t
125	indirect nonvirtual base class is not allowed
126	invalid union member -- class %t has a disallowed member function
127	
128	invalid use of non-lvalue array
129	expected an operator
12A	inherited member is not allowed
12B	cannot determine which instance of %n is intended
12C	a pointer to a bound function may only be used to call the function
12D	typedef name has already been declared (with same type)
12E	
12F	
130	no instance of %n matches the argument list
131	type definition is not allowed in function return type declaration
132	default argument not at end of parameter list
133	redefinition of default argument
134	more than one instance of %n matches the argument list:
135	more than one instance of constructor %no matches the argument list:
136	default argument of type %t1 is incompatible with parameter of type %t2
137	cannot overload functions distinguished by return type alone
138	no suitable user-defined conversion from %t1 to %t2 exists
139	
13A	only nonstatic member functions may be virtual
13B	the object has type qualifiers that are not compatible with the member function
13C	program too large to compile (too many virtual functions)
13D	return type is not identical to nor covariant with return type %t of overridden virtual function %no
13E	override of virtual %n is ambiguous
13F	pure specifier ("= 0") allowed only on virtual functions
140	badly-formed pure specifier (only "= 0" is allowed)
141	data member initializer is not allowed
142	object of abstract class type %t is not allowed:
143	function returning abstract class %t is not allowed:
144	duplicate friend declaration
145	inline specifier allowed on function declarations only
146	"inline" is not allowed
147	invalid storage class for an inline function
148	invalid storage class for a class member
149	local class member %n requires a definition
14A	%nfd is inaccessible
14B	
14C	class %t has no copy constructor to copy a const object
14D	defining an implicitly declared member function is not allowed
14E	class %t has no suitable copy constructor
14F	linkage specification is not allowed
150	unknown external linkage specification
151	linkage specification is incompatible with previous %nod
152	more than one instance of overloaded function %no has "C" linkage
153	class %t has more than one default constructor
154	value copied to temporary, reference to temporary used
155	"operator%s" must be a member function
156	operator may not be a static member function
157	no arguments allowed on user-defined conversion
158	too many parameters for this operator function
159	too few parameters for this operator function
15A	nonmember operator requires a parameter with class type
15B	default argument is not allowed
15C	more than one user-defined conversion from %t1 to %t2 applies:
15D	no operator %sq matches these operands
15E	more than one operator %sq matches these operands:
15F	first parameter of allocation function must be of type "size_t"
160	allocation function requires "void *" return type
161	deallocation function requires "void" return type
162	first parameter of deallocation function must be of type "void *"
163	
164	type must be an object type
165	base class %t has already been initialized
166	base class name required -- %t assumed (anachronism)
167	%n has already been initialized
168	name of member or base class is missing
169	assignment to "this" (anachronism)
16A	"overload" keyword used (anachronism)
16B	invalid anonymous union -- nonpublic member is not allowed
16C	invalid anonymous union -- member function is not allowed
16D	anonymous union at global or namespace scope must be declared static
16E	%nf provides no initializer for:
16F	implicitly generated constructor for class %t cannot initialize:
170	%n defines no constructor to initialize the following:
171	%n has an uninitialized const or reference member
172	%n has an uninitialized const field
173	class %t has no assignment operator to copy a const object
174	class %t has no suitable assignment operator
175	ambiguous assignment operator for class %t
176	
177	declaration requires a typedef name
178	
179	"virtual" is not allowed
17A	"static" is not allowed
17B	cast of bound function to normal function pointer (anachronism)
17C	expression must have pointer-to-member type
17D	extra ";" ignored
17E	in-class initializer for nonstatic member is nonstandard
17F	
180	no instance of overloaded %no matches the argument list
181	
182	no instance of %n matches the required type
183	delete array size expression used (anachronism)
184	
185	a cast to abstract class %t is not allowed:
186	function "main" may not be called or have its address taken
187	a new-initializer may not be specified for an array
188	member function %no may not be redeclared outside its class
189	
18A	reference to local variable of enclosing function is not allowed
18B	single-argument function used for postfix %sq (anachronism)
18C	
18D	implicitly generated assignment operator cannot copy:
18E	cast to array type is nonstandard (treated as cast to %t)
18F	%n has an operator new%s() but no default operator delete%s()
190	%n has a default operator delete%s() but no operator new%s()
191	destructor for base class %nod is not virtual
192	
193	invalid redeclaration of member %npd
194	function "main" may not be declared inline
195	member function with the same name as its class must be a constructor
196	using nested %n (anachronism)
197	a destructor may not have parameters
198	copy constructor for class %t may not have a parameter of type %t
199	%n returns incomplete type %t
19A	protected %nd is not accessible through a %t pointer or object
19B	a parameter is not allowed
19C	an "asm" declaration is not allowed here
19D	no suitable conversion function from %t1 to %t2 exists
19E	delete of pointer to incomplete class
19F	no suitable constructor exists to convert from %t1 to %t2
1A0	more than one constructor applies to convert from %t1 to %t2:
1A1	more than one conversion function from %t1 to %t2 applies:
1A2	more than one conversion function from %t to a built-in type applies:
1A3	const %n
1A4	reference %n
1A5	%npTd
1A6	built-in operator %sq
1A7	%nod, ambiguous by inheritance
1A8	a constructor or destructor may not have its address taken
1A9	
1AA	temporary used for initial value of reference to non-const (anachronism)
1AB	qualified name is not allowed in member declaration
1AC	enumerated type mixed with another type (anachronism)
1AD	the size of an array in "new" must be non-negative
1AE	returning reference to local temporary
1AF	
1B0	"enum" declaration is not allowed
1B1	qualifiers dropped in binding reference of type %t1 to initializer of type %t2
1B2	a reference of type %t1 (not const-qualified) cannot be initialized with a value of type %t2
1B3	a pointer to function may not be deleted
1B4	conversion function must be a nonstatic member function
1B5	a template declaration is not allowed here
1B6	expected a "<"
1B7	expected a ">"
1B8	template parameter declaration is missing
1B9	argument list for %nf is missing
1BA	too few arguments for %nf
1BB	too many arguments for %nf
1BC	
1BD	%n1 is not used in declaring the parameter types of %n2
1BE	two nested types have the same name: %no1 and %nod2 (cfront compatibility)
1BF	global %no1 was declared after nested %nod2 (cfront compatibility)
1C0	
1C1	more than one instance of %n matches the required type
1C2	the type "long long" is nonstandard
1C3	omission of %sq is nonstandard
1C4	return type may not be specified on a conversion function
1C5	detected during:
1C6	instantiation of %nt %p
1C7	implicit generation of %nt %p
1C8	excessive recursion at instantiation of %n
1C9	%sq is not a function or static data member
1CA	argument of type %t1 is incompatible with template parameter of type %t2
1CB	initialization requiring a temporary or conversion is not allowed
1CC	declaration of %sq hides function parameter
1CD	initial value of reference to non-const must be an lvalue
1CE	implicit definition of %nt %p
1CF	"template" is not allowed
1D0	%t is not a class template
1D1	
1D2	"main" is not a valid name for a function template
1D3	invalid reference to %n (union/nonunion mismatch)
1D4	a template argument may not reference a local type
1D5	tag kind of %s is incompatible with declaration of %nfd
1D6	the global scope has no tag named %sq
1D7	%n has no tag member named %sq
1D8	member function typedef (allowed for cfront compatibility)
1D9	%n may be used only in pointer-to-member declaration
1DA	
1DB	a template argument may not reference a non-external entity
1DC	name followed by "::~" must be a class name or a type name
1DD	
1DE	type used as destructor name does not match type %t
1DF	%n redeclared "inline" after being called
1E0	
1E1	invalid storage class for a template declaration
1E2	%nd is an inaccessible type (allowed for cfront compatibility)
1E3	
1E4	invalid explicit instantiation declaration
1E5	%nf is not an entity that can be instantiated
1E6	compiler generated %n cannot be explicitly instantiated
1E7	inline %n cannot be explicitly instantiated
1E8	
1E9	%n cannot be instantiated -- no template definition was supplied
1EA	%n cannot be instantiated -- it has been explicitly specialized
1EB	
1EC	
1ED	no instance of %n matches the specified type
1EE	declaring a void parameter list with a typedef is nonstandard
1EF	global %n1 used instead of %n2 (cfront compatibility)
1F0	template parameter %sq may not be redeclared in this scope
1F1	declaration of %sq hides template parameter
1F2	template argument list must match the parameter list
1F3	
1F4	extra parameter of postfix "operator%s" must be of type "int"
1F5	an operator name must be declared as a function
1F6	operator name is not allowed
1F7	%n cannot be specialized in the current scope
1F8	nonstandard form for taking the address of a member function
1F9	too few template parameters -- does not match previous declaration (declared %p)
1FA	too many template parameters -- does not match previous declaration (declared %p)
1FB	function template for operator delete(void *) is not allowed
1FC	class template and template parameter may not have the same name
1FD	
1FE	a template argument may not reference an unnamed type
1FF	this operation on an enumerated type requires an applicable user-defined operator function
200	type qualifier on a reference type is not allowed
201	a value of type %t1 cannot be assigned to an entity of type %t2
202	pointless comparison of unsigned integer with a negative constant
203	cannot convert to incomplete class %t
204	const object requires an initializer
205	object has an uninitialized const or reference member
206	nonstandard preprocessing directive
207	%n may not have a template argument list
208	initialization with "{...}" expected for aggregate object
209	pointer-to-member selection class types are incompatible (%t1 and %t2)
20A	pointless friend declaration
20B	"." used in place of "::" to form a qualified name
20C	non-const function called for const object (anachronism)
20D	a dependent statement may not be a declaration
20E	a parameter may not have void type
20F	instantiation of %na %p
210	processing of template argument list for %na %p
211	this operator is not allowed in a template argument expression
212	try block requires at least one handler
213	handler requires an exception declaration
214	handler is masked by default handler
215	handler is potentially masked by previous handler for type %t
216	use of a local type to specify an exception
217	redundant type in exception specification
218	exception specification is incompatible with that of previous %nd%s
219	previously specified: no exceptions will be thrown
21A	previously omitted: %t
21B	previously specified but omitted here: %t
21C	support for exception handling is disabled
21D	allowing all exceptions is incompatible with previous %nd
21E	could not create instantiation request file %sq
21F	non-arithmetic operation not allowed in nontype template argument
220	use of a local type to declare a nonlocal variable
221	use of a local type to declare a function
222	transfer of control bypasses initialization of:
223	%nd
224	transfer of control into an exception handler
225	%n is used before its value is set
226	%n was set but never used
227	%n cannot be defined in the current scope
228	exception specification is not allowed
229	external/internal linkage conflict for %nfd
22A	%nf will not be called for implicit or explicit conversions
22B	tag kind of %s is incompatible with template parameter of type %t
22C	function template for operator new(size_t) is not allowed
22D	
22E	pointer to member of type %t is not allowed
22F	ellipsis is not allowed in operator function parameter list
230	%no is reserved for future use as a keyword
231	invalid macro definition: %s
232	invalid macro undefinition: %s
233	
234	
235	IL file name must be specified if input is 
236	
237	
238	
239	
23A	error in debug option argument
23B	invalid option: %s
23C	back end requires name of IL file
23D	could not open IL file %s
23E	invalid number: %s
23F	incorrect host CPU id
240	invalid instantiation mode: %s
241	
242	invalid error limit: %s
243	
244	
245	
246	
247	
248	
249	virtual function tables can only be suppressed when compiling C++
24A	anachronism option can be used only when compiling C++
24B	instantiation mode option can be used only when compiling C++
24C	automatic instantiation mode can be used only when compiling C++
24D	implicit template inclusion mode can be used only when compiling C++
24E	exception handling option can be used only when compiling C++
24F	strict mode is incompatible with K&R mode
250	strict mode is incompatible with cfront mode
251	missing source file name
252	output files may not be specified when compiling several input files
253	too many arguments on command line
254	an output file was specified, but none is needed
255	IL display requires name of IL file
256	a template parameter may not have void type
257	excessive recursive instantiation of %n due to instantiate-all mode
258	strict mode is incompatible with allowing anachronisms
259	a throw expression may not have void type
25A	local instantiation mode is incompatible with automatic instantiation
25B	parameter of abstract class type %t is not allowed:
25C	array of abstract class %t is not allowed:
25D	floating-point template parameter is nonstandard
25E	this pragma must immediately precede a declaration
25F	this pragma must immediately precede a statement
260	this pragma must immediately precede a declaration or statement
261	this kind of pragma may not be used here
262	
263	overloaded virtual function %no1 is only partially overridden in %n2
264	specific definition of inline template function must precede its first use
265	invalid error tag in diagnostic control option: %s
266	invalid error number in diagnostic control option: %s
267	
268	
269	pointer-to-member-function cast to pointer to function
26A	struct or union declares no named members
26B	nonstandard unnamed field
26C	nonstandard unnamed member
26D	
26E	
26F	
270	%sq is not a type name
271	cannot open precompiled header input file %sq: %s2
272	precompiled header file %sq is either invalid or not generated by this version of the compiler
273	precompiled header file %sq was not generated in this directory
274	header files used to generate precompiled header file %sq have changed
275	the command line options do not match those used when precompiled header file %sq was created
276	the initial sequence of preprocessing directives is not compatible with those of precompiled header file %sq
277	unable to obtain mapped memory
278	"%s": using precompiled header file "%s"
279	"%s": creating precompiled header file "%s"
27A	memory usage conflict with precompiled header file %sq
27B	invalid PCH memory size: %s 
27C	PCH options must appear first in the command line
27D	insufficient memory for PCH memory allocation
27E	precompiled header files may not be used when compiling several input files
27F	insufficient preallocated memory for generation of precompiled header file (%s bytes required)
280	very large entity in program prevents generation of precompiled header file
281	%sq is not a valid directory
282	cannot build temporary file name
283	"restrict" is not allowed
284	a pointer or reference to function type may not be qualified by "restrict"
285	
286	a calling convention modifier may not be specified here
287	conflicting calling convention modifiers
288	strict mode is incompatible with Microsoft mode
289	cfront mode is incompatible with Microsoft mode
28A	calling convention specified here is ignored
28B	a calling convention may not be followed by a nested declarator
28C	calling convention is ignored for this type
28D	
28E	declaration modifiers are incompatible with previous declaration
28F	the modifier %sq is not allowed on this declaration
290	transfer of control into a try block
291	inline specification is incompatible with previous %nod
292	closing brace of template definition not found
293	wchar_t keyword option can be used only when compiling C++
294	invalid packing alignment value
295	expected an integer constant
296	call of pure virtual function
297	invalid source file identifier string
298	a class template cannot be defined in a friend declaration
299	"asm" is not allowed
29A	"asm" must be used with a function definition
29B	"asm" function is nonstandard
29C	ellipsis with no explicit parameters is nonstandard
29D	"&..." is nonstandard
29E	invalid use of "&..."
29F	
2A0	temporary used for initial value of reference to const volatile (anachronism)
2A1	a reference of type %t1 cannot be initialized with a value of type %t2
2A2	initial value of reference to const volatile must be an lvalue
2A3	SVR4 C compatibility option can be used only when compiling ANSI C
2A4	using out-of-scope declaration of %nd
2A5	strict mode is incompatible with SVR4 C mode
2A6	call of %nd cannot be inlined
2A7	%n cannot be inlined
2A8	invalid PCH directory: %s
2A9	expected __except or __finally
2AA	a __leave statement may only be used within a __try
2AB	detected during instantiation of %nt %p
2AC	detected during implicit generation of %nt %p
2AD	detected during instantiation of %na %p
2AE	detected during processing of template argument list for %na %p
2AF	detected during implicit definition of %nt %p
2B0	%sq not found on pack alignment stack
2B1	empty pack alignment stack
2B2	RTTI option can be used only when compiling C++
2B3	%nfd, required for copy that was eliminated, is inaccessible
2B4	%nf, required for copy that was eliminated, is not callable because reference parameter cannot be bound to rvalue
2B5	<typeinfo> must be included before typeid is used
2B6	%s cannot cast away const or other type qualifiers
2B7	the type in a dynamic_cast must be a pointer or reference to a complete class type, or void *
2B8	the operand of a pointer dynamic_cast must be a pointer to a complete class type
2B9	the operand of a reference dynamic_cast must be an lvalue of a complete class type
2BA	the operand of a runtime dynamic_cast must have a polymorphic class type
2BB	bool option can be used only when compiling C++
2BC	
2BD	an array type is not allowed here
2BE	expected an "="
2BF	
2C0	%sq, declared in condition, may not be redeclared in this scope
2C1	default template arguments are not allowed for function templates
2C2	expected a "," or ">"
2C3	expected a template parameter list
2C4	incrementing a bool value is deprecated
2C5	bool type is not allowed
2C6	offset of base class %no1 within class %no2 is too large
2C7	expression must have bool type (or be convertible to bool)
2C8	array new and delete option can be used only when compiling C++
2C9	%n is not a variable name
2CA	__based modifier is not allowed here
2CB	__based does not precede a pointer operator, __based ignored
2CC	variable in __based modifier must have pointer type
2CD	the type in a const_cast must be a pointer, reference, or pointer to member to an object type
2CE	a const_cast can only adjust type qualifiers; it cannot change the underlying type
2CF	mutable is not allowed
2D0	redeclaration of %n is not allowed to alter its access
2D1	
2D2	use of alternative token "<:" appears to be unintended
2D3	use of alternative token "%%:" appears to be unintended
2D4	namespace definition is not allowed
2D5	name must be a namespace name
2D6	namespace alias definition is not allowed
2D7	namespace-qualified name is required
2D8	a namespace name is not allowed
2D9	invalid combination of DLL attributes
2DA	%n is not a class template
2DB	array with incomplete element type is nonstandard
2DC	allocation operator may not be declared in a namespace
2DD	deallocation operator may not be declared in a namespace
2DE	%np1 conflicts with using-declaration of %np2
2DF	using-declaration of %np1 conflicts with %npd2
2E0	namespaces option can be used only when compiling C++
2E1	using-declaration ignored -- it refers to the current namespace
2E2	a class-qualified name is required
2E3	argument types are: (%s)
2E4	operand types are: %s
2E5	
2E6	%n has no actual member %sq
2E7	
2E8	incompatible memory attributes specified
2E9	memory attribute ignored
2EA	memory attribute may not be followed by a nested declarator
2EB	memory attribute specified more than once
2EC	calling convention specified more than once
2ED	a type qualifier is not allowed
2EE	%npd1 was used before its template was declared
2EF	static and nonstatic member functions with same parameter types cannot be overloaded
2F0	no prior declaration of %np
2F1	a template-id is not allowed
2F2	a class-qualified name is not allowed
2F3	%n may not be redeclared in the current scope
2F4	qualified name is not allowed in namespace member declaration
2F5	%n is not a type name
2F6	explicit instantiation is not allowed in the current scope
2F7	%n cannot be explicitly instantiated in the current scope
2F8	%n explicitly instantiated more than once
2F9	typename may only be used within a template
2FA	special_subscript_cost option can be used only when compiling C++
2FB	typename option can be used only when compiling C++
2FC	implicit typename option can be used only when compiling C++
2FD	nonstandard character at start of object-like macro definition
2FE	exception specification for virtual %n1 is incompatible with that of overridden %n2
2FF	conversion from pointer to smaller integer
300	exception specification for implicitly declared virtual %n1 is incompatible with that of overridden %n2
301	%no1, implicitly called from %np2, is ambiguous
302	option "explicit" can be used only when compiling C++
303	"explicit" is not allowed
304	declaration conflicts with %sq (reserved class name)
305	only "()" is allowed as initializer for array %n
306	"virtual" is not allowed in a function template declaration
307	invalid anonymous union -- class member template is not allowed
308	template nesting depth does not match the previous declaration of %n
309	this declaration cannot have multiple "template <...>" clauses
30A	option to control the for-init scope can be used only when compiling C++
30B	%sq, declared in for-loop initialization, may not be redeclared in this scope
30C	reference is to %nd1 -- under old for-init scoping rules it would have been %nd2
30D	option to control warnings on for-init differences can be used only when compiling C++
30E	definition of virtual %n is required here
30F	empty comment interpreted as token-pasting operator "##"
310	a storage class is not allowed in a friend declaration
311	template parameter list for %no is not allowed in this declaration
312	%n is not a valid class member template
313	not a valid member class or function template declaration
314	a template declaration containing a template parameter list may not be followed by an explicit specialization declaration
315	explicit specialization of %n1 must precede the first use of %n2
316	explicit specialization is not allowed in the current scope
317	partial specialization of %n is not allowed
318	%nf is not an entity that can be explicitly specialized
319	explicit specialization of %n must precede its first use
31A	template parameter %sq may not be used in an elaborated type specifier
31B	specializing %n requires "template<>" syntax
31C	
31D	
31E	option "old_specializations" can be used only when compiling C++
31F	specializing %n without "template<>" syntax is nonstandard
320	this declaration may not have extern "C" linkage
321	%sq is not a class or function template name in the current scope
322	specifying a default argument when redeclaring an unreferenced function template is nonstandard
323	specifying a default argument when redeclaring an already referenced function template is not allowed
324	cannot convert pointer to member of base class %t2 to pointer to member of derived class %t1 -- base class is virtual
325	exception specification is incompatible with that of %nd%s
326	allowing all exceptions is incompatible with %nd
327	unexpected end of default argument expression
328	default-initialization of reference is not allowed
329	uninitialized %n has a const member
32A	uninitialized base class %t has a const member
32B	const %n requires an initializer -- class %t has no user-provided default constructor
32C	const object requires an initializer -- class %t has no user-provided default constructor
32D	option "implicit_extern_c_type_conversion" can be used only when compiling C++
32E	strict mode is incompatible with long preserving rules
32F	type qualifier on return type is meaningless
330	in a function definition a type qualifier on a "void" return type is not allowed
331	static data member declaration is not allowed in this class
332	template instantiation resulted in an invalid function declaration
333	"..." is not allowed
334	option "extern_inline" can be used only when compiling C++
335	extern inline %n was referenced but not defined
336	invalid destructor name for type %t
337	
338	destructor reference is ambiguous -- both %n1 and %n2 could be used
339	virtual inline %n was never defined
33A	%n was never referenced
33B	only one member of a union may be specified in a constructor initializer list
33C	support for "new[]" and "delete[]" is disabled
33D	"double" used for "long double" in generated C code
33E	%n has no corresponding operator delete%s (to be called if an exception is thrown during initialization of an allocated object)
33F	support for placement delete is disabled
340	no appropriate operator delete is visible
341	pointer or reference to incomplete type %t is not allowed
342	invalid partial specialization -- %n is already fully specialized
343	incompatible exception specifications
344	returning reference to local variable
345	omission of explicit type is nonstandard ("int" assumed)
346	more than one partial specialization matches the template argument list of %n
347	%nod
348	a template argument list is not allowed in a declaration of a primary template
349	partial specializations may not have default template arguments
34A	%n1 is not used in or cannot be deduced from the template argument list of %n2
34B	
34C	the template argument list of the partial specialization includes a nontype argument whose type depends on a template parameter
34D	this partial specialization would have been used to instantiate %n
34E	this partial specialization would have made the instantiation of %n ambiguous
34F	expression must have integral or enum type
350	expression must have arithmetic or enum type
351	expression must have arithmetic, enum, or pointer type
352	type of cast must be integral or enum
353	type of cast must be arithmetic, enum, or pointer
354	expression must be a pointer to a complete object type
355	
356	
357	return type is not identical to return type %t of overridden virtual function %no
358	option "guiding_decls" can be used only when compiling C++
359	a partial specialization of a class template must be declared in the namespace of which it is a member
35A	%n is a pure virtual function
35B	pure virtual %n has no overrider
35C	__declspec attributes ignored
35D	invalid character in input line
35E	function returns incomplete type %t
35F	effect of this "#pragma pack" directive is local to %n
360	%s is not a template
361	a friend declaration may not declare a partial specialization
362	exception specification ignored
363	declaration of "size_t" does not match the expected type %t
364	space required between adjacent ">" delimiters of nested template argument lists (">>" is the right shift operator)
365	could not set locale %sq to allow processing of multibyte characters
366	invalid multibyte character sequence
367	template instantiation resulted in unexpected function type of %t1 (the meaning of a name may have changed since the template declaration -- the type of the template is %t2)
368	ambiguous guiding declaration -- more than one function template %no matches type %t
369	non-integral operation not allowed in nontype template argument
36A	option "embedded_c++" can be used only when compiling C++
36B	Embedded C++ does not support templates
36C	Embedded C++ does not support exception handling
36D	Embedded C++ does not support namespaces
36E	Embedded C++ does not support run-time type information
36F	Embedded C++ does not support the new cast syntax
370	Embedded C++ does not support using-declarations
371	Embedded C++ does not support "mutable"
372	Embedded C++ does not support multiple or virtual inheritance
373	invalid Microsoft version number: %s
374	pointer-to-member representation %sq has already been set for %n
375	%t1 cannot be used to designate constructor for %t2
376	invalid suffix on integral constant
377	operand of __uuidof must have a class or enum type for which __declspec(uuid("...")) has been specified
378	invalid GUID string in __declspec(uuid("..."))
379	option "vla" can be used only when compiling C
37A	variable length array with unspecified bound is not allowed
37B	an explicit template argument list is not allowed on this declaration
37C	an entity with linkage cannot have a type involving a variable length array
37D	a variable length array cannot have static storage duration
37E	%n is not a template
37F	variable length array dimension (declared %p)
380	expected a template argument
381	
382	nonmember operator requires a parameter with class or enum type
383	option "enum_overloading" can be used only when compiling C++
384	
385	qualifier of destructor name %t1 does not match type %t2
386	type qualifier ignored
387	option "nonstd_qualifier_deduction" can be used only when compiling C++
388	a function declared "dllimport" may not be defined
389	incorrect property specification; correct form is __declspec(property(get=name1,put=name2))
38A	property has already been specified
38B	__declspec(property) is not allowed on this declaration
38C	member is declared with __declspec(property), but no "get" function was specified
38D	the __declspec(property) "get" function %sq is missing
38E	member is declared with __declspec(property), but no "put" function was specified
38F	the __declspec(property) "put" function %sq is missing
390	ambiguous class member reference -- %nd1 used in preference to %nd2
391	
392	
393	
394	cannot convert pointer to member of derived class %t1 to pointer to member of base class %t2 -- base class is virtual
395	invalid directory for instantiation files: %s
396	option "one_instantiation_per_object" can be used only when compiling C++
397	
398	
399	an instantiation information file name may not be specified when compiling several input files
39A	option "one_instantiation_per_object" may not be used when compiling several input files
39B	more than one command line option matches the abbreviation "--%s":
39C	--%s
39D	type qualifiers on function types are ignored
39E	
39F	late/early tiebreaker option can be used only when compiling C++
3A0	incorrect use of va_start
3A1	incorrect use of va_arg
3A2	incorrect use of va_end
3A3	pending instantiations option can be used only when compiling C++
3A4	invalid directory for #import files: %s
3A5	an import directory can be specified only in Microsoft mode
3A6	a member with reference type is not allowed in a union
3A7	"typedef" may not be specified here
3A8	redeclaration of %n alters its access
3A9	a class or namespace qualified name is required
3AA	return type "int" omitted in declaration of function "main"
3AB	pointer-to-member representation %sq is too restrictive for %n
3AC	missing return statement at end of non-void %n
3AD	duplicate using-declaration of %no ignored
3AE	enum bit fields are always unsigned, but enum %t includes negative enumerator
3AF	option "class_name_injection" can be used only when compiling C++
3B0	option "arg_dep_lookup" can be used only when compiling C++
3B1	option "friend_injection" can be used only when compiling C++
3B2	name following "template" must be a template
3B3	
3B4	nonstandard local-class friend declaration -- no prior declaration in the enclosing scope
3B5	specifying a default argument on this declaration is nonstandard
3B6	option "nonstd_using_decl" can be used only when compiling C++
3B7	return type of function "main" must be "int"
3B8	a nontype template parameter may not have class type
3B9	a default template argument cannot be specified on the definition of a member of a class template outside the template
3BA	a return statement is not allowed in a handler of a function try block of a constructor
3BB	ordinary and extended designators cannot be combined in an initializer designation
3BC	the second subscript must not be smaller than the first
3BD	
3BE	option "extended_designators" can be used only when compiling C
3BF	declared size for bit field is larger than the size of the bit field type; truncated to %s bits
3C0	type used as constructor name does not match type %t
3C1	use of a type with no linkage to declare a variable with linkage
3C2	use of a type with no linkage to declare a function
3C3	return type may not be specified on a constructor
3C4	return type may not be specified on a destructor
3C5	incorrectly formed universal character name
3C6	universal character name specifies an invalid character
3C7	a universal character name cannot designate a character in the basic character set
3C8	this universal character is not allowed in an identifier
3C9	the identifier __VA_ARGS__ can only appear in the replacement lists of variadic macros
3CA	the qualifier on this friend declaration is ignored
3CB	array range designators cannot be applied to dynamic initializers
3CC	property name cannot appear here
3CD	"inline" used as a function qualifier is ignored
3CE	option "compound_literals" can be used only when compiling C
3CF	a variable-length array type is not allowed
3D0	a compound literal is not allowed in an integral constant expression
3D1	a compound literal of type %t is not allowed
3D2	a template friend declaration cannot be declared in a local class
3D3	ambiguous "?" operation: second operand of type %t1 can be converted to third operand type %t2, and vice versa
3D4	call of an object of a class type without appropriate operator() or conversion functions to pointer-to-function type
3D5	surrogate function from conversion %np
3D6	there is more than one way an object of type %t can be called for the argument list:
3D7	typedef name has already been declared (with similar type)
3D8	operator new and operator delete cannot be given internal linkage
3D9	storage class "mutable" is not allowed for anonymous unions
3DA	invalid precompiled header file
3DB	abstract class type %t is not allowed as catch type:
3DC	a qualified function type cannot be used to declare a nonmember function or a static member function
3DD	a qualified function type cannot be used to declare a parameter
3DE	cannot create a pointer or reference to qualified function type
3DF	extra braces are nonstandard
3E0	invalid macro definition: %s
3E1	subtraction of pointer types %t1 and %t2 is nonstandard
3E2	an empty template parameter list is not allowed in a template template parameter declaration
3E3	expected "class"
3E4	the "struct" keyword may not be used when declaring a template template parameter
3E5	%np2 is hidden by %no1 -- virtual function override intended?
3E6	a qualified name is not allowed for a friend declaration that is a function definition
3E7	%n1 is not compatible with %n2
3E8	a storage class may not be specified here
3E9	class member designated by a using-declaration must be visible in a direct base class
3EA	
3EB	Sun mode is incompatible with cfront mode
3EC	strict mode is incompatible with Sun mode
3ED	Sun mode is only allowed when compiling C++
3EE	a template template parameter cannot have the same name as one of its template parameters
3EF	recursive instantiation of default argument
3F0	
3F1	%n is not an entity that can be defined
3F2	destructor name must be qualified
3F3	friend class name may not be introduced with "typename"
3F4	a using-declaration may not name a constructor or destructor
3F5	a qualified friend template declaration must refer to a specific previously declared template
3F6	invalid specifier in class template declaration
3F7	argument is incompatible with formal parameter
3F8	option "dep_name" can be used only when compiling C++
3F9	loop in sequence of "operator->" functions starting at class %t1
3FA	%n has no member class %sq
3FB	the global scope has no class named %sq
3FC	recursive instantiation of template default argument
3FD	access declarations and using-declarations cannot appear in unions
3FE	%no is not a class member
3FF	nonstandard member constant declaration is not allowed
400	option "ignore_std" can be used only when compiling C++
401	option "parse_templates" can be used only when compiling C++
402	option "dep_name" cannot be used with "no_parse_templates"
403	language modes specified are incompatible
404	invalid redeclaration of nested class
405	type containing an unknown-size array is not allowed
406	a variable with static storage duration cannot be defined within an inline function
407	an entity with internal linkage cannot be referenced within an inline function with external linkage
408	argument type %t does not match this type-generic function macro
409	variable length array %nod
40A	friend declaration cannot add default arguments to previous declaration
40B	%n cannot be declared in this scope
40C	the reserved identifier %sq may only be used inside a function
40D	this universal character cannot begin an identifier
40E	expected a string literal
40F	unrecognized STDC pragma
410	expected "ON", "OFF", or "DEFAULT"
411	a STDC pragma may only appear between declarations in the global scope or before any statements or declarations in a block scope
412	incorrect use of va_copy
413	%s can only be used with floating-point types
414	complex type is not allowed
415	invalid designator kind
416	floating-point value cannot be represented exactly
417	complex floating-point operation result is out of range
418	conversion between real and imaginary yields zero
419	an initializer cannot be specified for a flexible array member
41A	imaginary *= imaginary sets the left-hand operand to zero
41B	standard requires that %n be given a type by a subsequent declaration ("int" assumed)
41C	a definition is required for inline %n
41D	conversion from integer to smaller pointer
41E	a floating-point type must be included in the type specifier for a _Complex or _Imaginary type
41F	types cannot be declared in anonymous unions
420	returning pointer to local variable
421	returning pointer to local temporary
422	option "export" can be used only when compiling C++
423	option "export" cannot be used with "no_dep_name"
424	option "export" cannot be used with "implicit_include"
425	declaration of %n is incompatible with a declaration in another translation unit
426	the other declaration is %p
427	detected during compilation of secondary translation unit %sq
428	compilation of secondary translation unit %sq
429	a field declaration cannot have a type involving a variable length array
42A	declaration of %n had a different meaning during compilation of %sq
42B	expected "template"
42C	"export" cannot be used on an explicit instantiation
42D	"export" cannot be used on this declaration
42E	a member of an unnamed namespace cannot be declared "export"
42F	a template cannot be declared "export" after it has been defined
430	a declaration cannot have a label
431	support for exported templates is disabled
432	
433	%n already defined during compilation of %sq
434	%n already defined in another translation unit
435	a nonstatic local variable may not be used in a __based specification
436	the option to list makefile dependencies may not be specified when compiling more than one translation unit
437	
438	the option to generate preprocessed output may not be specified when compiling more than one translation unit
439	a field with the same name as its class cannot be declared in a class with a user-declared constructor
43A	"implicit_include" cannot be used when compiling more than one translation unit
43B	exported template file %sq is corrupted
43C	%n cannot be instantiated -- it has been explicitly specialized in the translation unit containing the exported definition
43D	object type is: %s
43E	the object has type qualifiers that are not compatible with the member %n
43F	no instance of %n matches the argument list and object (the object has type qualifiers that prevent a match)
440	an attribute specifies a mode incompatible with %t
441	there is no type with the width specified
442	invalid alignment value specified by attribute
443	invalid attribute for %t
444	
445	
446	attribute %sq does not take arguments
447	
448	expected an attribute name
449	unknown attribute %sq
44A	attributes may not appear here
44B	invalid argument to attribute %sq
44C	
44D	in "goto *expr", expr must have type "void *"
44E	"goto *expr" is nonstandard
44F	taking the address of a label is nonstandard
450	file name specified more than once: %s
451	#warning directive: %s
452	
453	the "transparent_union" attribute only applies to unions, and %t is not a union
454	the "transparent_union" attribute is ignored on incomplete types
455	%t cannot be transparent because %n does not have the same size as the first field
456	%t1 cannot be transparent because it has a field of type %t2 which is not the same size as the first field
457	
458	attribute %sq does not apply to local variables
459	attributes are not permitted in a function definition
45A	
45B	the second constant in a case range must be larger than the first
45C	an asm name is not permitted in a function definition
45D	an asm name is ignored in a typedef
45E	unknown register name "%s"
45F	
460	unknown asm constraint modifier '%s'
461	unknown asm constraint letter '%s'
462	asm operand has no constraint letter
463	an asm output operand must have one of the '=' or '+' modifiers
464	an asm input operand may not have the '=' or '+' modifiers
465	
466	
467	register "%s" used more than once
468	register "%s" is both used and clobbered
469	register "%s" clobbered more than once
46A	register "%s" has a fixed purpose and may not be used in an asm statement
46B	register "%s" has a fixed purpose and may not be clobbered in an asm statement
46C	an empty clobbers list must be omitted entirely
46D	expected an asm operand
46E	expected a register to clobber
46F	"format" attribute requires an ellipsis parameter
470	first substitution argument is not the first variable argument
471	format argument index is greater than number of parameters
472	format argument does not have string type
473	the "template" keyword used for syntactic disambiguation may only be used within a template
474	a debug option must be specified on the command-line for the db_opt pragma to be used
475	
476	attribute %sq does not apply to non-function type %t
477	arithmetic on pointer to void or function type
478	storage class must be auto or register
479	%t1 would have been promoted to %t2 when passed through the ellipsis parameter; use the latter type instead
47A	%sq is not a base class member
47B	__super cannot appear after "::"
47C	__super may only be used in a class scope
47D	__super must be followed by "::"
47E	[ %d instantiation contexts not shown ]
47F	mangled name is too long
480	declaration aliased to undefined entity %sq
481	declaration does not match its alias %n
482	entity declared as alias cannot have definition
483	variable-length array field type will be treated as zero-length array field type
484	nonstandard cast on lvalue ignored
485	unrecognized flag name: %s
486	void return type cannot be qualified
487	the auto specifier is ignored here (invalid in standard C/C++)
488	a reduction in alignment without the "packed" attribute is ignored
489	a member template corresponding to %no is declared as a template of a different kind in another translation unit
48A	excess initializers are ignored
48B	va_start can appear only in a function with an ellipsis parameter
48C	the "short_enums" option is only valid in GNU C and GNU C++ modes
48D	invalid export information file %sq1 at line number %s2
48E	statement expressions are only allowed in block scope
48F	from translation unit 
490	an asm name is ignored on a non-register automatic variable
491	
492	unrecognized UPC pragma
493	shared block size does not match one previously specified
494	bracketed expression is assumed to be a block size specification rather than an array dimension
495	the block size of a shared array must be greater than zero
496	multiple block sizes not allowed
497	strict or relaxed requires shared
498	THREADS not allowed in this context
499	block size specified exceeds the maximum value of %s
49A	function returning shared is not allowed
49B	
49C	one dimension of an array of a shared type must be a multiple of THREADS when the number of threads is nonconstant
49D	shared type inside a struct or union is not allowed
49E	parameters may not have shared types
49F	a dynamic THREADS dimension requires a definite block size
4A0	shared variables must be static or extern
4A1	argument of upc_blocksizeof is a pointer to a shared type (not shared type itself)
4A2	affinity expression ignored in nested upc_forall
4A3	branching into or out of a upc_forall loop is not allowed
4A4	affinity expression must have a shared type or point to a shared type
4A5	affinity has shared type (not pointer to shared)
4A6	shared void* types can only be compared for equality
4A7	UPC mode is incompatible with C++ and K&R modes
4A8	null (zero) character in input line ignored
4A9	null (zero) character in string or character constant
4AA	null (zero) character in header name
4AB	declaration in for-initializer hides a declaration in the surrounding scope
4AC	the hidden declaration is %p
4AD	the prototype declaration of %nfd is ignored after this unprototyped redeclaration
4AE	
4AF	%npd must have external C linkage
4B0	variable declaration hides declaration in for-initializer
4B1	typedef %sq may not be used in an elaborated type specifier
4B2	call of zero constant ignored
4B3	parameter %sq may not be redeclared in a catch clause of function try block
4B4	the initial explicit specialization of %n must be declared in the namespace containing the template
4B5	"cc" clobber ignored
4B6	"template" must be followed by an identifier
4B7	MYTHREAD not allowed in this context
4B8	layout qualifier cannot qualify pointer to shared
4B9	layout qualifier cannot qualify an incomplete array
4BA	declaration of %sq hides handler parameter
4BB	nonstandard cast to array type ignored
4BC	this pragma cannot be used in a _Pragma operator (a #pragma directive must be used)
4BD	field uses tail padding of a base class
4BE	GNU C++ compilers may use bit field padding
4BF	%n was declared deprecated
4C0	an asm name is not allowed on a nonstatic member declaration
4C1	unrecognized format function type %sq ignored
4C2	base class %no1 uses tail padding of base class %no2
4C3	the "init_priority" attribute can only be used for definitions of static data members and namespace scope variables of class types
4C4	requested initialization priority is reserved for internal use
4C5	this anonymous union/struct field is hidden by %nd
4C6	invalid error number
4C7	invalid error tag
4C8	expected an error number or error tag
4C9	size of class is affected by tail padding
4CA	labels can be referenced only in function definitions
4CB	transfer of control into a statement expression is not allowed
4CC	
4CD	this statement is not allowed inside of a statement expression
4CE	a class that is not trivially copyable cannot be defined inside a statement expression
4CF	
4D0	a dynamically-initialized local static variable is not allowed inside of a statement expression
4D1	a variable-length array is not allowed inside of a statement expression
4D2	a statement expression is not allowed inside of a default argument
4D3	nonstandard conversion between pointer to function and pointer to data
4D4	interface types cannot have virtual base classes
4D5	interface types cannot specify "private" or "protected"
4D6	interface types can only derive from other interface types
4D7	%t is an interface type
4D8	interface types cannot have typedef members
4D9	interface types cannot have user-declared constructors or destructors
4DA	interface types cannot have user-declared member operators
4DB	interface types cannot be declared in functions
4DC	
4DD	interface types cannot have data members
4DE	interface types cannot contain friend declarations
4DF	
4E0	interface types cannot be nested class types
4E1	interface types cannot have member templates
4E2	interface types cannot have static member functions
4E3	this pragma cannot be used in a __pragma operator (a #pragma directive must be used)
4E4	qualifier must be base class of %t
4E5	declaration must correspond to a pure virtual member function in the indicated base class
4E6	integer overflow in internal computation due to size or complexity of %t
4E7	integer overflow in internal computation
4E8	__w64 can only be specified on int, long, and pointer types
4E9	potentially narrowing conversion when compiled in an environment where int, long, or pointer types are 64 bits wide
4EA	current value of pragma pack is %s
4EB	arguments for pragma pack(show) are ignored
4EC	
4ED	
4EE	earlier __declspec(align(...)) ignored
4EF	expected an argument value for the %sq attribute parameter
4F0	invalid argument value for the %sq attribute parameter
4F1	expected a boolean value for the %sq attribute parameter
4F2	a positional argument cannot follow a named argument in an attribute
4F3	attribute %sq1 has no parameter named %sq2
4F4	expected an argument list for the %sq attribute
4F5	expected a "," or "]"
4F6	attribute argument %sq has already been given a value
4F7	a value cannot be assigned to the %sq attribute
4F8	a throw expression may not have pointer-to-incomplete type
4F9	alignment-of operator applied to incomplete type
4FA	%sq may only be used as a standalone attribute
4FB	%sq attribute cannot be used here
4FC	
4FD	attributes are not allowed here
4FE	invalid argument value for the %sq attribute parameter
4FF	too many attribute arguments
500	conversion from inaccessible base class %t is not allowed
501	option "export" requires distinct template signatures
502	string literals with different character kinds cannot be concatenated
503	GNU layout bug not emulated because it places virtual base %no1 outside %no2 object boundaries
504	virtual base %no1 placed outside %no2 object boundaries
505	nonstandard qualified name in namespace member declaration
506	reduction in alignment ignored
507	const qualifier ignored
508	
509	invalid GNU asm qualifiers
50A	a class type that is not trivially copyable passed through ellipsis
50B	a class type that cannot be trivially copied cannot be fetched by va_arg
50C	the 'u' or 'U' suffix must appear before the 'l' or 'L' suffix in a fixed-point literal
50D	option "fixed_point" can be used only when compiling C
50E	integer operand may cause fixed-point overflow
50F	fixed-point constant is out of range
510	fixed-point value cannot be represented exactly
511	constant is too large for long long; given unsigned long long type (nonstandard)
512	layout qualifier cannot qualify pointer to shared void
513	duplicate THREADS in multidimensional array type
514	a strong using-directive may only appear in a namespace scope
515	%nf declares a non-template function -- add <> to refer to a template instance
516	operation may cause fixed-point overflow
517	expression must have integral, enum, or fixed-point type
518	expression must have integral or fixed-point type
519	function declared with "noreturn" does return
51A	asm name ignored because it conflicts with a previous declaration
51B	class member typedef may not be redeclared
51C	taking the address of a temporary
51D	attributes are ignored on a class declaration that is not also a definition
51E	fixed-point value implicitly converted to floating-point type
51F	fixed-point types have no classification
520	a template parameter may not have fixed-point type
521	hexadecimal floating-point constants are not allowed
522	option "named_address_spaces" can be used only when compiling C
523	floating-point value does not fit in required fixed-point type
524	value cannot be converted to fixed-point value exactly
525	fixed-point conversion resulted in a change of sign
526	integer value does not fit in required fixed-point type
527	fixed-point operation result is out of range
528	multiple named address spaces
529	variable with automatic storage duration cannot be stored in a named address space
52A	type cannot be qualified with named address space
52B	function type cannot be qualified with named address space
52C	field type cannot be qualified with named address space
52D	fixed-point value does not fit in required floating-point type
52E	fixed-point value does not fit in required integer type
52F	value does not fit in required fixed-point type
530	option "named_registers" can be used only when compiling C
531	a named-register storage class is not allowed here
532	%nd redeclared with incompatible named-register storage class
533	named-register storage class cannot be specified for aliased variable
534	named-register storage specifier is already in use
535	option "embedded_c" cannot be combined with options to control individual Embedded C features
536	invalid EDG_BASE directory: %s
537	
538	invalid predefined macro entry at line %s: %s2
539	invalid macro mode name %sq
53A	incompatible redefinition of predefined macro %sq
53B	redeclaration of %nd is missing a named-register storage class
53C	named register is too small for the type of the variable
53D	arrays cannot be declared with named-register storage class
53E	const_cast to enum type is nonstandard
53F	option "embedded_c" can be used only when compiling C
540	a named address space qualifier is not allowed here
541	an empty initializer is invalid for an array with unspecified bound
542	function returns incomplete class type %t
543	%n has already been initialized; the out-of-class initializer will be ignored
544	declaration hides %nd
545	a parameter cannot be allocated in a named address space
546	invalid suffix on fixed-point or floating-point constant
547	a register variable cannot be allocated in a named address space
548	expected "SAT" or "DEFAULT"
549	%n has no corresponding member operator delete%s (to be called if an exception is thrown during initialization of an allocated object)
54A	a thread-local variable cannot be declared with "dllimport" or "dllexport"
54B	a function return type cannot be qualified with a named address space
54C	an initializer cannot be specified for a flexible array member whose elements have a nontrivial destructor
54D	an initializer cannot be specified for an indirect flexible array member
54E	invalid GNU version number: %s
54F	variable attributes appearing after a parenthesized initializer are ignored
550	the result of this cast cannot be used as an lvalue
551	negation of an unsigned fixed-point value
552	
553	
554	register names can only be used for register variables
555	named-register variables cannot have void type
556	
557	parameters cannot have link scope specifiers
558	multiple link scope specifiers
559	link scope specifiers can only appear on functions and variables with external linkage
55A	a redeclaration cannot weaken a link scope
55B	link scope specifier not allowed on this declaration
55C	nonstandard qualified name in global scope declaration
55D	implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
55E	explicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
55F	conversion from pointer to same-sized integral type (potential portability problem)
560	
561	friend specifier is not allowed in a class definition; friend specifier is ignored
562	only static and extern variables can use thread-local storage
563	multiple thread-local storage specifiers
564	virtual %n was not defined (and cannot be defined elsewhere because it is a member of an unnamed namespace)
565	carriage return character in source line outside of comment or character/string literal
566	expression must have fixed-point type
567	invalid use of access specifier is ignored
568	pointer converted to bool
569	pointer-to-member converted to bool
56A	storage specifier ignored
56B	dllexport and dllimport are ignored on class templates
56C	base class dllexport/dllimport specification differs from that of the derived class
56D	redeclaration cannot add dllexport/dllimport to %nod
56E	dllexport/dllimport conflict with %nod; dllexport assumed
56F	cannot define dllimport entity
570	dllexport/dllimport requires external linkage
571	a member of a class declared with dllexport/dllimport cannot itself be declared with such a specifier
572	field of class type without a DLL interface used in a class with a DLL interface
573	parenthesized member declaration is nonstandard
574	white space between backslash and newline in line splice ignored
575	dllexport/dllimport conflict with %nod; dllimport/dllexport dropped
576	invalid member for anonymous member class -- class %t has a disallowed member function
577	nonstandard reinterpret_cast
578	positional format specifier cannot be zero
579	a local class cannot reference a variable-length array type from an enclosing function
57A	member %nd already has an explicit dllexport/dllimport specifier
57B	a variable-length array is not allowed in a function return type
57C	variable-length array type is not allowed in pointer to member of type %t
57D	the result of a statement expression cannot have a type involving a variable-length array
57E	support for trigraphs is disabled
57F	the %sq attribute can only appear on functions and variables with external linkage
580	strict mode is incompatible with treating namespace std as an alias for the global namespace
581	in expansion of macro "%s" %p
582	<UNKNOWN>
583	
584	[ %d macro expansions not shown ]
585	in macro expansion at %p
586	invalid symbolic operand name %sq
587	a symbolic match constraint must refer to one of the first ten operands
588	use of __if_exists is not supported in this context
589	__if_exists block not closed in the same scope in which it was opened
58A	thread-local variable cannot be dynamically initialized
58B	conversion drops "__unaligned" qualifier
58C	some enumerator values cannot be represented by the integral type underlying the enum type
58D	default argument is not allowed on a friend class template declaration
58E	multicharacter character literal (potential portability problem)
58F	expected a class, struct, or union type
590	second operand of offsetof must be a field
591	second operand of offsetof may not be a bit field
592	cannot apply offsetof to a member of a virtual base
593	offsetof applied to a type other than a standard-layout class
594	default arguments are not allowed on a friend declaration of a member function
595	default arguments are not allowed on friend declarations that are not definitions
596	redeclaration of %nd previously declared as a friend with default arguments is not allowed
597	invalid qualifier for %t (a derived class is not allowed here)
598	invalid qualifier for definition of class %t
599	no prior push_macro for %sq
59A	wide string literal not allowed
59B	
59C	%sq is only allowed in C
59D	__ptr32 and __ptr64 must follow a "*"
59E	__ptr32 and __ptr64 cannot both apply
59F	template argument list of %sq must match the parameter list
5A0	an incomplete class type is not allowed
5A1	complex integral types are not supported
5A2	__real and __imag can only be applied to complex values
5A3	__real/__imag applied to real value
5A4	%n was declared deprecated (%sq)
5A5	
5A6	dllimport/dllexport applied to a member of an unnamed namespace
5A7	__thiscall can only appear on nonstatic member function declarations
5A8	__thiscall not allowed on function with ellipsis parameter
5A9	explicit specialization of %n must precede its first use (%p)
5AA	a sealed class type cannot be used as a base class
5AB	duplicate class modifier
5AC	a member function cannot have both the "abstract" and "sealed" modifiers
5AD	a sealed member cannot be pure virtual
5AE	nonvirtual function cannot be declared with "abstract" or "sealed" modifier
5AF	member function declared with "override" does not override a base class member
5B0	cannot override sealed %nd
5B1	%nd was declared with the class modifier "abstract"
5B2	at line 
5B3	 of 
5B4	with 
5B5	keyword
5B6	macro
5B7	label
5B8	template parameter
5B9	type
5BA	union
5BB	class
5BC	struct
5BD	template template parameter
5BE	template
5BF	class template
5C0	enum
5C1	parameter
5C2	handler parameter
5C3	variable
5C4	nontype
5C5	constant
5C6	function
5C7	overloaded function
5C8	member
5C9	field
5CA	namespace
5CB	named register
5CC	named address space
5CD	function template
5CE	based on template argument
5CF	based on template arguments
5D0	 (declared 
5D1	(at end of source)
5D2	At end of source
5D3	Line
5D4	line
5D5	col.
5D6	remark
5D7	Remark
5D8	warning
5D9	Warning
5DA	error
5DB	Error
5DC	catastrophic error
5DD	Catastrophic error
5DE	command-line error
5DF	Command-line error
5E0	internal error
5E1	Internal error
5E2	-D
5E3	
5E4	Error limit reached.
5E5	Internal error loop
5E6	Loop in catastrophic error processing.
5E7	
5E8	temporary
5E9	preprocessing output
5EA	raw listing
5EB	cross-reference
5EC	intermediate language (1)
5ED	intermediate language (2)
5EE	intermediate language (3)
5EF	intermediate language (4)
5F0	intermediate language (5)
5F1	intermediate language (6)
5F2	intermediate language (7)
5F3	intermediate language (8)
5F4	intermediate language (9)
5F5	PCH
5F6	
5F7	
5F8	
5F9	
5FA	missing cannot-redefine flag
5FB	missing mode after ','
5FC	missing macro name
5FD	invalid cannot-redefine value
5FE	duplicate function modifier
5FF	invalid character for char16_t literal
600	
601	unrecognized calling convention %s, must be one of:
602	%s
603	
604	
605	underlying type of enum type must be an integral type
606	some enumerator constants cannot be represented by %t
607	%sq not allowed in current mode
608	type traits helpers option can be used only when compiling C++
609	attribute "sentinel" requires an ellipsis parameter
60A	argument must be a constant null pointer value
60B	insufficient number of arguments for sentinel value
60C	sentinel argument must correspond to an ellipsis parameter
60D	__declspec(implementation_key(...) can appear only between #pragma start_map_region and #pragma stop_map_region
60E	#pragma start_map_region already active: pragma ignored
60F	no #pragma start_map_region is currently active: pragma ignored
610	%n cannot be used to name a destructor (a type name is required)
611	nonstandard empty wide character literal treated as L'\0'
612	"typename" may not be specified here
613	a non-placement operator delete must be visible in a class with a virtual destructor
614	name linkage conflicts with previous declaration of %nd
615	alias creates cycle of aliased entities
616	
617	a variable with static storage duration allocated in a specific register cannot be declared with an initializer
618	a variable allocated in a specific register must be trivially copyable
619	predefined meaning of %no discarded
61A	
61B	class type not suitable for use with designators
61C	
61D	anonymous union qualifier is nonstandard
61E	anonymous union qualifier is ignored
61F	
620	__declspec(%s) ignored (it has no meaning for a C struct)
621	specifiers after comma between declarations are nonstandard
622	nonstandard specifier ignored
623	attributes are ignored on an enum declaration that is not also a definition
624	declaring a reference with "mutable" is nonstandard
625	a condition declaration for an array is always true
626	static assertion failed with %sq
627	visibility attribute ignored because it conflicts with a previous declaration
628	field name resolves to more than one offset -- see %nod1 and %nod2
629	%sq is not a field name
62A	case label value has already appeared in this switch %p
62B	a member function cannot have internal linkage
62C	declaration hides built-in %n
62D	declaration overloads built-in %n
62E	the option to list macro definitions may not be specified when compiling more than one translation unit
62F	unexpected parenthesis after declaration of %n (malformed parameter list or invalid initializer?)
630	parentheses around a string initializer are nonstandard
631	__interface
632	a variable declared with an auto type specifier cannot appear in its own initializer
633	cannot deduce "auto" type
634	initialization with "{...}" is not allowed for "auto" type
635	"auto" type cannot appear in top-level array type
636	"auto" type cannot appear in top-level function type
637	a member of type %t cannot have an in-class initializer
638	a member with an in-class initializer must be const
639	cannot deduce "auto" type (initializer required)
63A	"auto" type is %t1 for this entity, but was previously implied to be %t2
63B	invalid constructor declaration
63C	invalid use of a type qualifier
63D	a union cannot be abstract or sealed
63E	"auto" is not allowed here
63F	definition of base class type not completed yet
640	"extern template" cannot refer to a specialization of static %nd
641	"extern template" cannot follow explicit instantiation of %n
642	__declspec(restrict) requires a function returning a pointer type
643	the "report_gnu_extensions" option is only valid in GNU C and GNU C++ modes
644	variable-length array types are nonstandard
645	designators are nonstandard
646	this designator syntax is a GNU extension
647	compound literals are nonstandard
648	statement expressions are a GNU extension
649	asm name ignored for previously defined entity
64A	attributes are a GNU extension
64B	extended asm syntax is a GNU feature
64C	volatile asm declarations are a GNU extension
64D	asm name specifiers are a GNU extension
64E	the "__restrict" qualifier is nonstandard
64F	"typeof" is a GNU extension
650	modifying the size or signedness of a typedef is nonstandard
651	zero-length arrays are a GNU extension
652	flexible array members are nonstandard
653	attribute "nonnull" references nonpointer parameter
654	argument for attribute "nonnull" is larger than number of parameters
655	no parameter has pointer type
656	null argument provided for parameter marked with attribute "nonnull"
657	the destructor for %t1 has been suppressed because the destructor for %t2 is inaccessible
658	the suppressed destructor for %t is needed
659	routine is both "inline" and "noinline"
65A	invalid cleanup routine
65B	attribute "cleanup" requires automatic storage duration
65C	attribute "cleanup" does not apply to parameters
65D	cleanup routine has invalid type
65E	call of cleanup routine requires suspect conversion
65F	__sptr and __uptr must follow a "*"
660	__sptr and __uptr cannot both be specified
661	widening pointer conversion from %t1 to %t2 extends sign bit
662	__sptr and __uptr don't apply to pointer-to-member types
663	the declaration of the copy assignment operator for %t has been suppressed because %n is const
664	the declaration of the copy assignment operator for %t has been suppressed because %n has reference type
665	the declaration of the copy assignment operator for %t1 has been suppressed because that of %t2 was suppressed
666	the declaration of the copy assignment operator for %t1 has been suppressed because that of %t2 is ambiguous
667	the declaration of the copy assignment operator for %t1 has been suppressed because that of %t2 is inaccessible
668	the declaration of the copy constructor for %t1 has been suppressed because that of %t2 was suppressed
669	the declaration of the copy constructor for %t1 has been suppressed because that of %t2 is ambiguous
66A	the declaration of the copy constructor for %t1 has been suppressed because that of %t2 is inaccessible
66B	the destructor for %t1 will not be called because it is inaccessible and the destructor for %t2 was suppressed
66C	definition at end of file not followed by a semicolon or a declarator
66D	first argument must be a pointer to integer or enum type
66E	synchronized operations are valid only on objects of size 1, 2, 4, or 8
66F	extra arguments ignored
670	'=' assumed following macro name %sq in command-line definition
671	white space is required between the macro name %sq and its replacement text
672	result of call is not used
673	attribute "warn_unused_result" is ignored for void return type
674	
675	dllimport/dllexport is ignored on redeclaration using a qualified name
676	too many characters in character literal -- extra leading characters ignored
677	%n cannot be declared inline after its definition %p
678	
679	
67A	a template argument may not reference a type with no name linkage
67B	"virtual" is ignored here
67C	a template argument may not reference a variable-length array type
67D	a universal character name cannot designate a surrogate code point
67E	#include_next cannot be used in the primary source file
67F	%no1 cannot be specified in a template member definition -- %no2 assumed instead
680	attribute %sq is ignored on local function declaration
681	concatenation with %sq in %n does not create a valid token
682	%no is ambiguous (%n2 assumed)
683	a type qualifier is not allowed on a static member function
684	a type qualifier is not allowed on a constructor or destructor
685	a type qualifier is not allowed on operator new or operator delete
686	a type qualifier is not allowed on a nonmember function
687	argument to %s has side-effects but is unevaluated
688	unrecognized Unicode source kind (must be one of UTF-8, UTF-16, UTF-16LE, UTF-16BE): %s
689	Unicode character with hex value %s not representable in preprocessing output
68A	requested constructor/destructor priority is reserved for internal use
68B	unrecognized GCC pragma
68C	unrecognized GCC visibility pragma directive
68D	unrecognized visibility kind
68E	visibility pragma was still active
68F	no matching visibility push
690	typeid of incomplete type
691	
692	array %n assumed to have one element
693	vector_size attribute requires an arithmetic or enum type
694	vector size is too large
695	the number of elements in a vector must be a power of two
696	vector size must be a multiple of the element size
697	mixed vector-scalar operation not allowed
698	operation requires two vectors of the same size
699	template-dependent vector size is not allowed
69A	
69B	
69C	vector_size attribute is not allowed with a complex element type
69D	
69E	vector operation requires identical element types
69F	vector operation does not apply to vector with non-integral type
6A0	cannot open %s file %sq2
6A1	cannot open %s file %sq2: %s3
6A2	precompiled header
6A3	predefined macro
6A4	generated C
6A5	generated C++
6A6	source
6A7	error while writing %s file: %s2
6A8	not a regular file
6A9	is a directory
6AA	invalid file name
6AB	definition list
6AC	instantiation request
6AD	exported template
6AE	export information
6AF	template information
6B0	IL output
6B1	conversion drops "__restrict" qualifier
6B2	unable to obtain mapped memory for %sq: %s2
6B3	restrict qualifier is ignored
6B4	
6B5	array of elements containing a flexible array member is nonstandard
6B6	a template parameter may not have a vector type
6B7	the initialization of %n1 will be done before that of %n2
6B8	
6B9	inheritance kind is ignored on an enum specifier
6BA	
6BB	modifier is ignored on an enum specifier
6BC	identifier character cannot be represented in Unicode
6BD	header name contains characters that cannot be represented in Unicode
6BE	%sq is not a valid locale name
6BF	declaring a void parameter list with a template parameter is nonstandard
6C0	lambdas option can be used only when compiling C++
6C1	explicit capture matches default
6C2	%n is not a variable
6C3	a variable with static storage duration cannot be captured in a lambda
6C4	"this" cannot be captured by reference
6C5	"this" cannot be used inside the body of this lambda
6C6	a member of an outer-scope anonymous union cannot be referenced inside the body of a lambda
6C7	an enclosing-function local variable cannot be referenced in a lambda body unless it is in the capture list
6C8	invalid reference to an outer-scope local variable in a lambda body
6C9	a local variable outside the current function scope cannot be captured
6CA	the enclosing-function "this" cannot be referenced in a lambda body unless it is in the capture list
6CB	
6CC	lambda captured variable of type %t1 cannot be copied to closure class field of type %t2
6CD	invalid template directory: %s
6CE	error
6CF	errors
6D0	catastrophic error
6D1	catastrophic errors
6D2	and
6D3	detected in the compilation of "%s".
6D4	detected in this compilation.
6D5	enumeration value is outside the range of its underlying type (%t)
6D6	"\" followed by white space is not a line splice
6D7	this dynamic_cast cannot be done without runtime type information, which is disabled
6D8	conversion to %t is ambiguous; direct base selected
6D9	an internal buffer would be too large
6DA	C++ exception handler used, but exception handling semantics have not been specified
6DB	type qualifier ignored on constructor
6DC	a variable captured by a lambda cannot have a type involving a variable-length array
6DD	conversion between incompatible vector types
6DE	expected a "{" introducing a lambda body
6DF	rvalue references option can be used only when compiling C++
6E0	a type qualifier is not allowed on a lambda
6E1	a name cannot appear more than once in a capture-list
6E2	explicit template arguments ignored
6E3	a lambda is not allowed in a constant expression
6E4	%t is not a class type
6E5	"delete" applied to a pointer-to-array type treated as delete[]
6E6	"delete" applied to a pointer-to-array type is nonstandard; treated as delete[]
6E7	%n cannot be called with the given argument list
6E8	an rvalue reference cannot be bound to an lvalue
6E9	a nontype template parameter cannot have rvalue reference type
6EA	type qualifiers are ignored (underlying type is a reference)
6EB	%n, declared using a local type, must be defined in this translation unit
6EC	%n, declared using a type with no linkage, must be defined in this translation unit
6ED	the operand of an rvalue reference dynamic_cast must have a complete class type
6EE	"= default" can only appear on default constructors, copy/move constructors, copy/move assignment operators, and destructors
6EF	"= delete" can only appear on the first declaration of a function
6F0	%npd cannot be referenced -- it is a deleted function
6F1	a lambda is not allowed in an unevaluated expression
6F2	__builtin_va_arg_pack/__builtin_va_arg_pack_len can appear only in an inline function with an ellipsis parameter
6F3	"= default" cannot be specified on a friend declaration
6F4	expected a C++ keyword
6F5	
6F6	offset is not constant
6F7	unrecognized #pragma comment type %sq
6F8	option to control whether "auto" is a type specifier can be used only when compiling C++
6F9	option to control whether "auto" is a storage class can be used only when compiling C++
6FA	the type specifier and storage class specifier meanings of "auto" cannot both be disabled
6FB	invalid string in #pragma comment
6FC	deleted function overrides nondeleted %n
6FD	nondeleted function overrides deleted %n
6FE	the default constructor of %t cannot be referenced -- it is a deleted function
6FF	an rvalue reference is not allowed as a catch type
700	default arguments of %n is incompatible with a declaration in another translation unit
701	default arguments of %n were different during compilation of %sq
702	
703	initializer for %n is different in another translation unit
704	initializer for %n was different during compilation of %sq
705	a designator into a template-dependent type is not allowed
706	unrecognized conformance kind
707	expected "on" or "off"
708	#pragma conform(forScope) stack is empty
709	no previous #pragma conform(forScope) entry matches %sq
70A	forScope behavior is nonstandard
70B	forScope behavior is standard
70C	function "main" cannot be deleted
70D	type qualifiers are meaningless here
70E	invalid type for defaulted assignment operator
70F	function templates cannot be defaulted
710	invalid type for defaulted constructor
711	function call requires one argument
712	function call requires a real floating-point argument
713	a copy constructor with a default argument cannot be defaulted
714	a predeclared function cannot be deleted
715	empty dependent statement in if-statement
716	empty dependent statement in "else" clause of if-statement
717	%nfd, required for copy that was eliminated, cannot be referenced -- it is a deleted function
718	nonstandard first parameter %t of "main", expected "int"
719	nonstandard number of parameters for "main", expected zero or two parameters
71A	nonstandard second parameter %t of "main", expected "char *[]" or "char **"
71B	%sq was specified as both a system and non-system include directory -- the non-system entry will be ignored
71C	option to control move constructors and move assignment operators can be used only when compiling C++
71D	
71E	
71F	a trailing return type requires the "auto" type specifier
720	a trailing return type cannot appear in a nested declarator
721	a function declarator with a trailing return type must be preceded by a simple "auto" type specifier
722	"auto" function requires a trailing return type
723	a member template cannot have a pure specifier
724	string literal too long -- excess characters ignored
725	option to control the nullptr keyword can be used only when compiling C++
726	std::nullptr_t converted to bool
727	
728	
729	attribute %sq does not allow an empty argument list
72A	attribute appears more than once
72B	attribute %sq does not apply here
72C	attribute %sq does not apply to bit fields
72D	attribute %sq requires a bit field
72E	attribute %sq does not apply to member functions
72F	attribute %sq requires a member function
730	attribute %sq does not apply to virtual functions
731	attribute %sq requires a virtual function
732	attribute %sq does not apply to pure virtual functions
733	attribute %sq requires a pure virtual function
734	attribute %sq does not apply to register variables
735	attribute %sq requires a register variable
736	attribute %sq did not appear on original declaration
737	attributes are not allowed here
738	attribute %sq must appear in a class definition
739	"final" applied to a pure virtual function
73A	cannot override "final" %nd
73B	static %n treated as extern because it was referenced but not defined
73C	option to enable GNU-C89-style inlining can be used only when compiling C
73D	function was previously declared without the "gnu_inline" attribute
73E	the "gnu_inline" attribute is ignored on non-inline functions
73F	%n previously declared without the carries_dependency attribute
740	invalid initializer for array %n
741	must specify C++11 or C++14 mode when building runtime library
742	attribute %sq does not apply to function types
743	attribute %sq requires a function type
744	attribute %sq does not apply to nonstatic member functions
745	attribute %sq does not apply to automatic variables
746	attribute %sq requires an automatic variable
747	attribute %sq does not apply to a variable or function with external linkage
748	attribute %sq requires a local variable
749	attributes ignored here
74A	attribute does not apply to any entity
74B	bad attribute argument substitution
74C	the argument of the "tls_model" attribute must be "global-dynamic", "local-dynamic", "initial-exec", or "local-exec"
74D	the declaration %p specified a different "tls_model" argument
74E	attribute %sq does not apply to inline functions
74F	attribute %sq requires a inline function
750	both file names in an include_alias pragma must use the same delimiter characters
751	comparison between signed and unsigned operands
752	attribute %sq ignored on unnamed type
753	attribute %sq ignored because no definition follows
754	thread locality is incompatible with a previous declaration of %nd
755	this enclosing-function local variable cannot be referenced in this lambda body because an enclosing lambda does not allow implicit captures
756	this attribute argument contains unmatched parentheses, brackets, or braces
757	a call to __builtin_fpclassify requires five integral arguments followed by one floating-point argument
758	the last argument in a call to __builtin_fpclassify must have a real floating-point type
759	alignment cannot be set to less than the default alignment
75A	attributes are not allowed on explicit instantiations
75B	attribute %sq does not apply to a definition
75C	attribute %sq requires a definition
75D	standard attributes cannot appear on friend declarations that are not definitions
75E	specified alignment (%s1) is different from alignment (%s2) specified on a previous declaration
75F	alignment attribute must also appear on definition %p
760	%n may not be used in the type-id of the alias-declaration
761	alias template
762	%t cannot be transparent because its first field has a floating-point type
763	%t cannot be transparent because its first field is a bit field
764	virtual function of a "base_check" class overrides a base class member but lacks the "override" attribute
765	"hiding" attribute specified on a declaration that does not hide a base class declaration
766	"hiding" attribute specified on a declaration referred to by the using-declaration %p
767	attribute "hiding" is required on a declaration (in a "base_check" class) that hides %nd
768	%n is not defined in this translation unit but depends on a local type
769	%n is not defined in this translation unit but depends on a type with no linkage
76A	attribute %sq is missing in another translation unit
76B	attribute %sq conflicts with another translation unit
76C	the "nonstd_gnu_keywords" option is only valid in GNU C and GNU C++ modes
76D	use of a const variable in a constant expression is nonstandard in C
76E	an initializer cannot be specified for a flexible array member with automatic storage duration
76F	
770	a "final" class type cannot be used as a base class
771	exported templates are no longer in the standard C++ language
772	a template-dependent designator is not allowed
773	second operand of offsetof may not be a field with reference type
774	long lifetime temporaries are incompatible with other requested newer language features
775	wide character string literal will not be quoted in diagnostics
776	missing arguments for attribute %sq
777	options "c++11" and "c++11_sfinae" require a different compiler configuration
778	template parameter pack not at end of parameter list
779	a parameter pack declaration is not allowed here
77A	a parameter pack cannot have a default
77B	C++/CLI can be enabled only in Microsoft C++ mode
77C	"value__" cannot be used as the name of an enumerator constant (it is a reserved name in this context)
77D	an explicit enumerator value is required in an enum type with boolean underlying type
77E	
77F	parameter pack %sq was referenced but not expanded
780	pack expansion does not make use of any argument packs
781	pack %sq does not have the same number of elements as %sq2
782	
783	vector_size attribute is not allowed with an enum type
784	a property cannot be both static and virtual
785	an indexed property cannot be trivial
786	this declaration cannot appear in a property definition
787	a qualified function type cannot be used to declare an accessor function
788	an accessor function cannot have an ellipsis parameter
789	a "get" accessor was already declared for this property %p
78A	a "set" accessor was already declared for this property %p
78B	a "get" accessor cannot have a parameter
78C	return type of "get" accessor does not match property type
78D	return type of "set" accessor must be void
78E	a property cannot declare an empty list of indices
78F	a property index cannot have type void
790	index type does not match the corresponding parameter in the "set" accessor
791	index type does not match the corresponding parameter in the "get" accessor
792	index type is missing in the "set" accessor
793	index type is missing in the "get" accessor
794	"set" accessor is missing its value parameter
795	accessor function has too many parameters
796	the last parameter of the "set" accessor does not match the property type
797	%sq requires C++/CLI mode
798	error in Win32 API "%s": %s
799	#using may only be used at global scope
79A	metadata
79B	member name %sq is reserved by %nd
79C	expected a "["
79D	%[C++/CLI] mode requires microsoft_version >= 1600
79E	a default-indexed property cannot be static
79F	a property accessor cannot be both static and virtual
7A0	a top-level visibility specifier cannot appear on a nested type declaration
7A1	a top-level visibility specifier requires a type definition
7A2	a trivial property cannot have a reference type
7A3	a trivial property cannot have a const or volatile type
7A4	%nd was previously declared as a different kind of enum type
7A5	a variable captured by a lambda cannot have a %[managed] class type
7A6	virtual function overriding with a covariant return type is not allowed in a %[managed] class
7A7	array of handles is not allowed
7A8	handle to array is not allowed
7A9	handle to function is not allowed
7AA	handle to void is not allowed
7AB	handle to handle, pointer, or reference is not allowed
7AC	tracking reference to function is not allowed
7AD	
7AE	a field cannot be a tracking reference
7AF	a tracking reference cannot be combined with an ordinary reference in this way
7B0	a variable with static storage duration cannot have a ref class type
7B1	a %[managed] class cannot be unnamed
7B2	a %[managed] class cannot be local
7B3	%nd was previously declared as a different kind of class
7B4	%nd was previously declared as a different kind of class template
7B5	literal data members can only be members of %[managed] classes
7B6	a literal data member must be initialized
7B7	a literal data member of type %t is not allowed
7B8	const has no effect on a literal data member
7B9	initonly data members can only be members of %[managed] classes
7BA	const has no effect on an initonly data member
7BB	%nd has no "get" accessor
7BC	%nd has no "set" accessor
7BD	a static constructor cannot have parameters
7BE	a static constructor cannot be a member template
7BF	a compound lvalue is not allowed as an asm output operand
7C0	properties can only be members of %[managed] classes
7C1	a type qualifier is not allowed on a member function of a %[managed] class
7C2	an ordinary pointer to a %[C++/CLI] ref class or interface class is not allowed
7C3	an ordinary reference to a %[C++/CLI] ref class or interface class is not allowed
7C4	override specifier does not name a base class member function
7C5	override specifier designates a nonvirtual member %nd
7C6	member function overrides %nd1 which is already overridden by %nd2
7C7	at most one visibility specifier is allowed
7C8	type %t used for delegate definition is not a function type
7C9	delegate member types can only be members of %[managed] classes
7CA	a tracking reference to a delegate type is not allowed
7CB	a delegate type is not allowed here
7CC	this pack expansion produced an empty list of expressions, and an expression is needed here
7CD	an event cannot be both static and virtual
7CE	events can only be members of %[managed] classes
7CF	this declaration cannot appear in an event definition
7D0	event type must be a handle-to-delegate type
7D1	an "add" accessor was already declared for this event %p
7D2	a "remove" accessor was already declared for this event %p
7D3	a "raise" accessor was already declared for this event %p
7D4	an event accessor cannot be both static and virtual
7D5	return type of "add" and "remove" accessors must be void
7D6	event accessor is missing its value parameter
7D7	accessor function has too many parameters
7D8	the type %t1 of the parameter of the event accessor does not match the event type (%t2)
7D9	the type of the "raise" accessor does not match the event's delegate invocation type
7DA	an event definition must include both "add" and "remove" accessors
7DB	a static conversion function must accept exactly one argument
7DC	static operator must have a parameter type T, T&, T%%, or T^ with T = %t
7DD	the operand of sizeof... must be a parameter pack name
7DE	the sizeof... operator can be used only in a variadic template
7DF	event name cannot appear here
7E0	a handle to a non-%[managed] class is not allowed
7E1	a handle to an unscoped enum type is not allowed
7E2	"property" attribute not allowed in %[managed] class
7E3	a pure specifier ("= 0") followed by a definition is nonstandard
7E4	the %[managed] nullptr type cannot be used here
7E5	the "&" operator cannot be used to take the address of an object with a ref class type
7E6	array of %[managed] class is not allowed
7E7	a variable with static storage duration cannot have a handle or tracking reference type
7E8	a variable captured by a lambda cannot be a handle or tracking reference
7E9	a %[C++/CLI] parameter array requires a handle to a one-dimensional %[cli::array] type
7EA	could not import metadata from file %sq
7EB	the cli namespace cannot be extended
7EC	the element type of a %[cli::array] must be a handle or value type
7ED	invalid number of dimensions for %[cli::array] type
7EE	a cli::interior_ptr/cli::pin_ptr must point to a standard class, a value class, an integer, a handle, or a standard pointer
7EF	%t cannot be a class member
7F0	a parameter of type cli::pin_ptr is not allowed
7F1	invalid finalizer declaration
7F2	a finalizer may not have parameters
7F3	a type qualifier is not allowed on a finalizer
7F4	a return type may not be specified on a finalizer
7F5	a using-declaration may not name a finalizer
7F6	a finalizer name must be qualified
7F7	qualifier of finalizer name %t1 does not match type %t2
7F8	%n cannot be used to name a finalizer (a type name is required)
7F9	invalid finalizer name for type %t
7FA	finalizer reference is ambiguous -- both %n1 and %n2 could be used
7FB	a finalizer can only be a member of a ref class
7FC	
7FD	type used as finalizer name does not match type %t
7FE	a finalizer does not exist for this type
7FF	the "%%" operator can be used only on an object with a %[managed] class type
800	a pointer, handle, or reference to a cli::interior_ptr is not allowed
801	a pointer, handle, or reference to a cli::pin_ptr is not allowed
802	a pointer or reference to a %[C++/CLI] array is not allowed
803	a %[C++/CLI] array type is not allowed here
804	a %[C++/CLI] ref class can only derive from another ref class or from interface classes
805	a %[C++/CLI] value class can only derive from interface classes
806	a %[C++/CLI] interface class can only derive from interface classes
807	a ref class can have at most one direct ref base class (%t is already such a base)
808	a standard class cannot derive from a %[managed] class
809	a %[managed] class cannot have a virtual base
80A	a %[managed] class cannot have a "private" or "protected" base
80B	the "override" modifier requires a virtual function declaration with an explicit "virtual" keyword
80C	the "abstract" modifier requires a virtual function declaration with an explicit "virtual" keyword
80D	the "sealed" modifier requires a virtual function declaration with an explicit "virtual" keyword
80E	a named override specifier requires a virtual function declaration with an explicit "virtual" keyword
80F	a cli::pin_ptr return type is not allowed
810	attribute %sq applies in %[C++/CLI] mode only
811	a simple (non-tracking) reference cannot be bound to an entity on the managed heap
812	portable assembly
813	"%s" not loaded from default assemblies
814	list initialization syntax is a C++11 feature
815	operand of sizeof may not be a ref class type or interface class type
816	invalid number of subscripts for this %[cli::array] type
817	a pointer-to-member is not valid for a %[managed] class
818	private virtual member function of %[managed] class is not "sealed"
819	modifier is not allowed on a destructor
81A	modifier is not allowed on a finalizer
81B	"virtual" has no effect on a destructor of a %[managed] class
81C	"new" or "override" is required because this declaration matches %nd
81D	"new" or "virtual" is required because this declaration matches %nd
81E	"new" or "override" are not valid here because the matching %nd is a member of an interface
81F	"new" modifier without a matching base ref class member
820	%nd overridden with reduced access
821	a reference of type %t1 cannot be initialized with a value of type %t2
822	a copy constructor cannot be declared in a value class
823	a default constructor cannot be declared in a value class
824	a destructor cannot be declared in a value class
825	an assignment operator cannot be declared in a value class
826	non-value class %t cannot be the type of a member of a value class
827	option "cppcli" requires a different compiler configuration
828	exception specifications are not allowed on member functions of %[managed] classes
829	a %[managed] class cannot declare a friend
82A	
82B	
82C	a local class definition is not allowed in a member function of a %[managed] class
82D	a local lambda is not allowed in a member function of a %[managed] class
82E	a member function of a %[C++/CLI] interface class type cannot have a definition
82F	a property definition must include at least one accessor ("get" or "set")
830	default-indexed property conflicts with %nd
831	%n1 cannot be used because it follows a parameter pack and cannot be deduced from the parameters of %n2
832	this pack expansion produced more than one expression, and a single expression is needed here
833	type must correspond to System::Boolean, System::Byte, System::SByte, System::Int16, System::UInt16, System::Int32, System::UInt32, System::Int64, or System::UInt64
834	call of an object of a handle type without appropriate operator() or conversion functions to pointer-to-function type
835	an unnamed parameter pack declaration cannot be parenthesized
836	variadic templates can be enabled only when compiling C++
837	property definition conflicts with %nd
838	overloaded property
839	property
83A	a generic parameter cannot have a default
83B	a generic can only have type parameters
83C	to be used with "for each" statements, type %t must provide nonstatic member function %sq
83D	"for each" cannot use member %n because it is static
83E	in this "for each" statement, no instance of %no is callable with an empty argument list
83F	"for each" cannot use member function "MoveNext" because the return type is invalid
840	a "for each" statement cannot operate on an expression of type %t
841	to be used with "for each" statements, type %t must provide a non-indexed property %sq
842	
843	in this "for each" statement, %t2 is not a valid enumerator (returned by "GetEnumerator" of %t1)
844	expected "in"
845	class %t has no suitable assignment operator (after operator synthesis)
846	%sq is not a generic parameter
847	%sq is not a generic parameter of the innermost generic parameter list
848	invalid generic constraint
849	invalid use of event member (only subscription, unsubscription, and invocation are allowed)
84A	invoking an event with no "raise" accessor is invalid
84B	only "+=" and "-=" are valid for events
84C	typeid of a %[managed] type is not allowed
84D	typeid of a %[managed] pointer type is not allowed
84E	name followed by "::typeid" must be a type name
84F	a member %sq of this type is reserved within a %[managed] class -- destructor intended?
850	a member %sq of this type is reserved within a %[managed] class -- finalizer intended?
851	%[System]::IDisposable::Dispose is missing or invalid
852	%[System]::Object::Finalize is missing or invalid
853	%n does not override %[System]::Object::Finalize
854	the operand of a handle dynamic_cast must be a handle to a complete class type
855	the operand of a tracking-reference dynamic_cast must be an lvalue of a complete class type
856	the type in a dynamic_cast to a handle or tracking reference type must refer to a complete class
857	an interior pointer cannot be cast to a native pointer
858	explicit conversion operators can only be declared in ref and value class types
859	explicit conversion operator cannot be virtual
85A	expression must have arithmetic or unscoped enum type
85B	expression must have arithmetic, unscoped enum, or pointer type
85C	expression must have integral or unscoped enum type
85D	expression must have integral, unscoped enum, or fixed-point type
85E	a built-in binary operator applied to a scoped enumeration requires two operands of the same type
85F	%[gcnew] cannot allocate an entity of type %t
860	placement syntax cannot be used with %[gcnew]
861	new can only be used with simple value types
862	new cannot be used on a %[managed] class (%[gcnew] should be used instead)
863	new cannot be used on a handle type
864	%[gcnew] for a %[C++/CLI] array must have a new initializer or an array initializer
865	an array initializer can only be used to initialize a %[C++/CLI] array type
866	%[gcnew] does not allow auto
867	too many array bounds
868	too few array bounds
869	too few arguments for %nf
86A	too many arguments for %nf
86B	generic class
86C	no declaration of %nf accepts the number of generic arguments supplied
86D	invalid delegate initializer -- must be a function
86E	invalid delegate initializer -- more than one function matches the delegate type
86F	invalid delegate initializer -- function does not match the delegate type
870	invalid delegate initializer -- an object is needed in addition to a function
871	invalid delegate initializer -- function is not a member of a %[managed] class
872	invalid delegate initializer -- object is not needed for the specified function
873	invalid delegate initializer -- object has type %t1 but type %t2 is expected
874	taking the address of a member function of a %[managed] class is not allowed
875	invalid delegate initializer -- expected either "(<function-address>)" or "(<object-handle>, <member-address>)"
876	class fails to implement interface member %nd
877	%[gcnew] cannot be used to allocate a native array
878	a %[C++/CLI] interface class cannot declare an assignment operator
879	a %[C++/CLI] interface class cannot be sealed
87A	
87B	a destructor or finalizer declaration cannot include a named override specifier
87C	an override specifier cannot designate a destructor or finalizer
87D	a named override specifier is allowed only in a %[managed] class
87E	no member designated by the named override specifier matches the type of this member
87F	a static constructor declaration cannot include a named override specifier
880	a scoped enum type must have a name
881	transfer of control into a finally block is not allowed
882	return statement inside a finally block is not allowed
883	try block requires at least one handler or finally clause
884	a %[managed] object must be thrown by handle
885	a %[managed] object must be caught by handle
886	a break statement cannot be used in a finally block
887	a continue statement cannot be used in a finally block
888	builtin offsetof cannot be used when subscripting is overloaded
889	duplicate constraint
88A	more than one class constraint: %t1 and %t2
88B	more than one constraint clause for %n
88C	initonly static data members must have an initializer or be initialized in a static constructor
88D	GNU attributes on a template redeclaration have no effect
88E	GNU attributes on a template redeclaration have no effect (the attributes of the original declaration %p apply instead)
88F	a %[C++/CLI] parameter array must be the last parameter
890	a function with a %[C++/CLI] parameter array cannot have default arguments
891	a %[C++/CLI] parameter array cannot be followed by an ellipsis parameter
892	a %[C++/CLI] parameter array is not allowed in an operator function parameter list
893	__inline and __forceinline are not allowed here
894	a data member cannot have a %[C++/CLI] interface class type
895	a variable cannot have a %[C++/CLI] interface class type
896	a parameter cannot have a %[C++/CLI] interface class type
897	a function return type cannot be a %[C++/CLI] interface class type
898	an array of generic parameter type is not allowed
899	a pointer, handle, or reference to a generic parameter type is not allowed
89A	an initonly field cannot have a ref class type
89B	a reference cannot be bound to an initonly field
89C	taking the address of an initonly field is not allowed
89D	an initonly field can only be modified by the instance constructor of its containing class
89E	a static initonly field can only be modified by the static constructor of its containing class
89F	member function will be invoked on a copy of the initonly field
8A0	expression must have pointer or handle type but it has type %t
8A1	a move constructor or move assignment operator is used to copy an lvalue here, which may destroy the source object
8A2	member selection on a %[C++/CLI] generic entity must use the "->" syntax, not "."
8A3	a ref class type cannot derive from %t
8A4	a generic class must be %[managed] (i.e., a ref class, a value class, or an interface class)
8A5	a sealed class cannot be used as a constraint
8A6	the type in a dynamic_cast cannot be a generic type that might be a value type
8A7	a universal character name must designate a valid code point
8A8	generic constraints do not match those of %nd
8A9	__underlying_type only applies to enum types
8AA	expected only one operand expression for this cast
8AB	Unicode character with hex value %s not representable in the system default code page
8AC	nonstandard conversion of bound pointer-to-member to a function pointer
8AD	access specifier %s1 is deprecated -- use %s2 instead
8AE	a static accessor function is not permitted in a nonstatic property or event definition
8AF	%t has both a value class and ref class constraint
8B0	%t1 and %t2 involve circular naked type constraints
8B1	%t is not a valid type constraint
8B2	precompiled header file %sq not used (because it is incomplete)
8B3	%t is not a valid generic argument
8B4	assembly_info attribute applied to an invalid type
8B5	%t1 does not satisfy the ref class constraint of generic parameter %t2
8B6	%t1 does not satisfy the value class constraint of generic parameter %t2
8B7	%t1 does not satisfy the %[gcnew] constraint of generic parameter %t2 because it is abstract
8B8	%t1 does not satisfy the %[gcnew] constraint of generic parameter %t2 because it does not have a public default constructor
8B9	generic parameter %t1 does not satisfy the %[gcnew] constraint of generic parameter %t2 because it does not have the %[gcnew] constraint
8BA	%t1 does not satisfy the %t3 type constraint of generic parameter %t2
8BB	constraint on generic parameter %t differs from previous declaration (%p)
8BC	a member of a %[managed] class cannot be a standard array
8BD	a member of a non-%[managed] class cannot be a handle
8BE	a member of a non-%[managed] class cannot be a tracking reference
8BF	unsafe reinterpret_cast of handle
8C0	a template argument may not reference a generic type parameter
8C1	an expression list is not allowed in this subscript operation (use parentheses around a top-level comma operator)
8C2	expression must have pointer-to-object or handle-to-%[C++/CLI]-array type but it has type %t
8C3	unrecognized attribute
8C4	a member of a %[managed] class cannot be of a non-%[managed] class type
8C5	a member of a non-%[managed] class cannot have a ref class type or interface class type
8C6	in 
8C7	a delegate may not be declared as a template
8C8	a generic cannot be explicitly specialized
8C9	a generic cannot be declared in a class template
8CA	a template cannot be declared in a generic class
8CB	a literal field cannot be declared "static"
8CC	"long float" is a nonstandard extension -- use "double" instead
8CD	a standard class cannot be nested in a %[managed] class
8CE	__clrcall is valid only in C++/CLI mode
8CF	__clrcall not allowed on function with ellipsis parameter
8D0	%sq is not allowed here
8D1	a trivial property or event cannot be used to override %nd
8D2	expected an iterator variable name
8D3	the iterator type in this "for each" statement is %t, which is not a pointer type or an iterator-like class type
8D4	the iterator type in this "for each" statement is %t, which is not a pointer type or an iterator-like class type
8D5	the iterator type in this "for each" statement is %t, which is not a pointer type or an iterator-like class type
8D6	packing attribute on the parent type is ignored for this field of class type %t that is not standard-layout
8D7	%nd not implemented because this declaration is not public and has no named override specifier
8D8	this declaration is missing the gnu_inline attribute specified in the previous declaration %p
8D9	a member function of a %[managed] class cannot have an ellipsis parameter
8DA	previously-declared %n invalid as iterator of "for each" statement
8DB	calling convention ignored because the function type involves a generic parameter; __clrcall used instead
8DC	a function type involving a generic parameter cannot have an ellipsis parameter
8DD	"virtual" is required to override the matching %nd
8DE	"virtual" is required to implement the matching %nd
8DF	an initonly data member cannot be volatile
8E0	a member %sq of this type is reserved within a %[managed] class -- %[C++/CLI] operators must be declared using the keyword "operator"
8E1	a tracking reference to non-const cannot be bound to a constant
8E2	attributes ignored here because they do not apply to a declared entity
8E3	a tracking reference to %[System]::String is not allowed
8E4	invalid use of a generic class %t with pending constraints (probably caused by an invalid metadata file)
8E5	a pending constraint clause is only allowed for generic class declarations (but not generic class definitions)
8E6	empty initializer list not allowed here
8E7	a template cannot be declared in a %[managed] class
8E8	a generic declaration is not allowed here
8E9	interface types cannot have member generics
8EA	Unicode character not Latin-1, truncated to low-order byte
8EB	to be used with range-based "for" statements, type %t must provide function %sq
8EC	the iterator type in this range-based "for" statement is %t, which is not a pointer type or an iterator-like class type
8ED	the iterator type in this range-based "for" statement is %t, which is not a pointer type or an iterator-like class type
8EE	the iterator type in this range-based "for" statement is %t, which is not a pointer type or an iterator-like class type
8EF	a range-based "for" statement cannot operate on an array of unknown size or incomplete type %t
8F0	return types for "begin" and "end" functions used in a range-based "for" statement must be the same ("begin" return type is %t1, "end" return type is %t2)
8F1	%nfd, required to destroy temporary that was eliminated, is inaccessible
8F2	in this range-based "for" statement, no instance of %no matches the argument list
8F3	this range-based "for" statement requires a suitable %sq function and none was found
8F4	this "for each" statement requires a suitable %sq function and none was found
8F5	%t has a metadata representation not representable using %[C++/CLI]
8F6	expected "..."
8F7	%t in __implements list is not an interface
8F8	an __implements list must precede virtual function declarations
8F9	%t specified "__implements ..." in its list of bases, but is missing a matching __implements list
8FA	the result of dereferencing a handle to a ref or interface class type must be used
8FB	
8FC	expected a ")"; pragma ignored
8FD	a using-declaration or access declaration cannot appear in a managed class
8FE	Note: %nd could have been called but was not considered because it is inaccessible
8FF	an abstract member function of a C++/CLI managed class cannot have a definition
900	declaring this unary "operator*" can change the meaning of dereferencing a handle (use static member operators to explicitly indicate applicable types)
901	managed
902	C++/CX
903	C++/CLI
904	C++/CX mapping
905	default
906	cli mapping
907	cli::array
908	Platform::Array
909	C++/CLI array
90A	C++/CX array
90B	System
90C	Platform
90D	gcnew
90E	ref new
90F	an interface class cannot contain a nonstatic data member
910	#pragma GCC system_header cannot be used in the primary source file
911	%n is too large to be inlined
912	 (declared implicitly)
913	option to control move operations can be used only when compiling C++
914	move operations cannot be generated when rvalue constructors are copy constructors
915	option to control move operations cannot be used when rvalue references are disabled
916	"final" cannot be used for managed classes (use "sealed" instead)
917	a cast to CLI interface class %t is not allowed -- cast to handle intended?
918	cannot create an object of a CLI interface class
919	this declaration hides the nonstandard declaration of %nd because the underlying types are incompatible
91A	pointer comparison result is constant, because operand can never be null
91B	an object of the incomplete type %t cannot be value-initialized
91C	a reference cannot be value-initialized
91D	expected a "(" or a "{"
91E	copy-list-initialization cannot use a constructor marked "explicit"
91F	pointer to member of type void is not allowed
920	pointer to member of reference type is not allowed
921	pointer to member of handle type is not allowed
922	a brace-enclosed list is not allowed here
923	an operator->* member is not allowed in a managed class
924	assembly metadata refers to non-existent assembly
925	attribute %sq2 conflicts with earlier attribute %sq1
926	%nd was previously declared with a different base type
927	"enum class" and "enum struct" cannot be used here (use plain "enum" instead)
928	only one level of braces is allowed on an initializer for an object of type %t
929	%nd cannot be used as an enum type name
92A	
92B	a braced-initializer cannot be used with "new auto"
92C	the definition of std::initializer_list does not contain the expected constructor
92D	declaration hides %nd
92E	invalid template parameter list for std::initializer_list (it should be one ordinary type parameter with no default)
92F	a brace-enclosed list cannot be passed for an ellipsis parameter
930	an #include <initializer_list> is needed prior to a use of std::initializer_list, including an implicit use
931	the "inline" keyword cannot be used on a namespace alias declaration
932	the previous declaration of %n was not declared inline
933	%n was previously declared inline
934	the first argument must be an integer constant
935	a designator cannot be used with a non-aggregate type %t
936	a designator for an anonymous union member can only appear within braces corresponding to that anonymous union
937	function prototype tags can only be enabled when compiling C
938	braces cannot be omitted for this subobject initializer
939	invalid narrowing conversion from %t1 to %t2
93A	invalid narrowing conversion from %t1 to %t2: constant value does not fit in destination type
93B	cast to incomplete array type %t is not allowed
93C	invalid narrowing conversion from %t1 to %t2: constant value cannot be represented exactly in destination type
93D	a parenthesized initializer for a non-class entity must be an expression, not a brace-enclosed list
93E	a brace-enclosed list does not provide a return type for this lambda
93F	the declared exception specification is incompatible with the generated one
940	scoped enum types are a C++11 feature
941	a function type cannot be value-initialized
942	list-initialization of an object type %t is not allowed because the type is incomplete
943	std::initializer_list has a destructor, and is not supposed to -- library is misconfigured
944	explicit enum base types are a C++11 feature
945	this constant expression has type %t1 instead of the required %t2 type
946	a "new" of an std::initializer_list object is unlikely to work as expected because the underlying array will be destroyed at the end of the full expression
947	In predefined macro file
948	
949	"defined" is always false in a macro expansion in Microsoft mode
94A	%t cannot be the element type of an initializer list because it is not a complete object type
94B	mismatched delimiters in default argument expression
94C	nonstandard conversion of pointer-to-member to a function pointer
94D	dynamic exception specifications are deprecated
94E	%n cannot be partially specialized in the current scope
94F	%nd was previously declared constexpr
950	%nd was previously not declared constexpr
951	missing initializer for constexpr variable
952	"constexpr" is not valid here
953	a constexpr function must contain exactly one return statement
954	statement may not appear in a constexpr function
955	statement may not appear in a constexpr constructor
956	a function cannot be both constexpr and virtual in this mode
957	a constexpr function cannot have a nonliteral return type %t
958	a constexpr function cannot have a parameter of nonliteral type %t
959	unsequenced uses of %n in expression may produce undefined results
95A	the optional third argument of a call to __builtin_assumed_aligned must have integral type
95B	a destructor cannot be constexpr
95C	address supplied for mmap must be aligned on a page boundary: %s
95D	the body of a constexpr constructor cannot be a function try block
95E	constexpr %nf provides no initializer for:
95F	%n
960	calling the default constructor for %t does not produce a constant value
961	the default constructor for %t is not constexpr
962	a constexpr variable must have a literal type or a reference type
963	a constructor for a class with virtual bases cannot be constexpr
964	function call must have a constant value in a constant expression
965	function "main" may not be declared constexpr
966	
967	a class or enum type definition cannot appear in a constexpr function or constructor body
968	only GNU-style attributes are permitted here
969	nonstandard use of "auto" to both deduce the type from an initializer and to announce a trailing return type
96A	declaring a void parameter list with a qualified void type is nonstandard
96B	the qualifier on this local declaration is ignored
96C	this constant expression has type %t instead of the required %s type
96D	an instantiation of __bases or __direct_bases requires a class type
96E	the argument of __bases and __direct_bases must be a type template parameter
96F	%s can only be used in template contexts
970	constexpr function return is non-constant
971	constexpr constructor calls non-constexpr %n
972	constructor cannot be constexpr because the initializer of %n is not a constant expression
973	non-constant initializer for constexpr constructor
974	the generated default constructor for %t cannot be used in an initializer for its own data member
975	instantiation of initializer of %n depends on its own value
976	defaulted default constructor cannot be constexpr because the corresponding implicitly declared default constructor would not be constexpr
977	
978	invalid binary number
979	a union can have at most one field initializer -- %nd also has an initializer
97A	
97B	constexpr constructor of a union must initialize one of its fields
97C	constexpr constructor fails to initialize an anonymous union (defined %p)
97D	a constexpr static data member declaration requires an in-class initializer
97E	maximum constexpr depth/count options can be used only when compiling C++
97F	expression not folded to a constant due to excessive constexpr function call complexity
980	unrestricted union options can be used only when compiling C++
981	constexpr constructor must initialize direct base class %t
982	creation of an std::initializer_list object in a field initializer is unlikely to work as expected because the underlying array will be destroyed at the end of the full expression
983	"this" cannot be used in a constant expression
984	
985	"constexpr" is not allowed on an explicit instantiation directive
986	cannot determine the exception specification of the default constructor due to a circular dependency
987	anonymous union defined %p
988	this constructor uses the initializer of %nd, which would result in unbounded recursion
989	
98A	an initializer is not allowed on a local declaration of an extern variable
98B	an initializer is not allowed on a local declaration of a named register variable
98C	
98D	unrestricted unions cannot be enabled in Microsoft mode
98E	constructor delegates directly or indirectly to itself
98F	a delegating constructor cannot have other mem-initializers
990	a ref-qualifier is not allowed here
991	overloading two member functions with the same parameter types requires that they both have ref-qualifiers or both lack ref-qualifiers
992	invalid character in raw string delimiter
993	parenthesis terminating raw string delimiter not found within 16 characters -- raw string indicator ignored
994	ending delimiter for raw string not found
995	a parameter pack must be the final template argument in a partial specialization
996	a pointer-to-member function with type %t can only be used with an lvalue object
997	a pointer-to-member function with type %t can only be used with an rvalue object
998	the parameter of this defaulted copy-constructor cannot be const because a base or member copy constructor parameter is non-const
999	the parameter of this defaulted assignment operator cannot be const because a base or member copy assignment parameter is non-const
99A	an anonymous union must contain at least one nonstatic data member
99B	option "delegating_constructors" requires a different compiler configuration
99C	a reduction in alignment is ignored
99D	the operand of a const_cast to an rvalue reference type cannot be a non-class prvalue
99E	expression must be an lvalue or xvalue
99F	conversion may change the value
9A0	conversion from a string literal to "char *" is deprecated
9A1	conversion from a string literal to pointer-to-character (non-const) is deprecated
9A2	"override" and "final" are C++11 features
9A3	rvalue references are not allowed as exception specification types
9A4	attribute %sq does not apply to handler parameters
9A5	attribute %sq requires a handler parameter
9A6	alignas does not apply here
9A7	the standard "alignof" operator does not accept an expression argument (use a type instead)
9A8	invalid qualifier for %t (a derived class is not allowed here)
9A9	the "always_inline" attribute is ignored on non-inline functions
9AA	inheriting constructors must be inherited from a direct base class
9AB	
9AC	expected a label
9AD	expected an operand number after "%%l"
9AE	operand number for "%%l" does not refer to a valid label argument
9AF	a wide string is invalid in an "asm" statement
9B0	attribute is nonstandard
9B1	not a base class of class %t
9B2	non-identifier character in user-defined literal suffix
9B3	a multicharacter literal cannot be part of a user-defined literal
9B4	user-defined literal suffix does not match the earlier %sq
9B5	invalid literal operator name
9B6	user-defined literal operator not found
9B7	ambiguous literal operators and/or literal operator template:
9B8	a literal operator cannot be a member of a class
9B9	a literal operator cannot have extern "C" name linkage
9BA	at least one parameter expected for a literal operator
9BB	too many parameters for this literal operator
9BC	invalid parameter type %t for literal operator
9BD	invalid integer parameter type (%t) for literal operator; expected a character type or unsigned long long
9BE	invalid floating-point parameter type (%t) for literal operator; expected long double
9BF	invalid first parameter type (%t) for literal operator; pointer to non-const type is not allowed
9C0	invalid second parameter type (%t) for literal operator; must be size_t
9C1	invalid pointer parameter type (%t) for literal operator; expected a pointer to a character type
9C2	a literal operator cannot have an ellipsis parameter
9C3	a literal operator template cannot have any parameters
9C4	a literal operator template must have a template parameter list equivalent to "<char ...>"
9C5	thread-local storage class is not valid here
9C6	thread-local declaration follows non-thread-local declaration (declared %p)
9C7	non-thread-local declaration follows thread-local declaration (declared %p)
9C8	a literal operator cannot have default arguments
9C9	attribute is ignored for thread-local variables
9CA	a user-provided literal suffix must begin with "_"
9CB	rvalue references are a C++11 feature
9CC	lambda expressions are a C++11 feature
9CD	standard attribute syntax is a C++11 feature
9CE	delegating constructors are a C++11 feature
9CF	inheriting constructors are a C++11 feature
9D0	field initializers are a C++11 feature
9D1	deleted functions are a C++11 feature
9D2	defaulted functions are a C++11 feature
9D3	a storage class is not allowed in an explicit specialization
9D4	
9D5	an unscoped enumeration must be opaque in order to be specialized
9D6	an enumeration template declaration must refer to a previously declared member of a class template
9D7	expected a vector operand
9D8	shuffle source operands have incompatible types %t1 and %t2
9D9	shuffle mask (type %t) is not a vector of integers
9DA	shuffle mask (type %t1) has a length different from the source operand (type %t2)
9DB	static initialization with an address value requires a destination of the same size as the address
9DC	the argument to a feature-test macro must be a simple identifier
9DD	__has_include_next cannot be used in the primary source file
9DE	absolute file name used in __has_include_next
9DF	attribute %sq must be applied to a function type
9E0	
9E1	_Noreturn is not allowed here
9E2	expected an operand of real floating-point type (not %t)
9E3	__builtin_complex requires operands of compatible types (unlike %t1 and %t2)
9E4	a default association already appeared in this _Generic selection
9E5	a type involving a variable length array is not allowed here
9E6	duplicate association type (%t) in _Generic selection
9E7	no association matches the selector type %t
9E8	the type of %n (%t) is incompatible with an ifunc resolver type
9E9	a function cannot have both ifunc and alias attributes
9EA	a function cannot have both ifunc and weak attributes
9EB	call requires a string literal operand
9EC	duplicate inheriting constructor declaration (previous %p)
9ED	"decltype(auto)" must be a placeholder for the complete type of the variable (not for a component of that type)
9EE	decltype(auto) is not allowed here
9EF	cannot deduce "decltype(auto)" (initializer required)
9F0	cannot deduce "decltype(auto)" type
9F1	a block-scope thread-local declaration must include static or extern
9F2	deduced return type %t1 conflicts with previously deduced type %t2
9F3	cannot deduce the return type of %nd; it has not been defined
9F4	a virtual function cannot have a deduced return type
9F5	%n will be treated as a context-sensitive keyword from this point
9F6	the global namespace has no actual member %sq
9F7	comparison between two different enum types (%t1 and %t2)
9F8	target attribute not recognized
9F9	missing "default" target function
9FA	only one arch= target may be specified
9FB	a generic class cannot be a custom attribute
9FC	invalid attribute target %sq
9FD	ambiguous attribute -- both %t1 and %t2 could be used
9FE	a named attribute argument can only reference a public nonstatic read/write field or scalar property
9FF	a named attribute argument can only reference a nonstatic field or scalar property of an attribute parameter type
A00	invalid attribute argument -- expression must be a constant of an attribute parameter type
A01	an attribute argument cannot use generic type parameters
A02	%t may only be used as a standalone attribute
A03	the 'field' attribute target cannot be used on a non-trivial property/event
A04	invalid attribute target for a standalone attribute
A05	invalid attribute target for this context
A06	%t attribute cannot be used here
A07	%t is deprecated; use '...' to specify a parameter array
A08	the default namespace cannot be extended
A09	the boxed type must be a value class or enum
A0A	tracking reference to value class is not allowed
A0B	handle to value class is not allowed
A0C	tracking reference to enum is not allowed
A0D	handle to enum is not allowed
A0E	a public native type is not allowed
A0F	a public nested type is not allowed
A10	generic types are not permitted in C++/CX
A11	generic methods are not permitted in C++/CX
A12	generic constraints are not allowed
A13	non-public data members are not allowed in public C++/CX value types
A14	public non-data members are not allowed in public C++/CX value types
A15	constructors are not allowed in public C++/CX value types
A16	the return type of the "add" accessor must be Windows::Foundation::EventRegistrationToken
A17	the return type of the "remove" accessor must be void
A18	the parameter type of the "remove" accessor must be Windows::Foundation::EventRegistrationToken
A19	a handle or reference to a generic parameter type is not allowed
A1A	public data members are not allowed in non-value types
A1B	C++/CX can be enabled only in Microsoft C++ mode
A1C	C++/CLI and C++/CX modes cannot be combined
A1D	%sq requires C++/CX mode
A1E	C++/CX mode requires microsoft_version >= 1600
A1F	Literal fields are not allowed in C++/CX
A20	a standard reference cannot be bound to a C++/CX type
A21	type must correspond to Platform::Boolean, default::uint8, default::int8, default::int16, default::uint16, default::int32, default::uint32, default::int64, or default::uint64
A22	a C++/CX value type cannot have events
A23	a dynamic_cast to a handle type must refer to a complete class type
A24	Platform::Array can only be one-dimensional
A25	tracking reference to standard class type is not allowed
A26	a C++/CX value type cannot inherit from an interface
A27	a C++/CX value type cannot contain virtual functions
A28	"partial" can only be applied to "ref class" or "ref struct" at global scope or namespace scope
A29	the parameter of the "set" accessor must be of type "const Platform::Array<T>^"
A2A	the definition of a public C++/CX type is not allowed at global scope
A2B	an indexed property with a public "get" or "set" accessor is not allowed
A2C	a public nested delegate type is not allowed
A2D	invalid delegate initializer -- expected either "(<function-address or functor-object> [, Platform::CallbackContext])" or "(<object handle>, <member-address> [, Platform::CallbackContext [, bool]])"
A2E	invalid delegate initializer -- object must be a handle to a %[managed] class
A2F	C++/CX does not support 'in/out' arrays -- use "const Platform::Array<T>^" for 'in' and "Platform::WriteOnlyArray<T>^" or "Platform::Array<T>^*" for 'out' on public APIs
A30	missing "target" attribute for %nd
A31	no declared member function matches "target" attributes for %n
A32	Microsoft attributes in this location are only permitted for interface types
A33	GNU function multiversion resolver routine required
A34	an enum type declared in a managed class must include a definition
A35	a decltype-qualified name is nonstandard in this declaration context
A36	nonvirtual function cannot be declared with "final" modifier
A37	"target" attribute on special function is not supported
A38	must be a narrow string literal
A39	unmatched parentheses
A3A	no corresponding "push_options"
A3B	this pragma is not allowed inside a function
A3C	declaring a new or delete operator "inline" is nonstandard
A3D	a mem-initializer for a data member cannot be a pack expansion
A3E	generic lambda expressions cannot have capture defaults in this mode
A3F	a default template argument in a friend declaration may only be specified in a definition
A40	a friend template declaration with a default template argument must be the only declaration (first declared %p)
A41	an opaque enum declaration cannot be part of another declaration
A42	an opaque enum declaration is nonstandard in this context
A43	extended friend syntax is a C++11 feature
A44	digit separators not enabled, apostrophe begins a character literal
A45	digit separator cannot appear here
A46	"constexpr" is ignored here in Microsoft mode
A47	invalid expression for statement expression result
A48	identifier is a macro and not a literal suffix
A49	%nd cannot be called on an lvalue
A4A	%nd cannot be called on an rvalue
A4B	member function cannot be called on an lvalue
A4C	member function cannot be called on an rvalue
A4D	the template parameter list is too long
A4E	alias template type %t1 is incompatible with the previous type of %t2 in the redeclaration of %nfd
A4F	the field initializer for %nd is not a constant expression
A50	the number of operand constraints must be the same in each constraint string
A51	the constraint string contains too many alternative constraints; not all constraints were checked
A52	
A53	decltype(auto) cannot have added type qualifiers
A54	init-capture %nod cannot be captured here
A55	invalid nontype template argument of type %t
A56	the abi_tag attribute is ignored (it has no meaning in C mode)
A57	redeclaration adds abi_tag attribute "%s"
A58	abi_tag attribute is ignored (superseded by later abi_tag attribute)
A59	previous declaration of %nd had no abi_tag attribute
A5A	(see previous declaration %p)
A5B	abi_tag attribute is ignored on specialization
A5C	decltype(auto) cannot appear under a pointer, reference, or pointer-to-member construct
A5D	expected "class" or "typename"
A5E	placement "new" expression refers to non-placement %nd
A5F	must specify C++14 mode when building runtime library
A60	%s
A61	command-line warning
A62	Command-line warning
A63	constexpr non-static member function will not be implicitly 'const' in C++14
A64	variable type %t in constexpr function is not a literal type
A65	variable in constexpr function does not have automatic storage duration
A66	variable in constexpr function is uninitialized
A67	braced initialization of a variable declared with a placeholder type but without `=` requires exactly one element inside the braces
A68	no "%s" --target configuration exists
A69	attribute is supported only in 32-bit x86 configurations
A6A	"%s" requires an argument
A6B	a constructor or destructor cannot be a coroutine
A6C	%n cannot be a coroutine
A6D	co_yield expressions are not permitted in a catch clause
A6E	
A6F	
A70	
A71	
A72	class template %sq not found
A73	use the "typename" keyword to treat %n as a type in a dependent context
A74	argument value must be less than the sum of the vector elements
A75	%t has no member %sq
A76	a brace-enclosed list does not provide a return type
A77	a co_await expression must appear in a function scope
A78	a co_await expression is not allowed inside a catch clause
A79	a coroutine cannot have an ellipsis parameter
A7A	enabling C++14-style constexpr requires support for "bool"
A7B	constexpr %nd is not defined
A7C	this call cannot be evaluated because the target function %nd is not constexpr or not completely defined yet
A7D	note
A7E	Note
A7F	invalid anonymous union -- alias member template is not allowed
A80	a UTF-8 character literal value cannot occupy more than one code unit
A81	the value of %nd cannot be used as a constant
A82	a pointer or reference to %nd cannot be used as a constant
A83	nonzero subscript for non-array object
A84	cannot access position %d1 in array of %d2 elements
A85	called from:
A86	invalid access to inactive %n1 of union (%n2 is active)
A87	'goto' cannot be executed in constexpr contexts
A88	missing return value
A89	callee is null
A8A	attempt to dereference a null pointer
A8B	attempt to access storage one position past the end of an array of %d elements
A8C	attempt to access expired storage
A8D	attempt to access run-time storage
A8E	
A8F	cannot call non-constexpr %nd
A90	cannot use variable-length array during constexpr evaluation
A91	cannot perform a negative shift
A92	shift amount (%d) too large
A93	value exceeds range of %t
A94	floating-point error
A95	attempt to dereference a null pointer-to-member (data member)
A96	comparing a pointer to void and a pointer to a function is nonstandard
A97	metadata initialization failed
A98	invalid base-to-derived cast (complete class type is %t)
A99	invalid access to %n in object of complete type %t
A9A	"__auto_type" not allowed here
A9B	"__auto_type" does not permit multiple declarators
A9C	initialization with "{...}" is not allowed for "__auto_type"
A9D	"__auto_type" must be a placeholder for the complete type of the variable (not for a component of that type)
A9E	a variable declared with "__auto_type" requires an initializer
A9F	integer constant must be greater than or equal to zero
AA0	type must be an integral type
AA1	expression cannot be interpreted
AA2	statement cannot be interpreted
AA3	invalid use of address of interpreter storage
AA4	invalid constant kind for constant-expression
AA5	type %t too large for constant-expression evaluation
AA6	invalid type %t for constant-expression evaluation
AA7	conversion from %t1 to %t2 is invalid in constant-expression evaluation
AA8	floating-point conversion failed
AA9	
AAA	deduced return types are a C++14 feature
AAB	cannot evaluate a constructor with an associated destructor
AAC	%n not initialized during constexpr evaluation
AAD	invalid pointer difference in constexpr evaluation
AAE	invalid arithmetic on non-array pointer
AAF	cannot set pointer before the first array element
AB0	a coroutine with a deduced return type is invalid
AB1	expression not allowed in unevaluated context
AB2	
AB3	
AB4	"return" is not permitted in a coroutine (use "co_return" instead)
AB5	"co_return" is only allowed in coroutines
AB6	floating-point values cannot be compared
AB7	pointer values cannot be compared because they do not point into the same complete object or they point to subobjects with different accessibility
AB8	ignoring abi_tag attribute on non-inline namespace
AB9	ignoring abi_tag attribute on anonymous namespace
ABA	complex or imaginary template parameter type is nonstandard
ABB	co_yield expression is not permitted outside a function scope
ABC	ignoring thread-local indication on anonymous union
ABD	
ABE	variable template
ABF	access to uninitialized object
AC0	attempt to read from volatile storage
AC1	invalid access to inactive %n1 of union (no field is active)
AC2	label definitions cannot appear in constexpr functions
AC3	cannot compare a pointer past the end of an array with a pointer to another complete object
AC4	function type %t is an invalid type for a variable template instantiation
AC5	variable cannot have incomplete type %t
AC6	access to uninitialized subobject (%n)
AC7	access to uninitialized subobject (base class %t)
AC8	a pseudo-destructor call is not permitted in a constant-expression
AC9	attempt to modify const storage
ACA	
ACB	
ACC	attempt to access storage one position past an object treated as an array of one element
ACD	cannot use reinterpret_cast in constant-expression evaluation
ACE	operation not allowed on null pointer
ACF	the value of *this cannot be used as a constant
AD0	the "inline" keyword cannot be used on a nested namespace declaration
AD1	the "carries_dependency" attribute is ignored
AD2	an "__event __interface" cannot have a definition here
AD3	an event handler must have a void or integral return type
AD4	an "__event __interface" must have been previously defined
AD5	too many template arguments for %n
AD6	enumerator already declared (see %nd)
AD7	the version of Microsoft being emulated must be at least 1903 to use "--ms_c++14"
AD8	the version of Microsoft being emulated must be at least 1903 to use "--ms_c++latest"
AD9	type %t cannot be _Atomic because it is an array or function type
ADA	the _Atomic(...) specifier cannot be applied to qualified type %t
ADB	access to member of _Atomic object
ADC	a bit field cannot have an _Atomic type
ADD	
ADE	constexpr constructor calls non-constexpr constructor for subobject initialization
ADF	expected a comma (the one-argument version of static_assert is not enabled in this mode)
AE0	static assertion failed
AE1	at most one of the qualifiers _Nullable, _Nonnull, and _Null_unspecified can modify a type
AE2	nullability qualifiers are only permitted on pointer and pointer-to-member types
AE3	vector length is too large
AE4	vector element type must be integral, enum, or real floating-point type
AE5	builtin function is not available because 128-bit integers are not supported
AE6	builtin function is not available because vector types are not supported
AE7	two consecutive left square brackets always introduce an attribute list but an attribute list cannot appear here
AE8	unrecognized "target" attribute disqualifies this routine from being used by resolver routine
AE9	%t is not a vector type
AEA	vector types %t1 and %t2 must have the same length
AEB	added default arguments cannot result in declaring a default or copy constructor
AEC	a nontype template argument of reference type must bind to a function or to a complete object
AED	%t not allowed here
AEE	use of the "register" storage class specifier is not allowed
AEF	use of the "register" storage class specifier is deprecated
AF0	incrementing a bool value is not allowed
AF1	%sq, declared as iterator of range-based "for" statement, may not be redeclared in this scope
AF2	an attribute namespace may not be used here (because a "using" prefix was specified)
AF3	attribute namespace %sq is unrecognized
AF4	a default member initializer is not permitted in a value class
AF5	"--implicit_noexcept" requires a mode that enables noexcept
AF6	cannot fold operation involving virtual base class (%t)
AF7	initialization is not constant
AF8	cannot evaluate value of incomplete %t
AF9	ignoring return value from routine declared with "nodiscard" attribute
AFA	ignoring return value type with "nodiscard" attribute
AFB	the "nodiscard" attribute does not apply to destructors or routines with void return type
AFC	the "fallthrough" attribute only applies to null statements
AFD	the "fallthrough" attribute may only appear in an enclosing switch statement
AFE	fallthrough statement must precede switch case label or default
AFF	reference or pointer to temporary with limited lifetime
B00	cannot take the address of a function with an "enable_if" attribute whose condition is not unconditionally true
B01	"enable_if" attributes with conditions that are not constant values are not currently supported
B02	attribute was declared here
B03	__has_include cannot appear outside #if
B04	could not add CComCoClass base class
B05	not a null-terminated string
B06	non-scalar type %t cannot be used in a pseudo-destructor call
B07	address of "weak" %n is not constant
B08	too many recursive substitutions of function template signatures
B09	invalid specifier for structured binding declaration
B0A	invalid structured binding syntax
B0B	missing initializer
B0C	type %t has no components to bind to
B0D	too many identifiers
B0E	there are more elements than there are binding names
B0F	"std::tuple_element" not defined
B10	cannot instantiate "std::tuple_element" for <%s, %t>
B11	cannot call member function "get<%s>()" for type %t
B12	no instance of %no matches the argument list
B13	this structured binding requires a suitable %sq function and none was found
B14	a structured binding cannot be declared "inline"
B15	a structured binding cannot be declared "constexpr"
B16	a structured binding cannot declare an explicit storage class
B17	std::tuple_size<%t>::value is not a valid integral constant-expression
B18	a condition declaration must declare a variable
B19	a condition declaration must include an initializer
B1A	a parenthesized initializer is not permitted for a condition declaration
B1B	a condition declaration can only declare one variable
B1C	structured binding cannot bind to closure type
B1D	cannot bind to non-public %n
B1E	cannot bind to incomplete type %t
B1F	this declaration is not valid here
B20	the body of a constexpr function cannot be a function try block
B21	transfer of control into a constexpr if block is not allowed
B22	structured binding cannot be captured
B23	the version of Microsoft being emulated must be at least 1911 to use "--ms_c++17"
B24	attempt to read past the end of the object
B25	constexpr lambdas are not enabled in this mode
B26	a constant expression cannot contain a lambda expression
B27	value exceeds number of template arguments
B28	second operator in binary fold expression does not match first
B29	invalid fold expression operator
B2A	a binary fold expression cannot apply to two parameter packs
B2B	empty expansion not valid for this fold expression
B2C	a nonstatic data member cannot be declared as inline
B2D	fold expression does not refer to a parameter pack
B2E	two functions with the same parameter types but different exception specifications cannot be overloaded
B2F	dynamic exception specifications are not permitted in this mode
B30	
B31	invalid operand for noexcept specifier
B32	lambda expression cannot appear in noexcept specifier of a template
B33	%nfd is inaccessible
B34	invalid specifier in enum template declaration
B35	80-bit floating-point types are not supported in this configuration
B36	128-bit floating-point types are not supported in this configuration
B37	invalid enumerator value
B38	must be an _Atomic qualified type
B39	type of array element must be complete
B3A	the always_inline attribute has been suppressed for this function
B3B	a negative value is not permitted here
B3C	an integer pack element cannot match %n
B3D	an integer pack element cannot match %n
B3E	unexpected designator
B3F	cannot evaluate __builtin_offsetof
B40	deduction guide %t cannot be defined
B41	deduction guide must be declared in the same scope as %n
B42	invalid specifier for deduction guide declaration (only "explicit" is permitted)
B43	mutable %n of a constant cannot be accessed in a constant expression
B44	function modifier does not apply to static member declaration
B45	the "overloadable" attribute requires a prototyped function declaration
B46	cannot deduce "auto" template parameter type %t1 from %t2
B47	class template name must be a placeholder for the complete type being initialized (not for a component of that type)
B48	alias declarations are a C++11 feature
B49	alias templates are a C++11 feature
B4A	the return type must directly designate a specialization of the associated class template
B4B	copy-list-initialization cannot use "explicit" %n
B4C	deduction guide
B4D	Invalid value for user-defined literal operator
B4E	%s cannot appear outside of preprocessor directives
B4F	deduction guide must be declared with the same accessibility as %n
B50	a lambda is not permitted in this context
B51	specified alignment is not equivalent to previous declaration
B52	no alignment specified on definition; previous declaration had specified an alignment
B53	builtin function is not available because 128-bit floating-point types are not supported
B54	left-shifting a negative value has undefined behavior
B55	array designators are nonstandard in C++
B56	chained designators are nonstandard in C++
B57	mixing designated and non-designated initializers is nonstandard in C++
B58	out-of-order initializers are nonstandard in C++
B59	a string literal operator template must have a template parameter list equivalent to "<typename T, T ...>"
B5A	duplicate designator is not allowed
B5B	attribute conflicts with previous likely/unlikely attribute
B5C	the implicit by-copy capture of "this" is deprecated
B5D	an empty template parameter list is not allowed in a lambda expression
B5E	the version of Microsoft being emulated must be at least 1920 to use "--ms_c++20"
B5F	STDC pragma argument not accepted in this mode
B60	constexpr if statements are a C++17 feature
B61	pack expansion is not allowed in a designated initializer list
B62	field designator has no value
B63	a union can have at most one field initializer
B64	no valid std::%s type found (<compare> must be included)
B65	invalid types (%t1 and %t2) for built-in operator<=>
B66	fold expressions are nonstandard in this mode
B67	C++17-style initializer is nonstandard in this mode
B68	capturing *this is nonstandard in this mode
B69	C++17-style "using" attribute prefix is nonstandard in this mode
B6A	C++17-style nested namespaces are nonstandard in this mode
B6B	only one of "constexpr", "consteval", and "constinit" can appear on a declaration
B6C	a function cannot be both consteval and virtual in this mode
B6D	"consteval" is not allowed on an explicit instantiation directive
B6E	"consteval" is not valid here
B6F	a destructor cannot be consteval
B70	a constructor for a class with virtual bases cannot be consteval
B71	"consteval" is not permitted on the declaration of a variable or static data member
B72	%nd was previously declared consteval
B73	%nd was previously not declared consteval
B74	function "main" may not be declared consteval
B75	call to consteval %n did not produce a valid constant expression
B76	address of consteval %n in constant expression result
B77	consteval member cannot override non-consteval %n
B78	non-consteval member cannot override consteval %n
B79	structured binding
B7A	dynamic_cast to subobject of type %t1 is invalid (most-derived type is %t2)
B7B	the identifier __VA_OPT__ can only appear in the replacement lists of variadic macros
B7C	__VA_OPT__ cannot appear in a __VA_OPT__ operand
B7D	missing closing parenthesis for __VA_OPT__
B7E	__VA_OPT__ must be followed by "("
B7F	"##" may not be first in a __VA_OPT__ operand
B80	"##" may not be last in a __VA_OPT__ operand
B81	C++20-style nested inline namespaces are nonstandard in this mode
B82	cannot convert pointer to base class %t2 to pointer to derived class %t1 -- attempt to point beyond the most-derived object
B83	
B84	"main" cannot be used as a global variable name or given C language linkage
B85	function "main" cannot be declared in a linkage-specification
B86	structured binding is not allowed in a condition
B87	an attribute namespace identifier is required before "::"
B88	only one attribute namespace is allowed
B89	"return" not allowed here
B8A	a structured binding cannot be combined with other declarators
B8B	cannot branch out of a constant-evaluation context
B8C	structured binding templates are not permitted
B8D	a parenthesized initializer must be an expression, not a brace-enclosed list
B8E	cannot deduce class template arguments
B8F	a new or delete operator cannot be declared "consteval"
B90	the address of a consteval function cannot be used here
B91	the alignment of a function type (%t) is nonstandard
B92	the alignment of an array of unspecified bound is nonstandard in C
B93	a variable cannot have both "common" and "internal_linkage" attributes
B94	the "internal_linkage" attribute did not appear on a prior declaration
B95	no viable template argument deduction candidate found for %n
B96	a fully qualified constructor call is not allowed
B97	a defaulted comparison operator must be a member or a friend of the class it applies to
B98	bad type %t for parameter of defaulted comparison operator (must be "reference to const X" where X is the enclosing class type)
B99	return type of defaulted comparison operator must be "bool"
B9A	a defaulted member comparison operator must be "const"
B9B	
B9C	a coroutine's promise type %t cannot have both "return_void" and "return_value" set
B9D	"return_value" declared %p
B9E	"return_void" declared %p
B9F	missing co_return statement while %t has no "return_void" at end of %n
BA0	no nothrow variant of the global "operator new" found for coroutine state allocation
BA1	no viable "operator delete" found for coroutine state deallocation
BA2	a constexpr function cannot be a coroutine
BA3	the operand to this %s expression resolves to non-class %t
BA4	a co_await expression is not allowed in a static initializer
BA5	the co_await expression calling %n must be non-throwing
BA6	too many recursive comparison rewrite operations
BA7	a deducible return type for a default operator<=> must be "auto"
BA8	implicit copy of non-constant source
BA9	a structured binding cannot declare an explicit storage class other than static or thread_local
BAA	defaulted comparison operators are not supported for nontrivial Microsoft property fields
BAB	standard comparison type (%t) must be a class type with a single nonstatic data member of integral type
BAC	no constexpr static data member %sq found in %t
BAD	number of elements (%d) too large for dynamic allocation
BAE	constexpr dynamic allocation request too large
BAF	deallocation of storage that was not dynamically allocated
BB0	deallocation size (%d1) does not correspond to size allocated (%d2)
BB1	allocation occurred here
BB2	deallocation type (%t1) does not correspond to allocation type (%t2)
BB3	some dynamic allocations (total number = %d) were not deallocated
BB4	intrinsic %n declared with unexpected signature (type %t)
BB5	>> output from std::__report_constexpr_value
BB6	>> end output from std::__report_constexpr_value
BB7	cannot use array with dependent array size in constexpr evaluation
BB8	ignoring return value from routine declared with "nodiscard" attribute (%sq)
BB9	ignoring return value type with "nodiscard" attribute (%sq)
BBA	constructor used to create discarded object has "nodiscard" attribute
BBB	constructor used to create discarded object has "nodiscard" attribute (%sq)
BBC	type of discarded object has "nodiscard" attribute
BBD	type of discarded object has "nodiscard" attribute (%sq)
BBE	a pseudo-destructor reference can only be used for a pseudo-destructor call
BBF	an explicit destructor call is not permitted in a constant-expression
BC0	an unparenthesized comma operator in an array subscript expression is deprecated
BC1	number of dynamically-allocated elements (%d) too small for initializer
BC2	a volatile operand to %s expression is deprecated
BC3	use of the result of an assignment to a volatile scalar object is deprecated
BC4	a volatile destination type for a compound assignment expression is deprecated
BC5	a volatile function parameter is deprecated
BC6	a volatile return type is deprecated
BC7	use of a volatile qualifier on a structured binding is deprecated
BC8	the "ext_vector_type" argument must be between 1 and 2047
BC9	the "ext_vector_type" attribute may appear only in a typedef
BCA	the "ext_vector_type" attribute applies only to integer or floating-point types
BCB	this feature-test macro is ignored (and returns 0) in the current compilation mode
BCC	cannot evaluate an aggregate initializer with multiple elements for a union
BCD	%nd selected for operator rewrite does not return type bool
BCE	a new-expression calling a class-specific allocation function cannot be constant-evaluated
BCF	a placement new-expression cannot be constant-evaluated
BD0	deleting through a subobject pointer requires a virtual destructor
BD1	%npTd, with reversed arguments
BD2	operand of __INTADDR__ must be offset from null pointer
BD3	_Generic construct matches multiple types
BD4	the other match is %t
BD5	the "availability" attribute used here is ignored
BD6	C++20-style initializer statement in a range-based "for" statement is nonstandard in this mode
BD7	co_await can only apply to a range-based for statement
BD8	cannot deduce type of range in range-based "for" loop
BD9	inline variables are a C++17 feature
BDA	destroying operator delete requires %t as first parameter
BDB	a destroying operator delete cannot have parameters other than std::size_t and std::align_val_t
BDC	relaxed abstract class options can be used only when compiling C++
BDD	invalid start of expression in requires clause
BDE	a cast expression in a requires-clause must be parenthesized
BDF	this operator cannot appear at the top level (without parentheses) in a requires-clause
BE0	atomic constraint must have type bool
BE1	atomic constraint failed substitution
BE2	atomic constraint not constant
BE3	atomic constraint evaluates to false
BE4	template constraint not satisfied
BE5	concept definition cannot appear in this scope
BE6	invalid redeclaration of %nd
BE7	substitution of arguments %T for concept-id failed
BE8	concept is false for arguments %T
BE9	a requires-clause is not allowed here (not a templated function)
BEA	concept template
BEB	requires-clause incompatible with %nfd
BEC	expected an attribute
BED	
BEE	expected a type name
BEF	an ellipsis parameter is not permitted in a requires-expression
BF0	unnamed parameter in requires-expression has no effect
BF1	expected a concept name
BF2	call to %s appearing in a constant expression always produces "true"
BF3	call to %s appearing in a consteval context always produces "true"
BF4	call to %s appearing in a non-constexpr function always produces "false"
BF5	type constraint failed for %t
BF6	option "export" cannot be used in modes where C++ modules are enabled
BF7	a global module fragment declaration must precede any other declaration
BF8	a module declaration can only be preceded by a global module fragment
BF9	a private module fragment must be preceded by a module declaration
BFA	a %s module fragment cannot be exported
BFB	cannot declare more than one module
BFC	cannot declare more than one %s module fragment
BFD	a module must be declared with a non-empty name
BFE	%sq is not an importable header
BFF	cannot import a module with no name
C00	a module cannot have an interface dependency on itself
C01	module %sq has already been imported
C02	module file
C03	could not find module file for module %sq
C04	could not import module file %sq
C05	expected %s1, found %s2 instead
C06	when opening module file %sq
C07	unknown partition name %sq
C08	an unknown module file
C09	an importable header module file
C0A	an EDG module file
C0B	an IFC module file
C0C	an unexpected module file
C0D	the type of the second operand %t2 must have the same size as %t1
C0E	type must be trivially copyable
C0F	type %t is currently not supported for constexpr evaluation of __builtin_bit_cast
C10	class types with bitfields %t are not currently supported for constexpr evaluation of __builtin_bit_cast
C11	non-static data member of reference type %t prevents constexpr evaluation of __builtin_bit_cast
C12	a volatile type %t prevents constexpr evaluation of __builtin_bit_cast
C13	a union, pointer, or pointer-to-member type %t prevents constexpr evaluation of __builtin_bit_cast
C14	%npTd, inherited via using decl %p
C15	the sub-object construction of %t for inheriting constructors cannot be performed -- the associated constructor is deleted
C16	%n must return void
C17	invalid start of member declaration
C18	expected "auto"
C19	this operator is not allowed at this point; parenthesize the preceding new-expression
C1A	invalid use of concept
C1B	a defaulted member comparison operator cannot be "&&"-qualified
C1C	default constexpr comparison function calls non-constexpr function %nd
C1D	constexpr memory comparison is only supported for integer or array-of-integer objects
C1E	a concept template cannot have associated constraints
C1F	"export" is not allowed
C20	exporting individual class members is not allowed
C21	an exported declaration must introduce a name
C22	an export declaration cannot contain an export declaration (previous declaration %p)
C23	an export declaration cannot contain a module import declaration
C24	an export declaration can only appear in a module interface unit
C25	an export declaration cannot export a name with internal linkage
C26	
C27	
C28	a requires-expression must specify at least one requirement
C29	"constinit" is not valid here
C2A	"constinit" is only valid for declarations of variables with static or thread storage duration
C2B	constinit variable requires dynamic initialization
C2C	variable was previously declared with "constinit" %p
C2D	use of non-prototype function declarator
C2E	argument cannot have a const-qualified type
C2F	a pointer-to-member of an incomplete type %t is not allowed
C30	pack expansion in init-capture not enabled in this mode
C31	pack expansion in init-capture is a C++20 feature
C32	a comparison operator defaulted in a class definition must be the first declaration of that comparison operator (%nd)
C33	a pack expansion in an init-capture can be used only in a variadic template
C34	type constraint uses %nd that is not a type concept (i.e., a concept template whose first parameter is a type parameter)
C35	the deduced placeholder type %t failed the type constraint
C36	default constructor for %t is not eligible
C37	destructor for %t is ambiguous because of unordered constraints
C38	destructor for %t is ineligible because of failed constraints
C39	ambiguous destructor candidate
C3A	a virtual function cannot have a trailing requires clause
C3B	%nd does not satisfy its constraints
C3C	result of decltype qualifier %t is not a class or enumeration
C3D	comparison is ambiguous in standard C++20 because the implied comparison operator with reversed parameters is an equally good match -- this is usually caused by a missing "const" qualifier on the comparison operator; see %nod
C3E	invalid concept-id
C3F	substitution of arguments %T for requires-clause failed
C40	constraints for %nd are not satisfied
C41	variable type %t in constexpr function has virtual base classes
C42	a constant expression cannot allocate a virtual base subobject (for type %t)
C43	a template parameter of class type must be of structural class type
C44	support for UTF-8 literals requires u-literal support.
C45	module file mapping for "%s" specified more than once
C46	header unit mapping for "%s" specified more than once
C47	no mapping specified for "%s"
C48	
C49	cannot find header "%s" to import
C4A	more than one file in the module file list matches "%s"
C4B	module file found for "%s" is for a different module
C4C	any kind of module file
C4D	unable to read module file
C4E	builtin function is not available because the char8_t type is not supported with the current options
C4F	
C50	nonstandard use of explicit constructor %nod for default aggregate element initialization
C51	source or destination of memcpy-like intrinsic does not point to an object
C52	memcpy-like intrinsic attempts to copy representationally-distinct types %t1 and %t2
C53	memcpy-like intrinsic attempts to copy nontrivially-copyable type %t
C54	memcpy-like intrinsic attempts to copy partial object
C55	memcpy-like intrinsic attempts to copy past array boundary
C56	memcpy-like intrinsic attempts to copy overlapping byte ranges (using corresponding memmove operation instead)
C57	a friend declaration with a trailing-requires-clause must be a definition
C58	expression must have arithmetic or pointer type but has type %t
C59	expression must have arithmetic, enum, or pointer type but has type %t
C5A	expression must have arithmetic, unscoped enum, or pointer type but has type %t
C5B	expression must have pointer type but it has type %t
C5C	operator -> or ->* applied to %t instead of to a pointer type
C5D	
C5E	cannot interpret bit layout for this compilation target
C5F	no corresponding operator for IFC operator %sq
C60	no corresponding calling convention for IFC calling convention %sq
C61	module %sq contains unsupported constructs
C62	unsupported IFC construct: %sq
C63	__is_signed is no longer a keyword from this point
C64	an array dimension must have a constant unsigned integer value
C65	
C66	modules are not enabled in this mode
C67	"import" is not allowed in a module name
C68	"module" is not allowed in a module name
C69	
C6A	
C6B	%n is not an enum type
C6C	enumerator %no2 conflicts with %n1
C6D	enumerator %no has already been declared in this scope %p
C6E	the "throw()" specification is not part of C++20 and later
C6F	more than entry in the header unit map matches "%s"
C70	#pragma diagnostic must have either 'push' or 'pop' argument
C71	no '#pragma diagnostic push' was found to match this 'diagnostic pop'
C72	%sq cannot be a macro when used in an import or module directive
C73	this directive can only appear in the global namespace scope
C74	an "export" declaration can appear only at global or namespace scope
C75	%sq is parsed as an identifier rather than a keyword because the tokens that follow it do not match those of a preprocessor directive
C76	this appears to be the start of a preprocessor directive, but the lack of a ';' followed immediately by a newline prevents that
C77	this appears to be a modules preprocessing directive, but such directives cannot appear within a macro expansion
C78	a "module" directive cannot appear within the scope of conditional inclusion (e.g., #if, #else, #elseif, etc.)
C79	the import of %sq has been skipped
C7A	promise type %t must declare get_return_object_on_allocation_failure as a static member function requiring no arguments
C7B	an alias template cannot be explicitly specialized
C7C	to match this "{"
C7D	in this macro invocation
C7E	call requires an ambiguous argument conversion
C7F	declaration owned by module %s conflicts with %nd
C80	declaration owned by global module conflicts with %nd owned by a named module
C81	the first argument to a "malloc" attribute must be a function
C82	cannot capture %nod
C83	cannot capture "this"
C84	already in consteval context
C85	"if consteval" and "if not consteval" require braced dependent statements
C86	"if consteval" and "if not consteval" are meaningless in a non-constexpr function
C87	transfer of control into an "if consteval" or "if not consteval" statement is not allowed
C88	constant-evaluation cannot go through the declaration of a variable with static or thread storage duration
C89	the mutable qualifier is not allowed on a lambda with an explicit "this" parameter
C8A	a member function declared with "static" cannot have an explicit "this" parameter
C8B	an explicit "this" parameter must be the first declared parameter
C8C	"this" is not allowed here
C8D	a comparison function with explicit "this" cannot be defaulted
C8E	an explicit "this" function requires a selector operand
C8F	"if consteval" and "if not consteval" are not standard in this mode
C90	omitting "()" in a lambda declarator is nonstandard in this mode
C91	a trailing-requires-clause is not permitted when the lambda parameter list is omitted
C92	module %sq invalid partition requested
C93	module %sq1 undefined partition (believed to be %sq2) requested
C94	
C95	
C96	module %sq1 file position %u1 (relative position %u2) requested for partition %sq2 - which overflows the end of its partition
C97	module %sq1 file position %u1 (relative position %u2) requested for partition %sq2 - which is misaligned with its partitions elements
C98	from subfield %sq (relative position to node %u)
C99	from partition %sq element %u1 (file position %u2, relative position %u3)
C9A	attributes on lambdas are a C++23 feature
C9B	identifier %sq could be confused with a visually-similar one appearing %p
C9C	this comment contains suspicious Unicode formatting control characters
C9D	this string contains Unicode formatting control characters that could result in unexpected runtime behavior
C9E	%d1 suppressed warning was encountered while processing module %sq1
C9F	%d1 suppressed warnings were encountered while processing module %sq1
CA0	%d1 suppressed error was encountered while processing module %sq1
CA1	%d1 suppressed errors were encountered while processing module %sq1
CA2	including
CA3	suppressed
CA4	a virtual member function cannot have an explicit "this" parameter
CA5	taking the address of an explicit "this" function requires a qualified name
CA6	forming the address of an explicit "this" function requires the "&" operator
CA7	a string literal cannot be used to initialize a flexible array member
CA8	The IFC representation of the definition of function %sq is invalid
CA9	
CAA	a UniLevel IFC chart wasn't used to specify parameters
CAB	%u1 parameters were specified by the IFC parameter definition chart while %u2 parameters were specified by the IFC declaration
CAC	%u1 parameter was specified by the IFC parameter definition chart while %u2 parameters were specified by the IFC declaration
CAD	%u1 parameters were specified by the IFC parameter definition chart while %u2 parameter was specified by the IFC declaration
CAE	The IFC representation of the definition of function %sq is missing
CAF	function modifier does not apply to member template declaration
CB0	member selection involves too many nested anonymous types
CB1	there is no common type between the operands
CB2	expected a pointer-to-member
CB3	a flexible array member cannot be declared in an otherwise-empty type
CB4	expected "std::source_location::__impl" to be defined to a class with only the data members "_M_function_name", "_M_file_name", "_M_column", "_M_line"
CB5	given column number is too large for "std::source_location" implementation
CB6	given line number is too large for "std::source_location" implementation
CB7	a UTF-16 character constant cannot occupy more than one code unit; value truncated
CB8	both arguments must have the same type
CB9	type %t is invalid as an argument for this builtin
CBA	called from %nd:
CBB	a qualified type is nonstandard for anonymous bit fields
CBC	the element type of the vector condition (%t1) must have the same size as the element type of the result (%t2)
CBD	the floating-point vector operand type (%t) has no matching integer vector type
CBE	mangling for "requires" expressions is not yet implemented
CBF	because of an "unavailable" attribute
CC0	duplicate 'asm' qualifier
CC1	either a bit field with an incomplete enum type or an opaque enumeration with an invalid base type
CC2	attempted to construct an element from IFC partition %sq using an index into IFC partition %sq2
CC3	the partition %sq specified its entry size as %u1 when %u2 was expected
CC4	an unexpected IFC requirement was encountered while processing module %sq1
CC5	condition failed at line %d in %s1: %sq2
CC6	atomic constraint depends on itself
CC7	"noreturn" function has non-void return type
CC8	a correction has been made by dropping the parameter %sq (at relative index %u)
CC9	a default template argument cannot be specified on the definition of a member template outside its class
CCA	invalid IFC identifier name %sq encountered during entity reconstruction
CCB	
CCC	module %sq invalid sort value
CCD	a function template loaded from an IFC module was incorrectly parsed as %nd
CCE	failed to load an IFC entity reference in module %sq
CCF	from partition %sq element %u1 (file position %u2, relative position %u3)
CD0	chained designators are not permitted for a class type with a nontrivial destructor
CD1	an explicit specialization declaration may not be a friend declaration
CD2	the std::float128_t type is not supported; std::float64_t will be used instead
CD3	
CD4	a deduction guide may not be declared for alias template %no
CD5	%n was declared declared unavailable
CD6	%n was declared unavailable (%sq)
CD7	because of a "deprecated" attribute
CD8	explicit lambda template parameters are a C++20 feature
CD9	the use of "_Noreturn" has been obsoleted in C23; use "[[noreturn]]" instead
CDA	the use of "_Alignof" has been obsoleted in C23; use "alignof" instead
CDB	the use of "_Alignas" has been obsoleted in C23; use "alignas" instead
CDC	the use of "_Bool" has been obsoleted in C23; use "bool" instead
CDD	the use of "_Static_assert" has been obsoleted in C23; use "static_assert" instead
CDE	the use of "_Thread_local" has been obsoleted in C23; use "thread_local" instead
CDF	Microsoft mode must be enabled to use the module file %sq (a Microsoft Visual Studio IFC module)
CE0	could not open module file %sq
CE1	found in the module map for module %sq
CE2	found in the header unit map for %sq
CE3	unrecognized output mode (must be one of text, sarif): %s
CE4	option "c23_typeof" can be used only when compiling C
CE5	invalid clang version number: %s
CE6	
CE7	
CE8	
CE9	cannot evaluate an initializer for a flexible array member
CEA	a default bit-field initializer is a C++20 feature
CEB	too many arguments in template argument list in module %sq
CEC	detected for the template argument represented by %sq element %u1 (file position %u2, relative position %u3)
CED	too few arguments in template argument list in module %sq
CEE	detected while processing the template argument list represented by %sq element %u1 (file position %u2, relative position %u3)
CEF	conversion from scoped enumeration type %t is nonstandard
CF0	deallocation does not match allocation kind (one is for an array and the other not)
CF1	comparison involves unknown address (e.g., the address of a weak variable)
CF2	__make_signed is only compatible with non-bool integer and enum types
CF3	__make_unsigned is only compatible with non-bool integer and enum types
CF4	the intrinsic name %sq will be treated as an ordinary identifier from here
CF5	access to uninitialized subobject at index %d
CF6	IFC line number (%u1) overflows maximum allowed value (%u2) module %sq
CF7	module %sq1 requested element %u of partition %sq2, this file position exceeds the maximum representable value
CF8	wrong number of arguments
CF9	constraint on candidate %n not satisfied
CFA	number of parameters of %n does not match the call
CFB	substituting explicit template arguments %T for %n failed
CFC	%n is an implicitly "= delete" move function and thus ignored during overload resolution
CFD	%n does not match because argument #%d is provided for an empty parameter pack
CFE	%n does not match because argument #%d does not match parameter
CFF	candidate %n failed deduction
D00	built-in operator%s does not match because argument #%d does not match parameter
D01	<integral>
D02	<promoted integral>
D03	<ptrdiff_t>
D04	<enum>
D05	<scoped enum>
D06	<arithmetic>
D07	<promoted arithmetic>
D08	<non-bool arithmetic>
D09	<pointer>
D0A	<nullptr>
D0B	<handle>
D0C	<handle to CLI array>
D0D	<pointer to object>
D0E	<pointer to function>
D0F	<pointer-to-member>
D10	<bool>
D11	<bool-like>
D12	<class>
D13	auto(<expr>) and auto{<expr>} are a C++23 feature
D14	invalid anonymous union -- using declaration is not allowed
D15	IFC file %sq cannot be processed
D16	IFC version %u1.%u2 is not supported
D17	IFC architecture %sq is incompatible with the current target architecture
D18	module %sq1 requests index %u of an unsupported partition corresponding to %sq2
D19	parameter number %d of %n has type %t which cannot be completed
D1A	parameter number %d of %n has incomplete type %t
D1B	parameter number %d of %n has abstract type %t
D1C	structured bindings are a C++17 feature
D1D	capturing structured bindings is a C++20 feature
D1E	operand of splicer has type %t instead of std::meta::info
D1F	operand (reflection for %r) is not the reflection of a type
D20	nonconstant operand of splicer
D21	use of %t instead of std::string_view (= std::basic_string_view<char>)
D22	std::string_view used here is inconsistent with use in other intrinsics
D23	definition of std::string_view does not match assumptions of reflection (no base classes and data members for pointer and length)
D24	reflection is not that of a constant value
D25	cannot make a zero-length array
D26	length (%d1) passed to make_constexpr_array is larger than number of elements available (%d2)
D27	definition of std::meta::infovec does not match assumptions of reflection (no base classes and data members for pointer, length, and capacity)
D28	bad reflection (%r) for expression splice
D29	%n has already been defined (previous definition %p)
D2A	infovec object not initialized
D2B	value_of type %t1 is not compatible with the given reflection (entity with type %t2)
D2C	reflecting an overload set is not currently permitted
D2D	this intrinsic requires a reflection for a template instance
D2E	incompatible types %t1 and %t2 for operator
D2F	invalid reflection for intrinsic metafunction
D30	intrinsic metafunction requires a reflection for a class member
D31	a class cannot not derive from a union
D32	cannot derive from a class with a flexible array member
D33	null reflection
D34	namespace alias
D35	reflection (details unavailable)
D36	bad reflection (%r) for template argument in std::meta::substitute
D37	call to std::meta::substitute (for %r) failed
D38	reflection value refers to inactive entity
D39	an expression splice must splice a constant value, a variable, or a function
D3A	a member access splice must splice a data member or a member function
D3B	member %nd is not a direct or indirect member of %t
D3C	the name %sq does not designate a known Unicode character
D3D	unterminated named Unicode character escape
D3E	character cannot appear in a Unicode name
D3F	empty named Unicode character escape
D40	expected a "[:"
D41	expected a ":]"
D42	a lambda expression cannot be both "mutable" and "static"
D43	a "static" lambda expression is nonstandard
D44	a "static" lambda expression must have an empty capture specification
D45	EDG IFC header unit
D46	EDG IFC
D47	a header unit could not be created for the current translation unit
D48	the current translation unit uses one or more features that cannot currently be written to a header unit
D49	'explicit(bool)' is a C++20 feature
D4A	first argument must be a pointer to integer, enum, or supported floating-point type
D4B	C++ modules cannot be used when compiling multiple translation units
D4C	C++ modules cannot be used with the pre-C++11 "export" feature
D4D	the IFC token %sq is not supported
D4E	the "pass_object_size" attribute is only valid on parameters of function declarations
D4F	the argument of the %sq attribute %d1 must be a value between 0 and %d2
D50	a ref-qualifier here is ignored
D51	invalid NEON vector element type %t
D52	invalid NEON polyvector element type %t
D53	invalid scalable vector element type %t
D54	invalid number of tuple elements for scalable vector type
D55	a NEON vector or polyvector must be either 64 or 128 bits wide
D56	sizeless type %t is not allowed
D57	an object of the sizeless type %t cannot be value-initialized
D58	unexpected null declaration index found as part of scope %u
D59	a module name must be specified for the module file map referencing the file %sq
D5A	a null index value was received where a node in the IFC partition %sq was expected
D5B	%nd cannot have type %t
D5C	a ref-qualifier is nonstandard in this mode
D5D	a range-based "for" statement is nonstandard in this mode
D5E	"auto" as a type specifier is nonstandard in this mode
D5F	could not import module file %sq due to file corruption
D60	IFC
D61	extraneous tokens injected after member declaration
D62	bad injection scope (%r)
D63	expected a value of type std::string_view but got %t
D64	extraneous tokens injected after statement
D65	extraneous tokens injected after declaration
D66	tuple index value (%d) overflow
D67	>> output from std::__report_tokens
D68	>> end output from std::__report_tokens
D69	not in a context with parameter variables
D6A	a delimited escape sequence must have at least one character
D6B	unterminated delimited escape sequence
D6C	constant contains address of a local variable
D6D	a structured binding cannot be declared "consteval"
D6E	%no conflicts with the imported declaration %nd
D6F	character cannot be represented in the specified character type
D70	an annotation cannot appear in the context of a "using" attribute prefix
D71	type %t of annotation is not a literal type
D72	the "ext_vector_type" attribute applies only to bool, integer, or floating-point types
D73	multiple designators into the same union are not permitted
D74	test message
D75	the version of Microsoft being emulated must be at least 1943 to use "--ms_c++23"
D76	__DATE__ macro is not of expected size (11)
D77	expected a pointer operand
D78	function %sq has already been defined
D79	invalid or no value specified with --nv_arch flag
D7A	
D7B	calling a __device__ function(%sq1) from a __host__ __device__ function(%sq2) is not allowed
D7C	calling a constexpr __device__ function(%sq1) from a __host__ __device__ function(%sq2) is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
D7D	calling a __device__ function(%sq1) from a __host__ function(%sq2) is not allowed
D7E	calling a constexpr __device__ function(%sq1) from a __host__ function(%sq2) is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
D7F	
D80	
D81	calling a __host__ function(%sq1) from a __host__ __device__ function(%sq2) is not allowed
D82	%s1 annotation is ignored on a function(%sq2) that is explicitly defaulted on its first declaration
D83	calling a constexpr __host__ function(%sq1) from a __host__ __device__ function(%sq2) is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
D84	calling a __host__ function from a __host__ __device__ function is not allowed
D85	calling a constexpr __host__ function from a __host__ __device__ function is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
D86	calling a __host__ function(%sq1) from a __device__ function(%sq2) is not allowed
D87	calling a constexpr __host__ function(%sq1) from a __device__ function(%sq2) is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
D88	calling a __host__ function(%sq1) from a __global__ function(%sq2) is not allowed
D89	calling a constexpr __host__ function(%sq1) from a __global__ function(%sq2) is not allowed. The experimental flag '--expt-relaxed-constexpr' can be used to allow this.
D8A	
D8B	
D8C	
D8D	kernel launch from __device__ or __global__ functions requires separate compilation mode
D8E	illegal combination of memory qualifiers
D8F	memory qualifier on parameter is not allowed
D90	%s1 %sq2 variable declaration is not allowed inside a host function body
D91	%s1 %sq2 variable declaration is not allowed inside a device function body
D92	memory qualifier on data member is not allowed
D93	User-defined new and delete operators in the global namespace are not supported
D94	a __global__ function(%no1) redeclared without __global__
D95	a __global__ function(%no1) redeclared with __host__
D96	a __global__ function(%no1) redeclared with __device__
D97	a __global__ function(%no1) redeclared with __host__ __device__
D98	a __device__ function(%no1) redeclared with __global__
D99	a __device__ function(%no1) redeclared with __host__, hence treated as a __host__ __device__ function
D9A	a __device__ function(%no1) redeclared with __host__ __device__, hence treated as a __host__ __device__ function
D9B	a __device__ function(%no1) redeclared without __device__, hence treated as a __host__ __device__ function
D9C	a __host__ function(%no1) redeclared with __global__
D9D	a __host__ function(%no1) redeclared with __device__, hence treated as a __host__ __device__ function
D9E	a __host__ function(%no1) redeclared with __host__ __device__, hence treated as a __host__ __device__ function
D9F	a __host__ __device__ function(%no1) redeclared with __global__
DA0	a %s1 variable(%no1) redeclared with %s2
DA1	a %s variable(%no1) redeclared without %s
DA2	extern declaration of the entity %s is treated as a static definition
DA3	'%%' must be followed by a digit or escaped with another '%%' in asm declarations
DA4	a __global__ function cannot have ellipsis
DA5	__device__ or __host__ __device__ function with ellipsis requires compute_30 or higher architecture
DA6	a __global__ function must have a void return type
DA7	a __global__ function must not have a deduced return type
DA8	inline qualifier ignored for %sq function
DA9	a %s function call %s2 be configured
DAA	expected a ">>>"
DAB	initializer not allowed for %s variable %s2
DAC	dynamic initialization is not supported for a function-scope static %s variable within a __device__/__global__ function
DAD	function-scope static variable within a __device__/__global__ function requires a memory space specifier
DAE	__shared__ variables cannot have external linkage
DAF	incorrect value for launch bounds
DB0	the #pragma unroll must precede a loop
DB1	a microsoft style "asm" declaration is not allowed here
DB2	device code does not support exception handling
DB3	dynamic initialization is not supported for a %s variable
DB4	a __global__ function cannot have a parameter with __restrict__ qualified reference type
DB5	a __global__ function cannot have a parameter with rvalue reference type
DB6	cannot pass a parameter with a too large explicit alignment to a __global__ function on win32 platforms
DB7	device-side kernel launch could not be processed as the required runtime APIs are not declared
DB8	cannot pass an argument with a user-provided copy-constructor to a device-side kernel launch
DB9	cannot pass an argument with a user-provided destructor to a device-side kernel launch
DBA	identifier %sq is undefined in device code
DBB	cannot use an entity undefined in device code
DBC	identifier %sq is undefined
DBD	kernel launches from templates are not allowed in system files
DBE	an asm operand may specify only one constraint letter in a __device__/__global__ function
DBF	an asm operand must have scalar type
DC0	an asm operand must be an integral constant expression.
DC1	asm constraint letter '%s' is not allowed inside a __device__/__global__ function
DC2	asm operand type size(%s1) does not match type/size implied by constraint '%s2'
DC3	%s is only allowed on a __global__ function
DC4	%s is only allowed on a non-member function
DC5	cannot take address of builtin variable %sq
DC6	Variable type qualifier %sq is not allowed in "new" expressions
DC7	function main cannot be marked __device__ or __global__
DC8	address of label extension is not supported in __device__/__global__ functions
DC9	
DCA	Use of a virtual base (%t) requires the compute_20 or higher architecture
DCB	execution space mismatch: overridden entity (%n1) is a __host__ function, but overriding entity (%n2) is a __device__ function
DCC	execution space mismatch: overridden entity (%n1) is a __host__ function, but overriding entity (%n2) is a __host__ __device__ function
DCD	execution space mismatch: overridden entity (%n1) is a __device__ function, but overriding entity (%n2) is a __host__ __device__ function
DCE	execution space mismatch: overridden entity (%n1) is a __device__ function, but overriding entity (%n2) is a __host__ function
DCF	execution space mismatch: overridden entity (%n1) is a __host__ __device__ function, but overriding entity (%n2) is a __host__ function
DD0	execution space mismatch: overridden entity (%n1) is a __host__ __device__ function, but overriding entity (%n2) is a __device__ function
DD1	a %s1 %n1 cannot be directly read in a host function
DD2	a %s1 %n1 cannot be directly written in a host function
DD3	address of a %s1 %n1 cannot be directly taken in a host function
DD4	a host %n1 cannot be directly read in a device function
DD5	a host %n1 cannot be directly written in a device function
DD6	address of a host %n1 cannot be directly taken in a device function
DD7	cannot take address of texture/surface variable %sq in __device__/__global__ functions
DD8	cannot take address of texture/surface expression in __device__/__global__ functions
DD9	indirection not allowed for accessing texture/surface through variable %sq in __device__/__global__ functions
DDA	indirection not allowed for accessing texture/surface through expression in __device__/__global__ functions
DDB	a reference to texture/surface type cannot be used in __device__/__global__ functions
DDC	taking reference of texture/surface variable not allowed in __device__/__global__ functions
DDD	this attribute is not supported
DDE	member variables of an anonymous union at global or namespace scope cannot be directly accessed in __device__ and __global__ functions
DDF	module id
DE0	%t %s1 a %s2, which is not supported in device code
DE1	__managed__ variables require architecture compute_30 or higher
DE2	__managed__ variables are not yet supported for this configuration (compilation mode (32/64 bit) and/or target operating system)
DE3	a __managed__ variable cannot have a const qualified type
DE4	a __managed__ variable cannot have a reference type
DE5	__managed__ variables cannot be marked __shared__ or __constant__
DE6	ignoring attribute on enum value
DE7	cannot use thread_local specifier for a %s variable
DE8	cannot use thread_local specifier for variable declarations in device code
DE9	a __global__ function or function template cannot have a parameter with type std::initializer_list
DEA	Pack template parameter must be the last template parameter for a variadic __global__ function template
DEB	Multiple pack parameters are not allowed for a variadic __global__ function template
DEC	A __global__ function or function template cannot be marked constexpr
DED	A __managed__ variable cannot be used as an unparenthesized id-expression argument for decltype()
DEE	A %s variable cannot be marked constexpr
DEF	The %s specifier is not allowed for a structured binding declaration
DF0	A %s variable cannot be declared within an inline unnamed namespace
DF1	A texture or surface variable cannot be declared within an inline unnamed namespace
DF2	A __global__ function or function template cannot be declared within an inline unnamed namespace
DF3	The closure type for a lambda (%t%s) cannot be used in the template argument type of a __global__ function template instantiation, unless the lambda is defined within a __device__ or __global__ function, or the flag '-extended-lambda' is specified and the lambda is an extended lambda (a __device__ or __host__ __device__ lambda defined within a __host__ or __host__ __device__ function)
DF4	A type defined inside a __host__ function  (%t) cannot be used in the template argument type of a __global__ function template instantiation
DF5	A non-type template argument of a %s template cannot be of a pointer type or the std::nullptr_t type
DF6	A type that is defined inside a class and has private or protected access (%t) cannot be used in the template argument type of a __global__ function template instantiation, unless the class is local to a __device__ or __global__ function
DF7	An unnamed type (%t) cannot be used in the template argument type of a __global__ function template instantiation, unless the type is local to a __device__ or __global__ function
DF8	A template that is defined inside a class and has private or protected access cannot be used in the template template argument of a __global__ function template instantiation
DF9	A __global__ function or function template cannot have a parameter with va_list type
DFA	Could not determine parent function address from __parent() annotation
DFB	Cannot specify multiple __nv_parent directives in a lambda declaration
DFC	malformed __nv_parent annotation. Expected address of enclosing function
DFD	The enclosing parent function (%sq2) for an extended %s1 lambda must not be defined inside another function
DFE	An extended %s lambda cannot capture variables by reference
DFF	An extended %s lambda cannot capture an element of a parameter pack
E00	An extended %s lambda can only capture up to 1023 variables
E01	An extended %s lambda cannot init-capture variables with array type
E02	An extended %s lambda cannot capture an array variable (type: %t) with more than 7 dimensions
E03	An extended %s lambda cannot capture an array variable whose element type (%t) is not default constructible on the host
E04	An extended %s lambda cannot capture an array variable whose element type (%t) is not assignable on the host
E05	The enclosing parent function (%sq2) for an extended %s1 lambda must allow its address to be taken
E06	The enclosing parent function (%sq2) for an extended %s1 lambda cannot be a member function of a class that is unnamed
E07	On Windows, the enclosing parent function (%sq2) for an extended %s1 lambda cannot have internal or no linkage
E08	A type local to a function (%t) cannot be used in the type of a variable captured by an extended __device__ or __host__ __device__ lambda
E09	A type that is a private or protected class member (%t) cannot be used in the type of a variable captured by an extended __device__ or __host__ __device__ lambda
E0A	A template that is a private or protected class member cannot be used in the template argument of the enclosing parent function (and any parent classes) of an extended %s lambda
E0B	A type local to a function (%t) cannot be used in the template argument of the enclosing parent function (and any parent classes) of an extended __device__ or __host__ __device__ lambda
E0C	A type that is a private or protected class member (%t) cannot be used in the template argument of the enclosing parent function (and any parent classes) of an extended __device__ or __host__ __device__ lambda
E0D	The enclosing parent function (%sq2) for an extended %s1 lambda cannot have private or protected access within its class
E0E	An extended %s1 lambda cannot be defined inside a class (%sq2) with private or protected access within another class
E0F	A type local to a function (%t) cannot be used in the return or parameter types of the operator() of an extended __device__ or __host__ __device__ lambda
E10	A type that is a private or protected class member (%t) cannot be used in the return or parameter types of the operator() of an extended __device__ or __host__ __device__ lambda
E11	__host__ or __device__ annotation on lambda requires --extended-lambda nvcc flag
E12	The enclosing parent function (%sq2) for an extended %s1 lambda must not have deduced return type
E13	__host__ __device__ extended lambdas cannot be generic lambdas
E14	init-captures are not allowed for extended __host__ __device__ lambdas
E15	An extended %s lambda cannot have init-captures with type std::initializer_list
E16	If an extended %s lambda is defined within the body of one or more nested lambda expressions, each of these enclosing lambda expressions must be defined within the immediate or nested block scope of a function.
E17	An extended %s1 lambda cannot be defined inside a generic lambda expression(%sq2).
E18	An extended %s1 lambda cannot be defined inside an extended __host__ __device__  lambda expression(%sq2).
E19	The %s1 specifier is not allowed for an extended %s2 lambda
E1A	The operator() function for a lambda cannot be explicitly annotated with execution space annotations (__host__/__device__/__global__), the annotations are derived from its closure class
E1B	The cc clobber constraint is not supported in device code
E1C	A non-constexpr __device__ function (%sq1) with "auto" deduced return type cannot be directly referenced %s2, except if the reference is absent when __CUDA_ARCH__ is undefined
E1D	the unroll value does not fit in a integer, ignoring pragma for this loop
E1E	the unroll value cannot be zero or negative, ignoring pragma for this loop
E1F	the optional argument to the unroll pragma must be an integral constant expression, ignoring pragma for this loop
E20	extra characters in the unroll pragma (expected a single integral constant expression argument), ignoring pragma for this loop
E21	the #pragma nvopt must precede a loop
E22	the #pragma nvopt must have an argument, ignoring pragma for this loop
E23	the nvopt value does not fit in an integer, ignoring pragma for this loop
E24	the nvopt value cannot be negative, ignoring pragma for this loop
E25	the optional argument to the nvopt pragma must be an integral constant expression, ignoring pragma for this loop
E26	extra characters in the nvopt pragma (expected a single integral constant expression argument), ignoring pragma for this loop
E27	Unless enabled by language dialect, *this capture is only supported when the lambda is either __device__ only, or is defined within a __device__ or __global__ function
E28	Implicit capture of 'this' in extended lambda expression
E29	A texture or surface variable cannot be used in the non-type template argument of a __device__, __host__ __device__ or __global__ function template instantiation
E2A	The closure type for a lambda (%t%s) cannot be used in the template argument type of a variable template instantiation, unless the lambda is defined within a __device__ or __global__ function, or the lambda is an 'extended lambda' and the flag --extended-lambda is specified
E2B	A type defined inside a __host__ function  (%t) cannot be used in the template argument type of a variable template template instantiation
E2C	A type that is defined inside a class and has private or protected access (%t) cannot be used in the template argument type of a variable template instantiation, unless the class is local to a __device__ or __global__ function
E2D	A template that is defined inside a class and has private or protected access cannot be used in the template template argument of a variable template instantiation
E2E	An unnamed type (%t) cannot be used in the template argument type of a variable template template instantiation, unless the type is local to a __device__ or __global__ function
E2F	A %s variable template cannot have a const qualified type on Windows
E30	A __global__ function or function template cannot be defined in a friend declaration
E31	An operator function cannot be a __global__ function
E32	The operator '%s' is not allowed in device code
E33	Multiple %s specifiers are not allowed
E34	An exception specification is not allowed for a __global__ function or function template
E35	An inline __device__/__constant__/__managed__ variable must have internal linkage when the program is compiled in whole program mode (-rdc=false)
E36	the __shared__ memory space specifier is not allowed for a variable declared by the for-range-declaration
E37	
E38	
E39	
E3A	
E3B	unable to find __cudaPushCallConfiguration declaration. CUDA toolkit installation may be corrupt.
E3C	explicit stream argument not provided in kernel launch
E3D	unrecognized #pragma in device code
E3E	#pragma message: %sq
E3F	Universal character is not allowed in device entity name (%sq)
E40	__nv_register_params__ support is not enabled
E41	__nv_register_params__ is only supported for compute_80 or later architecture
E42	__nv_register_params__ is not allowed on a %s function
E43	__nv_register_params__ is not allowed on a function with ellipsis
E44	
E45	expected (global | shared | constant | local | generic | all) , unknown value for --nv-force-volatile flag: 
E46	'%s1' is treated as 'double' in device code
E47	%s1%sq2
E48	Asm operand modifier not supported at %sq, try removing modifier or escaping with %%
E49	zero-sized variable %sq is not allowed in device code
E4A	zero-sized parameter type %t is not allowed in device code
E4B	error in parsing __c11_atomic_* arguments
E4C	the first argument of this c11 atomic builtin must be a pointer to the _Atomic type
E4D	Byval trigger limit set lower than acceptable value
E4E	A function explicitly marked as a __host__ function is not allowed in JIT mode
E4F	A function without execution space annotations (__host__/__device__/__global__) is considered a host function, and host functions are not allowed in JIT mode. Consider using -default-device flag to process unannotated functions as __device__ functions in JIT mode
E50	A namespace scope variable without memory space annotations (__device__/__constant__/__shared__/__managed__) is considered a host variable, and host variables are not allowed in JIT mode. Consider using -default-device flag to process unannotated namespace scope variables as __device__ variables in JIT mode
E51	A class static data member with non-const type is considered a host variable, and host variables are not allowed in JIT mode. Consider using -default-device flag to process such data members as __device__ variables in JIT mode
E52	The execution space for the lambda closure class members was inferred to be __host__ (based on context). This is not allowed in JIT mode. Consider using -default-device to infer __device__ execution space for namespace scope lambda closure classes.
E53	Error in parsing name expression for lowered name lookup. Input name expression was: %sq
E54	Extra tokens found after parsing name expression for lowered name lookup. Input name expression was: %sq
E55	Internal error in parsing name expression for lowered name lookup. Input name expression was: %sq
E56	Name expression cannot form address of a non-__global__ function. Input name expression was: %sq
E57	Name expression cannot form address of a variable that is not a __device__/__constant__ variable. Input name expression was: %sq
E58	Name expression must form address of a __global__ function or the address of a __device__/__constant__ variable. Input name expression was: %sq
E59	alloca() is not supported for architectures lower than compute_52
E5A	%s arguments must be positive integers
E5B	cluster dimension value is too large
E5C	__cluster_dims__ is not supported for this GPU architecture
E5D	A __global__ function or function template cannot be a member function
E5E	For this host platform/dialect, an extended lambda cannot be defined inside the 'if' or 'else' block of a constexpr if statement
E5F	internal error: unable to find lambda sequence number in cache
E60	An extended %s lambda cannot first-capture variable in constexpr-if context
E61	128-bit integer type is only supported in Linux with the %sq flag in NVRTC
E62	
E63	operations on vector types are not supported in device code
E64	no __launch_bounds__ specified for __global__ function
E65	a parameter annotated with __grid_constant__ must have const-qualified type
E66	a parameter annotated with __grid_constant__ must not have reference type
E67	incompatible __grid_constant__ annotation for parameter %s in function redeclaration (see previous declaration %p)
E68	incompatible __grid_constant__ annotation for parameter %s in function template redeclaration (see previous declaration %p)
E69	incompatible __grid_constant__ annotation for parameter %s in function specialization (see previous declaration %p)
E6A	incompatible __grid_constant__ annotation for parameter %s in instantiation directive (see previous declaration %p)
E6B	__grid_constant__ annotation is only allowed on a parameter of a __global__ function
E6C	__grid_constant__ annotation is only allowed for architecture compute_70 or later
E6D	cannot specify max blocks per cluster for this GPU architecture
E6E	max blocks per cluster must not be negative
E6F	max blocks per cluster is too large
E70	total number of blocks in cluster computed from __cluster_dims__ exceeds __launch_bounds__ specified limit for max blocks in cluster
E71	device code does not support coroutines
E72	The warnings can be suppressed with "-diag-suppress <warning-number>"
E73	'#pragma omp end declare variant' with no matching '#pragma omp begin declare variant'
E74	A __global__ function or function template cannot be marked consteval
E75	"__inline_hint__" and "__noinline__" may not be used on the same declaration
E76	"__inline_hint__" and "__forceinline__" may not be used on the same declaration
E77	a local type %t (defined in %sq1) used in global function %sq2 template argument, the global function cannot be launched from host code.
E78	%s is only allowed on a __global__ function
E79	%s is only allowed on a non-member function
E7A	The maximum number of registers that can be allocated per thread must be positive
E7B	The maximum number of registers that can be allocated per thread is too large
E7C	The %s qualifiers cannot be applied to the same kernel
E7D	The 'C' constraint can only be used for asm statements in device code
E7E	No constraint modifiers are allowed for the 'C' constraint
E7F	The expression for the 'C' constraint could not be folded, ensure that it is a constant expression
E80	The constant-expression for the 'C' constraint evaluated to the address of a variable (%sq) with unsupported type (%t) (expected variable to have type 'array of const char')
E81	The constant-expression for the 'C' constraint evaluated to the address of a variable (%sq) that does not have static storage duration
E82	The constant-expression for the 'C' constraint evaluated to the address of a variable (%sq) without constant initialization
E83	The constant-expression for the 'C' constraint evaluated to the address of a static class member variable (%sq) that was not initialized at the point of declaration in the class
E84	The constant-expression for the 'C' constraint did not evaluate to the address of a variable
E85	__wgmma_mma_async builtins are only available for sm_90a
E86	Non-constant argument to __wgmma_mma_async call
E87	The 'A' or 'B' argument to __wgmma_mma_async call is missing
E88	'A' argument must have void* or unsigned long long type
E89	'B' argument must be unsigned long long type
E8A	The shape %s is not supported for __wgmma_mma_async builtin
E8B	128-bit floating point type is only supported in Linux with the %sq flag in NVRTC
E8C	when "-static-global-template-stub=true", extern __global__ function template is not supported in whole program compilation mode ("-rdc=false"). To resolve the issue, either use separate compilation mode ("-rdc=true"), or explicitly set "-static-global-template-stub=false" (but see nvcc documentation about downsides of turning it off)
E8D	in whole program compilation mode ("-rdc=false"), extern __global__ function template will not be supported in the future, when "-static-global-template-stub" will be set to "true" by default. To resolve this issue, either use "-rdc=true", or explicitly set "-static-global-template-stub=false" (but see nvcc documentation about downsides of turning it off)
E8E	when "-static-global-template-stub=true" in whole program compilation mode ("-rdc=false"), a __global__ function template instantiation or specialization (%sq) must have a definition in the current translation unit. To resolve this issue, either use separate compilation mode ("-rdc=true"), or explicitly set "-static-global-template-stub=false" (but see nvcc documentation about downsides of turning it off)
E8F	in whole program compilation mode ("-rdc=false"), a __global__ function template instantiation or specialization (%sq) will be required to have a definition in the current translation unit, when "-static-global-template-stub" will be set to "true" by default in the future. To resolve this issue, either use "-rdc=true", or explicitly set "-static-global-template-stub=false" (but see nvcc documentation about downsides of turning it off)
E90	incompatible precompiled header (PCH) heap allocation address from PCH file %sq.  This usually occurs if the PCH file was not created by the same dynamic instance of the NVRTC library, or if the NVRTC PCH heap was freed or resized after the PCH file had been created (see documentation for details)
E91	%s
E92	potential call to %s1. mitigation: %s2
E93	address of internal linkage device function (%sq) was taken (nv bug 2001144). mitigation: no mitigation required if the address is not used for comparision, or if the target function is not a CUDA C++ builtin. Otherwise, write a wrapper function to call the builtin, and take the address of the wrapper function instead
E94	an inline asm statement with no outputs and with "memory" clobber was not marked as 'volatile' (nv bug 3970970). mitigation: explicitly mark the inline asm statement with 'volatile'
E95	The 'const' or 'volatile' qualifier for parameter %s in function template redeclaration does not match the 'const' or 'volatile' qualifier for the same parameter in the previous declaration %p (nv bug 2780831). mitigation: change source code so that the const/volatile qualifiers for the parameter are consistent across template redeclarations
E96	first argument must be a pointer to integer, enum, float or struct type
E97	atomic operations and, or, xor, add, sub, min and max are valid only on objects of size 4, or 8.
E98	atomic CAS is valid only on objects of size 2, 4, 8 or 16 bytes.
E99	atomic CAS is valid only on objects of size 4, 8 or 16 bytes.
E9A	atomic operations add and sub are not valid on signed integer of size 8.
E9B	atomic operations min and max are not valid on all float types.
E9C	atomic operations are not in a device function.
E9D	atomic operation's scope argument is not a constant integer.
E9E	atomic operation's memory order argument is not a constant integer.
E9F	atomic load's memory order cannot be release or acq_rel.
EA0	atomic store's memory order cannot be consume, acquire or acq_rel.
EA1	128-bit atomic load and store are supported on architecture sm_70 or above.
EA2	atomic load and store's scope of cluster is supported on architecture sm_90 or above. Using device scope instead.
EA3	atomic operations' scope argument is supported on architecture sm_60 or above. Fall back to use membar.
EA4	atomic add and sub for 64-bit float is supported on architecture sm_60 or above.
EA5	atomic operations' argument of memory order is supported on architecture sm_70 or above. Fall back to use membar.
EA6	atomic operations' scope of cluster is supported on architecture sm_90 or above. Using device scope instead.
EA7	128-bit atomic exchange or compare-and-exchange is supported on architecture sm_90 or above.
EA8	16-bit atomic compare-and-exchange is supported on architecture sm_70 or above.
EA9	__nv_atomic_* functions are not supported on arch < sm_60.
EAA	generic nv atomic functions are valid only on objects of size 1, 2, 4, 8 and 16 bytes.
EAB	Cannot take address of a compiler device atomic builtin function. Write a wrapper function to call this builtin, and take the address of the wrapper function instead.
